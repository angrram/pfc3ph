// -------------------------------------------------------------
// 
// File Name: hdl_prj2\hdlsrc\HDL_pfc_gold_fi_og\dot_product_7.v
// Created: 2025-04-29 18:38:06
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dot_product_7
// Source Path: HDL_pfc_gold_fi_og/simscape_system/HDL Subsystem/Fixed-Point State-Space/hNNewMatrixC/dot_product_7
// Hierarchy Level: 3
// Model version: 1.184
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dot_product_7
          (clk,
           reset,
           enb,
           enb_1_1_1,
           in1_0,
           in1_1,
           in1_2,
           in1_3,
           in1_4,
           in1_5,
           in1_6,
           in2_0,
           in2_1,
           in2_2,
           in2_3,
           in2_4,
           in2_5,
           in2_6,
           out1);


  input   clk;
  input   reset;
  input   enb;
  input   enb_1_1_1;
  input   signed [24:0] in1_0;  // sfix25_En20
  input   signed [24:0] in1_1;  // sfix25_En20
  input   signed [24:0] in1_2;  // sfix25_En20
  input   signed [24:0] in1_3;  // sfix25_En20
  input   signed [24:0] in1_4;  // sfix25_En20
  input   signed [24:0] in1_5;  // sfix25_En20
  input   signed [24:0] in1_6;  // sfix25_En20
  input   signed [24:0] in2_0;  // sfix25_En13
  input   signed [24:0] in2_1;  // sfix25_En13
  input   signed [24:0] in2_2;  // sfix25_En13
  input   signed [24:0] in2_3;  // sfix25_En13
  input   signed [24:0] in2_4;  // sfix25_En13
  input   signed [24:0] in2_5;  // sfix25_En13
  input   signed [24:0] in2_6;  // sfix25_En13
  output  signed [49:0] out1;  // sfix50_En33


  wire [124:0] mergedInput;  // ufix125
  reg [124:0] mergedDelay_regin;  // ufix125
  reg [2:0] mergedDelay_waddr;  // ufix3
  wire mergedDelay_wrenb;  // ufix1
  reg [2:0] mergedDelay_raddr;  // ufix3
  wire [124:0] mergedDelay_regout;  // ufix125
  reg [124:0] mergedOutput;  // ufix125
  wire [49:0] mergedInput_1;  // ufix50
  reg [49:0] mergedDelay_regin_1;  // ufix50
  reg [2:0] mergedDelay_waddr_1;  // ufix3
  wire mergedDelay_wrenb_1;  // ufix1
  reg [2:0] mergedDelay_raddr_1;  // ufix3
  wire [49:0] mergedDelay_regout_1;  // ufix50
  reg [49:0] mergedOutput_1;  // ufix50
  wire [24:0] slicedInput;  // ufix25
  wire signed [24:0] delayOut0;  // sfix25_En20
  wire [24:0] slicedInput_1;  // ufix25
  wire signed [24:0] delayOut1;  // sfix25_En20
  wire [24:0] slicedInput_2;  // ufix25
  wire signed [24:0] delayOut2;  // sfix25_En20
  wire [24:0] slicedInput_3;  // ufix25
  wire signed [24:0] delayOut3;  // sfix25_En20
  wire [24:0] slicedInput_4;  // ufix25
  wire signed [24:0] delayOut4;  // sfix25_En20
  wire [24:0] slicedInput_5;  // ufix25
  wire signed [24:0] delayOut5;  // sfix25_En20
  wire [24:0] slicedInput_6;  // ufix25
  wire signed [24:0] delayOut6;  // sfix25_En20
  wire signed [24:0] mul_in1 [0:6];  // sfix25_En20 [7]
  wire signed [24:0] mul_in2 [0:6];  // sfix25_En13 [7]
  reg signed [24:0] mul_in2_1 [0:6];  // sfix25_En13 [7]
  wire signed [49:0] mul_out1 [0:6];  // sfix50_En33 [7]
  reg signed [49:0] mul_out1_1 [0:6];  // sfix50_En33 [7]
  wire signed [49:0] mul_out1_0;  // sfix50_En33
  wire signed [49:0] mul_out1_2;  // sfix50_En33
  wire signed [49:0] mul_out1_4;  // sfix50_En33
  wire signed [49:0] mul_out1_5;  // sfix50_En33
  wire signed [49:0] sum_stage1_3;  // sfix50_En33
  wire signed [49:0] mul_out1_1_1;  // sfix50_En33
  wire signed [49:0] sum_stage1_1;  // sfix50_En33
  wire signed [49:0] mul_out1_3;  // sfix50_En33
  wire signed [49:0] sum_stage1_2;  // sfix50_En33
  wire signed [49:0] sum_stage2_1;  // sfix50_En33
  wire signed [49:0] mul_out1_6;  // sfix50_En33
  wire signed [49:0] sum_stage2_2;  // sfix50_En33
  wire signed [49:0] sum_stage3_1;  // sfix50_En33
  reg signed [31:0] HwModeRegister1_t_0_0;  // int32
  reg signed [31:0] HwModeRegister1_t_1;  // int32
  reg signed [31:0] PipelineRegister_t_0_0;  // int32
  reg signed [31:0] PipelineRegister_t_1;  // int32


  assign mergedInput = {in1_0, in1_1, in1_2, in1_3, in1_4};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 125'h00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 3'b000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 3'b010) begin
            mergedDelay_waddr <= 3'b000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 3'b001;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 2
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 3'b001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 3'b010) begin
            mergedDelay_raddr <= 3'b000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 3'b001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(3),
                                     .DataWidth(125)
                                     )
                                   u_ShiftRegisterRAM_Wrapper (.clk(clk),
                                                               .reset(reset),
                                                               .enb(enb),
                                                               .enb_1_1_1(enb_1_1_1),
                                                               .wr_din(mergedDelay_regin),
                                                               .wr_addr(mergedDelay_waddr),
                                                               .wr_en(mergedDelay_wrenb),  // ufix1
                                                               .rd_addr(mergedDelay_raddr),
                                                               .dout(mergedDelay_regout)
                                                               );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 125'h00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign mergedInput_1 = {in1_5, in1_6};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_1_process
      if (reset == 1'b1) begin
        mergedDelay_regin_1 <= 50'h0000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_1 <= mergedInput_1;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_1_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_1 <= 3'b000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_1 >= 3'b010) begin
            mergedDelay_waddr_1 <= 3'b000;
          end
          else begin
            mergedDelay_waddr_1 <= mergedDelay_waddr_1 + 3'b001;
          end
        end
      end
    end

  assign mergedDelay_wrenb_1 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 2
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_1_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_1 <= 3'b001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_1 >= 3'b010) begin
            mergedDelay_raddr_1 <= 3'b000;
          end
          else begin
            mergedDelay_raddr_1 <= mergedDelay_raddr_1 + 3'b001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(3),
                                     .DataWidth(50)
                                     )
                                   u_ShiftRegisterRAM_Wrapper_1 (.clk(clk),
                                                                 .reset(reset),
                                                                 .enb(enb),
                                                                 .enb_1_1_1(enb_1_1_1),
                                                                 .wr_din(mergedDelay_regin_1),
                                                                 .wr_addr(mergedDelay_waddr_1),
                                                                 .wr_en(mergedDelay_wrenb_1),  // ufix1
                                                                 .rd_addr(mergedDelay_raddr_1),
                                                                 .dout(mergedDelay_regout_1)
                                                                 );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_1_process
      if (reset == 1'b1) begin
        mergedOutput_1 <= 50'h0000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_1 <= mergedDelay_regout_1;
        end
      end
    end

  assign slicedInput = mergedOutput[124:100];

  assign delayOut0 = slicedInput;

  assign slicedInput_1 = mergedOutput[99:75];

  assign delayOut1 = slicedInput_1;

  assign slicedInput_2 = mergedOutput[74:50];

  assign delayOut2 = slicedInput_2;

  assign slicedInput_3 = mergedOutput[49:25];

  assign delayOut3 = slicedInput_3;

  assign slicedInput_4 = mergedOutput[24:0];

  assign delayOut4 = slicedInput_4;

  assign slicedInput_5 = mergedOutput_1[49:25];

  assign delayOut5 = slicedInput_5;

  assign slicedInput_6 = mergedOutput_1[24:0];

  assign delayOut6 = slicedInput_6;

  assign mul_in1[0] = delayOut0;
  assign mul_in1[1] = delayOut1;
  assign mul_in1[2] = delayOut2;
  assign mul_in1[3] = delayOut3;
  assign mul_in1[4] = delayOut4;
  assign mul_in1[5] = delayOut5;
  assign mul_in1[6] = delayOut6;

  assign mul_in2[0] = in2_0;
  assign mul_in2[1] = in2_1;
  assign mul_in2[2] = in2_2;
  assign mul_in2[3] = in2_3;
  assign mul_in2[4] = in2_4;
  assign mul_in2[5] = in2_5;
  assign mul_in2[6] = in2_6;

  always @(posedge clk)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        for(HwModeRegister1_t_1 = 32'sd0; HwModeRegister1_t_1 <= 32'sd6; HwModeRegister1_t_1 = HwModeRegister1_t_1 + 32'sd1) begin
          mul_in2_1[HwModeRegister1_t_1] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister1_t_0_0 = 32'sd0; HwModeRegister1_t_0_0 <= 32'sd6; HwModeRegister1_t_0_0 = HwModeRegister1_t_0_0 + 32'sd1) begin
            mul_in2_1[HwModeRegister1_t_0_0] <= mul_in2[HwModeRegister1_t_0_0];
          end
        end
      end
    end


  genvar t_0_01;
  generate
    for(t_0_01 = 32'sd0; t_0_01 <= 32'sd6; t_0_01 = t_0_01 + 32'sd1) begin:mul_out1_gen
      assign mul_out1[t_0_01] = mul_in1[t_0_01] * mul_in2_1[t_0_01];
    end
  endgenerate
  always @(posedge clk)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        for(PipelineRegister_t_1 = 32'sd0; PipelineRegister_t_1 <= 32'sd6; PipelineRegister_t_1 = PipelineRegister_t_1 + 32'sd1) begin
          mul_out1_1[PipelineRegister_t_1] <= 50'sh0000000000000;
        end
      end
      else begin
        if (enb) begin
          for(PipelineRegister_t_0_0 = 32'sd0; PipelineRegister_t_0_0 <= 32'sd6; PipelineRegister_t_0_0 = PipelineRegister_t_0_0 + 32'sd1) begin
            mul_out1_1[PipelineRegister_t_0_0] <= mul_out1[PipelineRegister_t_0_0];
          end
        end
      end
    end

  assign mul_out1_0 = mul_out1_1[0];
  assign mul_out1_2 = mul_out1_1[2];

  assign mul_out1_4 = mul_out1_1[4];

  assign mul_out1_5 = mul_out1_1[5];

  assign sum_stage1_3 = mul_out1_4 + mul_out1_5;
  assign mul_out1_1_1 = mul_out1_1[1];

  assign sum_stage1_1 = mul_out1_0 + mul_out1_1_1;
  assign mul_out1_3 = mul_out1_1[3];

  assign sum_stage1_2 = mul_out1_2 + mul_out1_3;
  assign sum_stage2_1 = sum_stage1_1 + sum_stage1_2;
  assign mul_out1_6 = mul_out1_1[6];
  assign sum_stage2_2 = sum_stage1_3 + mul_out1_6;
  assign sum_stage3_1 = sum_stage2_1 + sum_stage2_2;
  assign out1 = sum_stage3_1;

endmodule  // dot_product_7

