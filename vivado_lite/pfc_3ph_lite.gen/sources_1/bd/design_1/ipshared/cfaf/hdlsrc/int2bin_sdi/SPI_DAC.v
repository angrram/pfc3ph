// -------------------------------------------------------------
// 
// File Name: C:\Users\Angel\Desktop\hil\ips\MCP_DRIVER\hdlsrc\int2bin_sdi\SPI_DAC.v
// Created: 2025-04-29 18:21:37
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 60
// Target subsystem base rate: 60
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        60
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// SDI                           ce_out        60
// SCK                           ce_out        60
// nCS1                          ce_out        60
// nCS2                          ce_out        60
// nCS3                          ce_out        60
// nCS4                          ce_out        60
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: SPI_DAC
// Source Path: int2bin_sdi/SPI_DAC
// Hierarchy Level: 0
// Model version: 3.71
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SPI_DAC
          (clk,
           rst,
           clk_enable,
           v1_1,
           v1_2,
           v2_1,
           v2_2,
           v3_2,
           v3_1,
           v4_1,
           v4_2,
           ce_out,
           SDI,
           SCK,
           nCS1,
           nCS2,
           nCS3,
           nCS4);


  input   clk;
  input   rst;
  input   clk_enable;
  input   [15:0] v1_1;  // uint16
  input   [15:0] v1_2;  // uint16
  input   [15:0] v2_1;  // uint16
  input   [15:0] v2_2;  // uint16
  input   [15:0] v3_2;  // uint16
  input   [15:0] v3_1;  // uint16
  input   [15:0] v4_1;  // uint16
  input   [15:0] v4_2;  // uint16
  output  ce_out;
  output  SDI;
  output  SCK;
  output  nCS1;
  output  nCS2;
  output  nCS3;
  output  nCS4;


  wire enb;
  reg [15:0] Delay_out1;  // uint16
  reg [15:0] Delay1_out1;  // uint16
  reg [15:0] Delay2_out1;  // uint16
  reg [15:0] Delay3_out1;  // uint16
  reg [15:0] Delay4_out1;  // uint16
  reg [15:0] Delay5_out1;  // uint16
  reg [15:0] Delay12_out1;  // uint16
  reg [15:0] Delay13_out1;  // uint16
  wire SDI_1;
  wire SCK_1;
  wire nCS1_1;
  wire nCS2_1;
  wire nCS3_1;
  wire nCS4_1;
  reg  [4:0] Delay6_reg;  // ufix1 [5]
  wire Delay6_out1;
  reg  [4:0] Delay7_reg;  // ufix1 [5]
  wire Delay7_out1;
  reg  [4:0] Delay8_reg;  // ufix1 [5]
  wire Delay8_out1;
  reg  [4:0] Delay9_reg;  // ufix1 [5]
  wire Delay9_out1;
  reg  [4:0] Delay10_reg;  // ufix1 [5]
  wire Delay10_out1;
  reg  [4:0] Delay11_reg;  // ufix1 [5]
  wire Delay11_out1;


  assign enb = clk_enable;

  always @(posedge clk)
    begin : Delay_process
      if (rst == 1'b1) begin
        Delay_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay_out1 <= v3_2;
        end
      end
    end
  always @(posedge clk)
    begin : Delay1_process
      if (rst == 1'b1) begin
        Delay1_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= v3_1;
        end
      end
    end
  always @(posedge clk)
    begin : Delay2_process
      if (rst == 1'b1) begin
        Delay2_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= v1_2;
        end
      end
    end
  always @(posedge clk)
    begin : Delay3_process
      if (rst == 1'b1) begin
        Delay3_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= v2_1;
        end
      end
    end
  always @(posedge clk)
    begin : Delay4_process
      if (rst == 1'b1) begin
        Delay4_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= v2_2;
        end
      end
    end
  always @(posedge clk)
    begin : Delay5_process
      if (rst == 1'b1) begin
        Delay5_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= v1_1;
        end
      end
    end
  always @(posedge clk)
    begin : Delay12_process
      if (rst == 1'b1) begin
        Delay12_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= v4_1;
        end
      end
    end
  always @(posedge clk)
    begin : Delay13_process
      if (rst == 1'b1) begin
        Delay13_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay13_out1 <= v4_2;
        end
      end
    end
  SPI_MNGR u_SPI_MNGR (.clk(clk),
                       .rst(rst),
                       .enb(clk_enable),
                       .v3_2(Delay_out1),  // uint16
                       .v3_1(Delay1_out1),  // uint16
                       .v1_2(Delay2_out1),  // uint16
                       .v2_1(Delay3_out1),  // uint16
                       .v2_2(Delay4_out1),  // uint16
                       .v1_1(Delay5_out1),  // uint16
                       .v4_2(Delay12_out1),  // uint16
                       .v4_1(Delay13_out1),  // uint16
                       .SDI(SDI_1),
                       .SCK(SCK_1),
                       .nCS1(nCS1_1),
                       .nCS2(nCS2_1),
                       .nCS3(nCS3_1),
                       .nCS4(nCS4_1)
                       );
  always @(posedge clk)
    begin : Delay6_process
      if (rst == 1'b1) begin
        Delay6_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          Delay6_reg[0] <= SDI_1;
          Delay6_reg[32'sd4:32'sd1] <= Delay6_reg[32'sd3:32'sd0];
        end
      end
    end

  assign Delay6_out1 = Delay6_reg[4];
  assign SDI = Delay6_out1;

  always @(posedge clk)
    begin : Delay7_process
      if (rst == 1'b1) begin
        Delay7_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          Delay7_reg[0] <= SCK_1;
          Delay7_reg[32'sd4:32'sd1] <= Delay7_reg[32'sd3:32'sd0];
        end
      end
    end

  assign Delay7_out1 = Delay7_reg[4];
  assign SCK = Delay7_out1;

  always @(posedge clk)
    begin : Delay8_process
      if (rst == 1'b1) begin
        Delay8_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          Delay8_reg[0] <= nCS1_1;
          Delay8_reg[32'sd4:32'sd1] <= Delay8_reg[32'sd3:32'sd0];
        end
      end
    end

  assign Delay8_out1 = Delay8_reg[4];
  assign nCS1 = Delay8_out1;

  always @(posedge clk)
    begin : Delay9_process
      if (rst == 1'b1) begin
        Delay9_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          Delay9_reg[0] <= nCS2_1;
          Delay9_reg[32'sd4:32'sd1] <= Delay9_reg[32'sd3:32'sd0];
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[4];
  assign nCS2 = Delay9_out1;

  always @(posedge clk)
    begin : Delay10_process
      if (rst == 1'b1) begin
        Delay10_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          Delay10_reg[0] <= nCS3_1;
          Delay10_reg[32'sd4:32'sd1] <= Delay10_reg[32'sd3:32'sd0];
        end
      end
    end

  assign Delay10_out1 = Delay10_reg[4];
  assign nCS3 = Delay10_out1;

  always @(posedge clk)
    begin : Delay11_process
      if (rst == 1'b1) begin
        Delay11_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          Delay11_reg[0] <= nCS4_1;
          Delay11_reg[32'sd4:32'sd1] <= Delay11_reg[32'sd3:32'sd0];
        end
      end
    end

  assign Delay11_out1 = Delay11_reg[4];
  assign nCS4 = Delay11_out1;

  assign ce_out = clk_enable;

endmodule  // SPI_DAC

