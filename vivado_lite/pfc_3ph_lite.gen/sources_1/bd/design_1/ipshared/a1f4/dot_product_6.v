// -------------------------------------------------------------
// 
// File Name: hdl_prj2\hdlsrc\HDL_pfc_gold_fi_og\dot_product_6.v
// Created: 2025-05-12 20:29:20
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dot_product_6
// Source Path: HDL_pfc_gold_fi_og/simscape_system/HDL Subsystem/Fixed-Point State-Space/hNNewMatrixA/dot_product_6
// Hierarchy Level: 3
// Model version: 1.239
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dot_product_6
          (clk,
           reset,
           enb,
           enb_1_1_1,
           in1_0,
           in1_1,
           in1_2,
           in1_3,
           in1_4,
           in1_5,
           in2_0,
           in2_1,
           in2_2,
           in2_3,
           in2_4,
           in2_5,
           out1);


  input   clk;
  input   reset;
  input   enb;
  input   enb_1_1_1;
  input   signed [24:0] in1_0;  // sfix25_En24
  input   signed [24:0] in1_1;  // sfix25_En24
  input   signed [24:0] in1_2;  // sfix25_En24
  input   signed [24:0] in1_3;  // sfix25_En24
  input   signed [24:0] in1_4;  // sfix25_En24
  input   signed [24:0] in1_5;  // sfix25_En24
  input   signed [24:0] in2_0;  // sfix25_En13
  input   signed [24:0] in2_1;  // sfix25_En13
  input   signed [24:0] in2_2;  // sfix25_En13
  input   signed [24:0] in2_3;  // sfix25_En13
  input   signed [24:0] in2_4;  // sfix25_En13
  input   signed [24:0] in2_5;  // sfix25_En13
  output  signed [49:0] out1;  // sfix50_En37


  wire [124:0] mergedInput;  // ufix125
  reg [124:0] mergedDelay_regin;  // ufix125
  reg [2:0] mergedDelay_waddr;  // ufix3
  wire mergedDelay_wrenb;  // ufix1
  reg [2:0] mergedDelay_raddr;  // ufix3
  wire [124:0] mergedDelay_regout;  // ufix125
  reg [124:0] mergedOutput;  // ufix125
  wire [24:0] slicedInput;  // ufix25
  wire signed [24:0] delayOut0;  // sfix25_En24
  wire [24:0] slicedInput_1;  // ufix25
  wire signed [24:0] delayOut1;  // sfix25_En24
  wire [24:0] slicedInput_2;  // ufix25
  wire signed [24:0] delayOut2;  // sfix25_En24
  wire [24:0] slicedInput_3;  // ufix25
  wire signed [24:0] delayOut3;  // sfix25_En24
  wire [24:0] slicedInput_4;  // ufix25
  wire signed [24:0] delayOut4;  // sfix25_En24
  reg signed [24:0] HwModeRegister5_regin;  // sfix25_En24
  reg [2:0] HwModeRegister5_waddr;  // ufix3
  wire HwModeRegister5_wrenb;  // ufix1
  reg [2:0] HwModeRegister5_raddr;  // ufix3
  wire signed [24:0] HwModeRegister5_regout;  // sfix25_En24
  reg signed [24:0] delayOut5;  // sfix25_En24
  wire signed [24:0] mul_in1 [0:5];  // sfix25_En24 [6]
  wire signed [24:0] mul_in2 [0:5];  // sfix25_En13 [6]
  reg signed [24:0] mul_in2_1 [0:5];  // sfix25_En13 [6]
  wire signed [49:0] mul_out1 [0:5];  // sfix50_En37 [6]
  reg signed [49:0] mul_out1_1 [0:5];  // sfix50_En37 [6]
  wire signed [49:0] mul_out1_0;  // sfix50_En37
  reg signed [49:0] mul_out1_0_1;  // sfix50_En37
  wire signed [49:0] mul_out1_1_1;  // sfix50_En37
  wire signed [49:0] mul_out1_2;  // sfix50_En37
  reg signed [49:0] mul_out1_2_1;  // sfix50_En37
  wire signed [49:0] mul_out1_3;  // sfix50_En37
  reg signed [49:0] mul_out1_1_2;  // sfix50_En37
  wire signed [49:0] sum_stage1_1;  // sfix50_En37
  reg signed [49:0] mul_out1_3_1;  // sfix50_En37
  wire signed [49:0] sum_stage1_2;  // sfix50_En37
  wire signed [49:0] sum_stage2_1;  // sfix50_En37
  reg signed [49:0] sum_stage2_1_1;  // sfix50_En37
  wire signed [49:0] mul_out1_4;  // sfix50_En37
  reg signed [49:0] mul_out1_4_1;  // sfix50_En37
  wire signed [49:0] mul_out1_5;  // sfix50_En37
  reg signed [49:0] mul_out1_5_1;  // sfix50_En37
  wire signed [49:0] sum_stage1_3;  // sfix50_En37
  reg signed [49:0] sum_stage2_2;  // sfix50_En37
  wire signed [49:0] sum_stage3_1;  // sfix50_En37
  reg signed [31:0] HwModeRegister1_t_0_0;  // int32
  reg signed [31:0] HwModeRegister1_t_1;  // int32
  reg signed [31:0] PipelineRegister_t_0_0;  // int32
  reg signed [31:0] PipelineRegister_t_1;  // int32


  assign mergedInput = {in1_0, in1_1, in1_2, in1_3, in1_4};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 125'h00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 3'b000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 3'b101) begin
            mergedDelay_waddr <= 3'b000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 3'b001;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 5
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 3'b001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 3'b101) begin
            mergedDelay_raddr <= 3'b000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 3'b001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(3),
                                     .DataWidth(125)
                                     )
                                   u_ShiftRegisterRAM_Wrapper (.clk(clk),
                                                               .reset(reset),
                                                               .enb(enb),
                                                               .enb_1_1_1(enb_1_1_1),
                                                               .wr_din(mergedDelay_regin),
                                                               .wr_addr(mergedDelay_waddr),
                                                               .wr_en(mergedDelay_wrenb),  // ufix1
                                                               .rd_addr(mergedDelay_raddr),
                                                               .dout(mergedDelay_regout)
                                                               );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 125'h00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign slicedInput = mergedOutput[124:100];

  assign delayOut0 = slicedInput;

  assign slicedInput_1 = mergedOutput[99:75];

  assign delayOut1 = slicedInput_1;

  assign slicedInput_2 = mergedOutput[74:50];

  assign delayOut2 = slicedInput_2;

  assign slicedInput_3 = mergedOutput[49:25];

  assign delayOut3 = slicedInput_3;

  assign slicedInput_4 = mergedOutput[24:0];

  assign delayOut4 = slicedInput_4;

  // Input register for RAM-based shift register HwModeRegister5
  always @(posedge clk)
    begin : HwModeRegister5_reginc_process
      if (reset == 1'b1) begin
        HwModeRegister5_regin <= 25'sb0000000000000000000000000;
      end
      else begin
        if (enb) begin
          HwModeRegister5_regin <= in1_5;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  // Write address counter for RAM-based shift register HwModeRegister5
  always @(posedge clk)
    begin : HwModeRegister5_wr_process
      if (reset == 1'b1) begin
        HwModeRegister5_waddr <= 3'b000;
      end
      else begin
        if (enb) begin
          if (HwModeRegister5_waddr >= 3'b101) begin
            HwModeRegister5_waddr <= 3'b000;
          end
          else begin
            HwModeRegister5_waddr <= HwModeRegister5_waddr + 3'b001;
          end
        end
      end
    end

  assign HwModeRegister5_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 5
  // Read address counter for RAM-based shift register HwModeRegister5
  always @(posedge clk)
    begin : HwModeRegister5_rd_process
      if (reset == 1'b1) begin
        HwModeRegister5_raddr <= 3'b001;
      end
      else begin
        if (enb) begin
          if (HwModeRegister5_raddr >= 3'b101) begin
            HwModeRegister5_raddr <= 3'b000;
          end
          else begin
            HwModeRegister5_raddr <= HwModeRegister5_raddr + 3'b001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(3),
                                     .DataWidth(25)
                                     )
                                   u_ShiftRegisterRAM_Wrapper_1 (.clk(clk),
                                                                 .reset(reset),
                                                                 .enb(enb),
                                                                 .enb_1_1_1(enb_1_1_1),
                                                                 .wr_din(HwModeRegister5_regin),
                                                                 .wr_addr(HwModeRegister5_waddr),
                                                                 .wr_en(HwModeRegister5_wrenb),  // ufix1
                                                                 .rd_addr(HwModeRegister5_raddr),
                                                                 .dout(HwModeRegister5_regout)
                                                                 );

  // Output register for RAM-based shift register HwModeRegister5
  always @(posedge clk)
    begin : HwModeRegister5_regoutc_process
      if (reset == 1'b1) begin
        delayOut5 <= 25'sb0000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayOut5 <= HwModeRegister5_regout;
        end
      end
    end

  assign mul_in1[0] = delayOut0;
  assign mul_in1[1] = delayOut1;
  assign mul_in1[2] = delayOut2;
  assign mul_in1[3] = delayOut3;
  assign mul_in1[4] = delayOut4;
  assign mul_in1[5] = delayOut5;

  assign mul_in2[0] = in2_0;
  assign mul_in2[1] = in2_1;
  assign mul_in2[2] = in2_2;
  assign mul_in2[3] = in2_3;
  assign mul_in2[4] = in2_4;
  assign mul_in2[5] = in2_5;

  always @(posedge clk)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        for(HwModeRegister1_t_1 = 32'sd0; HwModeRegister1_t_1 <= 32'sd5; HwModeRegister1_t_1 = HwModeRegister1_t_1 + 32'sd1) begin
          mul_in2_1[HwModeRegister1_t_1] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister1_t_0_0 = 32'sd0; HwModeRegister1_t_0_0 <= 32'sd5; HwModeRegister1_t_0_0 = HwModeRegister1_t_0_0 + 32'sd1) begin
            mul_in2_1[HwModeRegister1_t_0_0] <= mul_in2[HwModeRegister1_t_0_0];
          end
        end
      end
    end

  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space

  genvar t_0_01;
  generate
    for(t_0_01 = 32'sd0; t_0_01 <= 32'sd5; t_0_01 = t_0_01 + 32'sd1) begin:mul_out1_gen
      assign mul_out1[t_0_01] = mul_in1[t_0_01] * mul_in2_1[t_0_01];
    end
  endgenerate

  always @(posedge clk)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        for(PipelineRegister_t_1 = 32'sd0; PipelineRegister_t_1 <= 32'sd5; PipelineRegister_t_1 = PipelineRegister_t_1 + 32'sd1) begin
          mul_out1_1[PipelineRegister_t_1] <= 50'sh0000000000000;
        end
      end
      else begin
        if (enb) begin
          for(PipelineRegister_t_0_0 = 32'sd0; PipelineRegister_t_0_0 <= 32'sd5; PipelineRegister_t_0_0 = PipelineRegister_t_0_0 + 32'sd1) begin
            mul_out1_1[PipelineRegister_t_0_0] <= mul_out1[PipelineRegister_t_0_0];
          end
        end
      end
    end

  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  assign mul_out1_0 = mul_out1_1[0];

  always @(posedge clk)
    begin : rd_1_process
      if (reset == 1'b1) begin
        mul_out1_0_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_0_1 <= mul_out1_0;
        end
      end
    end

  assign mul_out1_1_1 = mul_out1_1[1];

  assign mul_out1_2 = mul_out1_1[2];

  always @(posedge clk)
    begin : rd_2_process
      if (reset == 1'b1) begin
        mul_out1_2_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_2_1 <= mul_out1_2;
        end
      end
    end

  assign mul_out1_3 = mul_out1_1[3];

  always @(posedge clk)
    begin : rd_4_process
      if (reset == 1'b1) begin
        mul_out1_1_2 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_1_2 <= mul_out1_1_1;
        end
      end
    end

  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  assign sum_stage1_1 = mul_out1_0_1 + mul_out1_1_2;

  always @(posedge clk)
    begin : rd_5_process
      if (reset == 1'b1) begin
        mul_out1_3_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_3_1 <= mul_out1_3;
        end
      end
    end

  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  assign sum_stage1_2 = mul_out1_2_1 + mul_out1_3_1;

  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  assign sum_stage2_1 = sum_stage1_1 + sum_stage1_2;

  always @(posedge clk)
    begin : rd_6_process
      if (reset == 1'b1) begin
        sum_stage2_1_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage2_1_1 <= sum_stage2_1;
        end
      end
    end

  assign mul_out1_4 = mul_out1_1[4];

  always @(posedge clk)
    begin : rd_3_process
      if (reset == 1'b1) begin
        mul_out1_4_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_4_1 <= mul_out1_4;
        end
      end
    end

  assign mul_out1_5 = mul_out1_1[5];

  always @(posedge clk)
    begin : rd_7_process
      if (reset == 1'b1) begin
        mul_out1_5_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_5_1 <= mul_out1_5;
        end
      end
    end

  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  assign sum_stage1_3 = mul_out1_4_1 + mul_out1_5_1;

  always @(posedge clk)
    begin : rd_8_process
      if (reset == 1'b1) begin
        sum_stage2_2 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage2_2 <= sum_stage1_3;
        end
      end
    end

  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  // <S179>/Fixed-Point State-Space
  assign sum_stage3_1 = sum_stage2_1_1 + sum_stage2_2;

  assign out1 = sum_stage3_1;

endmodule  // dot_product_6

