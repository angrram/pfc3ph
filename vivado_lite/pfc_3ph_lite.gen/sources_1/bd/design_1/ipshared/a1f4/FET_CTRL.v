// -------------------------------------------------------------
// 
// File Name: hdl_prj2\hdlsrc\HDL_pfc_gold_fi_og\FET_CTRL.v
// Created: 2025-05-12 20:29:20
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: FET_CTRL
// Source Path: HDL_pfc_gold_fi_og/simscape_system/FET_CTRL
// Hierarchy Level: 1
// Model version: 1.239
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module FET_CTRL
          (clk,
           reset,
           enb_1_49_1,
           enb,
           enb_1_1_1,
           is_0,
           is_1,
           is_2,
           is_3,
           is_4,
           is_5,
           vs_0,
           vs_1,
           vs_2,
           vs_3,
           vs_4,
           vs_5,
           G_0,
           G_1,
           G_2,
           G_3,
           G_4,
           G_5,
           sch_ctr_48,
           ic_0,
           ic_1,
           ic_2,
           ic_3,
           ic_4,
           ic_5);


  input   clk;
  input   reset;
  input   enb_1_49_1;
  input   enb;
  input   enb_1_1_1;
  input   signed [17:0] is_0;  // sfix18_En6
  input   signed [17:0] is_1;  // sfix18_En6
  input   signed [17:0] is_2;  // sfix18_En6
  input   signed [17:0] is_3;  // sfix18_En6
  input   signed [17:0] is_4;  // sfix18_En6
  input   signed [17:0] is_5;  // sfix18_En6
  input   signed [17:0] vs_0;  // sfix18_En6
  input   signed [17:0] vs_1;  // sfix18_En6
  input   signed [17:0] vs_2;  // sfix18_En6
  input   signed [17:0] vs_3;  // sfix18_En6
  input   signed [17:0] vs_4;  // sfix18_En6
  input   signed [17:0] vs_5;  // sfix18_En6
  input   G_0;  // boolean
  input   G_1;  // boolean
  input   G_2;  // boolean
  input   G_3;  // boolean
  input   G_4;  // boolean
  input   G_5;  // boolean
  input   [5:0] sch_ctr_48;  // ufix6
  output  signed [17:0] ic_0;  // sfix18_En8
  output  signed [17:0] ic_1;  // sfix18_En8
  output  signed [17:0] ic_2;  // sfix18_En8
  output  signed [17:0] ic_3;  // sfix18_En8
  output  signed [17:0] ic_4;  // sfix18_En8
  output  signed [17:0] ic_5;  // sfix18_En8


  wire crp_temp_streamed_enb_phase_0_5;
  reg  crp_temp_streamed_enb_phase_0_5_1;
  wire enb_gated;
  reg [2:0] counterSig;  // ufix3
  reg [5:0] rd_10_waddr;  // ufix6
  wire rd_10_wrenb;  // ufix1
  reg [5:0] rd_10_raddr;  // ufix6
  wire [5:0] mergedInput;  // ufix6
  reg [5:0] mergedDelay_regin;  // ufix6
  reg [4:0] mergedDelay_waddr;  // ufix5
  wire mergedDelay_wrenb;  // ufix1
  reg [4:0] mergedDelay_raddr;  // ufix5
  wire [5:0] mergedDelay_regout;  // ufix6
  reg [5:0] mergedOutput;  // ufix6
  wire [2:0] slicedInput;  // ufix3
  wire signed [17:0] vs [0:5];  // sfix18_En6 [6]
  reg signed [17:0] vs_6 [0:5];  // sfix18_En6 [6]
  wire signed [17:0] vs_0_1;  // sfix18_En6
  wire signed [17:0] vs_1_1;  // sfix18_En6
  wire signed [17:0] vs_2_1;  // sfix18_En6
  wire signed [17:0] vs_3_1;  // sfix18_En6
  wire signed [17:0] vs_4_1;  // sfix18_En6
  wire signed [17:0] vs_5_1;  // sfix18_En6
  wire signed [17:0] vs_unbuffer;  // sfix18_En6
  reg signed [17:0] vs_unbuffer_1;  // sfix18_En6
  wire signed [17:0] kconst;  // sfix18_En22
  reg signed [17:0] kconst_1;  // sfix18_En22
  wire signed [35:0] Gain3_out1;  // sfix36_En28
  reg signed [35:0] Gain3_out1_1;  // sfix36_En28
  wire signed [17:0] Gain3_out1_2;  // sfix18_En12
  reg signed [17:0] HwModeRegister_reg [0:1];  // sfix18 [2]
  wire signed [17:0] HwModeRegister_reg_next [0:1];  // sfix18_En12 [2]
  wire signed [17:0] Gain3_out1_3;  // sfix18_En12
  wire [2:0] slicedInput_1;  // ufix3
  wire signed [17:0] is [0:5];  // sfix18_En6 [6]
  reg signed [17:0] is_6 [0:5];  // sfix18_En6 [6]
  wire signed [17:0] is_0_1;  // sfix18_En6
  wire signed [17:0] is_1_1;  // sfix18_En6
  wire signed [17:0] is_2_1;  // sfix18_En6
  wire signed [17:0] is_3_1;  // sfix18_En6
  wire signed [17:0] is_4_1;  // sfix18_En6
  wire signed [17:0] is_5_1;  // sfix18_En6
  wire signed [17:0] is_unbuffer;  // sfix18_En6
  reg signed [17:0] is_unbuffer_1;  // sfix18_En6
  wire signed [17:0] kconst_2;  // sfix18_En17
  reg signed [17:0] kconst_3;  // sfix18_En17
  wire signed [35:0] on;  // sfix36_En23
  reg signed [35:0] on_1;  // sfix36_En23
  wire signed [17:0] on_2;  // sfix18_En12
  wire signed [18:0] Subtract1_sub_cast;  // sfix19_En12
  wire signed [18:0] Subtract1_sub_cast_1;  // sfix19_En12
  wire signed [18:0] Subtract1_sub_temp;  // sfix19_En12
  wire signed [17:0] Subtract1_out1;  // sfix18_En11
  reg signed [17:0] Subtract1_out1_1;  // sfix18_En11
  wire G_unbuffer;
  reg  rd_6_regin;
  reg [5:0] rd_6_waddr;  // ufix6
  wire rd_6_wrenb;  // ufix1
  reg [5:0] rd_6_raddr;  // ufix6
  wire rd_6_regout;
  reg  G_unbuffer_1;
  wire signed [17:0] Constant_out1;  // sfix18_En17
  wire signed [28:0] Equal_cast;  // sfix29_En17
  wire signed [28:0] Equal_cast_1;  // sfix29_En17
  wire Equal_out1;
  reg  Equal_out1_1;
  wire OR_out1;
  reg  [1:0] HwModeRegister1_reg;  // ufix1 [2]
  wire OR_out1_1;
  wire signed [17:0] Multiply_Add_mul_in1;  // sfix18_En11
  wire signed [18:0] Multiply_Add_mul_cast;  // sfix19_En11
  (* use_dsp  = "yes" *)   wire signed [17:0] mulOutput;  // sfix18_En11
  reg signed [17:0] mulOutput_1;  // sfix18_En11
  wire signed [19:0] Multiply_Add_add_add_cast;  // sfix20_En12
  wire signed [19:0] Multiply_Add_add_add_cast_1;  // sfix20_En12
  wire signed [19:0] Multiply_Add_add_add_temp;  // sfix20_En12
  wire signed [17:0] Multiply_Add_out1;  // sfix18_En12
  reg signed [17:0] rd_9_reg [0:1];  // sfix18 [2]
  wire signed [17:0] rd_9_reg_next [0:1];  // sfix18_En12 [2]
  wire signed [17:0] Multiply_Add_out1_1;  // sfix18_En12
  reg [5:0] rd_11_waddr;  // ufix6
  wire rd_11_wrenb;  // ufix1
  reg [5:0] rd_11_raddr;  // ufix6
  wire enb_counter_ge_32_1;
  reg  enb_counter_ge_32_2;
  wire enb_counter_le_36_1;
  reg  enb_counter_le_36_2;
  wire crp_temp_streamed_enb_phase_32_4;
  reg  [7:0] rd_16_reg;  // ufix1 [8]
  wire crp_temp_streamed_enb_phase_32_4_1;
  wire enb_gated_1;
  wire crp_temp_streamed_enb_phase_37_0;
  reg  [9:0] rd_19_reg;  // ufix1 [10]
  wire crp_temp_streamed_enb_phase_37_0_1;
  reg signed [17:0] Discrete_Time_Integrator_x_reg [0:5];  // sfix18_En8 [6]
  wire signed [17:0] Discrete_Time_Integrator_x_reg_5;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_4;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_3;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_2;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_1;  // sfix18_En8
  reg signed [17:0] Discrete_Time_Integrator_x_reg_6 [0:5];  // sfix18_En8 [6]
  wire signed [17:0] Discrete_Time_Integrator_u_sat;  // sfix18_En8
  reg signed [17:0] Discrete_Time_Integrator_u_sat_1;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_u_sat_2;  // sfix18_En8
  reg signed [17:0] Discrete_Time_Integrator_u_sat_held;  // sfix18_En8
  reg signed [17:0] Discrete_Time_Integrator_u_sat_3 [0:4];  // sfix18_En8 [5]
  reg signed [17:0] Discrete_Time_Integrator_u_sat_4 [0:4];  // sfix18_En8 [5]
  wire signed [17:0] Discrete_Time_Integrator_x_reg_unbuffer;  // sfix18_En8
  reg signed [17:0] rd_11_regin;  // sfix18_En8
  wire signed [17:0] rd_11_regout;  // sfix18_En8
  reg signed [17:0] ic;  // sfix18_En8
  wire signed [22:0] Subtract_sub_cast;  // sfix23_En12
  wire signed [22:0] Subtract_sub_cast_1;  // sfix23_En12
  wire signed [22:0] Subtract_sub_temp;  // sfix23_En12
  wire signed [17:0] Subtract_out1;  // sfix18_En12
  wire signed [17:0] Discrete_Time_Integrator_indtc;  // sfix18
  reg signed [17:0] Discrete_Time_Integrator_indtc_1;  // sfix18
  wire signed [18:0] gain_cast;  // sfix19_En4
  wire signed [17:0] Discrete_Time_Integrator_u_gain;  // sfix18
  wire signed [17:0] Discrete_Time_Integrator_u_dtc;  // sfix18_En8
  reg signed [17:0] Discrete_Time_Integrator_u_dtc_1;  // sfix18_En8
  reg signed [17:0] rd_10_regin;  // sfix18_En8
  wire signed [17:0] rd_10_regout;  // sfix18_En8
  reg signed [17:0] Discrete_Time_Integrator_add_in;  // sfix18_En8
  wire signed [18:0] adder_add_cast;  // sfix19_En8
  wire signed [18:0] adder_add_cast_1;  // sfix19_En8
  wire signed [18:0] adder_add_temp;  // sfix19_En8
  wire signed [17:0] Discrete_Time_Integrator_u_add;  // sfix18_En8
  reg signed [17:0] tapped_delay_reg [0:4];  // sfix18 [5]
  reg signed [17:0] tapped_delay_reg_next [0:4];  // sfix18_En8 [5]
  wire signed [17:0] Discrete_Time_Integrator_u_sat_5 [0:4];  // sfix18_En8 [5]
  wire signed [17:0] Discrete_Time_Integrator_u_sat_6 [0:5];  // sfix18_En8 [6]
  reg signed [17:0] Discrete_Time_Integrator_u_sat_7 [0:5];  // sfix18_En8 [6]
  reg signed [17:0] Discrete_Time_Integrator_reg_bypass_reg [0:5];  // sfix18 [6]
  reg signed [17:0] Discrete_Time_Integrator_reg_bypass_reg_next [0:5];  // sfix18_En8 [6]
  wire signed [17:0] Discrete_Time_Integrator_x_reg_7 [0:5];  // sfix18_En8 [6]
  wire signed [17:0] Discrete_Time_Integrator_x_reg_0;  // sfix18_En8
  wire crp_temp_streamed_enb_phase_0_4;
  reg  crp_temp_streamed_enb_phase_0_4_1;
  wire enb_gated_2;
  reg signed [17:0] tapped_delay_reg_1 [0:4];  // sfix18 [5]
  reg signed [17:0] tapped_delay_reg_next_1 [0:4];  // sfix18_En8 [5]
  reg signed [17:0] buffSig [0:4];  // sfix18_En8 [5]
  wire crp_temp_streamed_enb_phase_5_0;
  reg  crp_temp_streamed_enb_phase_5_0_1;
  wire signed [17:0] buffSig_1;  // sfix18_En8
  reg signed [17:0] buffSig_held;  // sfix18_En8
  reg signed [31:0] rd_4_t_0_0;  // int32
  reg signed [31:0] rd_4_t_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_0;  // int32
  reg signed [31:0] HwModeRegister_t_1;  // int32
  reg signed [31:0] rd_2_t_0_0;  // int32
  reg signed [31:0] rd_2_t_1;  // int32
  reg signed [31:0] rd_9_t_0_0;  // int32
  reg signed [31:0] rd_9_t_1;  // int32
  reg signed [31:0] tapped_delay_t_0_0;  // int32
  reg signed [31:0] tapped_delay_t_1;  // int32
  reg signed [31:0] tapped_delay_t_0_1;  // int32
  reg signed [31:0] tapped_delay_t_1_0;  // int32
  reg signed [31:0] rd_17_t_0_0;  // int32
  reg signed [31:0] rd_17_t_1;  // int32
  reg signed [31:0] crp_out_delay_t_0_0;  // int32
  reg signed [31:0] crp_out_delay_t_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_0_0;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_2;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_0_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_1_0;  // int32
  reg signed [31:0] rd_0_t_0_0;  // int32
  reg signed [31:0] rd_0_t_1;  // int32
  reg signed [31:0] tapped_delay_t_0_01;  // int32
  reg signed [31:0] tapped_delay_t_11;  // int32


  assign crp_temp_streamed_enb_phase_0_5 = sch_ctr_48 <= 6'b000101;

  always @(posedge clk)
    begin : rd_1_process
      if (reset == 1'b1) begin
        crp_temp_streamed_enb_phase_0_5_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          crp_temp_streamed_enb_phase_0_5_1 <= crp_temp_streamed_enb_phase_0_5;
        end
      end
    end

  assign enb_gated = crp_temp_streamed_enb_phase_0_5_1 && enb;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk)
    begin : ctr_0_5_process
      if (reset == 1'b1) begin
        counterSig <= 3'b000;
      end
      else begin
        if (enb_gated) begin
          if (counterSig >= 3'b101) begin
            counterSig <= 3'b000;
          end
          else begin
            counterSig <= counterSig + 3'b001;
          end
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 37
  // Write address counter for RAM-based shift register rd_10
  always @(posedge clk)
    begin : rd_10_wr_process
      if (reset == 1'b1) begin
        rd_10_waddr <= 6'b000000;
      end
      else begin
        if (enb) begin
          if (rd_10_waddr >= 6'b100101) begin
            rd_10_waddr <= 6'b000000;
          end
          else begin
            rd_10_waddr <= rd_10_waddr + 6'b000001;
          end
        end
      end
    end

  assign rd_10_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 37
  // Read address counter for RAM-based shift register rd_10
  always @(posedge clk)
    begin : rd_10_rd_process
      if (reset == 1'b1) begin
        rd_10_raddr <= 6'b000001;
      end
      else begin
        if (enb) begin
          if (rd_10_raddr >= 6'b100101) begin
            rd_10_raddr <= 6'b000000;
          end
          else begin
            rd_10_raddr <= rd_10_raddr + 6'b000001;
          end
        end
      end
    end

  assign mergedInput = {counterSig, counterSig};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 6'b000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 29
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 5'b00000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 5'b11101) begin
            mergedDelay_waddr <= 5'b00000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 5'b00001;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 29
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 5'b00001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 5'b11101) begin
            mergedDelay_raddr <= 5'b00000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 5'b00001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(5),
                                     .DataWidth(6)
                                     )
                                   u_ShiftRegisterRAM_Wrapper (.clk(clk),
                                                               .reset(reset),
                                                               .enb(enb),
                                                               .enb_1_1_1(enb_1_1_1),
                                                               .wr_din(mergedDelay_regin),
                                                               .wr_addr(mergedDelay_waddr),
                                                               .wr_en(mergedDelay_wrenb),  // ufix1
                                                               .rd_addr(mergedDelay_raddr),
                                                               .dout(mergedDelay_regout)
                                                               );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 6'b000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign slicedInput = mergedOutput[2:0];

  assign vs[0] = vs_0;
  assign vs[1] = vs_1;
  assign vs[2] = vs_2;
  assign vs[3] = vs_3;
  assign vs[4] = vs_4;
  assign vs[5] = vs_5;

  always @(posedge clk)
    begin : rd_4_process
      if (reset == 1'b1) begin
        for(rd_4_t_1 = 32'sd0; rd_4_t_1 <= 32'sd5; rd_4_t_1 = rd_4_t_1 + 32'sd1) begin
          vs_6[rd_4_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_4_t_0_0 = 32'sd0; rd_4_t_0_0 <= 32'sd5; rd_4_t_0_0 = rd_4_t_0_0 + 32'sd1) begin
            vs_6[rd_4_t_0_0] <= vs[rd_4_t_0_0];
          end
        end
      end
    end

  assign vs_0_1 = vs_6[0];

  assign vs_1_1 = vs_6[1];

  assign vs_2_1 = vs_6[2];

  assign vs_3_1 = vs_6[3];

  assign vs_4_1 = vs_6[4];

  assign vs_5_1 = vs_6[5];

  assign vs_unbuffer = (slicedInput == 3'b000 ? vs_0_1 :
              (slicedInput == 3'b001 ? vs_1_1 :
              (slicedInput == 3'b010 ? vs_2_1 :
              (slicedInput == 3'b011 ? vs_3_1 :
              (slicedInput == 3'b100 ? vs_4_1 :
              vs_5_1)))));

  always @(posedge clk)
    begin : HwModeRegister5_process
      if (reset == 1'b1) begin
        vs_unbuffer_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          vs_unbuffer_1 <= vs_unbuffer;
        end
      end
    end

  assign kconst = 18'sb010100011110101110;

  always @(posedge clk)
    begin : HwModeRegister6_process
      if (reset == 1'b1) begin
        kconst_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          kconst_1 <= kconst;
        end
      end
    end

  // <S178>/Gain3
  assign Gain3_out1 = vs_unbuffer_1 * kconst_1;

  always @(posedge clk)
    begin : PipelineRegister2_process
      if (reset == 1'b1) begin
        Gain3_out1_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Gain3_out1_1 <= Gain3_out1;
        end
      end
    end

  assign Gain3_out1_2 = Gain3_out1_1[33:16];

  always @(posedge clk)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1 = 32'sd0; HwModeRegister_t_1 <= 32'sd1; HwModeRegister_t_1 = HwModeRegister_t_1 + 32'sd1) begin
          HwModeRegister_reg[HwModeRegister_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_0 = 32'sd0; HwModeRegister_t_0_0 <= 32'sd1; HwModeRegister_t_0_0 = HwModeRegister_t_0_0 + 32'sd1) begin
            HwModeRegister_reg[HwModeRegister_t_0_0] <= HwModeRegister_reg_next[HwModeRegister_t_0_0];
          end
        end
      end
    end

  assign Gain3_out1_3 = HwModeRegister_reg[1];
  assign HwModeRegister_reg_next[0] = Gain3_out1_2;
  assign HwModeRegister_reg_next[1] = HwModeRegister_reg[0];

  assign slicedInput_1 = mergedOutput[5:3];

  assign is[0] = is_0;
  assign is[1] = is_1;
  assign is[2] = is_2;
  assign is[3] = is_3;
  assign is[4] = is_4;
  assign is[5] = is_5;

  always @(posedge clk)
    begin : rd_2_process
      if (reset == 1'b1) begin
        for(rd_2_t_1 = 32'sd0; rd_2_t_1 <= 32'sd5; rd_2_t_1 = rd_2_t_1 + 32'sd1) begin
          is_6[rd_2_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_2_t_0_0 = 32'sd0; rd_2_t_0_0 <= 32'sd5; rd_2_t_0_0 = rd_2_t_0_0 + 32'sd1) begin
            is_6[rd_2_t_0_0] <= is[rd_2_t_0_0];
          end
        end
      end
    end

  assign is_0_1 = is_6[0];

  assign is_1_1 = is_6[1];

  assign is_2_1 = is_6[2];

  assign is_3_1 = is_6[3];

  assign is_4_1 = is_6[4];

  assign is_5_1 = is_6[5];

  assign is_unbuffer = (slicedInput_1 == 3'b000 ? is_0_1 :
              (slicedInput_1 == 3'b001 ? is_1_1 :
              (slicedInput_1 == 3'b010 ? is_2_1 :
              (slicedInput_1 == 3'b011 ? is_3_1 :
              (slicedInput_1 == 3'b100 ? is_4_1 :
              is_5_1)))));

  always @(posedge clk)
    begin : HwModeRegister3_process
      if (reset == 1'b1) begin
        is_unbuffer_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          is_unbuffer_1 <= is_unbuffer;
        end
      end
    end

  assign kconst_2 = 18'sb100000000000000000;

  always @(posedge clk)
    begin : HwModeRegister4_process
      if (reset == 1'b1) begin
        kconst_3 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          kconst_3 <= kconst_2;
        end
      end
    end

  // <S178>/Gain1
  assign on = is_unbuffer_1 * kconst_3;

  always @(posedge clk)
    begin : PipelineRegister1_process
      if (reset == 1'b1) begin
        on_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          on_1 <= on;
        end
      end
    end

  assign on_2 = on_1[28:11];

  // <S178>/Subtract1
  assign Subtract1_sub_cast = {on_2[17], on_2};
  assign Subtract1_sub_cast_1 = {Gain3_out1_2[17], Gain3_out1_2};
  assign Subtract1_sub_temp = Subtract1_sub_cast - Subtract1_sub_cast_1;
  assign Subtract1_out1 = Subtract1_sub_temp[18:1];

  always @(posedge clk)
    begin : HwModeRegister_1_process
      if (reset == 1'b1) begin
        Subtract1_out1_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Subtract1_out1_1 <= Subtract1_out1;
        end
      end
    end

  assign G_unbuffer = (counterSig == 3'b000 ? G_0 :
              (counterSig == 3'b001 ? G_1 :
              (counterSig == 3'b010 ? G_2 :
              (counterSig == 3'b011 ? G_3 :
              (counterSig == 3'b100 ? G_4 :
              G_5)))));

  // Input register for RAM-based shift register rd_6
  always @(posedge clk)
    begin : rd_6_reginc_process
      if (reset == 1'b1) begin
        rd_6_regin <= 1'b0;
      end
      else begin
        if (enb) begin
          rd_6_regin <= G_unbuffer;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 30
  // Write address counter for RAM-based shift register rd_6
  always @(posedge clk)
    begin : rd_6_wr_process
      if (reset == 1'b1) begin
        rd_6_waddr <= 6'b000000;
      end
      else begin
        if (enb) begin
          if (rd_6_waddr >= 6'b011110) begin
            rd_6_waddr <= 6'b000000;
          end
          else begin
            rd_6_waddr <= rd_6_waddr + 6'b000001;
          end
        end
      end
    end

  assign rd_6_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 30
  // Read address counter for RAM-based shift register rd_6
  always @(posedge clk)
    begin : rd_6_rd_process
      if (reset == 1'b1) begin
        rd_6_raddr <= 6'b000001;
      end
      else begin
        if (enb) begin
          if (rd_6_raddr >= 6'b011110) begin
            rd_6_raddr <= 6'b000000;
          end
          else begin
            rd_6_raddr <= rd_6_raddr + 6'b000001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_singlebit #(.AddrWidth(6),
                                       .DataWidth(1)
                                       )
                                     u_ShiftRegisterRAM_Wrapper_singlebit (.clk(clk),
                                                                           .reset(reset),
                                                                           .enb(enb),
                                                                           .enb_1_1_1(enb_1_1_1),
                                                                           .wr_din(rd_6_regin),
                                                                           .wr_addr(rd_6_waddr),
                                                                           .wr_en(rd_6_wrenb),  // ufix1
                                                                           .rd_addr(rd_6_raddr),
                                                                           .dout(rd_6_regout)
                                                                           );

  // Output register for RAM-based shift register rd_6
  always @(posedge clk)
    begin : rd_6_regoutc_process
      if (reset == 1'b1) begin
        G_unbuffer_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          G_unbuffer_1 <= rd_6_regout;
        end
      end
    end

  // <S178>/Constant
  assign Constant_out1 = 18'sb101001100110011010;

  // <S178>/Equal
  assign Equal_cast = {{11{Constant_out1[17]}}, Constant_out1};
  assign Equal_cast_1 = {vs_unbuffer, 11'b00000000000};
  assign Equal_out1 = Equal_cast >= Equal_cast_1;

  always @(posedge clk)
    begin : rd_7_process
      if (reset == 1'b1) begin
        Equal_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Equal_out1_1 <= Equal_out1;
        end
      end
    end

  // <S178>/OR
  assign OR_out1 = G_unbuffer_1 | Equal_out1_1;

  always @(posedge clk)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        HwModeRegister1_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          HwModeRegister1_reg[0] <= OR_out1;
          HwModeRegister1_reg[1] <= HwModeRegister1_reg[0];
        end
      end
    end

  assign OR_out1_1 = HwModeRegister1_reg[1];

  // <S178>/Multiply-Add
  assign Multiply_Add_mul_in1 = (OR_out1_1 == 1'b1 ? Subtract1_out1_1 :
              18'sb000000000000000000);
  assign Multiply_Add_mul_cast = {Multiply_Add_mul_in1[17], Multiply_Add_mul_in1};
  assign mulOutput = Multiply_Add_mul_cast[17:0];

  always @(posedge clk)
    begin : HwModeRegister_2_process
      if (reset == 1'b1) begin
        mulOutput_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          mulOutput_1 <= mulOutput;
        end
      end
    end

  // <S178>/Multiply-Add
  assign Multiply_Add_add_add_cast = {{2{Gain3_out1_3[17]}}, Gain3_out1_3};
  assign Multiply_Add_add_add_cast_1 = {mulOutput_1[17], {mulOutput_1, 1'b0}};
  assign Multiply_Add_add_add_temp = Multiply_Add_add_add_cast + Multiply_Add_add_add_cast_1;
  assign Multiply_Add_out1 = ((Multiply_Add_add_add_temp[19] == 1'b0) && (Multiply_Add_add_add_temp[18:17] != 2'b00) ? 18'sb011111111111111111 :
              ((Multiply_Add_add_add_temp[19] == 1'b1) && (Multiply_Add_add_add_temp[18:17] != 2'b11) ? 18'sb100000000000000000 :
              $signed(Multiply_Add_add_add_temp[17:0])));

  always @(posedge clk)
    begin : rd_9_process
      if (reset == 1'b1) begin
        for(rd_9_t_1 = 32'sd0; rd_9_t_1 <= 32'sd1; rd_9_t_1 = rd_9_t_1 + 32'sd1) begin
          rd_9_reg[rd_9_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_9_t_0_0 = 32'sd0; rd_9_t_0_0 <= 32'sd1; rd_9_t_0_0 = rd_9_t_0_0 + 32'sd1) begin
            rd_9_reg[rd_9_t_0_0] <= rd_9_reg_next[rd_9_t_0_0];
          end
        end
      end
    end

  assign Multiply_Add_out1_1 = rd_9_reg[1];
  assign rd_9_reg_next[0] = Multiply_Add_out1;
  assign rd_9_reg_next[1] = rd_9_reg[0];

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 35
  // Write address counter for RAM-based shift register rd_11
  always @(posedge clk)
    begin : rd_11_wr_process
      if (reset == 1'b1) begin
        rd_11_waddr <= 6'b000000;
      end
      else begin
        if (enb) begin
          if (rd_11_waddr >= 6'b100011) begin
            rd_11_waddr <= 6'b000000;
          end
          else begin
            rd_11_waddr <= rd_11_waddr + 6'b000001;
          end
        end
      end
    end

  assign rd_11_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 35
  // Read address counter for RAM-based shift register rd_11
  always @(posedge clk)
    begin : rd_11_rd_process
      if (reset == 1'b1) begin
        rd_11_raddr <= 6'b000001;
      end
      else begin
        if (enb) begin
          if (rd_11_raddr >= 6'b100011) begin
            rd_11_raddr <= 6'b000000;
          end
          else begin
            rd_11_raddr <= rd_11_raddr + 6'b000001;
          end
        end
      end
    end

  assign enb_counter_ge_32_1 = sch_ctr_48 >= 6'b100000;

  always @(posedge clk)
    begin : rd_14_process
      if (reset == 1'b1) begin
        enb_counter_ge_32_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          enb_counter_ge_32_2 <= enb_counter_ge_32_1;
        end
      end
    end

  assign enb_counter_le_36_1 = sch_ctr_48 <= 6'b100100;

  always @(posedge clk)
    begin : rd_15_process
      if (reset == 1'b1) begin
        enb_counter_le_36_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          enb_counter_le_36_2 <= enb_counter_le_36_1;
        end
      end
    end

  assign crp_temp_streamed_enb_phase_32_4 = enb_counter_ge_32_2 & enb_counter_le_36_2;

  always @(posedge clk)
    begin : rd_16_process
      if (reset == 1'b1) begin
        rd_16_reg <= {8{1'b0}};
      end
      else begin
        if (enb) begin
          rd_16_reg[0] <= crp_temp_streamed_enb_phase_32_4;
          rd_16_reg[32'sd7:32'sd1] <= rd_16_reg[32'sd6:32'sd0];
        end
      end
    end

  assign crp_temp_streamed_enb_phase_32_4_1 = rd_16_reg[7];

  assign enb_gated_1 = crp_temp_streamed_enb_phase_32_4_1 && enb;

  assign crp_temp_streamed_enb_phase_37_0 = sch_ctr_48 == 6'b100101;

  always @(posedge clk)
    begin : rd_19_process
      if (reset == 1'b1) begin
        rd_19_reg <= {10{1'b0}};
      end
      else begin
        if (enb) begin
          rd_19_reg[0] <= crp_temp_streamed_enb_phase_37_0;
          rd_19_reg[32'sd9:32'sd1] <= rd_19_reg[32'sd8:32'sd0];
        end
      end
    end

  assign crp_temp_streamed_enb_phase_37_0_1 = rd_19_reg[9];

  assign Discrete_Time_Integrator_x_reg_5 = Discrete_Time_Integrator_x_reg[5];

  assign Discrete_Time_Integrator_x_reg_4 = Discrete_Time_Integrator_x_reg[4];

  assign Discrete_Time_Integrator_x_reg_3 = Discrete_Time_Integrator_x_reg[3];

  assign Discrete_Time_Integrator_x_reg_2 = Discrete_Time_Integrator_x_reg[2];

  assign Discrete_Time_Integrator_x_reg_1 = Discrete_Time_Integrator_x_reg[1];

  always @(posedge clk)
    begin : rd_18_process
      if (reset == 1'b1) begin
        Discrete_Time_Integrator_u_sat_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_u_sat_1 <= Discrete_Time_Integrator_u_sat;
        end
      end
    end

  always @(posedge clk)
    begin : Discrete_Time_Integrator_u_sat_state_process
      if (reset == 1'b1) begin
        Discrete_Time_Integrator_u_sat_held <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_u_sat_held <= Discrete_Time_Integrator_u_sat_2;
        end
      end
    end

  assign Discrete_Time_Integrator_u_sat_2 = (crp_temp_streamed_enb_phase_37_0_1 == 1'b0 ? Discrete_Time_Integrator_u_sat_held :
              Discrete_Time_Integrator_u_sat_1);

  // Input register for RAM-based shift register rd_11
  always @(posedge clk)
    begin : rd_11_reginc_process
      if (reset == 1'b1) begin
        rd_11_regin <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          rd_11_regin <= Discrete_Time_Integrator_x_reg_unbuffer;
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(6),
                                     .DataWidth(18)
                                     )
                                   u_ShiftRegisterRAM_Wrapper_generic (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb(enb),
                                                                       .enb_1_1_1(enb_1_1_1),
                                                                       .wr_din(rd_11_regin),
                                                                       .wr_addr(rd_11_waddr),
                                                                       .wr_en(rd_11_wrenb),  // ufix1
                                                                       .rd_addr(rd_11_raddr),
                                                                       .dout(rd_11_regout)
                                                                       );

  // Output register for RAM-based shift register rd_11
  always @(posedge clk)
    begin : rd_11_regoutc_process
      if (reset == 1'b1) begin
        ic <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          ic <= rd_11_regout;
        end
      end
    end

  // <S178>/Subtract
  assign Subtract_sub_cast = {{5{Multiply_Add_out1_1[17]}}, Multiply_Add_out1_1};
  assign Subtract_sub_cast_1 = {ic[17], {ic, 4'b0000}};
  assign Subtract_sub_temp = Subtract_sub_cast - Subtract_sub_cast_1;
  assign Subtract_out1 = Subtract_sub_temp[17:0];

  assign Discrete_Time_Integrator_indtc = Subtract_out1;

  always @(posedge clk)
    begin : rd_12_process
      if (reset == 1'b1) begin
        Discrete_Time_Integrator_indtc_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_indtc_1 <= Discrete_Time_Integrator_indtc;
        end
      end
    end

  assign gain_cast = {Discrete_Time_Integrator_indtc_1[17], Discrete_Time_Integrator_indtc_1};
  assign Discrete_Time_Integrator_u_gain = {{3{gain_cast[18]}}, gain_cast[18:4]};

  assign Discrete_Time_Integrator_u_dtc = Discrete_Time_Integrator_u_gain;

  always @(posedge clk)
    begin : rd_13_process
      if (reset == 1'b1) begin
        Discrete_Time_Integrator_u_dtc_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_u_dtc_1 <= Discrete_Time_Integrator_u_dtc;
        end
      end
    end

  // Input register for RAM-based shift register rd_10
  always @(posedge clk)
    begin : rd_10_reginc_process
      if (reset == 1'b1) begin
        rd_10_regin <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          rd_10_regin <= Discrete_Time_Integrator_x_reg_unbuffer;
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(6),
                                     .DataWidth(18)
                                     )
                                   u_ShiftRegisterRAM_Wrapper_1 (.clk(clk),
                                                                 .reset(reset),
                                                                 .enb(enb),
                                                                 .enb_1_1_1(enb_1_1_1),
                                                                 .wr_din(rd_10_regin),
                                                                 .wr_addr(rd_10_waddr),
                                                                 .wr_en(rd_10_wrenb),  // ufix1
                                                                 .rd_addr(rd_10_raddr),
                                                                 .dout(rd_10_regout)
                                                                 );

  // Output register for RAM-based shift register rd_10
  always @(posedge clk)
    begin : rd_10_regoutc_process
      if (reset == 1'b1) begin
        Discrete_Time_Integrator_add_in <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_add_in <= rd_10_regout;
        end
      end
    end

  assign adder_add_cast = {Discrete_Time_Integrator_add_in[17], Discrete_Time_Integrator_add_in};
  assign adder_add_cast_1 = {Discrete_Time_Integrator_u_dtc_1[17], Discrete_Time_Integrator_u_dtc_1};
  assign adder_add_temp = adder_add_cast + adder_add_cast_1;
  assign Discrete_Time_Integrator_u_add = ((adder_add_temp[18] == 1'b0) && (adder_add_temp[17] != 1'b0) ? 18'sb011111111111111111 :
              ((adder_add_temp[18] == 1'b1) && (adder_add_temp[17] != 1'b1) ? 18'sb100000000000000000 :
              $signed(adder_add_temp[17:0])));

  assign Discrete_Time_Integrator_u_sat = (Discrete_Time_Integrator_u_add > 18'sb000110010000000000 ? 18'sb000110010000000000 :
              (Discrete_Time_Integrator_u_add < 18'sb111001110000000000 ? 18'sb111001110000000000 :
              Discrete_Time_Integrator_u_add));

  always @(posedge clk)
    begin : tapped_delay_process
      if (reset == 1'b1) begin
        for(tapped_delay_t_1_0 = 32'sd0; tapped_delay_t_1_0 <= 32'sd4; tapped_delay_t_1_0 = tapped_delay_t_1_0 + 32'sd1) begin
          tapped_delay_reg[tapped_delay_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_gated_1) begin
          for(tapped_delay_t_0_1 = 32'sd0; tapped_delay_t_0_1 <= 32'sd4; tapped_delay_t_0_1 = tapped_delay_t_0_1 + 32'sd1) begin
            tapped_delay_reg[tapped_delay_t_0_1] <= tapped_delay_reg_next[tapped_delay_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(tapped_delay_t_0_0 = 32'sd0; tapped_delay_t_0_0 <= 32'sd4; tapped_delay_t_0_0 = tapped_delay_t_0_0 + 32'sd1) begin
      Discrete_Time_Integrator_u_sat_4[tapped_delay_t_0_0] = tapped_delay_reg[tapped_delay_t_0_0];
    end
    for(tapped_delay_t_1 = 32'sd0; tapped_delay_t_1 <= 32'sd3; tapped_delay_t_1 = tapped_delay_t_1 + 32'sd1) begin
      tapped_delay_reg_next[tapped_delay_t_1] = tapped_delay_reg[32'sd1 + tapped_delay_t_1];
    end

    tapped_delay_reg_next[4] = Discrete_Time_Integrator_u_sat;
  end

  assign Discrete_Time_Integrator_u_sat_5[0] = Discrete_Time_Integrator_u_sat_4[0];
  assign Discrete_Time_Integrator_u_sat_5[1] = Discrete_Time_Integrator_u_sat_4[1];
  assign Discrete_Time_Integrator_u_sat_5[2] = Discrete_Time_Integrator_u_sat_4[2];
  assign Discrete_Time_Integrator_u_sat_5[3] = Discrete_Time_Integrator_u_sat_4[3];
  assign Discrete_Time_Integrator_u_sat_5[4] = Discrete_Time_Integrator_u_sat_4[4];

  always @(posedge clk)
    begin : rd_17_process
      if (reset == 1'b1) begin
        for(rd_17_t_1 = 32'sd0; rd_17_t_1 <= 32'sd4; rd_17_t_1 = rd_17_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_u_sat_3[rd_17_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_17_t_0_0 = 32'sd0; rd_17_t_0_0 <= 32'sd4; rd_17_t_0_0 = rd_17_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_u_sat_3[rd_17_t_0_0] <= Discrete_Time_Integrator_u_sat_5[rd_17_t_0_0];
          end
        end
      end
    end

  assign Discrete_Time_Integrator_u_sat_6[0] = Discrete_Time_Integrator_u_sat_3[0];
  assign Discrete_Time_Integrator_u_sat_6[1] = Discrete_Time_Integrator_u_sat_3[1];
  assign Discrete_Time_Integrator_u_sat_6[2] = Discrete_Time_Integrator_u_sat_3[2];
  assign Discrete_Time_Integrator_u_sat_6[3] = Discrete_Time_Integrator_u_sat_3[3];
  assign Discrete_Time_Integrator_u_sat_6[4] = Discrete_Time_Integrator_u_sat_3[4];
  assign Discrete_Time_Integrator_u_sat_6[5] = Discrete_Time_Integrator_u_sat_2;

  always @(posedge clk)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        for(crp_out_delay_t_1 = 32'sd0; crp_out_delay_t_1 <= 32'sd5; crp_out_delay_t_1 = crp_out_delay_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_u_sat_7[crp_out_delay_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay_t_0_0 = 32'sd0; crp_out_delay_t_0_0 <= 32'sd5; crp_out_delay_t_0_0 = crp_out_delay_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_u_sat_7[crp_out_delay_t_0_0] <= Discrete_Time_Integrator_u_sat_6[crp_out_delay_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Discrete_Time_Integrator_reg_bypass_process
      if (reset == 1'b1) begin
        for(Discrete_Time_Integrator_reg_bypass_t_1_0 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_1_0 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_1_0 = Discrete_Time_Integrator_reg_bypass_t_1_0 + 32'sd1) begin
          Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Discrete_Time_Integrator_reg_bypass_t_0_1 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_0_1 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_0_1 = Discrete_Time_Integrator_reg_bypass_t_0_1 + 32'sd1) begin
            Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_0_1] <= Discrete_Time_Integrator_reg_bypass_reg_next[Discrete_Time_Integrator_reg_bypass_t_0_1];
          end
        end
      end
    end

  always @* begin
    if (enb_1_49_1 == 1'b1) begin
      for(Discrete_Time_Integrator_reg_bypass_t_1 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_1 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_1 = Discrete_Time_Integrator_reg_bypass_t_1 + 32'sd1) begin
        Discrete_Time_Integrator_x_reg_6[Discrete_Time_Integrator_reg_bypass_t_1] = Discrete_Time_Integrator_u_sat_7[Discrete_Time_Integrator_reg_bypass_t_1];
      end
    end
    else begin
      for(Discrete_Time_Integrator_reg_bypass_t_0_0 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_0_0 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_0_0 = Discrete_Time_Integrator_reg_bypass_t_0_0 + 32'sd1) begin
        Discrete_Time_Integrator_x_reg_6[Discrete_Time_Integrator_reg_bypass_t_0_0] = Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_0_0];
      end
    end

    for(Discrete_Time_Integrator_reg_bypass_t_2 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_2 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_2 = Discrete_Time_Integrator_reg_bypass_t_2 + 32'sd1) begin
      Discrete_Time_Integrator_reg_bypass_reg_next[Discrete_Time_Integrator_reg_bypass_t_2] = Discrete_Time_Integrator_u_sat_7[Discrete_Time_Integrator_reg_bypass_t_2];
    end

  end

  assign Discrete_Time_Integrator_x_reg_7[0] = Discrete_Time_Integrator_x_reg_6[0];
  assign Discrete_Time_Integrator_x_reg_7[1] = Discrete_Time_Integrator_x_reg_6[1];
  assign Discrete_Time_Integrator_x_reg_7[2] = Discrete_Time_Integrator_x_reg_6[2];
  assign Discrete_Time_Integrator_x_reg_7[3] = Discrete_Time_Integrator_x_reg_6[3];
  assign Discrete_Time_Integrator_x_reg_7[4] = Discrete_Time_Integrator_x_reg_6[4];
  assign Discrete_Time_Integrator_x_reg_7[5] = Discrete_Time_Integrator_x_reg_6[5];

  always @(posedge clk)
    begin : rd_0_process
      if (reset == 1'b1) begin
        for(rd_0_t_1 = 32'sd0; rd_0_t_1 <= 32'sd5; rd_0_t_1 = rd_0_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_x_reg[rd_0_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_0_t_0_0 = 32'sd0; rd_0_t_0_0 <= 32'sd5; rd_0_t_0_0 = rd_0_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_x_reg[rd_0_t_0_0] <= Discrete_Time_Integrator_x_reg_7[rd_0_t_0_0];
          end
        end
      end
    end

  assign Discrete_Time_Integrator_x_reg_0 = Discrete_Time_Integrator_x_reg[0];

  assign Discrete_Time_Integrator_x_reg_unbuffer = (counterSig == 3'b000 ? Discrete_Time_Integrator_x_reg_0 :
              (counterSig == 3'b001 ? Discrete_Time_Integrator_x_reg_1 :
              (counterSig == 3'b010 ? Discrete_Time_Integrator_x_reg_2 :
              (counterSig == 3'b011 ? Discrete_Time_Integrator_x_reg_3 :
              (counterSig == 3'b100 ? Discrete_Time_Integrator_x_reg_4 :
              Discrete_Time_Integrator_x_reg_5)))));

  assign crp_temp_streamed_enb_phase_0_4 = sch_ctr_48 <= 6'b000100;

  always @(posedge clk)
    begin : rd_20_process
      if (reset == 1'b1) begin
        crp_temp_streamed_enb_phase_0_4_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          crp_temp_streamed_enb_phase_0_4_1 <= crp_temp_streamed_enb_phase_0_4;
        end
      end
    end

  assign enb_gated_2 = crp_temp_streamed_enb_phase_0_4_1 && enb;

  always @(posedge clk)
    begin : tapped_delay_1_process
      if (reset == 1'b1) begin
        for(tapped_delay_t_1_0 = 32'sd0; tapped_delay_t_1_0 <= 32'sd4; tapped_delay_t_1_0 = tapped_delay_t_1_0 + 32'sd1) begin
          tapped_delay_reg_1[tapped_delay_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_gated_2) begin
          for(tapped_delay_t_0_1 = 32'sd0; tapped_delay_t_0_1 <= 32'sd4; tapped_delay_t_0_1 = tapped_delay_t_0_1 + 32'sd1) begin
            tapped_delay_reg_1[tapped_delay_t_0_1] <= tapped_delay_reg_next_1[tapped_delay_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(tapped_delay_t_0_01 = 32'sd0; tapped_delay_t_0_01 <= 32'sd4; tapped_delay_t_0_01 = tapped_delay_t_0_01 + 32'sd1) begin
      buffSig[tapped_delay_t_0_01] = tapped_delay_reg_1[tapped_delay_t_0_01];
    end
    for(tapped_delay_t_11 = 32'sd0; tapped_delay_t_11 <= 32'sd3; tapped_delay_t_11 = tapped_delay_t_11 + 32'sd1) begin
      tapped_delay_reg_next_1[tapped_delay_t_11] = tapped_delay_reg_1[32'sd1 + tapped_delay_t_11];
    end

    tapped_delay_reg_next_1[4] = Discrete_Time_Integrator_x_reg_unbuffer;
  end

  assign ic_0 = buffSig[0];

  assign ic_1 = buffSig[1];

  assign ic_2 = buffSig[2];

  assign ic_3 = buffSig[3];

  assign ic_4 = buffSig[4];

  assign crp_temp_streamed_enb_phase_5_0 = sch_ctr_48 == 6'b000101;

  always @(posedge clk)
    begin : rd_21_process
      if (reset == 1'b1) begin
        crp_temp_streamed_enb_phase_5_0_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          crp_temp_streamed_enb_phase_5_0_1 <= crp_temp_streamed_enb_phase_5_0;
        end
      end
    end

  always @(posedge clk)
    begin : buffSig_state_process
      if (reset == 1'b1) begin
        buffSig_held <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          buffSig_held <= buffSig_1;
        end
      end
    end

  assign buffSig_1 = (crp_temp_streamed_enb_phase_5_0_1 == 1'b0 ? buffSig_held :
              Discrete_Time_Integrator_x_reg_unbuffer);

  assign ic_5 = buffSig_1;

endmodule  // FET_CTRL

