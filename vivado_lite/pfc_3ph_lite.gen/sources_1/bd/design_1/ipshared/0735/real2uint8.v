// -------------------------------------------------------------
// 
// File Name: hdl_prj2\hdlsrc\HDL_pfc_gold_fi_og\real2uint8.v
// Created: 2025-05-03 19:08:43
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: real2uint8
// Source Path: HDL_pfc_gold_fi_og/simscape_system/real2uint8
// Hierarchy Level: 1
// Model version: 1.231
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module real2uint8
          (clk,
           reset,
           enb_1_49_1,
           enb,
           enb_1_49_0,
           I_load,
           Vout,
           Ib,
           Ic,
           Ia,
           Vb,
           Vc,
           Va,
           O_Ia,
           O_Ib,
           O_Ic,
           O_Vc,
           O_Vb,
           O_Va,
           O_Vout,
           O_I_load);


  input   clk;
  input   reset;
  input   enb_1_49_1;
  input   enb;
  input   enb_1_49_0;
  input   signed [17:0] I_load;  // sfix18_En6
  input   signed [17:0] Vout;  // sfix18_En6
  input   signed [17:0] Ib;  // sfix18_En6
  input   signed [17:0] Ic;  // sfix18_En6
  input   signed [17:0] Ia;  // sfix18_En6
  input   signed [17:0] Vb;  // sfix18_En6
  input   signed [17:0] Vc;  // sfix18_En6
  input   signed [17:0] Va;  // sfix18_En6
  output  [15:0] O_Ia;  // uint16
  output  [15:0] O_Ib;  // uint16
  output  [15:0] O_Ic;  // uint16
  output  [15:0] O_Vc;  // uint16
  output  [15:0] O_Vb;  // uint16
  output  [15:0] O_Va;  // uint16
  output  [15:0] O_Vout;  // uint16
  output  [15:0] O_I_load;  // uint16


  wire signed [17:0] Constant_out1;  // sfix18_En6
  wire signed [17:0] Mux1_out1 [0:2];  // sfix18_En6 [3]
  reg signed [17:0] Mux1_out1_1 [0:2];  // sfix18_En6 [3]
  reg signed [17:0] Mux1_out1_2 [0:2];  // sfix18_En6 [3]
  wire signed [17:0] delayIn0;  // sfix18_En6
  wire signed [17:0] delayIn1;  // sfix18_En6
  wire signed [17:0] delayIn2;  // sfix18_En6
  wire signed [17:0] kconst;  // sfix18_En9
  reg signed [17:0] kconst_1;  // sfix18_En9
  wire signed [17:0] Mux_out1 [0:2];  // sfix18_En6 [3]
  reg signed [17:0] Mux_out1_1 [0:2];  // sfix18_En6 [3]
  reg signed [17:0] Delay8_bypass_reg [0:2];  // sfix18 [3]
  reg signed [17:0] Delay8_bypass_reg_next [0:2];  // sfix18_En6 [3]
  reg signed [17:0] Delay8_out1 [0:2];  // sfix18_En6 [3]
  wire signed [17:0] Delay8_out1_1 [0:2];  // sfix18_En6 [3]
  reg signed [17:0] Delay8_out1_2 [0:2];  // sfix18_En6 [3]
  wire signed [17:0] Constant1_out1;  // sfix18_En6
  wire signed [18:0] Add3_v;  // sfix19_En6
  wire signed [18:0] Add3_add_cast [0:2];  // sfix19_En6 [3]
  wire signed [18:0] Add3_out1 [0:2];  // sfix19_En6 [3]
  reg signed [18:0] Add3_out1_1 [0:2];  // sfix19_En6 [3]
  reg signed [18:0] Add3_out1_2 [0:2];  // sfix19_En6 [3]
  wire signed [18:0] delayIn0_1;  // sfix19_En6
  wire signed [18:0] delayIn1_1;  // sfix19_En6
  wire signed [18:0] delayIn2_1;  // sfix19_En6
  wire [56:0] mergedInput;  // ufix57
  reg [56:0] mergedDelay_regin;  // ufix57
  reg [1:0] mergedDelay_waddr;  // ufix2
  wire mergedDelay_wrenb;  // ufix1
  reg [1:0] mergedDelay_raddr;  // ufix2
  wire [56:0] mergedDelay_regout;  // ufix57
  reg [56:0] mergedOutput;  // ufix57
  wire [18:0] slicedInput;  // ufix19
  wire signed [18:0] delayOut0;  // sfix19_En6
  wire [18:0] slicedInput_1;  // ufix19
  wire signed [18:0] delayOut1;  // sfix19_En6
  wire [18:0] slicedInput_2;  // ufix19
  wire signed [18:0] delayOut2;  // sfix19_En6
  wire signed [18:0] Delay11_out1 [0:2];  // sfix19_En6 [3]
  reg signed [18:0] Delay11_out1_1 [0:2];  // sfix19_En6 [3]
  wire signed [18:0] kconst_2;  // sfix19_En15
  reg signed [18:0] kconst_3;  // sfix19_En15
  (* use_dsp  = "no" *)   wire signed [37:0] Gain5_out1 [0:2];  // sfix38_En21 [3]
  reg signed [37:0] crp_out_delay12_reg [0:5];  // sfix38 [6]
  reg signed [37:0] crp_out_delay12_reg_next [0:5];  // sfix38_En21 [6]
  reg signed [37:0] Gain5_out1_1 [0:2];  // sfix38_En21 [3]
  reg signed [37:0] Gain5_out1_2 [0:2];  // sfix38_En21 [3]
  wire signed [37:0] delayIn0_2;  // sfix38_En21
  wire signed [37:0] delayIn1_2;  // sfix38_En21
  wire signed [37:0] delayIn2_2;  // sfix38_En21
  wire [113:0] mergedInput_1;  // ufix114
  reg [113:0] mergedDelay_regin_1;  // ufix114
  reg [1:0] mergedDelay_waddr_1;  // ufix2
  wire mergedDelay_wrenb_1;  // ufix1
  reg [1:0] mergedDelay_raddr_1;  // ufix2
  wire [113:0] mergedDelay_regout_1;  // ufix114
  reg [113:0] mergedOutput_1;  // ufix114
  wire [37:0] slicedInput_3;  // ufix38
  wire signed [37:0] delayOut0_1;  // sfix38_En21
  wire [37:0] slicedInput_4;  // ufix38
  wire signed [37:0] delayOut1_1;  // sfix38_En21
  wire [37:0] slicedInput_5;  // ufix38
  wire signed [37:0] delayOut2_1;  // sfix38_En21
  wire signed [37:0] Delay22_out1 [0:2];  // sfix38_En21 [3]
  wire [15:0] Data_Type_Conversion2_out1 [0:2];  // uint16 [3]
  reg [15:0] Data_Type_Conversion2_out1_1 [0:2];  // uint16 [3]
  reg [15:0] Data_Type_Conversion2_out1_2 [0:2];  // uint16 [3]
  wire [15:0] delayIn0_3;  // uint16
  wire [15:0] delayIn1_3;  // uint16
  wire [15:0] delayIn2_3;  // uint16
  reg signed [17:0] I_load_1;  // sfix18_En6
  reg signed [17:0] I_load_2;  // sfix18_En6
  reg signed [17:0] Vout_1;  // sfix18_En6
  reg signed [17:0] Vout_2;  // sfix18_En6
  wire [83:0] mergedInput_2;  // ufix84
  reg [83:0] mergedDelay_regin_2;  // ufix84
  reg [1:0] mergedDelay_waddr_2;  // ufix2
  wire mergedDelay_wrenb_2;  // ufix1
  reg [1:0] mergedDelay_raddr_2;  // ufix2
  wire [83:0] mergedDelay_regout_2;  // ufix84
  reg [83:0] mergedOutput_2;  // ufix84
  wire [17:0] slicedInput_6;  // ufix18
  wire signed [17:0] Delay6_out1;  // sfix18_En6
  wire signed [17:0] Delay6_out1_1;  // sfix18_En6
  reg signed [17:0] Delay6_out1_2;  // sfix18_En6
  (* use_dsp  = "no" *)   wire signed [35:0] Gain3_out1;  // sfix36_En15
  reg signed [35:0] crp_out_delay3_reg [0:1];  // sfix36 [2]
  wire signed [35:0] crp_out_delay3_reg_next [0:1];  // sfix36_En15 [2]
  wire signed [35:0] Gain3_out1_1;  // sfix36_En15
  reg signed [35:0] Delay16_bypass_reg;  // sfix36
  wire signed [35:0] Delay16_out1;  // sfix36_En15
  wire signed [35:0] Delay16_out1_1;  // sfix36_En15
  wire [15:0] Data_Type_Conversion1_out1;  // uint16
  reg [15:0] Data_Type_Conversion1_out1_1;  // uint16
  reg [15:0] Data_Type_Conversion1_out1_2;  // uint16
  wire signed [17:0] kconst_4;  // sfix18_En14
  reg signed [17:0] kconst_5;  // sfix18_En14
  wire [17:0] slicedInput_7;  // ufix18
  wire signed [17:0] Delay9_out1;  // sfix18_En6
  wire signed [17:0] Delay9_out1_1;  // sfix18_En6
  reg signed [17:0] Delay9_out1_2;  // sfix18_En6
  (* use_dsp  = "no" *)   wire signed [35:0] Gain4_out1;  // sfix36_En20
  reg signed [35:0] crp_out_delay4_reg [0:1];  // sfix36 [2]
  wire signed [35:0] crp_out_delay4_reg_next [0:1];  // sfix36_En20 [2]
  wire signed [35:0] Gain4_out1_1;  // sfix36_En20
  reg signed [35:0] Gain4_out1_2;  // sfix36_En20
  reg [1:0] mergedDelay_waddr_3;  // ufix2
  wire mergedDelay_wrenb_3;  // ufix1
  reg [1:0] mergedDelay_raddr_3;  // ufix2
  reg [121:0] mergedOutput_3;  // ufix122
  wire [35:0] slicedInput_8;  // ufix36
  wire signed [35:0] Delay12_out1;  // sfix36_En20
  wire signed [35:0] Delay12_out1_1;  // sfix36_En20
  wire [15:0] Data_Type_Conversion3_out1;  // uint16
  reg [15:0] Data_Type_Conversion3_out1_1;  // uint16
  reg [15:0] Data_Type_Conversion3_out1_2;  // uint16
  wire [121:0] mergedInput_3;  // ufix122
  reg [121:0] mergedDelay_regin_3;  // ufix122
  wire [121:0] mergedDelay_regout_3;  // ufix122
  wire [17:0] slicedInput_9;  // ufix18
  wire signed [17:0] delayOut0_2;  // sfix18_En6
  wire [17:0] slicedInput_10;  // ufix18
  wire signed [17:0] delayOut1_2;  // sfix18_En6
  wire [17:0] slicedInput_11;  // ufix18
  wire signed [17:0] delayOut2_2;  // sfix18_En6
  wire signed [17:0] Delay3_out1 [0:2];  // sfix18_En6 [3]
  reg signed [17:0] Delay3_out1_1 [0:2];  // sfix18_En6 [3]
  wire signed [18:0] Add2_u;  // sfix19_En6
  wire signed [18:0] Add2_add_cast [0:2];  // sfix19_En6 [3]
  wire signed [18:0] Add2_out1 [0:2];  // sfix19_En6 [3]
  reg signed [18:0] Add2_out1_1 [0:2];  // sfix19_En6 [3]
  reg signed [18:0] Add2_out1_2 [0:2];  // sfix19_En6 [3]
  wire signed [18:0] delayIn0_4;  // sfix19_En6
  wire signed [18:0] delayIn1_4;  // sfix19_En6
  wire signed [18:0] delayIn2_4;  // sfix19_En6
  wire [56:0] mergedInput_4;  // ufix57
  reg [56:0] mergedDelay_regin_4;  // ufix57
  reg [1:0] mergedDelay_waddr_4;  // ufix2
  wire mergedDelay_wrenb_4;  // ufix1
  reg [1:0] mergedDelay_raddr_4;  // ufix2
  wire [56:0] mergedDelay_regout_4;  // ufix57
  reg [56:0] mergedOutput_4;  // ufix57
  wire [18:0] slicedInput_12;  // ufix19
  wire signed [18:0] delayOut0_3;  // sfix19_En6
  wire [18:0] slicedInput_13;  // ufix19
  wire signed [18:0] delayOut1_3;  // sfix19_En6
  wire [18:0] slicedInput_14;  // ufix19
  wire signed [18:0] delayOut2_3;  // sfix19_En6
  wire signed [18:0] Delay2_out1 [0:2];  // sfix19_En6 [3]
  reg signed [18:0] Delay2_out1_1 [0:2];  // sfix19_En6 [3]
  wire signed [18:0] kconst_6;  // sfix19_En12
  reg signed [18:0] kconst_7;  // sfix19_En12
  (* use_dsp  = "no" *)   wire signed [37:0] Gain2_out1 [0:2];  // sfix38_En18 [3]
  reg signed [37:0] crp_out_delay13_reg [0:5];  // sfix38 [6]
  reg signed [37:0] crp_out_delay13_reg_next [0:5];  // sfix38_En18 [6]
  reg signed [37:0] Gain2_out1_1 [0:2];  // sfix38_En18 [3]
  reg signed [37:0] Gain2_out1_2 [0:2];  // sfix38_En18 [3]
  wire signed [37:0] delayIn0_5;  // sfix38_En18
  wire signed [37:0] delayIn1_5;  // sfix38_En18
  wire signed [37:0] delayIn2_5;  // sfix38_En18
  wire [113:0] mergedInput_5;  // ufix114
  reg [113:0] mergedDelay_regin_5;  // ufix114
  reg [1:0] mergedDelay_waddr_5;  // ufix2
  wire mergedDelay_wrenb_5;  // ufix1
  reg [1:0] mergedDelay_raddr_5;  // ufix2
  wire [113:0] mergedDelay_regout_5;  // ufix114
  reg [113:0] mergedOutput_5;  // ufix114
  wire [37:0] slicedInput_15;  // ufix38
  wire signed [37:0] delayOut0_4;  // sfix38_En18
  wire [37:0] slicedInput_16;  // ufix38
  wire signed [37:0] delayOut1_4;  // sfix38_En18
  wire [37:0] slicedInput_17;  // ufix38
  wire signed [37:0] delayOut2_4;  // sfix38_En18
  wire signed [37:0] Delay_out1 [0:2];  // sfix38_En18 [3]
  wire [15:0] Data_Type_Conversion5_out1 [0:2];  // uint16 [3]
  reg [15:0] Data_Type_Conversion5_out1_1 [0:2];  // uint16 [3]
  reg [15:0] Data_Type_Conversion5_out1_2 [0:2];  // uint16 [3]
  wire [15:0] delayIn0_6;  // uint16
  wire [15:0] delayIn1_6;  // uint16
  wire [15:0] delayIn2_6;  // uint16
  wire [47:0] mergedInput_6;  // ufix48
  reg [47:0] mergedDelay_regin_6;  // ufix48
  reg [1:0] mergedDelay_waddr_6;  // ufix2
  wire mergedDelay_wrenb_6;  // ufix1
  reg [1:0] mergedDelay_raddr_6;  // ufix2
  wire [47:0] mergedDelay_regout_6;  // ufix48
  reg [47:0] mergedOutput_6;  // ufix48
  wire [15:0] slicedInput_18;  // ufix16
  wire [15:0] delayOut1_5;  // uint16
  wire [15:0] slicedInput_19;  // ufix16
  wire [15:0] delayOut0_5;  // uint16
  wire [15:0] slicedInput_20;  // ufix16
  wire [15:0] delayOut2_5;  // uint16
  wire [15:0] slicedInput_21;  // ufix16
  wire [15:0] delayOut1_6;  // uint16
  wire [15:0] slicedInput_22;  // ufix16
  wire [15:0] delayOut0_6;  // uint16
  wire [15:0] slicedInput_23;  // ufix16
  wire [15:0] delayOut2_6;  // uint16
  wire [15:0] slicedInput_24;  // ufix16
  wire [15:0] Delay25_out1;  // uint16
  wire [15:0] slicedInput_25;  // ufix16
  wire [15:0] Delay29_out1;  // uint16
  reg signed [31:0] crp_out_delay_t_0_0;  // int32
  reg signed [31:0] crp_out_delay_t_1;  // int32
  reg signed [31:0] Delay31_output_t_0_0;  // int32
  reg signed [31:0] Delay31_output_t_1;  // int32
  reg signed [31:0] crp_out_delay1_t_0_0;  // int32
  reg signed [31:0] crp_out_delay1_t_1;  // int32
  reg signed [31:0] Delay8_bypass_t_0_0;  // int32
  reg signed [31:0] Delay8_bypass_t_1;  // int32
  reg signed [31:0] Delay8_bypass_t_2;  // int32
  reg signed [31:0] Delay8_bypass_t_0_1;  // int32
  reg signed [31:0] Delay8_bypass_t_1_0;  // int32
  reg signed [31:0] rd_0_t_0_0;  // int32
  reg signed [31:0] rd_0_t_1;  // int32
  reg signed [31:0] crp_out_delay6_t_0_0;  // int32
  reg signed [31:0] crp_out_delay6_t_1;  // int32
  reg signed [31:0] Delay11_output_t_0_0;  // int32
  reg signed [31:0] Delay11_output_t_1;  // int32
  reg signed [31:0] HwModeRegister4_t_0_0;  // int32
  reg signed [31:0] HwModeRegister4_t_1;  // int32
  reg signed [31:0] crp_out_delay12_t_0_0;  // int32
  reg signed [31:0] crp_out_delay12_t_0_1;  // int32
  reg signed [31:0] crp_out_delay12_t_1;  // int32
  reg signed [31:0] Delay22_output_t_0_0;  // int32
  reg signed [31:0] Delay22_output_t_1;  // int32
  reg signed [31:0] crp_out_delay5_t_0_0;  // int32
  reg signed [31:0] crp_out_delay5_t_1;  // int32
  reg signed [31:0] Delay24_output_t_0_0;  // int32
  reg signed [31:0] Delay24_output_t_1;  // int32
  reg signed [31:0] crp_out_delay3_t_0_0;  // int32
  reg signed [31:0] crp_out_delay3_t_1;  // int32
  reg signed [31:0] crp_out_delay4_t_0_0;  // int32
  reg signed [31:0] crp_out_delay4_t_1;  // int32
  reg signed [31:0] rd_4_t_0_0;  // int32
  reg signed [31:0] rd_4_t_1;  // int32
  reg signed [31:0] crp_out_delay9_t_0_0;  // int32
  reg signed [31:0] crp_out_delay9_t_1;  // int32
  reg signed [31:0] Delay2_output_t_0_0;  // int32
  reg signed [31:0] Delay2_output_t_1;  // int32
  reg signed [31:0] HwModeRegister6_t_0_0;  // int32
  reg signed [31:0] HwModeRegister6_t_1;  // int32
  reg signed [31:0] crp_out_delay13_t_0_0;  // int32
  reg signed [31:0] crp_out_delay13_t_0_1;  // int32
  reg signed [31:0] crp_out_delay13_t_1;  // int32
  reg signed [31:0] Delay_output_t_0_0;  // int32
  reg signed [31:0] Delay_output_t_1;  // int32
  reg signed [31:0] crp_out_delay2_t_0_0;  // int32
  reg signed [31:0] crp_out_delay2_t_1;  // int32
  reg signed [31:0] Delay1_output_t_0_0;  // int32
  reg signed [31:0] Delay1_output_t_1;  // int32


  // <S180>/Constant
  assign Constant_out1 = 18'sb000000101000000000;

  // <S180>/Mux1
  assign Mux1_out1[0] = Ib;
  assign Mux1_out1[1] = Ia;
  assign Mux1_out1[2] = Ic;

  always @(posedge clk)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        for(crp_out_delay_t_1 = 32'sd0; crp_out_delay_t_1 <= 32'sd2; crp_out_delay_t_1 = crp_out_delay_t_1 + 32'sd1) begin
          Mux1_out1_1[crp_out_delay_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay_t_0_0 = 32'sd0; crp_out_delay_t_0_0 <= 32'sd2; crp_out_delay_t_0_0 = crp_out_delay_t_0_0 + 32'sd1) begin
            Mux1_out1_1[crp_out_delay_t_0_0] <= Mux1_out1[crp_out_delay_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Delay31_output_process
      if (reset == 1'b1) begin
        for(Delay31_output_t_1 = 32'sd0; Delay31_output_t_1 <= 32'sd2; Delay31_output_t_1 = Delay31_output_t_1 + 32'sd1) begin
          Mux1_out1_2[Delay31_output_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Delay31_output_t_0_0 = 32'sd0; Delay31_output_t_0_0 <= 32'sd2; Delay31_output_t_0_0 = Delay31_output_t_0_0 + 32'sd1) begin
            Mux1_out1_2[Delay31_output_t_0_0] <= Mux1_out1_1[Delay31_output_t_0_0];
          end
        end
      end
    end

  assign delayIn0 = Mux1_out1_2[0];

  assign delayIn1 = Mux1_out1_2[1];

  assign delayIn2 = Mux1_out1_2[2];

  assign kconst = 18'sb011001100101100110;

  always @(posedge clk)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        kconst_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          kconst_1 <= kconst;
        end
      end
    end

  // <S180>/Mux
  assign Mux_out1[0] = Vb;
  assign Mux_out1[1] = Vc;
  assign Mux_out1[2] = Va;

  always @(posedge clk)
    begin : crp_out_delay1_process
      if (reset == 1'b1) begin
        for(crp_out_delay1_t_1 = 32'sd0; crp_out_delay1_t_1 <= 32'sd2; crp_out_delay1_t_1 = crp_out_delay1_t_1 + 32'sd1) begin
          Mux_out1_1[crp_out_delay1_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay1_t_0_0 = 32'sd0; crp_out_delay1_t_0_0 <= 32'sd2; crp_out_delay1_t_0_0 = crp_out_delay1_t_0_0 + 32'sd1) begin
            Mux_out1_1[crp_out_delay1_t_0_0] <= Mux_out1[crp_out_delay1_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Delay8_bypass_process
      if (reset == 1'b1) begin
        for(Delay8_bypass_t_1_0 = 32'sd0; Delay8_bypass_t_1_0 <= 32'sd2; Delay8_bypass_t_1_0 = Delay8_bypass_t_1_0 + 32'sd1) begin
          Delay8_bypass_reg[Delay8_bypass_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Delay8_bypass_t_0_1 = 32'sd0; Delay8_bypass_t_0_1 <= 32'sd2; Delay8_bypass_t_0_1 = Delay8_bypass_t_0_1 + 32'sd1) begin
            Delay8_bypass_reg[Delay8_bypass_t_0_1] <= Delay8_bypass_reg_next[Delay8_bypass_t_0_1];
          end
        end
      end
    end

  always @* begin
    if (enb_1_49_1 == 1'b1) begin
      for(Delay8_bypass_t_1 = 32'sd0; Delay8_bypass_t_1 <= 32'sd2; Delay8_bypass_t_1 = Delay8_bypass_t_1 + 32'sd1) begin
        Delay8_out1[Delay8_bypass_t_1] = Mux_out1_1[Delay8_bypass_t_1];
      end
    end
    else begin
      for(Delay8_bypass_t_0_0 = 32'sd0; Delay8_bypass_t_0_0 <= 32'sd2; Delay8_bypass_t_0_0 = Delay8_bypass_t_0_0 + 32'sd1) begin
        Delay8_out1[Delay8_bypass_t_0_0] = Delay8_bypass_reg[Delay8_bypass_t_0_0];
      end
    end

    for(Delay8_bypass_t_2 = 32'sd0; Delay8_bypass_t_2 <= 32'sd2; Delay8_bypass_t_2 = Delay8_bypass_t_2 + 32'sd1) begin
      Delay8_bypass_reg_next[Delay8_bypass_t_2] = Mux_out1_1[Delay8_bypass_t_2];
    end

  end

  assign Delay8_out1_1[0] = Delay8_out1[0];
  assign Delay8_out1_1[1] = Delay8_out1[1];
  assign Delay8_out1_1[2] = Delay8_out1[2];

  always @(posedge clk)
    begin : rd_0_process
      if (reset == 1'b1) begin
        for(rd_0_t_1 = 32'sd0; rd_0_t_1 <= 32'sd2; rd_0_t_1 = rd_0_t_1 + 32'sd1) begin
          Delay8_out1_2[rd_0_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_0_t_0_0 = 32'sd0; rd_0_t_0_0 <= 32'sd2; rd_0_t_0_0 = rd_0_t_0_0 + 32'sd1) begin
            Delay8_out1_2[rd_0_t_0_0] <= Delay8_out1_1[rd_0_t_0_0];
          end
        end
      end
    end

  // <S180>/Constant1
  assign Constant1_out1 = 18'sb000110100100000000;

  // <S180>/Add3
  assign Add3_v = {Constant1_out1[17], Constant1_out1};

  genvar t_0_04;
  generate
    for(t_0_04 = 32'sd0; t_0_04 <= 32'sd2; t_0_04 = t_0_04 + 32'sd1) begin:Add3_out1_gen
      assign Add3_add_cast[t_0_04] = {Delay8_out1_2[t_0_04][17], Delay8_out1_2[t_0_04]};
      assign Add3_out1[t_0_04] = Add3_add_cast[t_0_04] + Add3_v;
    end
  endgenerate

  always @(posedge clk)
    begin : crp_out_delay6_process
      if (reset == 1'b1) begin
        for(crp_out_delay6_t_1 = 32'sd0; crp_out_delay6_t_1 <= 32'sd2; crp_out_delay6_t_1 = crp_out_delay6_t_1 + 32'sd1) begin
          Add3_out1_1[crp_out_delay6_t_1] <= 19'sb0000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay6_t_0_0 = 32'sd0; crp_out_delay6_t_0_0 <= 32'sd2; crp_out_delay6_t_0_0 = crp_out_delay6_t_0_0 + 32'sd1) begin
            Add3_out1_1[crp_out_delay6_t_0_0] <= Add3_out1[crp_out_delay6_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Delay11_output_process
      if (reset == 1'b1) begin
        for(Delay11_output_t_1 = 32'sd0; Delay11_output_t_1 <= 32'sd2; Delay11_output_t_1 = Delay11_output_t_1 + 32'sd1) begin
          Add3_out1_2[Delay11_output_t_1] <= 19'sb0000000000000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Delay11_output_t_0_0 = 32'sd0; Delay11_output_t_0_0 <= 32'sd2; Delay11_output_t_0_0 = Delay11_output_t_0_0 + 32'sd1) begin
            Add3_out1_2[Delay11_output_t_0_0] <= Add3_out1_1[Delay11_output_t_0_0];
          end
        end
      end
    end

  assign delayIn0_1 = Add3_out1_2[0];

  assign delayIn1_1 = Add3_out1_2[1];

  assign delayIn2_1 = Add3_out1_2[2];

  assign mergedInput = {delayIn0_1, delayIn1_1, delayIn2_1};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 57'h000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 2'b00;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_waddr >= 2'b01) begin
            mergedDelay_waddr <= 2'b00;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 2'b01;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_raddr >= 2'b01) begin
            mergedDelay_raddr <= 2'b00;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 2'b01;
          end
        end
      end
    end

  // <S180>/Delay11
  // <S180>/Delay11
  // <S180>/Delay11
  ShiftRegisterRAM_Wrapper_generic_block #(.AddrWidth(2),
                                           .DataWidth(57)
                                           )
                                         u_ShiftRegisterRAM_Wrapper (.clk(clk),
                                                                     .reset(reset),
                                                                     .enb_1_49_1(enb_1_49_1),
                                                                     .enb_1_49_0(enb_1_49_0),
                                                                     .wr_din(mergedDelay_regin),
                                                                     .wr_addr(mergedDelay_waddr),
                                                                     .wr_en(mergedDelay_wrenb),  // ufix1
                                                                     .rd_addr(mergedDelay_raddr),
                                                                     .dout(mergedDelay_regout)
                                                                     );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 57'h000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign slicedInput = mergedOutput[56:38];

  assign delayOut0 = slicedInput;

  assign slicedInput_1 = mergedOutput[37:19];

  assign delayOut1 = slicedInput_1;

  assign slicedInput_2 = mergedOutput[18:0];

  assign delayOut2 = slicedInput_2;

  assign Delay11_out1[0] = delayOut0;
  assign Delay11_out1[1] = delayOut1;
  assign Delay11_out1[2] = delayOut2;

  always @(posedge clk)
    begin : HwModeRegister4_process
      if (reset == 1'b1) begin
        for(HwModeRegister4_t_1 = 32'sd0; HwModeRegister4_t_1 <= 32'sd2; HwModeRegister4_t_1 = HwModeRegister4_t_1 + 32'sd1) begin
          Delay11_out1_1[HwModeRegister4_t_1] <= 19'sb0000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister4_t_0_0 = 32'sd0; HwModeRegister4_t_0_0 <= 32'sd2; HwModeRegister4_t_0_0 = HwModeRegister4_t_0_0 + 32'sd1) begin
            Delay11_out1_1[HwModeRegister4_t_0_0] <= Delay11_out1[HwModeRegister4_t_0_0];
          end
        end
      end
    end

  assign kconst_2 = 19'sb0100110111111011001;

  always @(posedge clk)
    begin : HwModeRegister5_process
      if (reset == 1'b1) begin
        kconst_3 <= 19'sb0000000000000000000;
      end
      else begin
        if (enb) begin
          kconst_3 <= kconst_2;
        end
      end
    end

  // <S180>/Gain5

  genvar t_0_011;
  generate
    for(t_0_011 = 32'sd0; t_0_011 <= 32'sd2; t_0_011 = t_0_011 + 32'sd1) begin:Gain5_out1_gen
      assign Gain5_out1[t_0_011] = Delay11_out1_1[t_0_011] * kconst_3;
    end
  endgenerate

  always @(posedge clk)
    begin : crp_out_delay12_process
      if (reset == 1'b1) begin
        for(crp_out_delay12_t_1 = 32'sd0; crp_out_delay12_t_1 <= 32'sd5; crp_out_delay12_t_1 = crp_out_delay12_t_1 + 32'sd1) begin
          crp_out_delay12_reg[crp_out_delay12_t_1] <= 38'sh0000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay12_t_0_1 = 32'sd0; crp_out_delay12_t_0_1 <= 32'sd5; crp_out_delay12_t_0_1 = crp_out_delay12_t_0_1 + 32'sd1) begin
            crp_out_delay12_reg[crp_out_delay12_t_0_1] <= crp_out_delay12_reg_next[crp_out_delay12_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(crp_out_delay12_t_0_0 = 32'sd0; crp_out_delay12_t_0_0 <= 32'sd2; crp_out_delay12_t_0_0 = crp_out_delay12_t_0_0 + 32'sd1) begin
      Gain5_out1_1[crp_out_delay12_t_0_0] = crp_out_delay12_reg[32'sd3 + crp_out_delay12_t_0_0];
      crp_out_delay12_reg_next[crp_out_delay12_t_0_0] = Gain5_out1[crp_out_delay12_t_0_0];
      crp_out_delay12_reg_next[crp_out_delay12_t_0_0 + 32'sd3] = crp_out_delay12_reg[crp_out_delay12_t_0_0];
    end

  end

  always @(posedge clk)
    begin : Delay22_output_process
      if (reset == 1'b1) begin
        for(Delay22_output_t_1 = 32'sd0; Delay22_output_t_1 <= 32'sd2; Delay22_output_t_1 = Delay22_output_t_1 + 32'sd1) begin
          Gain5_out1_2[Delay22_output_t_1] <= 38'sh0000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Delay22_output_t_0_0 = 32'sd0; Delay22_output_t_0_0 <= 32'sd2; Delay22_output_t_0_0 = Delay22_output_t_0_0 + 32'sd1) begin
            Gain5_out1_2[Delay22_output_t_0_0] <= Gain5_out1_1[Delay22_output_t_0_0];
          end
        end
      end
    end

  assign delayIn0_2 = Gain5_out1_2[0];

  assign delayIn1_2 = Gain5_out1_2[1];

  assign delayIn2_2 = Gain5_out1_2[2];

  assign mergedInput_1 = {delayIn0_2, delayIn1_2, delayIn2_2};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_1_process
      if (reset == 1'b1) begin
        mergedDelay_regin_1 <= 114'h00000000000000000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedDelay_regin_1 <= mergedInput_1;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_1_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_1 <= 2'b00;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_waddr_1 >= 2'b01) begin
            mergedDelay_waddr_1 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_1 <= mergedDelay_waddr_1 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_1 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_1_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_1 <= 2'b01;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_raddr_1 >= 2'b01) begin
            mergedDelay_raddr_1 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_1 <= mergedDelay_raddr_1 + 2'b01;
          end
        end
      end
    end

  // <S180>/Delay22
  // <S180>/Delay22
  // <S180>/Delay22
  ShiftRegisterRAM_Wrapper_generic_block #(.AddrWidth(2),
                                           .DataWidth(114)
                                           )
                                         u_ShiftRegisterRAM_Wrapper_1 (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb_1_49_1(enb_1_49_1),
                                                                       .enb_1_49_0(enb_1_49_0),
                                                                       .wr_din(mergedDelay_regin_1),
                                                                       .wr_addr(mergedDelay_waddr_1),
                                                                       .wr_en(mergedDelay_wrenb_1),  // ufix1
                                                                       .rd_addr(mergedDelay_raddr_1),
                                                                       .dout(mergedDelay_regout_1)
                                                                       );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_1_process
      if (reset == 1'b1) begin
        mergedOutput_1 <= 114'h00000000000000000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedOutput_1 <= mergedDelay_regout_1;
        end
      end
    end

  assign slicedInput_3 = mergedOutput_1[113:76];

  assign delayOut0_1 = slicedInput_3;

  assign slicedInput_4 = mergedOutput_1[75:38];

  assign delayOut1_1 = slicedInput_4;

  assign slicedInput_5 = mergedOutput_1[37:0];

  assign delayOut2_1 = slicedInput_5;

  assign Delay22_out1[0] = delayOut0_1;
  assign Delay22_out1[1] = delayOut1_1;
  assign Delay22_out1[2] = delayOut2_1;

  // <S180>/Data Type Conversion2

  genvar ii2;
  generate
    for(ii2 = 32'sd0; ii2 <= 32'sd2; ii2 = ii2 + 32'sd1) begin:Data_Type_Conversion2_out1_gen
      assign Data_Type_Conversion2_out1[ii2] = Delay22_out1[ii2][36:21];
    end
  endgenerate

  always @(posedge clk)
    begin : crp_out_delay5_process
      if (reset == 1'b1) begin
        for(crp_out_delay5_t_1 = 32'sd0; crp_out_delay5_t_1 <= 32'sd2; crp_out_delay5_t_1 = crp_out_delay5_t_1 + 32'sd1) begin
          Data_Type_Conversion2_out1_1[crp_out_delay5_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay5_t_0_0 = 32'sd0; crp_out_delay5_t_0_0 <= 32'sd2; crp_out_delay5_t_0_0 = crp_out_delay5_t_0_0 + 32'sd1) begin
            Data_Type_Conversion2_out1_1[crp_out_delay5_t_0_0] <= Data_Type_Conversion2_out1[crp_out_delay5_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Delay24_output_process
      if (reset == 1'b1) begin
        for(Delay24_output_t_1 = 32'sd0; Delay24_output_t_1 <= 32'sd2; Delay24_output_t_1 = Delay24_output_t_1 + 32'sd1) begin
          Data_Type_Conversion2_out1_2[Delay24_output_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Delay24_output_t_0_0 = 32'sd0; Delay24_output_t_0_0 <= 32'sd2; Delay24_output_t_0_0 = Delay24_output_t_0_0 + 32'sd1) begin
            Data_Type_Conversion2_out1_2[Delay24_output_t_0_0] <= Data_Type_Conversion2_out1_1[Delay24_output_t_0_0];
          end
        end
      end
    end

  assign delayIn0_3 = Data_Type_Conversion2_out1_2[0];

  assign delayIn1_3 = Data_Type_Conversion2_out1_2[1];

  assign delayIn2_3 = Data_Type_Conversion2_out1_2[2];

  always @(posedge clk)
    begin : crp_out_delay10_process
      if (reset == 1'b1) begin
        I_load_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          I_load_1 <= I_load;
        end
      end
    end

  always @(posedge clk)
    begin : Delay6_output_process
      if (reset == 1'b1) begin
        I_load_2 <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_49_1) begin
          I_load_2 <= I_load_1;
        end
      end
    end

  always @(posedge clk)
    begin : crp_out_delay11_process
      if (reset == 1'b1) begin
        Vout_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Vout_1 <= Vout;
        end
      end
    end

  always @(posedge clk)
    begin : Delay9_output_process
      if (reset == 1'b1) begin
        Vout_2 <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_49_1) begin
          Vout_2 <= Vout_1;
        end
      end
    end

  assign mergedInput_2 = {delayIn0_3, delayIn1_3, delayIn2_3, I_load_2, Vout_2};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_2_process
      if (reset == 1'b1) begin
        mergedDelay_regin_2 <= 84'h000000000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedDelay_regin_2 <= mergedInput_2;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_2_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_2 <= 2'b00;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_waddr_2 >= 2'b01) begin
            mergedDelay_waddr_2 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_2 <= mergedDelay_waddr_2 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_2 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_2_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_2 <= 2'b01;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_raddr_2 >= 2'b01) begin
            mergedDelay_raddr_2 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_2 <= mergedDelay_raddr_2 + 2'b01;
          end
        end
      end
    end

  // <S180>/Delay24
  // <S180>/Delay24
  // <S180>/Delay24
  // <S180>/Delay6
  // <S180>/Delay9
  ShiftRegisterRAM_Wrapper_generic_block #(.AddrWidth(2),
                                           .DataWidth(84)
                                           )
                                         u_ShiftRegisterRAM_Wrapper_2 (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb_1_49_1(enb_1_49_1),
                                                                       .enb_1_49_0(enb_1_49_0),
                                                                       .wr_din(mergedDelay_regin_2),
                                                                       .wr_addr(mergedDelay_waddr_2),
                                                                       .wr_en(mergedDelay_wrenb_2),  // ufix1
                                                                       .rd_addr(mergedDelay_raddr_2),
                                                                       .dout(mergedDelay_regout_2)
                                                                       );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_2_process
      if (reset == 1'b1) begin
        mergedOutput_2 <= 84'h000000000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedOutput_2 <= mergedDelay_regout_2;
        end
      end
    end

  assign slicedInput_6 = mergedOutput_2[35:18];

  assign Delay6_out1 = slicedInput_6;

  assign Delay6_out1_1 = Delay6_out1;

  always @(posedge clk)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        Delay6_out1_2 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Delay6_out1_2 <= Delay6_out1_1;
        end
      end
    end

  // <S180>/Gain3
  assign Gain3_out1 = kconst_1 * Delay6_out1_2;

  always @(posedge clk)
    begin : crp_out_delay3_process
      if (reset == 1'b1) begin
        for(crp_out_delay3_t_1 = 32'sd0; crp_out_delay3_t_1 <= 32'sd1; crp_out_delay3_t_1 = crp_out_delay3_t_1 + 32'sd1) begin
          crp_out_delay3_reg[crp_out_delay3_t_1] <= 36'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay3_t_0_0 = 32'sd0; crp_out_delay3_t_0_0 <= 32'sd1; crp_out_delay3_t_0_0 = crp_out_delay3_t_0_0 + 32'sd1) begin
            crp_out_delay3_reg[crp_out_delay3_t_0_0] <= crp_out_delay3_reg_next[crp_out_delay3_t_0_0];
          end
        end
      end
    end

  assign Gain3_out1_1 = crp_out_delay3_reg[1];
  assign crp_out_delay3_reg_next[0] = Gain3_out1;
  assign crp_out_delay3_reg_next[1] = crp_out_delay3_reg[0];

  always @(posedge clk)
    begin : Delay16_bypass_process
      if (reset == 1'b1) begin
        Delay16_bypass_reg <= 36'sh000000000;
      end
      else begin
        if (enb_1_49_1) begin
          Delay16_bypass_reg <= Gain3_out1_1;
        end
      end
    end

  assign Delay16_out1 = (enb_1_49_1 == 1'b1 ? Gain3_out1_1 :
              Delay16_bypass_reg);

  assign Delay16_out1_1 = Delay16_out1;

  // <S180>/Data Type Conversion1
  assign Data_Type_Conversion1_out1 = Delay16_out1_1[30:15];

  always @(posedge clk)
    begin : crp_out_delay7_process
      if (reset == 1'b1) begin
        Data_Type_Conversion1_out1_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Data_Type_Conversion1_out1_1 <= Data_Type_Conversion1_out1;
        end
      end
    end

  always @(posedge clk)
    begin : Delay291_output_process
      if (reset == 1'b1) begin
        Data_Type_Conversion1_out1_2 <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_49_1) begin
          Data_Type_Conversion1_out1_2 <= Data_Type_Conversion1_out1_1;
        end
      end
    end

  assign kconst_4 = 18'sb010001001111001110;

  always @(posedge clk)
    begin : HwModeRegister2_process
      if (reset == 1'b1) begin
        kconst_5 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          kconst_5 <= kconst_4;
        end
      end
    end

  assign slicedInput_7 = mergedOutput_2[17:0];

  assign Delay9_out1 = slicedInput_7;

  assign Delay9_out1_1 = Delay9_out1;

  always @(posedge clk)
    begin : HwModeRegister3_process
      if (reset == 1'b1) begin
        Delay9_out1_2 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Delay9_out1_2 <= Delay9_out1_1;
        end
      end
    end

  // <S180>/Gain4
  assign Gain4_out1 = kconst_5 * Delay9_out1_2;

  always @(posedge clk)
    begin : crp_out_delay4_process
      if (reset == 1'b1) begin
        for(crp_out_delay4_t_1 = 32'sd0; crp_out_delay4_t_1 <= 32'sd1; crp_out_delay4_t_1 = crp_out_delay4_t_1 + 32'sd1) begin
          crp_out_delay4_reg[crp_out_delay4_t_1] <= 36'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay4_t_0_0 = 32'sd0; crp_out_delay4_t_0_0 <= 32'sd1; crp_out_delay4_t_0_0 = crp_out_delay4_t_0_0 + 32'sd1) begin
            crp_out_delay4_reg[crp_out_delay4_t_0_0] <= crp_out_delay4_reg_next[crp_out_delay4_t_0_0];
          end
        end
      end
    end

  assign Gain4_out1_1 = crp_out_delay4_reg[1];
  assign crp_out_delay4_reg_next[0] = Gain4_out1;
  assign crp_out_delay4_reg_next[1] = crp_out_delay4_reg[0];

  always @(posedge clk)
    begin : Delay12_output_process
      if (reset == 1'b1) begin
        Gain4_out1_2 <= 36'sh000000000;
      end
      else begin
        if (enb_1_49_1) begin
          Gain4_out1_2 <= Gain4_out1_1;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_3_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_3 <= 2'b00;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_waddr_3 >= 2'b01) begin
            mergedDelay_waddr_3 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_3 <= mergedDelay_waddr_3 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_3 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_3_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_3 <= 2'b01;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_raddr_3 >= 2'b01) begin
            mergedDelay_raddr_3 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_3 <= mergedDelay_raddr_3 + 2'b01;
          end
        end
      end
    end

  assign slicedInput_8 = mergedOutput_3[35:0];

  assign Delay12_out1 = slicedInput_8;

  assign Delay12_out1_1 = Delay12_out1;

  // <S180>/Data Type Conversion3
  assign Data_Type_Conversion3_out1 = Delay12_out1_1[35:20];

  always @(posedge clk)
    begin : crp_out_delay8_process
      if (reset == 1'b1) begin
        Data_Type_Conversion3_out1_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Data_Type_Conversion3_out1_1 <= Data_Type_Conversion3_out1;
        end
      end
    end

  always @(posedge clk)
    begin : Delay251_output_process
      if (reset == 1'b1) begin
        Data_Type_Conversion3_out1_2 <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_49_1) begin
          Data_Type_Conversion3_out1_2 <= Data_Type_Conversion3_out1_1;
        end
      end
    end

  assign mergedInput_3 = {delayIn0, delayIn1, delayIn2, Data_Type_Conversion1_out1_2, Data_Type_Conversion3_out1_2, Gain4_out1_2};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_3_process
      if (reset == 1'b1) begin
        mergedDelay_regin_3 <= 122'h0000000000000000000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedDelay_regin_3 <= mergedInput_3;
        end
      end
    end

  // <S180>/Delay3
  // <S180>/Delay3
  // <S180>/Delay3
  // <S180>/Delay29
  // <S180>/Delay25
  // <S180>/Delay12
  ShiftRegisterRAM_Wrapper_generic_block #(.AddrWidth(2),
                                           .DataWidth(122)
                                           )
                                         u_ShiftRegisterRAM_Wrapper_generic (.clk(clk),
                                                                             .reset(reset),
                                                                             .enb_1_49_1(enb_1_49_1),
                                                                             .enb_1_49_0(enb_1_49_0),
                                                                             .wr_din(mergedDelay_regin_3),
                                                                             .wr_addr(mergedDelay_waddr_3),
                                                                             .wr_en(mergedDelay_wrenb_3),  // ufix1
                                                                             .rd_addr(mergedDelay_raddr_3),
                                                                             .dout(mergedDelay_regout_3)
                                                                             );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_3_process
      if (reset == 1'b1) begin
        mergedOutput_3 <= 122'h0000000000000000000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedOutput_3 <= mergedDelay_regout_3;
        end
      end
    end

  assign slicedInput_9 = mergedOutput_3[121:104];

  assign delayOut0_2 = slicedInput_9;

  assign slicedInput_10 = mergedOutput_3[103:86];

  assign delayOut1_2 = slicedInput_10;

  assign slicedInput_11 = mergedOutput_3[85:68];

  assign delayOut2_2 = slicedInput_11;

  assign Delay3_out1[0] = delayOut0_2;
  assign Delay3_out1[1] = delayOut1_2;
  assign Delay3_out1[2] = delayOut2_2;

  always @(posedge clk)
    begin : rd_4_process
      if (reset == 1'b1) begin
        for(rd_4_t_1 = 32'sd0; rd_4_t_1 <= 32'sd2; rd_4_t_1 = rd_4_t_1 + 32'sd1) begin
          Delay3_out1_1[rd_4_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_4_t_0_0 = 32'sd0; rd_4_t_0_0 <= 32'sd2; rd_4_t_0_0 = rd_4_t_0_0 + 32'sd1) begin
            Delay3_out1_1[rd_4_t_0_0] <= Delay3_out1[rd_4_t_0_0];
          end
        end
      end
    end

  // <S180>/Add2
  assign Add2_u = {Constant_out1[17], Constant_out1};

  genvar t_0_021;
  generate
    for(t_0_021 = 32'sd0; t_0_021 <= 32'sd2; t_0_021 = t_0_021 + 32'sd1) begin:Add2_out1_gen
      assign Add2_add_cast[t_0_021] = {Delay3_out1_1[t_0_021][17], Delay3_out1_1[t_0_021]};
      assign Add2_out1[t_0_021] = Add2_u + Add2_add_cast[t_0_021];
    end
  endgenerate

  always @(posedge clk)
    begin : crp_out_delay9_process
      if (reset == 1'b1) begin
        for(crp_out_delay9_t_1 = 32'sd0; crp_out_delay9_t_1 <= 32'sd2; crp_out_delay9_t_1 = crp_out_delay9_t_1 + 32'sd1) begin
          Add2_out1_1[crp_out_delay9_t_1] <= 19'sb0000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay9_t_0_0 = 32'sd0; crp_out_delay9_t_0_0 <= 32'sd2; crp_out_delay9_t_0_0 = crp_out_delay9_t_0_0 + 32'sd1) begin
            Add2_out1_1[crp_out_delay9_t_0_0] <= Add2_out1[crp_out_delay9_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Delay2_output_process
      if (reset == 1'b1) begin
        for(Delay2_output_t_1 = 32'sd0; Delay2_output_t_1 <= 32'sd2; Delay2_output_t_1 = Delay2_output_t_1 + 32'sd1) begin
          Add2_out1_2[Delay2_output_t_1] <= 19'sb0000000000000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Delay2_output_t_0_0 = 32'sd0; Delay2_output_t_0_0 <= 32'sd2; Delay2_output_t_0_0 = Delay2_output_t_0_0 + 32'sd1) begin
            Add2_out1_2[Delay2_output_t_0_0] <= Add2_out1_1[Delay2_output_t_0_0];
          end
        end
      end
    end

  assign delayIn0_4 = Add2_out1_2[0];

  assign delayIn1_4 = Add2_out1_2[1];

  assign delayIn2_4 = Add2_out1_2[2];

  assign mergedInput_4 = {delayIn0_4, delayIn1_4, delayIn2_4};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_4_process
      if (reset == 1'b1) begin
        mergedDelay_regin_4 <= 57'h000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedDelay_regin_4 <= mergedInput_4;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_4_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_4 <= 2'b00;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_waddr_4 >= 2'b01) begin
            mergedDelay_waddr_4 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_4 <= mergedDelay_waddr_4 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_4 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_4_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_4 <= 2'b01;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_raddr_4 >= 2'b01) begin
            mergedDelay_raddr_4 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_4 <= mergedDelay_raddr_4 + 2'b01;
          end
        end
      end
    end

  // <S180>/Delay2
  // <S180>/Delay2
  // <S180>/Delay2
  ShiftRegisterRAM_Wrapper_generic_block #(.AddrWidth(2),
                                           .DataWidth(57)
                                           )
                                         u_ShiftRegisterRAM_Wrapper_3 (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb_1_49_1(enb_1_49_1),
                                                                       .enb_1_49_0(enb_1_49_0),
                                                                       .wr_din(mergedDelay_regin_4),
                                                                       .wr_addr(mergedDelay_waddr_4),
                                                                       .wr_en(mergedDelay_wrenb_4),  // ufix1
                                                                       .rd_addr(mergedDelay_raddr_4),
                                                                       .dout(mergedDelay_regout_4)
                                                                       );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_4_process
      if (reset == 1'b1) begin
        mergedOutput_4 <= 57'h000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedOutput_4 <= mergedDelay_regout_4;
        end
      end
    end

  assign slicedInput_12 = mergedOutput_4[56:38];

  assign delayOut0_3 = slicedInput_12;

  assign slicedInput_13 = mergedOutput_4[37:19];

  assign delayOut1_3 = slicedInput_13;

  assign slicedInput_14 = mergedOutput_4[18:0];

  assign delayOut2_3 = slicedInput_14;

  assign Delay2_out1[0] = delayOut0_3;
  assign Delay2_out1[1] = delayOut1_3;
  assign Delay2_out1[2] = delayOut2_3;

  always @(posedge clk)
    begin : HwModeRegister6_process
      if (reset == 1'b1) begin
        for(HwModeRegister6_t_1 = 32'sd0; HwModeRegister6_t_1 <= 32'sd2; HwModeRegister6_t_1 = HwModeRegister6_t_1 + 32'sd1) begin
          Delay2_out1_1[HwModeRegister6_t_1] <= 19'sb0000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister6_t_0_0 = 32'sd0; HwModeRegister6_t_0_0 <= 32'sd2; HwModeRegister6_t_0_0 = HwModeRegister6_t_0_0 + 32'sd1) begin
            Delay2_out1_1[HwModeRegister6_t_0_0] <= Delay2_out1[HwModeRegister6_t_0_0];
          end
        end
      end
    end

  assign kconst_6 = 19'sb0110011001011001101;

  always @(posedge clk)
    begin : HwModeRegister7_process
      if (reset == 1'b1) begin
        kconst_7 <= 19'sb0000000000000000000;
      end
      else begin
        if (enb) begin
          kconst_7 <= kconst_6;
        end
      end
    end

  // <S180>/Gain2

  genvar t_0_031;
  generate
    for(t_0_031 = 32'sd0; t_0_031 <= 32'sd2; t_0_031 = t_0_031 + 32'sd1) begin:Gain2_out1_gen
      assign Gain2_out1[t_0_031] = Delay2_out1_1[t_0_031] * kconst_7;
    end
  endgenerate

  always @(posedge clk)
    begin : crp_out_delay13_process
      if (reset == 1'b1) begin
        for(crp_out_delay13_t_1 = 32'sd0; crp_out_delay13_t_1 <= 32'sd5; crp_out_delay13_t_1 = crp_out_delay13_t_1 + 32'sd1) begin
          crp_out_delay13_reg[crp_out_delay13_t_1] <= 38'sh0000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay13_t_0_1 = 32'sd0; crp_out_delay13_t_0_1 <= 32'sd5; crp_out_delay13_t_0_1 = crp_out_delay13_t_0_1 + 32'sd1) begin
            crp_out_delay13_reg[crp_out_delay13_t_0_1] <= crp_out_delay13_reg_next[crp_out_delay13_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(crp_out_delay13_t_0_0 = 32'sd0; crp_out_delay13_t_0_0 <= 32'sd2; crp_out_delay13_t_0_0 = crp_out_delay13_t_0_0 + 32'sd1) begin
      Gain2_out1_1[crp_out_delay13_t_0_0] = crp_out_delay13_reg[32'sd3 + crp_out_delay13_t_0_0];
      crp_out_delay13_reg_next[crp_out_delay13_t_0_0] = Gain2_out1[crp_out_delay13_t_0_0];
      crp_out_delay13_reg_next[crp_out_delay13_t_0_0 + 32'sd3] = crp_out_delay13_reg[crp_out_delay13_t_0_0];
    end

  end

  always @(posedge clk)
    begin : Delay_output_process
      if (reset == 1'b1) begin
        for(Delay_output_t_1 = 32'sd0; Delay_output_t_1 <= 32'sd2; Delay_output_t_1 = Delay_output_t_1 + 32'sd1) begin
          Gain2_out1_2[Delay_output_t_1] <= 38'sh0000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Delay_output_t_0_0 = 32'sd0; Delay_output_t_0_0 <= 32'sd2; Delay_output_t_0_0 = Delay_output_t_0_0 + 32'sd1) begin
            Gain2_out1_2[Delay_output_t_0_0] <= Gain2_out1_1[Delay_output_t_0_0];
          end
        end
      end
    end

  assign delayIn0_5 = Gain2_out1_2[0];

  assign delayIn1_5 = Gain2_out1_2[1];

  assign delayIn2_5 = Gain2_out1_2[2];

  assign mergedInput_5 = {delayIn0_5, delayIn1_5, delayIn2_5};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_5_process
      if (reset == 1'b1) begin
        mergedDelay_regin_5 <= 114'h00000000000000000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedDelay_regin_5 <= mergedInput_5;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_5_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_5 <= 2'b00;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_waddr_5 >= 2'b01) begin
            mergedDelay_waddr_5 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_5 <= mergedDelay_waddr_5 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_5 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_5_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_5 <= 2'b01;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_raddr_5 >= 2'b01) begin
            mergedDelay_raddr_5 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_5 <= mergedDelay_raddr_5 + 2'b01;
          end
        end
      end
    end

  // <S180>/Delay
  // <S180>/Delay
  // <S180>/Delay
  ShiftRegisterRAM_Wrapper_generic_block #(.AddrWidth(2),
                                           .DataWidth(114)
                                           )
                                         u_ShiftRegisterRAM_Wrapper_4 (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb_1_49_1(enb_1_49_1),
                                                                       .enb_1_49_0(enb_1_49_0),
                                                                       .wr_din(mergedDelay_regin_5),
                                                                       .wr_addr(mergedDelay_waddr_5),
                                                                       .wr_en(mergedDelay_wrenb_5),  // ufix1
                                                                       .rd_addr(mergedDelay_raddr_5),
                                                                       .dout(mergedDelay_regout_5)
                                                                       );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_5_process
      if (reset == 1'b1) begin
        mergedOutput_5 <= 114'h00000000000000000000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedOutput_5 <= mergedDelay_regout_5;
        end
      end
    end

  assign slicedInput_15 = mergedOutput_5[113:76];

  assign delayOut0_4 = slicedInput_15;

  assign slicedInput_16 = mergedOutput_5[75:38];

  assign delayOut1_4 = slicedInput_16;

  assign slicedInput_17 = mergedOutput_5[37:0];

  assign delayOut2_4 = slicedInput_17;

  assign Delay_out1[0] = delayOut0_4;
  assign Delay_out1[1] = delayOut1_4;
  assign Delay_out1[2] = delayOut2_4;

  // <S180>/Data Type Conversion5

  genvar ii11;
  generate
    for(ii11 = 32'sd0; ii11 <= 32'sd2; ii11 = ii11 + 32'sd1) begin:Data_Type_Conversion5_out1_gen
      assign Data_Type_Conversion5_out1[ii11] = Delay_out1[ii11][33:18];
    end
  endgenerate

  always @(posedge clk)
    begin : crp_out_delay2_process
      if (reset == 1'b1) begin
        for(crp_out_delay2_t_1 = 32'sd0; crp_out_delay2_t_1 <= 32'sd2; crp_out_delay2_t_1 = crp_out_delay2_t_1 + 32'sd1) begin
          Data_Type_Conversion5_out1_1[crp_out_delay2_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay2_t_0_0 = 32'sd0; crp_out_delay2_t_0_0 <= 32'sd2; crp_out_delay2_t_0_0 = crp_out_delay2_t_0_0 + 32'sd1) begin
            Data_Type_Conversion5_out1_1[crp_out_delay2_t_0_0] <= Data_Type_Conversion5_out1[crp_out_delay2_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Delay1_output_process
      if (reset == 1'b1) begin
        for(Delay1_output_t_1 = 32'sd0; Delay1_output_t_1 <= 32'sd2; Delay1_output_t_1 = Delay1_output_t_1 + 32'sd1) begin
          Data_Type_Conversion5_out1_2[Delay1_output_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb_1_49_1) begin
          for(Delay1_output_t_0_0 = 32'sd0; Delay1_output_t_0_0 <= 32'sd2; Delay1_output_t_0_0 = Delay1_output_t_0_0 + 32'sd1) begin
            Data_Type_Conversion5_out1_2[Delay1_output_t_0_0] <= Data_Type_Conversion5_out1_1[Delay1_output_t_0_0];
          end
        end
      end
    end

  assign delayIn0_6 = Data_Type_Conversion5_out1_2[0];

  assign delayIn1_6 = Data_Type_Conversion5_out1_2[1];

  assign delayIn2_6 = Data_Type_Conversion5_out1_2[2];

  assign mergedInput_6 = {delayIn0_6, delayIn1_6, delayIn2_6};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_6_process
      if (reset == 1'b1) begin
        mergedDelay_regin_6 <= 48'h000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedDelay_regin_6 <= mergedInput_6;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_6_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_6 <= 2'b00;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_waddr_6 >= 2'b01) begin
            mergedDelay_waddr_6 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_6 <= mergedDelay_waddr_6 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_6 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_6_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_6 <= 2'b01;
      end
      else begin
        if (enb_1_49_0) begin
          if (mergedDelay_raddr_6 >= 2'b01) begin
            mergedDelay_raddr_6 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_6 <= mergedDelay_raddr_6 + 2'b01;
          end
        end
      end
    end

  // <S180>/Delay1
  // <S180>/Delay1
  // <S180>/Delay1
  ShiftRegisterRAM_Wrapper_generic_block #(.AddrWidth(2),
                                           .DataWidth(48)
                                           )
                                         u_ShiftRegisterRAM_Wrapper_5 (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb_1_49_1(enb_1_49_1),
                                                                       .enb_1_49_0(enb_1_49_0),
                                                                       .wr_din(mergedDelay_regin_6),
                                                                       .wr_addr(mergedDelay_waddr_6),
                                                                       .wr_en(mergedDelay_wrenb_6),  // ufix1
                                                                       .rd_addr(mergedDelay_raddr_6),
                                                                       .dout(mergedDelay_regout_6)
                                                                       );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_6_process
      if (reset == 1'b1) begin
        mergedOutput_6 <= 48'h000000000000;
      end
      else begin
        if (enb_1_49_0) begin
          mergedOutput_6 <= mergedDelay_regout_6;
        end
      end
    end

  assign slicedInput_18 = mergedOutput_6[31:16];

  assign delayOut1_5 = slicedInput_18;

  assign O_Ia = delayOut1_5;

  assign slicedInput_19 = mergedOutput_6[47:32];

  assign delayOut0_5 = slicedInput_19;

  // <S180>/Demux1
  assign O_Ib = delayOut0_5;

  assign slicedInput_20 = mergedOutput_6[15:0];

  assign delayOut2_5 = slicedInput_20;

  assign O_Ic = delayOut2_5;

  assign slicedInput_21 = mergedOutput_2[67:52];

  assign delayOut1_6 = slicedInput_21;

  assign O_Vc = delayOut1_6;

  assign slicedInput_22 = mergedOutput_2[83:68];

  assign delayOut0_6 = slicedInput_22;

  // <S180>/Demux
  assign O_Vb = delayOut0_6;

  assign slicedInput_23 = mergedOutput_2[51:36];

  assign delayOut2_6 = slicedInput_23;

  assign O_Va = delayOut2_6;

  assign slicedInput_24 = mergedOutput_3[51:36];

  assign Delay25_out1 = slicedInput_24;

  assign O_Vout = Delay25_out1;

  assign slicedInput_25 = mergedOutput_3[67:52];

  assign Delay29_out1 = slicedInput_25;

  assign O_I_load = Delay29_out1;

endmodule  // real2uint8

