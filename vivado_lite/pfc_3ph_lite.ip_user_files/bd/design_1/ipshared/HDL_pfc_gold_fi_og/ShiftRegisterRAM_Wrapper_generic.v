// -------------------------------------------------------------
// 
// File Name: hdl_prj2\hdlsrc\HDL_pfc_gold_fi_og\ShiftRegisterRAM_Wrapper_generic.v
// Created: 2025-04-21 11:32:18
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: ShiftRegisterRAM_Wrapper_generic
// Source Path: HDL_pfc_gold_fi_og/simscape_system/FET_CTRL/ShiftRegisterRAM_Wrapper_generic
// Hierarchy Level: 4
// Model version: 1.182
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module ShiftRegisterRAM_Wrapper_generic
          (clk,
           reset,
           enb,
           enb_1_1_1,
           wr_din,
           wr_addr,
           wr_en,
           rd_addr,
           dout);

  parameter integer AddrWidth  = 1;
  parameter integer DataWidth  = 1;

  input   clk;
  input   reset;
  input   enb;
  input   enb_1_1_1;
  input   [DataWidth - 1:0] wr_din;  // parameterized width
  input   [AddrWidth - 1:0] wr_addr;  // parameterized width
  input   wr_en;  // ufix1
  input   [AddrWidth - 1:0] rd_addr;  // parameterized width
  output  [DataWidth - 1:0] dout;  // parameterized width


  wire const_one;
  reg  filwait;
  reg  enb_1_1_1_delay1;
  wire not_en1_delay1;
  wire filmode;
  reg  filreg;
  wire notfilreg;
  wire ram_is_fastest_rate;
  reg  enb_1_1_1_delay2;
  reg  enb_1_1_1_delay3;
  wire not_en1_delay3;
  wire not_en1;
  wire not_en1_delay2;
  wire not_en0;
  wire ram_is_down2;
  wire bypass1_and;
  wire ram_is_down3;
  reg [DataWidth - 1:0] wr_din_last_value;  // ufix7
  wire [DataWidth - 1:0] wr_din_1;  // ufix7
  reg [AddrWidth - 1:0] wr_addr_last_value;  // ufix5
  wire [AddrWidth - 1:0] wr_addr_1;  // ufix5
  reg  wr_en_last_value;  // ufix1
  wire wr_en_1;  // ufix1
  reg [AddrWidth - 1:0] rd_addr_last_value;  // ufix5
  wire [AddrWidth - 1:0] rd_addr_1;  // ufix5
  wire [DataWidth - 1:0] dout_1;  // ufix7
  wire ram_is_down4;
  reg [DataWidth - 1:0] dout_last_value;  // ufix7
  wire [DataWidth - 1:0] dout_bypass_1;  // ufix7
  reg [DataWidth - 1:0] dout_bypass_last_value;  // ufix7
  wire [DataWidth - 1:0] dout_bypass_bypass;  // ufix7


  assign const_one = 1;

  always @(posedge clk)
    begin : fil_wait
      if (reset) begin
        filwait <= 0;
      end
      else begin
        if (enb) begin
          filwait <= const_one;
        end
      end
    end

  always @(posedge clk)
    begin : ram_enb_delay1
      if (reset) begin
        enb_1_1_1_delay1 <= 1'b1;
      end
      else begin
        enb_1_1_1_delay1 <= enb_1_1_1;
      end
    end

  assign not_en1_delay1 = !enb_1_1_1_delay1;

  assign filmode = filwait && (not_en1_delay1 && enb_1_1_1 && enb);

  always @(posedge clk)
    begin : fil_hold
      if (reset) begin
        filreg <= 0;
      end
      else begin
        if (filmode) begin
          filreg <= const_one;
        end
      end
    end

  assign notfilreg = !filreg;

  assign ram_is_fastest_rate = enb_1_1_1 && enb && notfilreg;

  always @(posedge clk)
    begin : ram_enb_delay2
      if (reset) begin
        enb_1_1_1_delay2 <= 1'b1;
      end
      else begin
        enb_1_1_1_delay2 <= enb_1_1_1_delay1;
      end
    end

  always @(posedge clk)
    begin : ram_enb_delay3
      if (reset) begin
        enb_1_1_1_delay3 <= 1'b1;
      end
      else begin
        enb_1_1_1_delay3 <= enb_1_1_1_delay2;
      end
    end

  assign not_en1_delay3 = !enb_1_1_1_delay3;

  assign not_en1 = !enb_1_1_1;

  assign not_en1_delay2 = !enb_1_1_1_delay2;

  assign not_en0 = !enb;

  assign ram_is_down2 = (enb_1_1_1 && not_en1_delay1 && enb_1_1_1_delay2 && not_en1_delay3) || (not_en1 && enb_1_1_1_delay1 && not_en1_delay2 && enb_1_1_1_delay3) || (not_en1 && enb_1_1_1_delay1 && enb_1_1_1_delay2 && enb_1_1_1_delay3 && enb) || (enb_1_1_1 && not_en1_delay1 && enb_1_1_1_delay2 && enb_1_1_1_delay3 && not_en0);

  assign bypass1_and = ram_is_down2 && enb_1_1_1;

  assign ram_is_down3 = (enb_1_1_1 && not_en1_delay1 && not_en1_delay2 && enb_1_1_1_delay3) || (not_en1 && enb_1_1_1_delay1 && not_en1_delay2 && not_en1_delay3) || (not_en1 && not_en1_delay1 && enb_1_1_1_delay2 && not_en1_delay3) || (not_en1 && not_en1_delay1 && enb_1_1_1_delay2 && enb_1_1_1_delay3 && enb);

  always @(posedge clk)
    begin : wr_din_bypass
      if (reset) begin
        wr_din_last_value <= 0;
      end
      else begin
        if (enb_1_1_1) begin
          wr_din_last_value <= wr_din;
        end
      end
    end

  assign wr_din_1 = (ram_is_fastest_rate == 1 ? wr_din : wr_din_last_value);

  always @(posedge clk)
    begin : wr_addr_bypass
      if (reset) begin
        wr_addr_last_value <= 0;
      end
      else begin
        if (enb_1_1_1) begin
          wr_addr_last_value <= wr_addr;
        end
      end
    end

  assign wr_addr_1 = (ram_is_fastest_rate == 1 ? wr_addr : wr_addr_last_value);

  always @(posedge clk)
    begin : wr_en_bypass
      if (reset) begin
        wr_en_last_value <= 0;
      end
      else begin
        if (enb_1_1_1) begin
          wr_en_last_value <= wr_en;
        end
      end
    end

  assign wr_en_1 = (ram_is_fastest_rate == 1 ? wr_en : wr_en_last_value);

  always @(posedge clk)
    begin : rd_addr_bypass
      if (reset) begin
        rd_addr_last_value <= 0;
      end
      else begin
        if (enb_1_1_1) begin
          rd_addr_last_value <= rd_addr;
        end
      end
    end

  assign rd_addr_1 = (ram_is_fastest_rate == 1 ? rd_addr : rd_addr_last_value);

  SimpleDualPortRAM_generic #(.AddrWidth(AddrWidth),
                              .DataWidth(DataWidth)
                              )
                            u_SimpleDualPortRAM_generic (.clk(clk),
                                                         .wr_din(wr_din_1),
                                                         .wr_addr(wr_addr_1),
                                                         .wr_en(wr_en_1),  // ufix1
                                                         .rd_addr(rd_addr_1),
                                                         .dout(dout_1)
                                                         );

  assign ram_is_down4 = (enb_1_1_1 && not_en1_delay1 && not_en1_delay2 && not_en1_delay3) || (not_en1 && enb_1_1_1_delay1 && not_en1_delay2 && not_en1_delay3) || (not_en1 && not_en1_delay1 && enb_1_1_1_delay2 && not_en1_delay3) || (not_en1 && not_en1_delay1 && not_en1_delay2 && enb_1_1_1_delay3) || !(enb_1_1_1 || enb_1_1_1_delay1 || enb_1_1_1_delay2 || enb_1_1_1_delay3) || (not_en1 && not_en1_delay1 && enb_1_1_1_delay2 && enb_1_1_1_delay3 && not_en0);

  always @(posedge clk)
    begin : dout_bypass
      if (reset) begin
        dout_last_value <= 0;
      end
      else begin
        if (bypass1_and || (ram_is_down4 && enb_1_1_1_delay2) || (enb_1_1_1 && enb_1_1_1_delay1 && enb_1_1_1_delay2 && enb_1_1_1_delay3)) begin
          dout_last_value <= dout_1;
        end
      end
    end

  assign dout_bypass_1 = ((ram_is_fastest_rate || bypass1_and || ram_is_down3) && notfilreg == 1 ? dout_1 : dout_last_value);

  always @(posedge clk)
    begin : dout_bypass_2
      if (reset) begin
        dout_bypass_last_value <= 0;
      end
      else begin
        if (enb) begin
          dout_bypass_last_value <= dout_bypass_1;
        end
      end
    end

  assign dout_bypass_bypass = (ram_is_fastest_rate || ram_is_down2 || filreg == 1 ? dout_bypass_1 : dout_bypass_last_value);

  assign dout = dout_bypass_bypass;

endmodule  // ShiftRegisterRAM_Wrapper_generic

