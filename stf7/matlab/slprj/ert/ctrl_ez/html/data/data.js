var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"ctrl_ez","ref":true,"files":[{"name":"ctrl_ez.c","type":"source","group":"model","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ctrl_ez.c\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.643\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun May 11 12:01:05 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"ctrl_ez.h\"\r\n#include <stdbool.h>\r\n#include \"ctrl_ez_private.h\"\r\n#include <math.h>\r\n#include <stdint.h>\r\n#include \"mw_cmsis.h\"\r\n#include \"plook_u32ff_evenc.h\"\r\n#include \"intrp1d_fu32fl.h\"\r\n\r\n/* Exported block states */\r\nfloat filter_IA;                       /* 'Data Store Memory' (':2047') */\r\nfloat filter_IB;                       /* 'Data Store Memory1' (':2049') */\r\nfloat filter_IC;                       /* 'Data Store Memory2' (':2051') */\r\n\r\n/* Block states (default storage) */\r\nDW_ctrl_ez_f_T ctrl_ez_DW;\r\n\r\n/*\r\n * Output and update for action system:\r\n *    'If Action Subsystem' (':2053:76:684')\r\n *    'If Action Subsystem' (':2056:76:684')\r\n */\r\nvoid ctrl_ez_IfActionSubsystem(float rtu_In1, float *rty_Out1)\r\n{\r\n  /* Sum: 'Sum' (':2053:76:693') incorporates:\r\n   *  DataTypeConversion: 'Convert_back' (':2053:76:695')\r\n   *  DataTypeConversion: 'Convert_uint16' (':2053:76:694')\r\n   */\r\n  *rty_Out1 = rtu_In1 - (float)(int16_t)floorf(rtu_In1);\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    'If Action Subsystem1' (':2053:76:688')\r\n *    'If Action Subsystem1' (':2056:76:688')\r\n */\r\nvoid ctrl_ez_IfActionSubsystem1(float rtu_In1, float *rty_Out1)\r\n{\r\n  /* Sum: 'Sum' (':2053:76:700') incorporates:\r\n   *  DataTypeConversion: 'Convert_back' (':2053:76:698')\r\n   *  DataTypeConversion: 'Convert_uint16' (':2053:76:697')\r\n   */\r\n  *rty_Out1 = rtu_In1 - (float)(int16_t)rtu_In1;\r\n}\r\n\r\n/* System initialize for referenced model: 'ctrl_ez' */\r\nvoid ctrl_ez_Init(float *rty_Qa)\r\n{\r\n  /* SystemInitialize for RootInportFunctionCallGenerator generated from: 'trigger_ctrl_ez' (':21') incorporates:\r\n   *  SubSystem: 'ctrl_ez_fcn' (':498')\r\n   */\r\n  /* InitializeConditions for Memory: 'Memory' (':561') */\r\n  ctrl_ez_DW.Memory_PreviousInput = true;\r\n\r\n  /* SystemInitialize for Enabled SubSystem: 'ctrl' (':1270') */\r\n  /* InitializeConditions for DiscreteIntegrator: 'Accumulator' (':1396') */\r\n  ctrl_ez_DW.Accumulator_PrevResetState = 2;\r\n\r\n  /* End of SystemInitialize for SubSystem: 'ctrl' (':1270') */\r\n\r\n  /* SystemInitialize for SignalConversion generated from: 'Qa' (':570') */\r\n  *rty_Qa = ctrl_ez_DW.T2[0];\r\n\r\n  /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: 'trigger_ctrl_ez' (':21') */\r\n}\r\n\r\n/* Output and update for referenced model: 'ctrl_ez' */\r\nvoid ctrl_ez_trigger_ctrl_ez(const float *rtu_ia, const float *rtu_ib, const\r\n  float *rtu_ic, const float *rtu_ov_out, const float *rtu_w, const float\r\n  *rtu_lock_pll, const float *rtu_sine, const float *rtu_cos, const float\r\n  *rtu_va, const float *rtu_vc, const float *rtu_vb, float *rty_Qa, float\r\n  *rty_Qb, float *rty_Qc, bool *rty_lock)\r\n{\r\n  float rtb_Gain_0[3];\r\n  float rtb_Add1_idx_0;\r\n  float rtb_Add1_idx_1;\r\n  float rtb_Add1_idx_2;\r\n  float rtb_Gain;\r\n  float rtb_Gain1_l;\r\n  float rtb_Kalphabeta0_d_idx_0;\r\n  float rtb_Kalphabeta0_d_idx_1;\r\n  float rtb_Kalphabeta0_idx_0;\r\n  float rtb_Sum4_i;\r\n  float rtb_Switch;\r\n  float rtb_Switch1_idx_0;\r\n  float rtb_vd_ctrl;\r\n  float rtb_vq_park_o;\r\n  int32_t rtb_Accumulator_o2;\r\n  int32_t y;\r\n  uint32_t bpIdx;\r\n  uint8_t quadrantInfo;\r\n  bool isReciprocal;\r\n  static const float tableData_c[16] = { 0.0F, 0.010594652F, 0.0210962314F,\r\n    0.0314164795F, 0.0414761603F, 0.0512081906F, 0.0605594702F, 0.0694913715F,\r\n    0.0779791325F, 0.0860104337F, 0.0935835242F, 0.100705102F, 0.107388355F,\r\n    0.113651067F, 0.11951407F, 0.125F };\r\n\r\n  /* RootInportFunctionCallGenerator generated from: 'trigger_ctrl_ez' (':21') incorporates:\r\n   *  SubSystem: 'ctrl_ez_fcn' (':498')\r\n   */\r\n  /* Sum: 'Add1' (':831:360') incorporates:\r\n   *  Product: 'Product' (':831:364')\r\n   *  Product: 'Product1' (':831:365')\r\n   *  UnitDelay: 'Unit Delay' (':831:366')\r\n   */\r\n  rtb_Add1_idx_0 = *rtu_ia * 0.1F + ctrl_ez_DW.UnitDelay_DSTATE[0] * 0.9F;\r\n  rtb_Add1_idx_1 = *rtu_ib * 0.1F + 0.9F * ctrl_ez_DW.UnitDelay_DSTATE[1];\r\n  rtb_Add1_idx_2 = *rtu_ic * 0.1F + 0.9F * ctrl_ez_DW.UnitDelay_DSTATE[2];\r\n\r\n  /* DataStoreWrite: 'Data Store Write' (':2046') */\r\n  filter_IA = rtb_Add1_idx_0;\r\n\r\n  /* DataStoreWrite: 'Data Store Write1' (':2048') */\r\n  filter_IB = rtb_Add1_idx_1;\r\n\r\n  /* DataStoreWrite: 'Data Store Write2' (':2050') */\r\n  filter_IC = rtb_Add1_idx_2;\r\n\r\n  /* Switch: 'Switch' (':562') incorporates:\r\n   *  Constant: 'Pi1' (':1837')\r\n   *  Logic: 'AND' (':1985')\r\n   *  Memory: 'Memory' (':561')\r\n   *  RelationalOperator: 'Equal' (':1807')\r\n   */\r\n  *rty_lock = (((*rtu_w <= 0.0F) || (*rtu_lock_pll == 0.0F)) &&\r\n               ctrl_ez_DW.Memory_PreviousInput);\r\n\r\n  /* Gain: 'Kalphabeta0' (':2058:641') incorporates:\r\n   *  Gain: 'one_by_3' (':2058:648')\r\n   *  Gain: 'one_by_sqrt3_' (':2058:649')\r\n   *  Sum: 'Sum' (':2058:644')\r\n   *  Sum: 'Sum1' (':2058:645')\r\n   *  Sum: 'Sum2' (':2058:646')\r\n   */\r\n  rtb_Kalphabeta0_idx_0 = (*rtu_va - ((*rtu_va + *rtu_vb) + *rtu_vc) *\r\n    0.333333343F) * 1.22474492F;\r\n  rtb_Switch1_idx_0 = (*rtu_vb - *rtu_vc) * 0.577350259F * 1.22474492F;\r\n\r\n  /* Outputs for Enabled SubSystem: 'ctrl' (':1270') incorporates:\r\n   *  EnablePort: 'Enable' (':1272')\r\n   */\r\n  /* Logic: 'NOT' (':591') */\r\n  if (!*rty_lock) {\r\n    /* Gain: 'Kalphabeta0' (':1278:641') incorporates:\r\n     *  Gain: 'one_by_3' (':1278:648')\r\n     *  Gain: 'one_by_sqrt3_' (':1278:649')\r\n     *  Sum: 'Sum' (':1278:644')\r\n     *  Sum: 'Sum1' (':1278:645')\r\n     *  Sum: 'Sum2' (':1278:646')\r\n     */\r\n    rtb_Kalphabeta0_d_idx_0 = (rtb_Add1_idx_0 - ((rtb_Add1_idx_0 +\r\n      rtb_Add1_idx_1) + rtb_Add1_idx_2) * 0.333333343F) * 1.22474492F;\r\n    rtb_Kalphabeta0_d_idx_1 = (rtb_Add1_idx_1 - rtb_Add1_idx_2) * 0.577350259F *\r\n      1.22474492F;\r\n\r\n    /* MATLAB Function: 'park_tf' (':2017') */\r\n    rtb_vq_park_o = *rtu_sine * rtb_Kalphabeta0_d_idx_1 + *rtu_cos *\r\n      rtb_Kalphabeta0_d_idx_0;\r\n    rtb_Kalphabeta0_d_idx_0 = *rtu_sine * rtb_Kalphabeta0_d_idx_0 - *rtu_cos *\r\n      rtb_Kalphabeta0_d_idx_1;\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1374') */\r\n    if (ctrl_ez_DW.Accumulator_DSTATE == 50.0F) {\r\n      rtb_Accumulator_o2 = 1;\r\n    } else if (ctrl_ez_DW.Accumulator_DSTATE == -50.0F) {\r\n      rtb_Accumulator_o2 = -1;\r\n    } else {\r\n      rtb_Accumulator_o2 = 0;\r\n    }\r\n\r\n    /* Sum: 'Add2' (':1375') incorporates:\r\n     *  Constant: 'Constant' (':1324')\r\n     *  DiscreteIntegrator: 'Accumulator' (':1374')\r\n     *  Gain: 'Gain1' (':1378')\r\n     *  Sum: 'Sum1' (':1323')\r\n     */\r\n    rtb_Sum4_i = (650.0F - *rtu_ov_out) * 0.3F + ctrl_ez_DW.Accumulator_DSTATE;\r\n\r\n    /* Saturate: 'Saturation' (':1380') */\r\n    if (rtb_Sum4_i > 50.0F) {\r\n      /* Saturate: 'Saturation' (':1380') */\r\n      ctrl_ez_DW.I_D_CTRL_VDC = 50.0F;\r\n    } else if (rtb_Sum4_i < -50.0F) {\r\n      /* Saturate: 'Saturation' (':1380') */\r\n      ctrl_ez_DW.I_D_CTRL_VDC = -50.0F;\r\n    } else {\r\n      /* Saturate: 'Saturation' (':1380') */\r\n      ctrl_ez_DW.I_D_CTRL_VDC = rtb_Sum4_i;\r\n    }\r\n\r\n    /* End of Saturate: 'Saturation' (':1380') */\r\n\r\n    /* Sum: 'Sum2' (':1328') */\r\n    rtb_Kalphabeta0_d_idx_1 = ctrl_ez_DW.I_D_CTRL_VDC - rtb_Kalphabeta0_d_idx_0;\r\n\r\n    /* Switch: 'Switch' (':1934') incorporates:\r\n     *  Constant: 'Constant' (':1935')\r\n     *  Delay: 'Delay' (':1933')\r\n     *  Gain: 'Gain2' (':1390')\r\n     */\r\n    if (ctrl_ez_DW.Delay_DSTATE[0U] > 0.0F) {\r\n      rtb_Gain = 0.0F;\r\n    } else {\r\n      rtb_Gain = 0.0769230798F * rtb_Kalphabeta0_d_idx_1;\r\n    }\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1385') incorporates:\r\n     *  Switch: 'Switch' (':1934')\r\n     */\r\n    rtb_Switch = ctrl_ez_DW.Accumulator_DSTATE_a + rtb_Gain;\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n    if (rtb_Switch > 100.0F) {\r\n      /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n      rtb_Switch = 100.0F;\r\n    } else if (rtb_Switch < -100.0F) {\r\n      /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n      rtb_Switch = -100.0F;\r\n    }\r\n\r\n    /* Sum: 'Sum3' (':1332') incorporates:\r\n     *  Gain: 'Gain1' (':1389')\r\n     *  Gain: 'Gain' (':1333')\r\n     *  MATLAB Function: 'park_tf' (':2016')\r\n     *  Sum: 'Add2' (':1386')\r\n     */\r\n    rtb_vd_ctrl = ((*rtu_sine * rtb_Kalphabeta0_idx_0 - *rtu_cos *\r\n                    rtb_Switch1_idx_0) + 0.0471238904F * rtb_vq_park_o) - (10.0F\r\n      * rtb_Kalphabeta0_d_idx_1 + rtb_Switch);\r\n\r\n    /* Sum: 'Sum4' (':1336') incorporates:\r\n     *  Constant: 'Constant1' (':1337')\r\n     */\r\n    rtb_Sum4_i = 0.0F - rtb_vq_park_o;\r\n\r\n    /* Gain: 'Gain1' (':1400') incorporates:\r\n     *  Constant: 'Constant1' (':1337')\r\n     *  Sum: 'Sum4' (':1336')\r\n     */\r\n    rtb_Gain1_l = (0.0F - rtb_vq_park_o) * 10.0F;\r\n\r\n    /* Delay: 'Delay1' (':1399') */\r\n    rtb_vq_park_o = ctrl_ez_DW.Delay1_DSTATE;\r\n\r\n    /* Switch: 'Switch' (':1403') incorporates:\r\n     *  Constant: 'Constant1' (':1398')\r\n     *  Delay: 'Delay1' (':1399')\r\n     */\r\n    if (ctrl_ez_DW.Delay1_DSTATE > 0.0F) {\r\n      rtb_Sum4_i = 0.0F;\r\n    }\r\n\r\n    /* End of Switch: 'Switch' (':1403') */\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1396') incorporates:\r\n     *  Delay: 'Delay1' (':1399')\r\n     */\r\n    if ((ctrl_ez_DW.Delay1_DSTATE > 0.0F) &&\r\n        (ctrl_ez_DW.Accumulator_PrevResetState <= 0)) {\r\n      ctrl_ez_DW.Accumulator_DSTATE_p = 0.0F;\r\n    }\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1396') incorporates:\r\n     *  Gain: 'Gain2' (':1401')\r\n     */\r\n    rtb_Kalphabeta0_d_idx_1 = 0.0769230798F * rtb_Sum4_i +\r\n      ctrl_ez_DW.Accumulator_DSTATE_p;\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n    if (rtb_Kalphabeta0_d_idx_1 > 500.0F) {\r\n      /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n      rtb_Kalphabeta0_d_idx_1 = 500.0F;\r\n    } else if (rtb_Kalphabeta0_d_idx_1 < -500.0F) {\r\n      /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n      rtb_Kalphabeta0_d_idx_1 = -500.0F;\r\n    }\r\n\r\n    /* Sum: 'Sum5' (':1341') incorporates:\r\n     *  Gain: 'Gain1' (':1342')\r\n     *  MATLAB Function: 'park_tf' (':2016')\r\n     *  Sum: 'Add2' (':1397')\r\n     */\r\n    rtb_Sum4_i = ((*rtu_sine * rtb_Switch1_idx_0 + *rtu_cos *\r\n                   rtb_Kalphabeta0_idx_0) - 0.0471238904F *\r\n                  rtb_Kalphabeta0_d_idx_0) - (rtb_Gain1_l +\r\n      rtb_Kalphabeta0_d_idx_1);\r\n\r\n    /* MATLAB Function: 'mine_invpark_tf' (':2020') */\r\n    rtb_Kalphabeta0_idx_0 = *rtu_cos * *rtu_cos + *rtu_sine * *rtu_sine;\r\n    rtb_Kalphabeta0_d_idx_0 = -(*rtu_cos * rtb_vd_ctrl - *rtu_sine * rtb_Sum4_i)\r\n      / rtb_Kalphabeta0_idx_0;\r\n    rtb_vd_ctrl = (*rtu_cos * rtb_Sum4_i + *rtu_sine * rtb_vd_ctrl) /\r\n      rtb_Kalphabeta0_idx_0;\r\n\r\n    /* Outputs for Atomic SubSystem: 'atan2' (':2028') */\r\n    /* Trigonometry: 'Atan2' (':2028:325') */\r\n    if ((rtb_vd_ctrl == 0.0F) && (rtb_Kalphabeta0_d_idx_0 == 0.0F)) {\r\n      rtb_Gain = 0.0F;\r\n    } else {\r\n      isReciprocal = false;\r\n      if (rtb_Kalphabeta0_d_idx_0 < 0.0F) {\r\n        if (rtb_vd_ctrl < 0.0F) {\r\n          quadrantInfo = 3U;\r\n        } else {\r\n          quadrantInfo = 4U;\r\n        }\r\n      } else if (rtb_vd_ctrl < 0.0F) {\r\n        quadrantInfo = 2U;\r\n      } else {\r\n        quadrantInfo = 1U;\r\n      }\r\n\r\n      rtb_Gain1_l = fabsf(rtb_vd_ctrl);\r\n      rtb_Gain = fabsf(rtb_Kalphabeta0_d_idx_0);\r\n      if (rtb_Gain > rtb_Gain1_l) {\r\n        rtb_Sum4_i = rtb_Gain;\r\n        rtb_Gain = rtb_Gain1_l;\r\n        isReciprocal = true;\r\n      } else {\r\n        rtb_Sum4_i = rtb_Gain1_l;\r\n      }\r\n\r\n      bpIdx = plook_u32ff_evenc(rtb_Gain / rtb_Sum4_i, 0.0F, 0.0666666701F, 15U,\r\n        &rtb_Gain1_l);\r\n      rtb_Gain = intrp1d_fu32fl(bpIdx, rtb_Gain1_l, tableData_c);\r\n      if (isReciprocal) {\r\n        rtb_Gain = 0.25F - rtb_Gain;\r\n      }\r\n\r\n      if (quadrantInfo == 2) {\r\n        rtb_Gain = 0.5F - rtb_Gain;\r\n      } else if (quadrantInfo == 3) {\r\n        rtb_Gain -= 0.5F;\r\n      } else if (quadrantInfo == 4) {\r\n        rtb_Gain = -rtb_Gain;\r\n      }\r\n    }\r\n\r\n    rtb_Gain *= 6.28318548F;\r\n\r\n    /* End of Trigonometry: 'Atan2' (':2028:325') */\r\n\r\n    /* MATLAB Function: 'mod_fcn' (':2052') incorporates:\r\n     *  AlgorithmDescriptorDelegate generated from: 'a16' (':2028:305')\r\n     */\r\n    rtb_Gain -= floorf(rtb_Gain / 6.28318548F) * 6.28318548F;\r\n\r\n    /* End of Outputs for SubSystem: 'atan2' (':2028') */\r\n\r\n    /* MATLAB Function: 'sector_selection' (':1809') */\r\n    if ((rtb_Gain >= 0.0F) && (rtb_Gain < 1.04719758F)) {\r\n      y = 0;\r\n      isReciprocal = true;\r\n    } else if ((rtb_Gain >= 1.04719758F) && (rtb_Gain < 2.09439516F)) {\r\n      y = 1;\r\n      isReciprocal = false;\r\n    } else if ((rtb_Gain >= 2.09439516F) && (rtb_Gain < 3.14159274F)) {\r\n      y = 2;\r\n      isReciprocal = true;\r\n    } else if ((rtb_Gain >= 3.14159274F) && (rtb_Gain < 4.18879032F)) {\r\n      y = 3;\r\n      isReciprocal = false;\r\n    } else if ((rtb_Gain >= 4.18879032F) && (rtb_Gain < 5.23598766F)) {\r\n      y = 4;\r\n      isReciprocal = true;\r\n    } else if ((rtb_Gain >= 5.23598766F) && (rtb_Gain < 6.28318548F)) {\r\n      y = 5;\r\n      isReciprocal = false;\r\n    } else {\r\n      y = 1;\r\n      isReciprocal = false;\r\n    }\r\n\r\n    rtb_Gain -= (float)y * 1.04719758F;\r\n\r\n    /* Gain: 'convert_pu' (':2053:76:652') incorporates:\r\n     *  Constant: 'Constant' (':1789')\r\n     *  Sum: 'Add1' (':1790')\r\n     */\r\n    rtb_Gain1_l = (1.04719758F - rtb_Gain) * 0.159154937F;\r\n\r\n    /* If: 'If' (':2053:76:683') incorporates:\r\n     *  Constant: 'Constant' (':2053:76:692:3')\r\n     *  RelationalOperator: 'Compare' (':2053:76:692:2')\r\n     */\r\n    if (rtb_Gain1_l < 0.0F) {\r\n      /* Outputs for IfAction SubSystem: 'If Action Subsystem' (':2053:76:684') incorporates:\r\n       *  ActionPort: 'Action Port' (':2053:76:686')\r\n       */\r\n      ctrl_ez_IfActionSubsystem(rtb_Gain1_l, &rtb_Sum4_i);\r\n\r\n      /* End of Outputs for SubSystem: 'If Action Subsystem' (':2053:76:684') */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: 'If Action Subsystem1' (':2053:76:688') incorporates:\r\n       *  ActionPort: 'Action Port' (':2053:76:690')\r\n       */\r\n      ctrl_ez_IfActionSubsystem1(rtb_Gain1_l, &rtb_Sum4_i);\r\n\r\n      /* End of Outputs for SubSystem: 'If Action Subsystem1' (':2053:76:688') */\r\n    }\r\n\r\n    /* End of If: 'If' (':2053:76:683') */\r\n\r\n    /* Gain: 'indexing' (':2053:76:605') */\r\n    rtb_Sum4_i *= 800.0F;\r\n\r\n    /* DataTypeConversion: 'Data Type Conversion1' (':2053:76:653') incorporates:\r\n     *  DataTypeConversion: 'Get_Integer' (':2053:76:608')\r\n     */\r\n    rtb_Gain1_l = (uint16_t)rtb_Sum4_i;\r\n\r\n    /* Selector: 'Lookup' (':2053:76:557') incorporates:\r\n     *  Constant: 'sine_table_values' (':2053:76:549')\r\n     *  DataTypeConversion: 'Get_Integer' (':2053:76:608')\r\n     */\r\n    rtb_Switch1_idx_0 = rtCP_sine_table_values_Value[(uint16_t)rtb_Sum4_i];\r\n\r\n    /* Sum: 'Sum4' (':2053:76:615') incorporates:\r\n     *  Constant: 'offset' (':2053:76:657')\r\n     *  Constant: 'sine_table_values' (':2053:76:549')\r\n     *  DataTypeConversion: 'Data Type Conversion1' (':2053:76:653')\r\n     *  DataTypeConversion: 'Get_Integer' (':2053:76:608')\r\n     *  Product: 'Product' (':2053:76:616')\r\n     *  Selector: 'Lookup' (':2053:76:557')\r\n     *  Sum: 'Sum' (':2053:76:610')\r\n     *  Sum: 'Sum2' (':2053:76:612')\r\n     *  Sum: 'Sum3' (':2053:76:614')\r\n     */\r\n    rtb_Sum4_i = (rtCP_sine_table_values_Value[(int32_t)((uint16_t)rtb_Sum4_i +\r\n      1U)] - rtb_Switch1_idx_0) * (rtb_Sum4_i - (float)(uint16_t)rtb_Sum4_i) +\r\n      rtb_Switch1_idx_0;\r\n\r\n    /* Gain: 'convert_pu' (':2056:76:652') */\r\n    rtb_Gain *= 0.159154937F;\r\n\r\n    /* If: 'If' (':2056:76:683') incorporates:\r\n     *  Constant: 'Constant' (':2056:76:692:3')\r\n     *  RelationalOperator: 'Compare' (':2056:76:692:2')\r\n     */\r\n    if (rtb_Gain < 0.0F) {\r\n      /* Outputs for IfAction SubSystem: 'If Action Subsystem' (':2056:76:684') incorporates:\r\n       *  ActionPort: 'Action Port' (':2056:76:686')\r\n       */\r\n      ctrl_ez_IfActionSubsystem(rtb_Gain, &rtb_Gain1_l);\r\n\r\n      /* End of Outputs for SubSystem: 'If Action Subsystem' (':2056:76:684') */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: 'If Action Subsystem1' (':2056:76:688') incorporates:\r\n       *  ActionPort: 'Action Port' (':2056:76:690')\r\n       */\r\n      ctrl_ez_IfActionSubsystem1(rtb_Gain, &rtb_Gain1_l);\r\n\r\n      /* End of Outputs for SubSystem: 'If Action Subsystem1' (':2056:76:688') */\r\n    }\r\n\r\n    /* End of If: 'If' (':2056:76:683') */\r\n\r\n    /* Gain: 'indexing' (':2056:76:605') */\r\n    rtb_Gain1_l *= 800.0F;\r\n\r\n    /* Sqrt: 'Sqrt' (':2027') incorporates:\r\n     *  Product: 'Product' (':2024')\r\n     *  Product: 'Product1' (':2025')\r\n     *  Sum: 'Add' (':2026')\r\n     */\r\n    rtb_Gain = rtb_vd_ctrl * rtb_vd_ctrl + rtb_Kalphabeta0_d_idx_0 *\r\n      rtb_Kalphabeta0_d_idx_0;\r\n    mw_arm_sqrt_f32(&rtb_Gain, &rtb_vd_ctrl, 1U);\r\n\r\n    /* Sum: 'Add1' (':1981:360') incorporates:\r\n     *  Product: 'Product' (':1981:364')\r\n     *  Product: 'Product1' (':1981:365')\r\n     *  UnitDelay: 'Unit Delay' (':1981:366')\r\n     */\r\n    rtb_Kalphabeta0_d_idx_0 = *rtu_ov_out * 0.01F + 0.99F *\r\n      ctrl_ez_DW.UnitDelay_DSTATE_f;\r\n\r\n    /* Saturate: 'Saturation3' (':1853') */\r\n    if (rtb_Kalphabeta0_d_idx_0 > 2000.0F) {\r\n      rtb_Gain = 2000.0F;\r\n    } else if (rtb_Kalphabeta0_d_idx_0 < 100.0F) {\r\n      rtb_Gain = 100.0F;\r\n    } else {\r\n      rtb_Gain = rtb_Kalphabeta0_d_idx_0;\r\n    }\r\n\r\n    /* End of Saturate: 'Saturation3' (':1853') */\r\n\r\n    /* Product: 'Divide1' (':1795') incorporates:\r\n     *  Constant: 'Constant1' (':1792')\r\n     */\r\n    rtb_Switch1_idx_0 = rtb_Sum4_i * rtb_vd_ctrl * 1.73205078F / rtb_Gain;\r\n\r\n    /* Saturate: 'Saturation' (':1823') */\r\n    if (rtb_Switch1_idx_0 > 1.0F) {\r\n      rtb_Switch1_idx_0 = 1.0F;\r\n    } else if (rtb_Switch1_idx_0 < 0.0F) {\r\n      rtb_Switch1_idx_0 = 0.0F;\r\n    }\r\n\r\n    /* Selector: 'Lookup' (':2056:76:557') incorporates:\r\n     *  Constant: 'sine_table_values' (':2056:76:549')\r\n     *  DataTypeConversion: 'Get_Integer' (':2056:76:608')\r\n     */\r\n    rtb_Kalphabeta0_idx_0 = rtCP_sine_table_values_Value_d[(uint16_t)rtb_Gain1_l];\r\n\r\n    /* Product: 'Divide1' (':1795') incorporates:\r\n     *  Constant: 'Constant1' (':1792')\r\n     *  Constant: 'offset' (':2056:76:657')\r\n     *  Constant: 'sine_table_values' (':2056:76:549')\r\n     *  DataTypeConversion: 'Data Type Conversion1' (':2056:76:653')\r\n     *  DataTypeConversion: 'Get_Integer' (':2056:76:608')\r\n     *  Product: 'Product' (':2056:76:616')\r\n     *  Selector: 'Lookup' (':2056:76:557')\r\n     *  Sum: 'Sum' (':2056:76:610')\r\n     *  Sum: 'Sum2' (':2056:76:612')\r\n     *  Sum: 'Sum3' (':2056:76:614')\r\n     *  Sum: 'Sum4' (':2056:76:615')\r\n     */\r\n    rtb_Gain = ((rtCP_sine_table_values_Value_d[(int32_t)((uint16_t)rtb_Gain1_l\r\n      + 1U)] - rtb_Kalphabeta0_idx_0) * (rtb_Gain1_l - (float)(uint16_t)\r\n      rtb_Gain1_l) + rtb_Kalphabeta0_idx_0) * rtb_vd_ctrl * 1.73205078F /\r\n      rtb_Gain;\r\n\r\n    /* Saturate: 'Saturation' (':1823') */\r\n    if (rtb_Gain > 1.0F) {\r\n      rtb_Gain = 1.0F;\r\n    } else if (rtb_Gain < 0.0F) {\r\n      rtb_Gain = 0.0F;\r\n    }\r\n\r\n    /* Sum: 'Sum of Elements' (':1941') */\r\n    rtb_vd_ctrl = rtb_Switch1_idx_0 + rtb_Gain;\r\n\r\n    /* Switch: 'Switch' (':1877') */\r\n    if (isReciprocal) {\r\n      rtb_Kalphabeta0_idx_0 = rtb_Switch1_idx_0;\r\n      rtb_Switch1_idx_0 = rtb_Gain;\r\n    } else {\r\n      rtb_Kalphabeta0_idx_0 = rtb_Gain;\r\n    }\r\n\r\n    /* End of Switch: 'Switch' (':1877') */\r\n\r\n    /* Saturate: 'Saturation2' (':1825') incorporates:\r\n     *  Constant: 'Constant2' (':1797')\r\n     *  Sum: 'Add2' (':1799')\r\n     */\r\n    if (1.0F - rtb_vd_ctrl < 0.0F) {\r\n      rtb_Gain = 0.0F;\r\n    } else {\r\n      rtb_Gain = 1.0F - rtb_vd_ctrl;\r\n    }\r\n\r\n    /* Gain: 'Gain' (':1802') incorporates:\r\n     *  Saturate: 'Saturation2' (':1825')\r\n     */\r\n    rtb_Gain *= 0.5F;\r\n\r\n    /* Sum: 'Add3' (':1803') */\r\n    rtb_vd_ctrl = rtb_Switch1_idx_0 + rtb_Gain;\r\n\r\n    /* Saturate: 'Saturation4' (':1872') */\r\n    if (rtb_vd_ctrl > 1.0F) {\r\n      rtb_vd_ctrl = 1.0F;\r\n    }\r\n\r\n    /* End of Saturate: 'Saturation4' (':1872') */\r\n\r\n    /* LookupNDDirect: 'Direct Lookup Table (n-D)' (':1813') incorporates:\r\n     *  MATLAB Function: 'sector_selection' (':1809')\r\n     *\r\n     * About 'Direct Lookup Table (n-D)' (':1813'):\r\n     *  2-dimensional Direct Look-Up returning a Column,\r\n     *  which is contiguous for column-major array\r\n     *     Remove protection against out-of-range input in generated code: 'on'\r\n     *   */\r\n    y *= 3;\r\n\r\n    /* Sum: 'Add4' (':1804') */\r\n    rtb_Sum4_i = rtb_Kalphabeta0_idx_0 + rtb_vd_ctrl;\r\n\r\n    /* SignalConversion generated from: 'Selector' (':1810') */\r\n    rtb_Gain_0[0] = rtb_Gain;\r\n    rtb_Gain_0[1] = rtb_vd_ctrl;\r\n\r\n    /* Saturate: 'Saturation5' (':1873') */\r\n    if (rtb_Sum4_i > 1.0F) {\r\n      /* SignalConversion generated from: 'Selector' (':1810') */\r\n      rtb_Gain_0[2] = 1.0F;\r\n    } else {\r\n      /* SignalConversion generated from: 'Selector' (':1810') */\r\n      rtb_Gain_0[2] = rtb_Sum4_i;\r\n    }\r\n\r\n    /* End of Saturate: 'Saturation5' (':1873') */\r\n\r\n    /* Saturate: 'Saturation1' (':1937') incorporates:\r\n     *  LookupNDDirect: 'Direct Lookup Table (n-D)' (':1813')\r\n     *  Selector: 'Selector' (':1810')\r\n     *\r\n     * About 'Direct Lookup Table (n-D)' (':1813'):\r\n     *  2-dimensional Direct Look-Up returning a Column,\r\n     *  which is contiguous for column-major array\r\n     *     Remove protection against out-of-range input in generated code: 'on'\r\n     *   */\r\n    rtb_Sum4_i = rtb_Gain_0[(int32_t)rtCP_DirectLookupTablenD_table[y] - 1];\r\n    if (rtb_Sum4_i > 0.97F) {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[0] = 0.97F;\r\n    } else if (rtb_Sum4_i < 0.03F) {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[0] = 0.03F;\r\n    } else {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[0] = rtb_Sum4_i;\r\n    }\r\n\r\n    rtb_Sum4_i = rtb_Gain_0[(int32_t)rtCP_DirectLookupTablenD_table[y + 1] - 1];\r\n    if (rtb_Sum4_i > 0.97F) {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[1] = 0.97F;\r\n    } else if (rtb_Sum4_i < 0.03F) {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[1] = 0.03F;\r\n    } else {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[1] = rtb_Sum4_i;\r\n    }\r\n\r\n    rtb_Sum4_i = rtb_Gain_0[(int32_t)rtCP_DirectLookupTablenD_table[y + 2] - 1];\r\n    if (rtb_Sum4_i > 0.97F) {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[2] = 0.97F;\r\n    } else if (rtb_Sum4_i < 0.03F) {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[2] = 0.03F;\r\n    } else {\r\n      /* Saturate: 'Saturation1' (':1937') */\r\n      ctrl_ez_DW.T2[2] = rtb_Sum4_i;\r\n    }\r\n\r\n    /* End of Saturate: 'Saturation1' (':1937') */\r\n\r\n    /* SignalConversion generated from: 'Qb' (':1369') */\r\n    *rty_Qb = ctrl_ez_DW.T2[1];\r\n\r\n    /* SignalConversion generated from: 'Qc' (':1370') */\r\n    *rty_Qc = ctrl_ez_DW.T2[2];\r\n\r\n    /* Switch: 'Switch' (':1381') incorporates:\r\n     *  Constant: 'Constant1' (':1376')\r\n     *  Constant: 'Constant' (':1324')\r\n     *  Delay: 'Delay1' (':1377')\r\n     *  Sum: 'Sum1' (':1323')\r\n     */\r\n    if (ctrl_ez_DW.Delay1_DSTATE_e > 0.0F) {\r\n      rtb_Gain = 0.0F;\r\n    } else {\r\n      rtb_Gain = 650.0F - *rtu_ov_out;\r\n    }\r\n\r\n    /* Update for DiscreteIntegrator: 'Accumulator' (':1374') incorporates:\r\n     *  Gain: 'Gain2' (':1379')\r\n     *  Switch: 'Switch' (':1381')\r\n     */\r\n    ctrl_ez_DW.Accumulator_DSTATE += 0.001F * rtb_Gain;\r\n    if (ctrl_ez_DW.Accumulator_DSTATE > 50.0F) {\r\n      ctrl_ez_DW.Accumulator_DSTATE = 50.0F;\r\n    } else if (ctrl_ez_DW.Accumulator_DSTATE < -50.0F) {\r\n      ctrl_ez_DW.Accumulator_DSTATE = -50.0F;\r\n    }\r\n\r\n    /* End of Update for DiscreteIntegrator: 'Accumulator' (':1374') */\r\n\r\n    /* Update for Delay: 'Delay' (':1933') */\r\n    ctrl_ez_DW.Delay_DSTATE[0] = ctrl_ez_DW.Delay_DSTATE[1];\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n    if (rtb_Switch == 100.0F) {\r\n      /* Update for Delay: 'Delay' (':1933') */\r\n      ctrl_ez_DW.Delay_DSTATE[1] = 1.0F;\r\n    } else if (rtb_Switch == -100.0F) {\r\n      /* Update for Delay: 'Delay' (':1933') */\r\n      ctrl_ez_DW.Delay_DSTATE[1] = -1.0F;\r\n    } else {\r\n      /* Update for Delay: 'Delay' (':1933') */\r\n      ctrl_ez_DW.Delay_DSTATE[1] = 0.0F;\r\n    }\r\n\r\n    /* Update for DiscreteIntegrator: 'Accumulator' (':1385') */\r\n    ctrl_ez_DW.Accumulator_DSTATE_a = rtb_Switch;\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n    if (rtb_Kalphabeta0_d_idx_1 == 500.0F) {\r\n      /* Update for Delay: 'Delay1' (':1399') */\r\n      ctrl_ez_DW.Delay1_DSTATE = 1.0F;\r\n    } else if (rtb_Kalphabeta0_d_idx_1 == -500.0F) {\r\n      /* Update for Delay: 'Delay1' (':1399') */\r\n      ctrl_ez_DW.Delay1_DSTATE = -1.0F;\r\n    } else {\r\n      /* Update for Delay: 'Delay1' (':1399') */\r\n      ctrl_ez_DW.Delay1_DSTATE = 0.0F;\r\n    }\r\n\r\n    /* Update for DiscreteIntegrator: 'Accumulator' (':1396') */\r\n    ctrl_ez_DW.Accumulator_DSTATE_p = rtb_Kalphabeta0_d_idx_1;\r\n    if (rtb_vq_park_o > 0.0F) {\r\n      ctrl_ez_DW.Accumulator_PrevResetState = 1;\r\n    } else if (rtb_vq_park_o < 0.0F) {\r\n      ctrl_ez_DW.Accumulator_PrevResetState = -1;\r\n    } else if (rtb_vq_park_o == 0.0F) {\r\n      ctrl_ez_DW.Accumulator_PrevResetState = 0;\r\n    } else {\r\n      ctrl_ez_DW.Accumulator_PrevResetState = 2;\r\n    }\r\n\r\n    /* End of Update for DiscreteIntegrator: 'Accumulator' (':1396') */\r\n\r\n    /* Update for UnitDelay: 'Unit Delay' (':1981:366') */\r\n    ctrl_ez_DW.UnitDelay_DSTATE_f = rtb_Kalphabeta0_d_idx_0;\r\n\r\n    /* Update for Delay: 'Delay1' (':1377') */\r\n    ctrl_ez_DW.Delay1_DSTATE_e = (float)rtb_Accumulator_o2;\r\n  }\r\n\r\n  /* End of Logic: 'NOT' (':591') */\r\n  /* End of Outputs for SubSystem: 'ctrl' (':1270') */\r\n\r\n  /* SignalConversion generated from: 'Qa' (':570') */\r\n  *rty_Qa = ctrl_ez_DW.T2[0];\r\n\r\n  /* Update for UnitDelay: 'Unit Delay' (':831:366') */\r\n  ctrl_ez_DW.UnitDelay_DSTATE[0] = rtb_Add1_idx_0;\r\n  ctrl_ez_DW.UnitDelay_DSTATE[1] = rtb_Add1_idx_1;\r\n  ctrl_ez_DW.UnitDelay_DSTATE[2] = rtb_Add1_idx_2;\r\n\r\n  /* Update for Memory: 'Memory' (':561') */\r\n  ctrl_ez_DW.Memory_PreviousInput = *rty_lock;\r\n\r\n  /* End of Outputs for RootInportFunctionCallGenerator generated from: 'trigger_ctrl_ez' (':21') */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ctrl_ez.h","type":"header","group":"model","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ctrl_ez.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.643\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun May 11 12:01:05 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ctrl_ez_h_\r\n#define ctrl_ez_h_\r\n#ifndef ctrl_ez_COMMON_INCLUDES_\r\n#define ctrl_ez_COMMON_INCLUDES_\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n#endif                                 /* ctrl_ez_COMMON_INCLUDES_ */\r\n\r\n#include \"ctrl_ez_types.h\"\r\n\r\n/*\r\n * Exported States\r\n *\r\n * Note: Exported states are block states with an exported global\r\n * storage class designation.  Code generation will declare the memory for these\r\n * states and exports their symbols.\r\n *\r\n */\r\nextern float filter_IA;                /* 'Data Store Memory' (':2047') */\r\nextern float filter_IB;                /* 'Data Store Memory1' (':2049') */\r\nextern float filter_IC;                /* 'Data Store Memory2' (':2051') */\r\nextern void ctrl_ez_Init(float *rty_Qa);\r\nextern void ctrl_ez_trigger_ctrl_ez(const float *rtu_ia, const float *rtu_ib,\r\n  const float *rtu_ic, const float *rtu_ov_out, const float *rtu_w, const float *\r\n  rtu_lock_pll, const float *rtu_sine, const float *rtu_cos, const float *rtu_va,\r\n  const float *rtu_vc, const float *rtu_vb, float *rty_Qa, float *rty_Qb, float *\r\n  rty_Qc, bool *rty_lock);\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block 'Delay' (':869') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'Constant2' (':2070') : Unused code path elimination\r\n * Block 'Gain' (':1968') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'Bias' (':1856') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Eliminate redundant data type conversion\r\n * Block synthesized block : Eliminate redundant data type conversion\r\n * Block synthesized block : Eliminate redundant data type conversion\r\n * Block synthesized block : Eliminate redundant data type conversion\r\n * Block synthesized block : Eliminate redundant data type conversion\r\n * Block 'One' (':1981:479') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'UseInputPort' (':1981:484') : Unused code path elimination\r\n * Block 'a' (':1981:844') : Unused code path elimination\r\n * Block 'One' (':831:479') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'UseInputPort' (':831:484') : Unused code path elimination\r\n * Block 'a' (':831:844') : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is 'block_name' ('SID'), where block_name is the name of the block\r\n * and SID is the Simulink identifier of the block without the model name.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system(':3')    - opens block with Simulink identifier 'model:3'\r\n */\r\n\r\n/*-\r\n * Requirements for model: ctrl_ez\r\n\r\n\r\n */\r\n#endif                                 /* ctrl_ez_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ctrl_ez_private.h","type":"header","group":"model","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ctrl_ez_private.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.643\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun May 11 12:01:05 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ctrl_ez_private_h_\r\n#define ctrl_ez_private_h_\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n#include \"ctrl_ez_types.h\"\r\n\r\n/* Block signals and states (default storage) for model 'ctrl_ez' */\r\ntypedef struct {\r\n  float T2[3];                         /* 'Saturation1' (':1937') */\r\n  float UnitDelay_DSTATE[3];           /* 'Unit Delay' (':831:366') */\r\n  float Delay_DSTATE[2];               /* 'Delay' (':1933') */\r\n  float I_D_CTRL_VDC;                  /* 'Saturation' (':1380') */\r\n  float Accumulator_DSTATE;            /* 'Accumulator' (':1374') */\r\n  float Accumulator_DSTATE_a;          /* 'Accumulator' (':1385') */\r\n  float Delay1_DSTATE;                 /* 'Delay1' (':1399') */\r\n  float Accumulator_DSTATE_p;          /* 'Accumulator' (':1396') */\r\n  float UnitDelay_DSTATE_f;            /* 'Unit Delay' (':1981:366') */\r\n  float Delay1_DSTATE_e;               /* 'Delay1' (':1377') */\r\n  int8_t Accumulator_PrevResetState;   /* 'Accumulator' (':1396') */\r\n  bool Memory_PreviousInput;           /* 'Memory' (':561') */\r\n} DW_ctrl_ez_f_T;\r\n\r\nextern const float rtCP_pooled_7x7Hr3MX2jW3[1002];\r\nextern const float rtCP_pooled_c9mIltOBYHuW[18];\r\n\r\n#define rtCP_sine_table_values_Value   rtCP_pooled_7x7Hr3MX2jW3  /* Computed Parameter: rtCP_sine_table_values_Value\r\n                                                                  * Referenced by: 'sine_table_values' (':2053:76:549')\r\n                                                                  */\r\n#define rtCP_sine_table_values_Value_d rtCP_pooled_7x7Hr3MX2jW3  /* Computed Parameter: rtCP_sine_table_values_Value_d\r\n                                                                  * Referenced by: 'sine_table_values' (':2056:76:549')\r\n                                                                  */\r\n#define rtCP_DirectLookupTablenD_table rtCP_pooled_c9mIltOBYHuW  /* Computed Parameter: rtCP_DirectLookupTablenD_table\r\n                                                                  * Referenced by: 'Direct Lookup Table (n-D)' (':1813')\r\n                                                                  */\r\n\r\nextern void ctrl_ez_IfActionSubsystem(float rtu_In1, float *rty_Out1);\r\nextern void ctrl_ez_IfActionSubsystem1(float rtu_In1, float *rty_Out1);\r\n\r\n/* Block states (default storage) */\r\nextern DW_ctrl_ez_f_T ctrl_ez_DW;\r\n\r\n#endif                                 /* ctrl_ez_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ctrl_ez_types.h","type":"header","group":"model","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ctrl_ez_types.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.643\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun May 11 12:01:05 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ctrl_ez_types_h_\r\n#define ctrl_ez_types_h_\r\n#endif                                 /* ctrl_ez_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"const_params.c","type":"source","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * const_params.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"ctrl_ez\".\r\n *\r\n * Model version              : 1.643\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Sun May 11 11:58:31 2025\r\n */\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n\r\nextern const float rtCP_pooled_7x7Hr3MX2jW3[1002];\r\nconst float rtCP_pooled_7x7Hr3MX2jW3[1002] = { 0.0F, 0.00785390101F,\r\n  0.0157073177F, 0.023559764F, 0.0314107575F, 0.0392598175F, 0.0471064523F,\r\n  0.0549501814F, 0.0627905205F, 0.070626989F, 0.0784591F, 0.086286366F,\r\n  0.0941083133F, 0.101924457F, 0.109734312F, 0.117537394F, 0.125333235F,\r\n  0.133121341F, 0.140901238F, 0.148672432F, 0.156434461F, 0.16418685F,\r\n  0.171929106F, 0.179660752F, 0.187381312F, 0.195090324F, 0.202787295F,\r\n  0.210471764F, 0.21814324F, 0.225801274F, 0.233445361F, 0.241075054F,\r\n  0.24868989F, 0.256289363F, 0.263873041F, 0.271440446F, 0.278991103F,\r\n  0.286524564F, 0.294040322F, 0.301537961F, 0.309017F, 0.316476971F,\r\n  0.323917419F, 0.331337899F, 0.338737935F, 0.346117049F, 0.353474855F,\r\n  0.360810816F, 0.368124545F, 0.375415564F, 0.382683426F, 0.389927685F,\r\n  0.397147894F, 0.404343605F, 0.411514372F, 0.418659747F, 0.425779283F,\r\n  0.432872593F, 0.439939171F, 0.446978629F, 0.453990489F, 0.460974365F,\r\n  0.46792981F, 0.474856377F, 0.481753677F, 0.488621235F, 0.495458663F,\r\n  0.502265513F, 0.509041429F, 0.515785873F, 0.522498548F, 0.529179F,\r\n  0.535826802F, 0.542441547F, 0.549022794F, 0.555570245F, 0.562083364F,\r\n  0.568561852F, 0.575005233F, 0.581413209F, 0.587785244F, 0.594121039F,\r\n  0.600420237F, 0.60668236F, 0.612907052F, 0.619093955F, 0.625242651F,\r\n  0.631352782F, 0.637424F, 0.643455863F, 0.649448037F, 0.655400157F,\r\n  0.661311865F, 0.667182744F, 0.673012495F, 0.678800762F, 0.684547126F,\r\n  0.690251231F, 0.695912778F, 0.70153141F, 0.707106769F, 0.712638497F,\r\n  0.718126297F, 0.723569751F, 0.72896862F, 0.734322488F, 0.739631116F, 0.744894F,\r\n  0.750111043F, 0.755281806F, 0.760405958F, 0.765483201F, 0.770513237F,\r\n  0.775495768F, 0.780430436F, 0.785316944F, 0.790155F, 0.794944346F,\r\n  0.799684644F, 0.804375648F, 0.809017F, 0.813608468F, 0.818149745F,\r\n  0.822640538F, 0.827080548F, 0.831469595F, 0.835807383F, 0.840093553F,\r\n  0.844327927F, 0.848510206F, 0.852640152F, 0.856717527F, 0.860742033F,\r\n  0.86471343F, 0.868631542F, 0.872496F, 0.876306653F, 0.880063295F, 0.883765638F,\r\n  0.887413442F, 0.891006529F, 0.894544661F, 0.898027599F, 0.901455104F,\r\n  0.904827058F, 0.908143163F, 0.911403298F, 0.914607167F, 0.91775465F,\r\n  0.920845509F, 0.923879504F, 0.926856577F, 0.92977649F, 0.932639F, 0.935444057F,\r\n  0.938191354F, 0.940880775F, 0.943512142F, 0.946085334F, 0.948600173F,\r\n  0.95105654F, 0.953454196F, 0.955793F, 0.958072901F, 0.96029371F, 0.962455213F,\r\n  0.964557409F, 0.96660012F, 0.968583167F, 0.970506489F, 0.972369909F,\r\n  0.974173367F, 0.975916743F, 0.977599919F, 0.979222834F, 0.980785251F,\r\n  0.982287228F, 0.983728647F, 0.985109329F, 0.986429274F, 0.987688363F,\r\n  0.988886476F, 0.990023673F, 0.991099775F, 0.992114723F, 0.993068457F,\r\n  0.993961F, 0.994792163F, 0.995561957F, 0.996270359F, 0.996917307F,\r\n  0.997502804F, 0.998026729F, 0.998489082F, 0.998889863F, 0.999229F,\r\n  0.999506533F, 0.999722421F, 0.999876618F, 0.999969184F, 1.0F, 0.999969184F,\r\n  0.999876618F, 0.999722421F, 0.999506533F, 0.999229F, 0.998889863F,\r\n  0.998489082F, 0.998026729F, 0.997502804F, 0.996917307F, 0.996270359F,\r\n  0.995561957F, 0.994792163F, 0.993961F, 0.993068457F, 0.992114723F,\r\n  0.991099775F, 0.990023673F, 0.988886476F, 0.987688363F, 0.986429274F,\r\n  0.985109329F, 0.983728647F, 0.982287228F, 0.980785251F, 0.979222834F,\r\n  0.977599919F, 0.975916743F, 0.974173367F, 0.972369909F, 0.970506489F,\r\n  0.968583167F, 0.96660012F, 0.964557409F, 0.962455213F, 0.96029371F,\r\n  0.958072901F, 0.955793F, 0.953454196F, 0.95105654F, 0.948600173F, 0.946085334F,\r\n  0.943512142F, 0.940880775F, 0.938191354F, 0.935444057F, 0.932639F, 0.92977649F,\r\n  0.926856577F, 0.923879504F, 0.920845509F, 0.91775465F, 0.914607167F,\r\n  0.911403298F, 0.908143163F, 0.904827058F, 0.901455104F, 0.898027599F,\r\n  0.894544661F, 0.891006529F, 0.887413442F, 0.883765638F, 0.880063295F,\r\n  0.876306653F, 0.872496F, 0.868631542F, 0.86471343F, 0.860742033F, 0.856717527F,\r\n  0.852640152F, 0.848510206F, 0.844327927F, 0.840093553F, 0.835807383F,\r\n  0.831469595F, 0.827080548F, 0.822640538F, 0.818149745F, 0.813608468F,\r\n  0.809017F, 0.804375648F, 0.799684644F, 0.794944346F, 0.790155F, 0.785316944F,\r\n  0.780430436F, 0.775495768F, 0.770513237F, 0.765483201F, 0.760405958F,\r\n  0.755281806F, 0.750111043F, 0.744894F, 0.739631116F, 0.734322488F, 0.72896862F,\r\n  0.723569751F, 0.718126297F, 0.712638497F, 0.707106769F, 0.70153141F,\r\n  0.695912778F, 0.690251231F, 0.684547126F, 0.678800762F, 0.673012495F,\r\n  0.667182744F, 0.661311865F, 0.655400157F, 0.649448037F, 0.643455863F,\r\n  0.637424F, 0.631352782F, 0.625242651F, 0.619093955F, 0.612907052F, 0.60668236F,\r\n  0.600420237F, 0.594121039F, 0.587785244F, 0.581413209F, 0.575005233F,\r\n  0.568561852F, 0.562083364F, 0.555570245F, 0.549022794F, 0.542441547F,\r\n  0.535826802F, 0.529179F, 0.522498548F, 0.515785873F, 0.509041429F,\r\n  0.502265513F, 0.495458663F, 0.488621235F, 0.481753677F, 0.474856377F,\r\n  0.46792981F, 0.460974365F, 0.453990489F, 0.446978629F, 0.439939171F,\r\n  0.432872593F, 0.425779283F, 0.418659747F, 0.411514372F, 0.404343605F,\r\n  0.397147894F, 0.389927685F, 0.382683426F, 0.375415564F, 0.368124545F,\r\n  0.360810816F, 0.353474855F, 0.346117049F, 0.338737935F, 0.331337899F,\r\n  0.323917419F, 0.316476971F, 0.309017F, 0.301537961F, 0.294040322F,\r\n  0.286524564F, 0.278991103F, 0.271440446F, 0.263873041F, 0.256289363F,\r\n  0.24868989F, 0.241075054F, 0.233445361F, 0.225801274F, 0.21814324F,\r\n  0.210471764F, 0.202787295F, 0.195090324F, 0.187381312F, 0.179660752F,\r\n  0.171929106F, 0.16418685F, 0.156434461F, 0.148672432F, 0.140901238F,\r\n  0.133121341F, 0.125333235F, 0.117537394F, 0.109734312F, 0.101924457F,\r\n  0.0941083133F, 0.086286366F, 0.0784591F, 0.070626989F, 0.0627905205F,\r\n  0.0549501814F, 0.0471064523F, 0.0392598175F, 0.0314107575F, 0.023559764F,\r\n  0.0157073177F, 0.00785390101F, 1.22464685E-16F, -0.00785390101F,\r\n  -0.0157073177F, -0.023559764F, -0.0314107575F, -0.0392598175F, -0.0471064523F,\r\n  -0.0549501814F, -0.0627905205F, -0.070626989F, -0.0784591F, -0.086286366F,\r\n  -0.0941083133F, -0.101924457F, -0.109734312F, -0.117537394F, -0.125333235F,\r\n  -0.133121341F, -0.140901238F, -0.148672432F, -0.156434461F, -0.16418685F,\r\n  -0.171929106F, -0.179660752F, -0.187381312F, -0.195090324F, -0.202787295F,\r\n  -0.210471764F, -0.21814324F, -0.225801274F, -0.233445361F, -0.241075054F,\r\n  -0.24868989F, -0.256289363F, -0.263873041F, -0.271440446F, -0.278991103F,\r\n  -0.286524564F, -0.294040322F, -0.301537961F, -0.309017F, -0.316476971F,\r\n  -0.323917419F, -0.331337899F, -0.338737935F, -0.346117049F, -0.353474855F,\r\n  -0.360810816F, -0.368124545F, -0.375415564F, -0.382683426F, -0.389927685F,\r\n  -0.397147894F, -0.404343605F, -0.411514372F, -0.418659747F, -0.425779283F,\r\n  -0.432872593F, -0.439939171F, -0.446978629F, -0.453990489F, -0.460974365F,\r\n  -0.46792981F, -0.474856377F, -0.481753677F, -0.488621235F, -0.495458663F,\r\n  -0.502265513F, -0.509041429F, -0.515785873F, -0.522498548F, -0.529179F,\r\n  -0.535826802F, -0.542441547F, -0.549022794F, -0.555570245F, -0.562083364F,\r\n  -0.568561852F, -0.575005233F, -0.581413209F, -0.587785244F, -0.594121039F,\r\n  -0.600420237F, -0.60668236F, -0.612907052F, -0.619093955F, -0.625242651F,\r\n  -0.631352782F, -0.637424F, -0.643455863F, -0.649448037F, -0.655400157F,\r\n  -0.661311865F, -0.667182744F, -0.673012495F, -0.678800762F, -0.684547126F,\r\n  -0.690251231F, -0.695912778F, -0.70153141F, -0.707106769F, -0.712638497F,\r\n  -0.718126297F, -0.723569751F, -0.72896862F, -0.734322488F, -0.739631116F,\r\n  -0.744894F, -0.750111043F, -0.755281806F, -0.760405958F, -0.765483201F,\r\n  -0.770513237F, -0.775495768F, -0.780430436F, -0.785316944F, -0.790155F,\r\n  -0.794944346F, -0.799684644F, -0.804375648F, -0.809017F, -0.813608468F,\r\n  -0.818149745F, -0.822640538F, -0.827080548F, -0.831469595F, -0.835807383F,\r\n  -0.840093553F, -0.844327927F, -0.848510206F, -0.852640152F, -0.856717527F,\r\n  -0.860742033F, -0.86471343F, -0.868631542F, -0.872496F, -0.876306653F,\r\n  -0.880063295F, -0.883765638F, -0.887413442F, -0.891006529F, -0.894544661F,\r\n  -0.898027599F, -0.901455104F, -0.904827058F, -0.908143163F, -0.911403298F,\r\n  -0.914607167F, -0.91775465F, -0.920845509F, -0.923879504F, -0.926856577F,\r\n  -0.92977649F, -0.932639F, -0.935444057F, -0.938191354F, -0.940880775F,\r\n  -0.943512142F, -0.946085334F, -0.948600173F, -0.95105654F, -0.953454196F,\r\n  -0.955793F, -0.958072901F, -0.96029371F, -0.962455213F, -0.964557409F,\r\n  -0.96660012F, -0.968583167F, -0.970506489F, -0.972369909F, -0.974173367F,\r\n  -0.975916743F, -0.977599919F, -0.979222834F, -0.980785251F, -0.982287228F,\r\n  -0.983728647F, -0.985109329F, -0.986429274F, -0.987688363F, -0.988886476F,\r\n  -0.990023673F, -0.991099775F, -0.992114723F, -0.993068457F, -0.993961F,\r\n  -0.994792163F, -0.995561957F, -0.996270359F, -0.996917307F, -0.997502804F,\r\n  -0.998026729F, -0.998489082F, -0.998889863F, -0.999229F, -0.999506533F,\r\n  -0.999722421F, -0.999876618F, -0.999969184F, -1.0F, -0.999969184F,\r\n  -0.999876618F, -0.999722421F, -0.999506533F, -0.999229F, -0.998889863F,\r\n  -0.998489082F, -0.998026729F, -0.997502804F, -0.996917307F, -0.996270359F,\r\n  -0.995561957F, -0.994792163F, -0.993961F, -0.993068457F, -0.992114723F,\r\n  -0.991099775F, -0.990023673F, -0.988886476F, -0.987688363F, -0.986429274F,\r\n  -0.985109329F, -0.983728647F, -0.982287228F, -0.980785251F, -0.979222834F,\r\n  -0.977599919F, -0.975916743F, -0.974173367F, -0.972369909F, -0.970506489F,\r\n  -0.968583167F, -0.96660012F, -0.964557409F, -0.962455213F, -0.96029371F,\r\n  -0.958072901F, -0.955793F, -0.953454196F, -0.95105654F, -0.948600173F,\r\n  -0.946085334F, -0.943512142F, -0.940880775F, -0.938191354F, -0.935444057F,\r\n  -0.932639F, -0.92977649F, -0.926856577F, -0.923879504F, -0.920845509F,\r\n  -0.91775465F, -0.914607167F, -0.911403298F, -0.908143163F, -0.904827058F,\r\n  -0.901455104F, -0.898027599F, -0.894544661F, -0.891006529F, -0.887413442F,\r\n  -0.883765638F, -0.880063295F, -0.876306653F, -0.872496F, -0.868631542F,\r\n  -0.86471343F, -0.860742033F, -0.856717527F, -0.852640152F, -0.848510206F,\r\n  -0.844327927F, -0.840093553F, -0.835807383F, -0.831469595F, -0.827080548F,\r\n  -0.822640538F, -0.818149745F, -0.813608468F, -0.809017F, -0.804375648F,\r\n  -0.799684644F, -0.794944346F, -0.790155F, -0.785316944F, -0.780430436F,\r\n  -0.775495768F, -0.770513237F, -0.765483201F, -0.760405958F, -0.755281806F,\r\n  -0.750111043F, -0.744894F, -0.739631116F, -0.734322488F, -0.72896862F,\r\n  -0.723569751F, -0.718126297F, -0.712638497F, -0.707106769F, -0.70153141F,\r\n  -0.695912778F, -0.690251231F, -0.684547126F, -0.678800762F, -0.673012495F,\r\n  -0.667182744F, -0.661311865F, -0.655400157F, -0.649448037F, -0.643455863F,\r\n  -0.637424F, -0.631352782F, -0.625242651F, -0.619093955F, -0.612907052F,\r\n  -0.60668236F, -0.600420237F, -0.594121039F, -0.587785244F, -0.581413209F,\r\n  -0.575005233F, -0.568561852F, -0.562083364F, -0.555570245F, -0.549022794F,\r\n  -0.542441547F, -0.535826802F, -0.529179F, -0.522498548F, -0.515785873F,\r\n  -0.509041429F, -0.502265513F, -0.495458663F, -0.488621235F, -0.481753677F,\r\n  -0.474856377F, -0.46792981F, -0.460974365F, -0.453990489F, -0.446978629F,\r\n  -0.439939171F, -0.432872593F, -0.425779283F, -0.418659747F, -0.411514372F,\r\n  -0.404343605F, -0.397147894F, -0.389927685F, -0.382683426F, -0.375415564F,\r\n  -0.368124545F, -0.360810816F, -0.353474855F, -0.346117049F, -0.338737935F,\r\n  -0.331337899F, -0.323917419F, -0.316476971F, -0.309017F, -0.301537961F,\r\n  -0.294040322F, -0.286524564F, -0.278991103F, -0.271440446F, -0.263873041F,\r\n  -0.256289363F, -0.24868989F, -0.241075054F, -0.233445361F, -0.225801274F,\r\n  -0.21814324F, -0.210471764F, -0.202787295F, -0.195090324F, -0.187381312F,\r\n  -0.179660752F, -0.171929106F, -0.16418685F, -0.156434461F, -0.148672432F,\r\n  -0.140901238F, -0.133121341F, -0.125333235F, -0.117537394F, -0.109734312F,\r\n  -0.101924457F, -0.0941083133F, -0.086286366F, -0.0784591F, -0.070626989F,\r\n  -0.0627905205F, -0.0549501814F, -0.0471064523F, -0.0392598175F, -0.0314107575F,\r\n  -0.023559764F, -0.0157073177F, -0.00785390101F, -2.44929371E-16F,\r\n  0.00785390101F, 0.0157073177F, 0.023559764F, 0.0314107575F, 0.0392598175F,\r\n  0.0471064523F, 0.0549501814F, 0.0627905205F, 0.070626989F, 0.0784591F,\r\n  0.086286366F, 0.0941083133F, 0.101924457F, 0.109734312F, 0.117537394F,\r\n  0.125333235F, 0.133121341F, 0.140901238F, 0.148672432F, 0.156434461F,\r\n  0.16418685F, 0.171929106F, 0.179660752F, 0.187381312F, 0.195090324F,\r\n  0.202787295F, 0.210471764F, 0.21814324F, 0.225801274F, 0.233445361F,\r\n  0.241075054F, 0.24868989F, 0.256289363F, 0.263873041F, 0.271440446F,\r\n  0.278991103F, 0.286524564F, 0.294040322F, 0.301537961F, 0.309017F,\r\n  0.316476971F, 0.323917419F, 0.331337899F, 0.338737935F, 0.346117049F,\r\n  0.353474855F, 0.360810816F, 0.368124545F, 0.375415564F, 0.382683426F,\r\n  0.389927685F, 0.397147894F, 0.404343605F, 0.411514372F, 0.418659747F,\r\n  0.425779283F, 0.432872593F, 0.439939171F, 0.446978629F, 0.453990489F,\r\n  0.460974365F, 0.46792981F, 0.474856377F, 0.481753677F, 0.488621235F,\r\n  0.495458663F, 0.502265513F, 0.509041429F, 0.515785873F, 0.522498548F,\r\n  0.529179F, 0.535826802F, 0.542441547F, 0.549022794F, 0.555570245F,\r\n  0.562083364F, 0.568561852F, 0.575005233F, 0.581413209F, 0.587785244F,\r\n  0.594121039F, 0.600420237F, 0.60668236F, 0.612907052F, 0.619093955F,\r\n  0.625242651F, 0.631352782F, 0.637424F, 0.643455863F, 0.649448037F,\r\n  0.655400157F, 0.661311865F, 0.667182744F, 0.673012495F, 0.678800762F,\r\n  0.684547126F, 0.690251231F, 0.695912778F, 0.70153141F, 0.707106769F,\r\n  0.712638497F, 0.718126297F, 0.723569751F, 0.72896862F, 0.734322488F,\r\n  0.739631116F, 0.744894F, 0.750111043F, 0.755281806F, 0.760405958F,\r\n  0.765483201F, 0.770513237F, 0.775495768F, 0.780430436F, 0.785316944F,\r\n  0.790155F, 0.794944346F, 0.799684644F, 0.804375648F, 0.809017F, 0.813608468F,\r\n  0.818149745F, 0.822640538F, 0.827080548F, 0.831469595F, 0.835807383F,\r\n  0.840093553F, 0.844327927F, 0.848510206F, 0.852640152F, 0.856717527F,\r\n  0.860742033F, 0.86471343F, 0.868631542F, 0.872496F, 0.876306653F, 0.880063295F,\r\n  0.883765638F, 0.887413442F, 0.891006529F, 0.894544661F, 0.898027599F,\r\n  0.901455104F, 0.904827058F, 0.908143163F, 0.911403298F, 0.914607167F,\r\n  0.91775465F, 0.920845509F, 0.923879504F, 0.926856577F, 0.92977649F, 0.932639F,\r\n  0.935444057F, 0.938191354F, 0.940880775F, 0.943512142F, 0.946085334F,\r\n  0.948600173F, 0.95105654F, 0.953454196F, 0.955793F, 0.958072901F, 0.96029371F,\r\n  0.962455213F, 0.964557409F, 0.96660012F, 0.968583167F, 0.970506489F,\r\n  0.972369909F, 0.974173367F, 0.975916743F, 0.977599919F, 0.979222834F,\r\n  0.980785251F, 0.982287228F, 0.983728647F, 0.985109329F, 0.986429274F,\r\n  0.987688363F, 0.988886476F, 0.990023673F, 0.991099775F, 0.992114723F,\r\n  0.993068457F, 0.993961F, 0.994792163F, 0.995561957F, 0.996270359F,\r\n  0.996917307F, 0.997502804F, 0.998026729F, 0.998489082F, 0.998889863F,\r\n  0.999229F, 0.999506533F, 0.999722421F, 0.999876618F, 0.999969184F, 1.0F,\r\n  0.999969184F } ;\r\n\r\nextern const float rtCP_pooled_c9mIltOBYHuW[18];\r\nconst float rtCP_pooled_c9mIltOBYHuW[18] = { 3.0F, 2.0F, 1.0F, 2.0F, 3.0F, 1.0F,\r\n  1.0F, 3.0F, 2.0F, 1.0F, 2.0F, 3.0F, 2.0F, 1.0F, 3.0F, 3.0F, 1.0F, 2.0F } ;\r\n"},{"name":"intrp1d_fu32fl.c","type":"source","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: intrp1d_fu32fl.c\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.643\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun May 11 11:58:31 2025\r\n */\r\n\r\n#include \"intrp1d_fu32fl.h\"\r\n#include <stdint.h>\r\n\r\nfloat intrp1d_fu32fl(uint32_t bpIndex, float frac, const float table[])\r\n{\r\n  float yL_0d0;\r\n\r\n  /* Column-major Interpolation 1-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Overflow mode: 'wrapping'\r\n   */\r\n  yL_0d0 = table[bpIndex];\r\n  return (table[bpIndex + 1U] - yL_0d0) * frac + yL_0d0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"intrp1d_fu32fl.h","type":"header","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: intrp1d_fu32fl.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.643\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun May 11 11:58:31 2025\r\n */\r\n\r\n#ifndef intrp1d_fu32fl_h_\r\n#define intrp1d_fu32fl_h_\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n\r\nextern float intrp1d_fu32fl(uint32_t bpIndex, float frac, const float table[]);\r\n\r\n#endif                                 /* intrp1d_fu32fl_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"plook_u32ff_evenc.c","type":"source","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: plook_u32ff_evenc.c\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.643\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun May 11 11:58:31 2025\r\n */\r\n\r\n#include \"plook_u32ff_evenc.h\"\r\n#include <stdint.h>\r\n\r\nuint32_t plook_u32ff_evenc(float u, float bp0, float bpSpace, uint32_t maxIndex,\r\n  float *fraction)\r\n{\r\n  uint32_t bpIndex;\r\n\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'even'\r\n     Extrapolation method: 'Clip'\r\n     Use previous index: 'off'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u <= bp0) {\r\n    bpIndex = 0U;\r\n    *fraction = 0.0F;\r\n  } else {\r\n    float fbpIndex;\r\n    float invSpc;\r\n    invSpc = 1.0F / bpSpace;\r\n    fbpIndex = (u - bp0) * invSpc;\r\n    if (fbpIndex < maxIndex) {\r\n      bpIndex = (uint32_t)fbpIndex;\r\n      *fraction = (u - ((float)(uint32_t)fbpIndex * bpSpace + bp0)) * invSpc;\r\n    } else {\r\n      bpIndex = maxIndex - 1U;\r\n      *fraction = 1.0F;\r\n    }\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"plook_u32ff_evenc.h","type":"header","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: plook_u32ff_evenc.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.643\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun May 11 11:58:31 2025\r\n */\r\n\r\n#ifndef plook_u32ff_evenc_h_\r\n#define plook_u32ff_evenc_h_\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n\r\nextern uint32_t plook_u32ff_evenc(float u, float bp0, float bpSpace, uint32_t\r\n  maxIndex, float *fraction);\r\n\r\n#endif                                 /* plook_u32ff_evenc_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 0\n#include \"mw_stm32_board_header.h\"\n#include \"SysTickScheduler.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE STM32F7xx Based (Double precision FPU)\n#define MW_EXTMODEPROTOCOLINFO_CAN_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_CAN_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_SERIAL_BAUDRATE stm32cube.codegen.getConnectivityBaudrate(hCS)\n#define MW_CONNECTIONINFO_SERIAL_COMPORT stm32cube.codegen.getConnectivityCOMPort(hCS)\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 1\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS stm32cube.parameters.EthernetConfigIPAddressExternalMode\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 1\n#define MW_CONNECTIONINFO_CAN_CANVENDOR matlab:stm32cube.codegen.getXCPonCANConnectivity(hCS,'Vendor')\n#define MW_CONNECTIONINFO_CAN_CANDEVICE matlab:stm32cube.codegen.getXCPonCANConnectivity(hCS,'Device')\n#define MW_CONNECTIONINFO_CAN_CANCHANNEL stm32cube.codegen.getXCPonCANConnectivity(hCS,'Channel')\n#define MW_CONNECTIONINFO_CAN_BUSSPEED stm32cube.codegen.getXCPonCANConnectivity(hCS,'Baudrate')\n#define MW_CONNECTIONINFO_CAN_CANIDCOMMAND stm32cube.codegen.getXCPonCANConnectivity(hCS,'CANIDCommand')\n#define MW_CONNECTIONINFO_CAN_CANIDRESPONSE stm32cube.codegen.getXCPonCANConnectivity(hCS,'CANIDResponse')\n#define MW_CONNECTIONINFO_CAN_ISCANIDEXTENDED stm32cube.codegen.getXCPonCANConnectivity(hCS,'IsCANIDExtended')\n#define MW_CONNECTIONINFO_CAN_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION Serial\n#define MW_EXTMODE_SIGNALBUFFERSIZE 2048.000000\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 1\n#define MW_RTOS Baremetal\n#define MW_RTOSBASERATETASKPRIORITY 40\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_RUNTIMELIBRARY 0\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_STM32CUBEMX_PROJECTFILEBUTTON \n#define MW_STM32CUBEMX_CREATEPROJECTFILEBUTTON \n#define MW_STM32CUBEMX_LAUNCHPROJECTFILEBUTTON \n#define MW_STM32CUBEMX_PROJECTFILE C:/Users/Angel/Desktop/hil/pfc3ph/stf7/matlab/3ph_pil/3ph_pil.ioc\n#define MW_STM32CUBEMX_DEVICEID STM32F767ZITx\n#define MW_STM32CUBEMX_FAMILY STM32F7\n#define MW_STM32CUBEMX_CONNECTIVITYMODE 0\n#define MW_STM32CUBEMX_CONNECTIONPORT 0\n#define MW_STM32CUBEMX_MODE 0\n#define MW_STM32CUBEMX_ACCESSPORT 0\n#define MW_STM32CUBEMX_RESETMODE 0\n#define MW_STM32CUBEMX_AUTODETECTBOARD 1\n#define MW_STM32CUBEMX_DEVICELIST -1\n#define MW_STM32CUBEMX_DEVICELISTREFRESH \n#define MW_CLOCKING_CPUCLOCKRATEMHZ 216.000000\n#define MW_CONNECTION_SERIALCONFIGUREMODULE 1\n#define MW_CONNECTION_SERIALMODULE 2\n#define MW_CONNECTION_SERIALPORT COM3\n#define MW_CONNECTION_ETHERNETCONFIGUREMODULE 48\n#define MW_CONNECTION_ETHERNETPORT 17725.000000\n#define MW_CONNECTION_CANCONFIGUREMODULE 48\n#define MW_CONNECTION_CANMODULE 0\n#define MW_CONNECTION_BAUDRATE 1000000\n#define MW_CONNECTION_CANREADSOURCE 0\n#define MW_CONNECTION_CANVENDOR -1\n#define MW_CONNECTION_CANDEVICE -1\n#define MW_CONNECTION_CANCHANNEL -1\n#define MW_CONNECTION_ISCANIDEXTENDED 48\n#define MW_CONNECTION_CANIDCOMMAND 2\n#define MW_CONNECTION_CANIDRESPONSE 3\n#define MW_CONNECTIVITY_REFRESH \n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN stm32cube.connectedIO.getConfigSetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN stm32cube.connectedIO.updateServer\n#define MW_SIMULINKIO_VALIDATESERVERFCN stm32cube.connectedIO.validateIoServer\n#define MW_SIMULINKIO_INTERFACE 0\n#define MW_SIMULINKIO_VALIDATEBEFORECONNECTFCN stm32cube.connectedIO.connectedIOModelValidation\n#define MW_USART_USART1CONFIGUREMODULE 48\n#define MW_USART_USART1TRANSMITMODE 0\n#define MW_USART_USART1RECEIVEMODE 0\n#define MW_USART_USART1TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART1RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART1DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART2CONFIGUREMODULE 48\n#define MW_USART_USART2TRANSMITMODE 0\n#define MW_USART_USART2RECEIVEMODE 0\n#define MW_USART_USART2TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART2RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART2DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART3CONFIGUREMODULE 48\n#define MW_USART_USART3TRANSMITMODE 0\n#define MW_USART_USART3RECEIVEMODE 0\n#define MW_USART_USART3TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART3RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART3DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART4CONFIGUREMODULE 48\n#define MW_USART_UART4TRANSMITMODE 0\n#define MW_USART_UART4RECEIVEMODE 0\n#define MW_USART_UART4TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART4RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART4DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART5CONFIGUREMODULE 48\n#define MW_USART_UART5TRANSMITMODE 0\n#define MW_USART_UART5RECEIVEMODE 0\n#define MW_USART_UART5TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART5RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART5DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART6CONFIGUREMODULE 48\n#define MW_USART_USART6TRANSMITMODE 0\n#define MW_USART_USART6RECEIVEMODE 0\n#define MW_USART_USART6TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART6RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART6DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART7CONFIGUREMODULE 48\n#define MW_USART_UART7TRANSMITMODE 0\n#define MW_USART_UART7RECEIVEMODE 0\n#define MW_USART_UART7TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART7RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART7DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART8CONFIGUREMODULE 48\n#define MW_USART_UART8TRANSMITMODE 0\n#define MW_USART_UART8RECEIVEMODE 0\n#define MW_USART_UART8TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART8RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART8DISABLEDMAINTERRUPTONERROR 48\n#define MW_ETHERNET_HOSTNAME STM32F7xx_dp\n#define MW_ETHERNET_MACADDR 00:80:E1:00:00:00\n#define MW_ETHERNET_DHCPENABLED 1\n#define MW_ETHERNET_LOCALIPADDRESS 0.0.0.0\n#define MW_ETHERNET_SUBNETMASK 0.0.0.0\n#define MW_ETHERNET_GATEWAY 0.0.0.0\n#define MW_ADC1_USEDMA 0\n#define MW_ADC1_USEWATCHDOG 0\n#define MW_ADC1_EOCENABLEINTERRUPT 0\n#define MW_ADC1_JEOCENABLEINTERRUPT 48\n#define MW_ADC1_OVRENABLEINTERRUPT 48\n#define MW_ADC1_PROJECTFILEBUTTON \n#define MW_ADC2_USEDMA 0\n#define MW_ADC2_USEWATCHDOG 0\n#define MW_ADC2_EOCENABLEINTERRUPT 0\n#define MW_ADC2_JEOCENABLEINTERRUPT 48\n#define MW_ADC2_OVRENABLEINTERRUPT 48\n#define MW_ADC2_PROJECTFILEBUTTON \n#define MW_ADC3_USEDMA 0\n#define MW_ADC3_USEWATCHDOG 0\n#define MW_ADC3_EOCENABLEINTERRUPT 0\n#define MW_ADC3_JEOCENABLEINTERRUPT 48\n#define MW_ADC3_OVRENABLEINTERRUPT 48\n#define MW_ADC3_PROJECTFILEBUTTON \n#define MW_SPI_SPIMODULESELECT 0\n#define MW_SPI_SPI1RXFIFOINTERRUPT 0\n#define MW_SPI_SPI1ERRORINTERRUPT 0\n#define MW_SPI_SPI2RXFIFOINTERRUPT 0\n#define MW_SPI_SPI2ERRORINTERRUPT 0\n#define MW_SPI_SPI3RXFIFOINTERRUPT 0\n#define MW_SPI_SPI3ERRORINTERRUPT 0\n#define MW_SPI_SPI4RXFIFOINTERRUPT 0\n#define MW_SPI_SPI4ERRORINTERRUPT 0\n#define MW_SPI_SPI5RXFIFOINTERRUPT 0\n#define MW_SPI_SPI5ERRORINTERRUPT 0\n#define MW_SPI_SPI6RXFIFOINTERRUPT 0\n#define MW_SPI_SPI6ERRORINTERRUPT 0\n#define MW_TIMER_TIMERGROUP 0\n#define MW_TIMER_TIM1CONFIGUREMODULE 48\n#define MW_TIMER_TIM8CONFIGUREMODULE 48\n#define MW_TIMER_TIM2CONFIGUREMODULE 48\n#define MW_TIMER_TIM3CONFIGUREMODULE 48\n#define MW_TIMER_TIM4CONFIGUREMODULE 48\n#define MW_TIMER_TIM5CONFIGUREMODULE 48\n#define MW_TIMER_TIM6CONFIGUREMODULE 48\n#define MW_TIMER_TIM7CONFIGUREMODULE 48\n#define MW_TIMER_TIM9CONFIGUREMODULE 48\n#define MW_TIMER_TIM10CONFIGUREMODULE 48\n#define MW_TIMER_TIM11CONFIGUREMODULE 48\n#define MW_TIMER_TIM12CONFIGUREMODULE 48\n#define MW_TIMER_TIM13CONFIGUREMODULE 48\n#define MW_TIMER_TIM14CONFIGUREMODULE 48\n#define MW_TIM1_STARTTIMER 49\n#define MW_TIM1_TRIGGERINTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM1_UPDATEINTERRUPT 48\n#define MW_TIM1_BREAKINTERRUPT 48\n#define MW_TIM1_COMINTERRUPT 48\n#define MW_TIM8_STARTTIMER 49\n#define MW_TIM8_TRIGGERINTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM8_UPDATEINTERRUPT 48\n#define MW_TIM8_BREAKINTERRUPT 48\n#define MW_TIM8_COMINTERRUPT 48\n#define MW_TIM2_STARTTIMER 49\n#define MW_TIM2_TRIGGERINTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM2_UPDATEINTERRUPT 48\n#define MW_TIM3_STARTTIMER 49\n#define MW_TIM3_TRIGGERINTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM3_UPDATEINTERRUPT 48\n#define MW_TIM4_STARTTIMER 49\n#define MW_TIM4_TRIGGERINTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM4_UPDATEINTERRUPT 48\n#define MW_TIM5_STARTTIMER 49\n#define MW_TIM5_TRIGGERINTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM5_UPDATEINTERRUPT 48\n#define MW_TIM6_STARTTIMER 49\n#define MW_TIM6_UPDATEINTERRUPT 48\n#define MW_TIM7_STARTTIMER 49\n#define MW_TIM7_UPDATEINTERRUPT 48\n#define MW_TIM9_STARTTIMER 49\n#define MW_TIM9_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM9_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM9_UPDATEINTERRUPT 48\n#define MW_TIM10_STARTTIMER 49\n#define MW_TIM10_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM10_UPDATEINTERRUPT 48\n#define MW_TIM11_STARTTIMER 49\n#define MW_TIM11_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM11_UPDATEINTERRUPT 48\n#define MW_TIM12_STARTTIMER 49\n#define MW_TIM12_TRIGGERINTERRUPT 48\n#define MW_TIM12_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM12_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM12_UPDATEINTERRUPT 48\n#define MW_TIM13_STARTTIMER 49\n#define MW_TIM13_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM13_UPDATEINTERRUPT 48\n#define MW_TIM14_STARTTIMER 49\n#define MW_TIM14_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM14_UPDATEINTERRUPT 48\n#define MW_CAN_MODULE 0\n#define MW_CAN1_BAUDRATE 1000000\n#define MW_CAN1_CONFIGUREINTENRX 0\n#define MW_CAN1_CONFIGUREINTFIFO0RX 0\n#define MW_CAN1_ENABLEFIFO0MSGPENDINGINTR 0\n#define MW_CAN1_ENABLEFIFO0FULLINTR 0\n#define MW_CAN1_ENABLEFIFO0OVRINTR 0\n#define MW_CAN1_CONFIGUREINTFIFO1RX 0\n#define MW_CAN1_ENABLEFIFO1MSGPENDINGINTR 0\n#define MW_CAN1_ENABLEFIFO1FULLINTR 0\n#define MW_CAN1_ENABLEFIFO1OVRINTR 0\n#define MW_CAN1_CONFIGUREINTENTX 0\n#define MW_CAN1_ENABLETXMAILBOXEMPTYINTR 0\n#define MW_CAN1_CONFIGUREINTENOTHER 0\n#define MW_CAN1_ENABLEERRWARNINTR 0\n#define MW_CAN1_ENABLEERRPASSIVEINTR 0\n#define MW_CAN1_ENABLEBUSOFFINTR 0\n#define MW_CAN1_ENABLELASTERRCODEINTR 0\n#define MW_CAN1_ENABLEWAKEUPINTR 0\n#define MW_CAN1_ENABLESLEEPACKINTR 0\n#define MW_CAN1_ACCEPTALLMESSAGES 1\n#define MW_CAN1_FILTERBANKNUMBER 0\n#define MW_CAN1_ENABLEFILTERBANK00 0\n#define MW_CAN1_SCALE00 0\n#define MW_CAN1_MODE00 0\n#define MW_CAN1_FIFOASSIGNMENT00 0\n#define MW_CAN1_IDTYPE00 0\n#define MW_CAN1_ID1_00 0\n#define MW_CAN1_MASK1_00 0\n#define MW_CAN1_ID2_00 0\n#define MW_CAN1_MASK2_00 0\n#define MW_CAN1_ID3_00 0\n#define MW_CAN1_ID4_00 0\n#define MW_CAN1_ENABLEFILTERBANK01 0\n#define MW_CAN1_SCALE01 0\n#define MW_CAN1_MODE01 0\n#define MW_CAN1_FIFOASSIGNMENT01 0\n#define MW_CAN1_IDTYPE01 0\n#define MW_CAN1_ID1_01 0\n#define MW_CAN1_MASK1_01 0\n#define MW_CAN1_ID2_01 0\n#define MW_CAN1_MASK2_01 0\n#define MW_CAN1_ID3_01 0\n#define MW_CAN1_ID4_01 0\n#define MW_CAN1_ENABLEFILTERBANK02 0\n#define MW_CAN1_SCALE02 0\n#define MW_CAN1_MODE02 0\n#define MW_CAN1_FIFOASSIGNMENT02 0\n#define MW_CAN1_IDTYPE02 0\n#define MW_CAN1_ID1_02 0\n#define MW_CAN1_MASK1_02 0\n#define MW_CAN1_ID2_02 0\n#define MW_CAN1_MASK2_02 0\n#define MW_CAN1_ID3_02 0\n#define MW_CAN1_ID4_02 0\n#define MW_CAN1_ENABLEFILTERBANK03 0\n#define MW_CAN1_SCALE03 0\n#define MW_CAN1_MODE03 0\n#define MW_CAN1_FIFOASSIGNMENT03 0\n#define MW_CAN1_IDTYPE03 0\n#define MW_CAN1_ID1_03 0\n#define MW_CAN1_MASK1_03 0\n#define MW_CAN1_ID2_03 0\n#define MW_CAN1_MASK2_03 0\n#define MW_CAN1_ID3_03 0\n#define MW_CAN1_ID4_03 0\n#define MW_CAN1_ENABLEFILTERBANK04 0\n#define MW_CAN1_SCALE04 0\n#define MW_CAN1_MODE04 0\n#define MW_CAN1_FIFOASSIGNMENT04 0\n#define MW_CAN1_IDTYPE04 0\n#define MW_CAN1_ID1_04 0\n#define MW_CAN1_MASK1_04 0\n#define MW_CAN1_ID2_04 0\n#define MW_CAN1_MASK2_04 0\n#define MW_CAN1_ID3_04 0\n#define MW_CAN1_ID4_04 0\n#define MW_CAN1_ENABLEFILTERBANK05 0\n#define MW_CAN1_SCALE05 0\n#define MW_CAN1_MODE05 0\n#define MW_CAN1_FIFOASSIGNMENT05 0\n#define MW_CAN1_IDTYPE05 0\n#define MW_CAN1_ID1_05 0\n#define MW_CAN1_MASK1_05 0\n#define MW_CAN1_ID2_05 0\n#define MW_CAN1_MASK2_05 0\n#define MW_CAN1_ID3_05 0\n#define MW_CAN1_ID4_05 0\n#define MW_CAN1_ENABLEFILTERBANK06 0\n#define MW_CAN1_SCALE06 0\n#define MW_CAN1_MODE06 0\n#define MW_CAN1_FIFOASSIGNMENT06 0\n#define MW_CAN1_IDTYPE06 0\n#define MW_CAN1_ID1_06 0\n#define MW_CAN1_MASK1_06 0\n#define MW_CAN1_ID2_06 0\n#define MW_CAN1_MASK2_06 0\n#define MW_CAN1_ID3_06 0\n#define MW_CAN1_ID4_06 0\n#define MW_CAN1_ENABLEFILTERBANK07 0\n#define MW_CAN1_SCALE07 0\n#define MW_CAN1_MODE07 0\n#define MW_CAN1_FIFOASSIGNMENT07 0\n#define MW_CAN1_IDTYPE07 0\n#define MW_CAN1_ID1_07 0\n#define MW_CAN1_MASK1_07 0\n#define MW_CAN1_ID2_07 0\n#define MW_CAN1_MASK2_07 0\n#define MW_CAN1_ID3_07 0\n#define MW_CAN1_ID4_07 0\n#define MW_CAN1_ENABLEFILTERBANK08 0\n#define MW_CAN1_SCALE08 0\n#define MW_CAN1_MODE08 0\n#define MW_CAN1_FIFOASSIGNMENT08 0\n#define MW_CAN1_IDTYPE08 0\n#define MW_CAN1_ID1_08 0\n#define MW_CAN1_MASK1_08 0\n#define MW_CAN1_ID2_08 0\n#define MW_CAN1_MASK2_08 0\n#define MW_CAN1_ID3_08 0\n#define MW_CAN1_ID4_08 0\n#define MW_CAN1_ENABLEFILTERBANK09 0\n#define MW_CAN1_SCALE09 0\n#define MW_CAN1_MODE09 0\n#define MW_CAN1_FIFOASSIGNMENT09 0\n#define MW_CAN1_IDTYPE09 0\n#define MW_CAN1_ID1_09 0\n#define MW_CAN1_MASK1_09 0\n#define MW_CAN1_ID2_09 0\n#define MW_CAN1_MASK2_09 0\n#define MW_CAN1_ID3_09 0\n#define MW_CAN1_ID4_09 0\n#define MW_CAN1_ENABLEFILTERBANK10 0\n#define MW_CAN1_SCALE10 0\n#define MW_CAN1_MODE10 0\n#define MW_CAN1_FIFOASSIGNMENT10 0\n#define MW_CAN1_IDTYPE10 0\n#define MW_CAN1_ID1_10 0\n#define MW_CAN1_MASK1_10 0\n#define MW_CAN1_ID2_10 0\n#define MW_CAN1_MASK2_10 0\n#define MW_CAN1_ID3_10 0\n#define MW_CAN1_ID4_10 0\n#define MW_CAN1_ENABLEFILTERBANK11 0\n#define MW_CAN1_SCALE11 0\n#define MW_CAN1_MODE11 0\n#define MW_CAN1_FIFOASSIGNMENT11 0\n#define MW_CAN1_IDTYPE11 0\n#define MW_CAN1_ID1_11 0\n#define MW_CAN1_MASK1_11 0\n#define MW_CAN1_ID2_11 0\n#define MW_CAN1_MASK2_11 0\n#define MW_CAN1_ID3_11 0\n#define MW_CAN1_ID4_11 0\n#define MW_CAN1_ENABLEFILTERBANK12 0\n#define MW_CAN1_SCALE12 0\n#define MW_CAN1_MODE12 0\n#define MW_CAN1_FIFOASSIGNMENT12 0\n#define MW_CAN1_IDTYPE12 0\n#define MW_CAN1_ID1_12 0\n#define MW_CAN1_MASK1_12 0\n#define MW_CAN1_ID2_12 0\n#define MW_CAN1_MASK2_12 0\n#define MW_CAN1_ID3_12 0\n#define MW_CAN1_ID4_12 0\n#define MW_CAN1_ENABLEFILTERBANK13 0\n#define MW_CAN1_SCALE13 0\n#define MW_CAN1_MODE13 0\n#define MW_CAN1_FIFOASSIGNMENT13 0\n#define MW_CAN1_IDTYPE13 0\n#define MW_CAN1_ID1_13 0\n#define MW_CAN1_MASK1_13 0\n#define MW_CAN1_ID2_13 0\n#define MW_CAN1_MASK2_13 0\n#define MW_CAN1_ID3_13 0\n#define MW_CAN1_ID4_13 0\n#define MW_CAN2_BAUDRATE 1000000\n#define MW_CAN2_CONFIGUREINTENRX 0\n#define MW_CAN2_CONFIGUREINTFIFO0RX 0\n#define MW_CAN2_ENABLEFIFO0MSGPENDINGINTR 0\n#define MW_CAN2_ENABLEFIFO0FULLINTR 0\n#define MW_CAN2_ENABLEFIFO0OVRINTR 0\n#define MW_CAN2_CONFIGUREINTFIFO1RX 0\n#define MW_CAN2_ENABLEFIFO1MSGPENDINGINTR 0\n#define MW_CAN2_ENABLEFIFO1FULLINTR 0\n#define MW_CAN2_ENABLEFIFO1OVRINTR 0\n#define MW_CAN2_CONFIGUREINTENTX 0\n#define MW_CAN2_ENABLETXMAILBOXEMPTYINTR 0\n#define MW_CAN2_CONFIGUREINTENOTHER 0\n#define MW_CAN2_ENABLEERRWARNINTR 0\n#define MW_CAN2_ENABLEERRPASSIVEINTR 0\n#define MW_CAN2_ENABLEBUSOFFINTR 0\n#define MW_CAN2_ENABLELASTERRCODEINTR 0\n#define MW_CAN2_ENABLEWAKEUPINTR 0\n#define MW_CAN2_ENABLESLEEPACKINTR 0\n#define MW_CAN2_ACCEPTALLMESSAGES 1\n#define MW_CAN2_FILTERBANKNUMBER 0\n#define MW_CAN2_ENABLEFILTERBANK00 0\n#define MW_CAN2_SCALE00 0\n#define MW_CAN2_MODE00 0\n#define MW_CAN2_FIFOASSIGNMENT00 0\n#define MW_CAN2_IDTYPE00 0\n#define MW_CAN2_ID1_00 0\n#define MW_CAN2_MASK1_00 0\n#define MW_CAN2_ID2_00 0\n#define MW_CAN2_MASK2_00 0\n#define MW_CAN2_ID3_00 0\n#define MW_CAN2_ID4_00 0\n#define MW_CAN2_ENABLEFILTERBANK01 0\n#define MW_CAN2_SCALE01 0\n#define MW_CAN2_MODE01 0\n#define MW_CAN2_FIFOASSIGNMENT01 0\n#define MW_CAN2_IDTYPE01 0\n#define MW_CAN2_ID1_01 0\n#define MW_CAN2_MASK1_01 0\n#define MW_CAN2_ID2_01 0\n#define MW_CAN2_MASK2_01 0\n#define MW_CAN2_ID3_01 0\n#define MW_CAN2_ID4_01 0\n#define MW_CAN2_ENABLEFILTERBANK02 0\n#define MW_CAN2_SCALE02 0\n#define MW_CAN2_MODE02 0\n#define MW_CAN2_FIFOASSIGNMENT02 0\n#define MW_CAN2_IDTYPE02 0\n#define MW_CAN2_ID1_02 0\n#define MW_CAN2_MASK1_02 0\n#define MW_CAN2_ID2_02 0\n#define MW_CAN2_MASK2_02 0\n#define MW_CAN2_ID3_02 0\n#define MW_CAN2_ID4_02 0\n#define MW_CAN2_ENABLEFILTERBANK03 0\n#define MW_CAN2_SCALE03 0\n#define MW_CAN2_MODE03 0\n#define MW_CAN2_FIFOASSIGNMENT03 0\n#define MW_CAN2_IDTYPE03 0\n#define MW_CAN2_ID1_03 0\n#define MW_CAN2_MASK1_03 0\n#define MW_CAN2_ID2_03 0\n#define MW_CAN2_MASK2_03 0\n#define MW_CAN2_ID3_03 0\n#define MW_CAN2_ID4_03 0\n#define MW_CAN2_ENABLEFILTERBANK04 0\n#define MW_CAN2_SCALE04 0\n#define MW_CAN2_MODE04 0\n#define MW_CAN2_FIFOASSIGNMENT04 0\n#define MW_CAN2_IDTYPE04 0\n#define MW_CAN2_ID1_04 0\n#define MW_CAN2_MASK1_04 0\n#define MW_CAN2_ID2_04 0\n#define MW_CAN2_MASK2_04 0\n#define MW_CAN2_ID3_04 0\n#define MW_CAN2_ID4_04 0\n#define MW_CAN2_ENABLEFILTERBANK05 0\n#define MW_CAN2_SCALE05 0\n#define MW_CAN2_MODE05 0\n#define MW_CAN2_FIFOASSIGNMENT05 0\n#define MW_CAN2_IDTYPE05 0\n#define MW_CAN2_ID1_05 0\n#define MW_CAN2_MASK1_05 0\n#define MW_CAN2_ID2_05 0\n#define MW_CAN2_MASK2_05 0\n#define MW_CAN2_ID3_05 0\n#define MW_CAN2_ID4_05 0\n#define MW_CAN2_ENABLEFILTERBANK06 0\n#define MW_CAN2_SCALE06 0\n#define MW_CAN2_MODE06 0\n#define MW_CAN2_FIFOASSIGNMENT06 0\n#define MW_CAN2_IDTYPE06 0\n#define MW_CAN2_ID1_06 0\n#define MW_CAN2_MASK1_06 0\n#define MW_CAN2_ID2_06 0\n#define MW_CAN2_MASK2_06 0\n#define MW_CAN2_ID3_06 0\n#define MW_CAN2_ID4_06 0\n#define MW_CAN2_ENABLEFILTERBANK07 0\n#define MW_CAN2_SCALE07 0\n#define MW_CAN2_MODE07 0\n#define MW_CAN2_FIFOASSIGNMENT07 0\n#define MW_CAN2_IDTYPE07 0\n#define MW_CAN2_ID1_07 0\n#define MW_CAN2_MASK1_07 0\n#define MW_CAN2_ID2_07 0\n#define MW_CAN2_MASK2_07 0\n#define MW_CAN2_ID3_07 0\n#define MW_CAN2_ID4_07 0\n#define MW_CAN2_ENABLEFILTERBANK08 0\n#define MW_CAN2_SCALE08 0\n#define MW_CAN2_MODE08 0\n#define MW_CAN2_FIFOASSIGNMENT08 0\n#define MW_CAN2_IDTYPE08 0\n#define MW_CAN2_ID1_08 0\n#define MW_CAN2_MASK1_08 0\n#define MW_CAN2_ID2_08 0\n#define MW_CAN2_MASK2_08 0\n#define MW_CAN2_ID3_08 0\n#define MW_CAN2_ID4_08 0\n#define MW_CAN2_ENABLEFILTERBANK09 0\n#define MW_CAN2_SCALE09 0\n#define MW_CAN2_MODE09 0\n#define MW_CAN2_FIFOASSIGNMENT09 0\n#define MW_CAN2_IDTYPE09 0\n#define MW_CAN2_ID1_09 0\n#define MW_CAN2_MASK1_09 0\n#define MW_CAN2_ID2_09 0\n#define MW_CAN2_MASK2_09 0\n#define MW_CAN2_ID3_09 0\n#define MW_CAN2_ID4_09 0\n#define MW_CAN2_ENABLEFILTERBANK10 0\n#define MW_CAN2_SCALE10 0\n#define MW_CAN2_MODE10 0\n#define MW_CAN2_FIFOASSIGNMENT10 0\n#define MW_CAN2_IDTYPE10 0\n#define MW_CAN2_ID1_10 0\n#define MW_CAN2_MASK1_10 0\n#define MW_CAN2_ID2_10 0\n#define MW_CAN2_MASK2_10 0\n#define MW_CAN2_ID3_10 0\n#define MW_CAN2_ID4_10 0\n#define MW_CAN2_ENABLEFILTERBANK11 0\n#define MW_CAN2_SCALE11 0\n#define MW_CAN2_MODE11 0\n#define MW_CAN2_FIFOASSIGNMENT11 0\n#define MW_CAN2_IDTYPE11 0\n#define MW_CAN2_ID1_11 0\n#define MW_CAN2_MASK1_11 0\n#define MW_CAN2_ID2_11 0\n#define MW_CAN2_MASK2_11 0\n#define MW_CAN2_ID3_11 0\n#define MW_CAN2_ID4_11 0\n#define MW_CAN2_ENABLEFILTERBANK12 0\n#define MW_CAN2_SCALE12 0\n#define MW_CAN2_MODE12 0\n#define MW_CAN2_FIFOASSIGNMENT12 0\n#define MW_CAN2_IDTYPE12 0\n#define MW_CAN2_ID1_12 0\n#define MW_CAN2_MASK1_12 0\n#define MW_CAN2_ID2_12 0\n#define MW_CAN2_MASK2_12 0\n#define MW_CAN2_ID3_12 0\n#define MW_CAN2_ID4_12 0\n#define MW_CAN2_ENABLEFILTERBANK13 0\n#define MW_CAN2_SCALE13 0\n#define MW_CAN2_MODE13 0\n#define MW_CAN2_FIFOASSIGNMENT13 0\n#define MW_CAN2_IDTYPE13 0\n#define MW_CAN2_ID1_13 0\n#define MW_CAN2_MASK1_13 0\n#define MW_CAN2_ID2_13 0\n#define MW_CAN2_MASK2_13 0\n#define MW_CAN2_ID3_13 0\n#define MW_CAN2_ID4_13 0\n#define MW_CAN3_BAUDRATE 1000000\n#define MW_CAN3_CONFIGUREINTENRX 0\n#define MW_CAN3_CONFIGUREINTFIFO0RX 0\n#define MW_CAN3_ENABLEFIFO0MSGPENDINGINTR 0\n#define MW_CAN3_ENABLEFIFO0FULLINTR 0\n#define MW_CAN3_ENABLEFIFO0OVRINTR 0\n#define MW_CAN3_CONFIGUREINTFIFO1RX 0\n#define MW_CAN3_ENABLEFIFO1MSGPENDINGINTR 0\n#define MW_CAN3_ENABLEFIFO1FULLINTR 0\n#define MW_CAN3_ENABLEFIFO1OVRINTR 0\n#define MW_CAN3_CONFIGUREINTENTX 0\n#define MW_CAN3_ENABLETXMAILBOXEMPTYINTR 0\n#define MW_CAN3_CONFIGUREINTENOTHER 0\n#define MW_CAN3_ENABLEERRWARNINTR 0\n#define MW_CAN3_ENABLEERRPASSIVEINTR 0\n#define MW_CAN3_ENABLEBUSOFFINTR 0\n#define MW_CAN3_ENABLELASTERRCODEINTR 0\n#define MW_CAN3_ENABLEWAKEUPINTR 0\n#define MW_CAN3_ENABLESLEEPACKINTR 0\n#define MW_CAN3_ACCEPTALLMESSAGES 1\n#define MW_CAN3_FILTERBANKNUMBER 0\n#define MW_CAN3_ENABLEFILTERBANK00 0\n#define MW_CAN3_SCALE00 0\n#define MW_CAN3_MODE00 0\n#define MW_CAN3_FIFOASSIGNMENT00 0\n#define MW_CAN3_IDTYPE00 0\n#define MW_CAN3_ID1_00 0\n#define MW_CAN3_MASK1_00 0\n#define MW_CAN3_ID2_00 0\n#define MW_CAN3_MASK2_00 0\n#define MW_CAN3_ID3_00 0\n#define MW_CAN3_ID4_00 0\n#define MW_CAN3_ENABLEFILTERBANK01 0\n#define MW_CAN3_SCALE01 0\n#define MW_CAN3_MODE01 0\n#define MW_CAN3_FIFOASSIGNMENT01 0\n#define MW_CAN3_IDTYPE01 0\n#define MW_CAN3_ID1_01 0\n#define MW_CAN3_MASK1_01 0\n#define MW_CAN3_ID2_01 0\n#define MW_CAN3_MASK2_01 0\n#define MW_CAN3_ID3_01 0\n#define MW_CAN3_ID4_01 0\n#define MW_CAN3_ENABLEFILTERBANK02 0\n#define MW_CAN3_SCALE02 0\n#define MW_CAN3_MODE02 0\n#define MW_CAN3_FIFOASSIGNMENT02 0\n#define MW_CAN3_IDTYPE02 0\n#define MW_CAN3_ID1_02 0\n#define MW_CAN3_MASK1_02 0\n#define MW_CAN3_ID2_02 0\n#define MW_CAN3_MASK2_02 0\n#define MW_CAN3_ID3_02 0\n#define MW_CAN3_ID4_02 0\n#define MW_CAN3_ENABLEFILTERBANK03 0\n#define MW_CAN3_SCALE03 0\n#define MW_CAN3_MODE03 0\n#define MW_CAN3_FIFOASSIGNMENT03 0\n#define MW_CAN3_IDTYPE03 0\n#define MW_CAN3_ID1_03 0\n#define MW_CAN3_MASK1_03 0\n#define MW_CAN3_ID2_03 0\n#define MW_CAN3_MASK2_03 0\n#define MW_CAN3_ID3_03 0\n#define MW_CAN3_ID4_03 0\n#define MW_CAN3_ENABLEFILTERBANK04 0\n#define MW_CAN3_SCALE04 0\n#define MW_CAN3_MODE04 0\n#define MW_CAN3_FIFOASSIGNMENT04 0\n#define MW_CAN3_IDTYPE04 0\n#define MW_CAN3_ID1_04 0\n#define MW_CAN3_MASK1_04 0\n#define MW_CAN3_ID2_04 0\n#define MW_CAN3_MASK2_04 0\n#define MW_CAN3_ID3_04 0\n#define MW_CAN3_ID4_04 0\n#define MW_CAN3_ENABLEFILTERBANK05 0\n#define MW_CAN3_SCALE05 0\n#define MW_CAN3_MODE05 0\n#define MW_CAN3_FIFOASSIGNMENT05 0\n#define MW_CAN3_IDTYPE05 0\n#define MW_CAN3_ID1_05 0\n#define MW_CAN3_MASK1_05 0\n#define MW_CAN3_ID2_05 0\n#define MW_CAN3_MASK2_05 0\n#define MW_CAN3_ID3_05 0\n#define MW_CAN3_ID4_05 0\n#define MW_CAN3_ENABLEFILTERBANK06 0\n#define MW_CAN3_SCALE06 0\n#define MW_CAN3_MODE06 0\n#define MW_CAN3_FIFOASSIGNMENT06 0\n#define MW_CAN3_IDTYPE06 0\n#define MW_CAN3_ID1_06 0\n#define MW_CAN3_MASK1_06 0\n#define MW_CAN3_ID2_06 0\n#define MW_CAN3_MASK2_06 0\n#define MW_CAN3_ID3_06 0\n#define MW_CAN3_ID4_06 0\n#define MW_CAN3_ENABLEFILTERBANK07 0\n#define MW_CAN3_SCALE07 0\n#define MW_CAN3_MODE07 0\n#define MW_CAN3_FIFOASSIGNMENT07 0\n#define MW_CAN3_IDTYPE07 0\n#define MW_CAN3_ID1_07 0\n#define MW_CAN3_MASK1_07 0\n#define MW_CAN3_ID2_07 0\n#define MW_CAN3_MASK2_07 0\n#define MW_CAN3_ID3_07 0\n#define MW_CAN3_ID4_07 0\n#define MW_CAN3_ENABLEFILTERBANK08 0\n#define MW_CAN3_SCALE08 0\n#define MW_CAN3_MODE08 0\n#define MW_CAN3_FIFOASSIGNMENT08 0\n#define MW_CAN3_IDTYPE08 0\n#define MW_CAN3_ID1_08 0\n#define MW_CAN3_MASK1_08 0\n#define MW_CAN3_ID2_08 0\n#define MW_CAN3_MASK2_08 0\n#define MW_CAN3_ID3_08 0\n#define MW_CAN3_ID4_08 0\n#define MW_CAN3_ENABLEFILTERBANK09 0\n#define MW_CAN3_SCALE09 0\n#define MW_CAN3_MODE09 0\n#define MW_CAN3_FIFOASSIGNMENT09 0\n#define MW_CAN3_IDTYPE09 0\n#define MW_CAN3_ID1_09 0\n#define MW_CAN3_MASK1_09 0\n#define MW_CAN3_ID2_09 0\n#define MW_CAN3_MASK2_09 0\n#define MW_CAN3_ID3_09 0\n#define MW_CAN3_ID4_09 0\n#define MW_CAN3_ENABLEFILTERBANK10 0\n#define MW_CAN3_SCALE10 0\n#define MW_CAN3_MODE10 0\n#define MW_CAN3_FIFOASSIGNMENT10 0\n#define MW_CAN3_IDTYPE10 0\n#define MW_CAN3_ID1_10 0\n#define MW_CAN3_MASK1_10 0\n#define MW_CAN3_ID2_10 0\n#define MW_CAN3_MASK2_10 0\n#define MW_CAN3_ID3_10 0\n#define MW_CAN3_ID4_10 0\n#define MW_CAN3_ENABLEFILTERBANK11 0\n#define MW_CAN3_SCALE11 0\n#define MW_CAN3_MODE11 0\n#define MW_CAN3_FIFOASSIGNMENT11 0\n#define MW_CAN3_IDTYPE11 0\n#define MW_CAN3_ID1_11 0\n#define MW_CAN3_MASK1_11 0\n#define MW_CAN3_ID2_11 0\n#define MW_CAN3_MASK2_11 0\n#define MW_CAN3_ID3_11 0\n#define MW_CAN3_ID4_11 0\n#define MW_CAN3_ENABLEFILTERBANK12 0\n#define MW_CAN3_SCALE12 0\n#define MW_CAN3_MODE12 0\n#define MW_CAN3_FIFOASSIGNMENT12 0\n#define MW_CAN3_IDTYPE12 0\n#define MW_CAN3_ID1_12 0\n#define MW_CAN3_MASK1_12 0\n#define MW_CAN3_ID2_12 0\n#define MW_CAN3_MASK2_12 0\n#define MW_CAN3_ID3_12 0\n#define MW_CAN3_ID4_12 0\n#define MW_CAN3_ENABLEFILTERBANK13 0\n#define MW_CAN3_SCALE13 0\n#define MW_CAN3_MODE13 0\n#define MW_CAN3_FIFOASSIGNMENT13 0\n#define MW_CAN3_IDTYPE13 0\n#define MW_CAN3_ID1_13 0\n#define MW_CAN3_MASK1_13 0\n#define MW_CAN3_ID2_13 0\n#define MW_CAN3_MASK2_13 0\n#define MW_CAN3_ID3_13 0\n#define MW_CAN3_ID4_13 0\n#define MW_MQTT_BROKERADDRESS <Enter Broker I.P. Address>\n#define MW_MQTT_PORT 1883\n#define MW_MQTT_USERNAME NULL\n#define MW_MQTT_PASSWORD NULL\n#define MW_MQTT_CID NULL\n#define MW_PIL_INTERFACE 0\n#define MW_I2S_I2SPDMFILTERCUBEMXCONFIGUREMODULE 0\n#define MW_I2S_I2S1PDMCONFIGUREMODULE 0\n#define MW_I2S_I2S1PDM_CHANNELS_1 1\n#define MW_I2S_I2S1PDM_CHANNELS_2 2\n#define MW_I2S_I2S2PDMCONFIGUREMODULE 0\n#define MW_I2S_I2S2PDM_CHANNELS_1 1\n#define MW_I2S_I2S2PDM_CHANNELS_2 2\n#define MW_I2S_I2S3PDMCONFIGUREMODULE 0\n#define MW_I2S_I2S3PDM_CHANNELS_1 1\n#define MW_I2S_I2S3PDM_CHANNELS_2 2\n#define MW_SDCLOG_ENABLELOGGING 0\n#define MW_SDCLOG_INTERFACE 0\n#define MW_SDCLOG_ENABLELOGGINGSTATUS 0\n#define MW_SDCLOG_LOGGINGSTATUSGPIOGROUP 0\n#define MW_SDCLOG_LOGGINGSTATUSGPIOPIN 1\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"CodeInstrTgtAppSvc.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\extern\\include\\coder\\connectivity\\CodeInstrTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2022 The MathWorks, Inc. */\n\n#ifndef CodeInstrTgtAppSvc_h\n#define CodeInstrTgtAppSvc_h\n\n#include \"CodeInstrTgtAppSvc_spec.h\"\n\n#include \"rtwtypes.h\"\n\n#if defined (USING_CS_API) || defined(BUILDING_LIBMWCODER_CODEINSTRTGTAPPSVC)\n       \n    typedef uint8_T IOUnit_T;   \n#else\n   \n    #include \"xilcomms_rtiostream.h\"\n#endif\n       \nstatic const boolean_T CODEINSTRTGTAPPSVC_ERROR = 0;\nstatic const boolean_T CODEINSTRTGTAPPSVC_SUCCESS = 1;\n\n#define CODEINSTR_RTIOSTREAM_BASED_SERVICE_ID 2\n             \n#endif\n"},{"name":"CodeInstrTgtAppSvc_CInterface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\extern\\include\\coder\\connectivity\\CodeInstrTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n#ifndef CodeInstrTgtAppSvc_CInterface_h\n#define CodeInstrTgtAppSvc_CInterface_h\n\n#include \"CodeInstrTgtAppSvc.h\"\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C uint8_T codeInstrTgtAppSvcCreate(void);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C void codeInstrTgtAppSvcDestroy(void);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C uint8_T codeInstrTgtAppSvcAllocBuffer(void** ppBuf,\n        const uint16_T size);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C IOUnit_T* codeInstrTgtAppSvcGetBufferDataPtr(void* pBufVoid);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C uint8_T codeInstrTgtAppSvcSend(void* pBufVoid,\n        const uint16_T payloadSize);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C uint16_T codeInstrTgtAppSvcGetMaxPayloadCapacity(void);\n\n#endif\n"},{"name":"CoderAssumpTgtAppSvc_CInterface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\extern\\include\\coder\\connectivity\\CoderAssumpTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2022 The MathWorks, Inc. */\n\n#ifndef CoderAssumpTgtAppSvc_CInterface_h\n#define CoderAssumpTgtAppSvc_CInterface_h\n\n#include \"CoderAssumpTgtAppSvc_spec.h\"\n\n#include \"rtwtypes.h\"\n\n#if defined (USING_CS_API) || defined(BUILDING_LIBMWCODER_CODERASSUMPTGTAPPSVC) \n    typedef uint8_T IOUnit_T;  \n#else\n    #include \"xilcomms_rtiostream.h\"\n#endif\n\n#define CODERASSUMP_RTIOSTREAM_BASED_SERVICE_ID 3\n\n#ifdef USE_CODERASSUMPTGTAPPSVC_ERROR\n    static const uint8_T CODERASSUMPTGTAPPSVC_ERROR = 0;\n#endif\n#ifdef USE_CODERASSUMPTGTAPPSVC_SUCCESS\n    static const uint8_T CODERASSUMPTGTAPPSVC_SUCCESS = 1;\n#endif\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcCreate(void);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C void coderAssumpTgtAppSvcDestroy(void);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcAllocBuffer(void** ppBuf,\n        const uint16_T size);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C IOUnit_T* coderAssumpTgtAppSvcGetBufferDataPtr(void* pBufVoid);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcSend(void* pBufVoid,\n        const uint16_T payloadSize);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint16_T coderAssumpTgtAppSvcGetMaxPayloadCapacity(void);\n\n#endif\n"},{"name":"XILTgtAppSvc.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\extern\\include\\coder\\connectivity\\XILTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2022 The MathWorks, Inc. */\n\n#ifndef XILTgtAppSvc_h\n#define XILTgtAppSvc_h\n\n#include \"XILTgtAppSvc_spec.h\"\n\n#include \"rtwtypes.h\"\n\n#if defined (USING_CS_API) || defined(BUILDING_LIBMWCODER_XILTGTAPPSVC)\n       \n    typedef uint8_T IOUnit_T;   \n#else\n   \n    #include \"xilcomms_rtiostream.h\"\n#endif\n       \n#ifdef USE_XILTGTAPPSVC_ERROR\n    static const boolean_T XILTGTAPPSVC_ERROR = 0;\n#endif\n#ifdef USE_XILTGTAPPSVC_SUCCESS\n    static const boolean_T XILTGTAPPSVC_SUCCESS = 1;\n#endif\n\n#define XIL_RTIOSTREAM_BASED_SERVICE_ID 1\ntypedef enum {XIL_COMMAND_NOT_COMPLETE=0,\n              XIL_COMMAND_COMPLETE,\n              XIL_STEP_COMPLETE} XILCommandResponseType;\n             \n#endif\n"},{"name":"XILTgtAppSvc_CInterface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\extern\\include\\coder\\connectivity\\XILTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n#ifndef XILTgtAppSvc_CInterface_h\n#define XILTgtAppSvc_CInterface_h\n\n#include \"XILTgtAppSvc.h\"\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcCreate(void);\n\nXILTGTAPPSVC_API_EXTERN_C void xilTgtAppSvcDestroy(void);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T* xilTgtAppSvcGetReceivedData(uint16_T* size);\n\nXILTGTAPPSVC_API_EXTERN_C void xilTgtAppSvcFreeLastReceivedData(void);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcAllocBuffer(void** ppBuf,\n        const uint16_T size);\n\nXILTGTAPPSVC_API_EXTERN_C IOUnit_T* xilTgtAppSvcGetBufferDataPtr(void* pBufVoid);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcSend(void* pBufVoid,\n        const uint16_T payloadSize);\n\nXILTGTAPPSVC_API_EXTERN_C uint16_T xilTgtAppSvcGetMaxPayloadCapacity(void);\n\n#endif\n"},{"name":"codeinstr_data_stream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2007-2015 The MathWorks, Inc. */\n\n#include \"codeinstr_data_stream.h\"\n#include \"xil_interface_lib.h\"\n#include \"CodeInstrTgtAppSvc_CInterface.h\"\n\n#ifdef USING_CS_API    \n    #define CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE codeInstrTgtAppSvcGetMaxPayloadCapacity()\n    #define BUFFER_HEADER_SIZE 0    \n#else\n    #include \"rx_tx_buffer_sizes.h\"    \n#endif\n\n#define COMMAND_COMPLETE_SIZE (sizeof(MemUnit_T))\n#define COMMAND_COMPLETE_IDX 0\n#define WRITE_DATA_BUFFER_IDX (COMMAND_COMPLETE_IDX + COMMAND_COMPLETE_SIZE)\n#define USED_WRITE_BUFFER_SIZE (COMMAND_COMPLETE_SIZE + codeInstrWriteDataAvail)\n#define WRITE_BUFFER_SIZE (CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE - COMMAND_COMPLETE_SIZE - BUFFER_HEADER_SIZE)\n\nstatic void* pBuffer;\nstatic IOUnit_T* codeInstrWriteBuffer;\nstatic IOUnit_T* codeInstrWriteDataPtr;\nstatic uint16_T codeInstrWriteDataAvail;\nstatic MemUnit_T* commandComplete;\n\n/* reset the write buffer */\nstatic XIL_INTERFACE_LIB_ERROR_CODE resetCodeInstrWriteBuffer(void) {\n    \n    /* Ask the CS to allocate a buffer that the CodeInstr app service will \n     * use for transmission\n     */\n    if (!codeInstrTgtAppSvcAllocBuffer(&pBuffer, CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE)) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    codeInstrWriteBuffer = codeInstrTgtAppSvcGetBufferDataPtr(pBuffer);\n    \n    /* set commandComplete and codeInstrWriteDataPtr pointer */\n    commandComplete = (MemUnit_T *) &codeInstrWriteBuffer[COMMAND_COMPLETE_IDX];\n    codeInstrWriteDataPtr = &codeInstrWriteBuffer[WRITE_DATA_BUFFER_IDX];\n    \n    /* ready for next command */\n    codeInstrWriteDataAvail = 0;\n    *commandComplete = 0;\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\nXIL_INTERFACE_LIB_ERROR_CODE codeInstrInit(void) {\n    /* Create code instrumentation app service */\n    if (codeInstrTgtAppSvcCreate() != CODEINSTRTGTAPPSVC_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    /* Reset write buffer */\n    return resetCodeInstrWriteBuffer();\n}\n\nvoid codeInstrTerminate(void) {\n    codeInstrTgtAppSvcDestroy();\n}\n\n/* send pending writes */\nstatic XIL_DATA_STREAM_ERROR_CODE sendWriteBuffer(void) {\n   /* send */\n   if (codeInstrTgtAppSvcSend(pBuffer, USED_WRITE_BUFFER_SIZE) == CODEINSTRTGTAPPSVC_ERROR) {             \n      return XIL_DATA_FLUSH_ERROR;\n   }   \n   \n   /* reset */\n   if (resetCodeInstrWriteBuffer()!= XIL_INTERFACE_LIB_SUCCESS) {\n\t   return XIL_DATA_FLUSH_ERROR;\n   }\n   \n   return XIL_DATA_STREAM_SUCCESS;\n}\n\n\nXIL_DATA_STREAM_ERROR_CODE codeInstrWriteData(const MemUnit_T * src, uint32_T size) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   const IOUnit_T * srcPtr = (const IOUnit_T *) src;   \n   size_t transferAmount;\n   uint16_T bufferAvail;\n  \n   /* block until all data is processed */\n   while (size > 0) {      \n      /* send if we have a full message worth of data */   \n      if (codeInstrWriteDataAvail == WRITE_BUFFER_SIZE) {\n         errorCode = sendWriteBuffer();\n         if (errorCode != XIL_DATA_STREAM_SUCCESS) {\n            return errorCode;\n         }\n      }\n      bufferAvail = WRITE_BUFFER_SIZE - codeInstrWriteDataAvail;\n      transferAmount = (uint16_T) MIN(bufferAvail, size);\n      /* copy data into write buffer */\n      memcpy((void *) codeInstrWriteDataPtr, srcPtr, transferAmount);\n      size -= (uint32_T) transferAmount;\n      codeInstrWriteDataAvail += (uint16_T) transferAmount;\n      srcPtr += transferAmount;\n      codeInstrWriteDataPtr += transferAmount;\n   }\n   return errorCode;\n}\n\n\nXIL_DATA_STREAM_ERROR_CODE codeInstrDataFlush(void) {   \n\n    /* final part of command */\n    *commandComplete = 1;\n\n    /* send the write buffer */\n    if (sendWriteBuffer() == XIL_DATA_FLUSH_ERROR){\n        return XIL_DATA_FLUSH_ERROR;\n    }\n    \n    return XIL_DATA_STREAM_SUCCESS;\n\n}\n"},{"name":"codeinstr_data_stream.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n/* \n * File: codeInstr_data_stream.h\n *\n */\t\t\t\t\t \n\n/* need error codes */\n#include \"xil_interface_lib.h\"\n\n/* initialize code instrumentation service */\nextern XIL_INTERFACE_LIB_ERROR_CODE codeInstrInit(void);\n/* terminate code instrumentation service */\nextern void codeInstrTerminate(void);\n/* copy specified amount of data from the address specified to the output stream */\nextern XIL_DATA_STREAM_ERROR_CODE codeInstrWriteData(const MemUnit_T *, uint32_T);\n/* flush any buffered writes */\nextern XIL_DATA_STREAM_ERROR_CODE codeInstrDataFlush(void);\n"},{"name":"codeinstr_rtiostream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"CodeInstrTgtAppSvc_CInterface.h\"\n\n/* code instrumentation buffer is statically allocated for rtiostream-based implementation */\nstatic IOUnit_T codeInstrWriteBuffer[CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE];\n\nextern uint8_T codeInstrTgtAppSvcCreate(void) {\n    return CODEINSTRTGTAPPSVC_SUCCESS;\n}\n\nextern void codeInstrTgtAppSvcDestroy(void) {\n}\n\n/* Allocation method simply returns the statically allocated buffer */\nextern uint8_T codeInstrTgtAppSvcAllocBuffer(\n        void** ppBuf,\n        const uint16_T dataSize) {\n    \n    /* buffer is already statically allocated */\n    *ppBuf = &codeInstrWriteBuffer[APPLICATION_ID_IDX];\n    \n    UNUSED_PARAMETER(dataSize);\n    \n    /* nothing to do as buffer is already statically allocated */\n    return CODEINSTRTGTAPPSVC_SUCCESS;\n}\n\n/* return pointer to the code instrumentation buffer data */\nextern IOUnit_T * codeInstrTgtAppSvcGetBufferDataPtr(\n        void* const pBuf) {\n    \n    /* buffer is already statically allocated */\n    UNUSED_PARAMETER(pBuf);\n       \n    return &codeInstrWriteBuffer[PAYLOAD_IDX];\n}\n\n/* send data over rtiostream */\nextern uint8_T codeInstrTgtAppSvcSend(\n        void* const pBuf,        \n        const uint16_T dataSize) {\n    \n    return (uint8_T)commsEnqueueBuffer(pBuf, CODEINSTR_RTIOSTREAM_BASED_SERVICE_ID, dataSize);\n}\n\n"},{"name":"coder_assumptions_app.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#include \"coder_assumptions_app.h\"\n#include \"coder_assumptions_data_stream.h\"\n#include \"xil_interface_lib.h\"\n\n/*\n * Include coder_assumptions.h for Hardware Implementation setting\n * preprocessor validation checks.\n * These checks verify fundamental data types that the comms \n * stack relies on, e.g. uint8_T, uint16_T, uint32_T.\n *\n * Also access the global results variables and the entry point\n * function for running coder assumptions tests.\n */\n#include \"coder_assumptions.h\" \n\n/* combine arguments (after expanding arguments) */\n#define CA_EXP_CONCAT(a,b) CA_CONCAT(a,b)\n#define CA_CONCAT(a,b) a ## b\n\n/* Compile time static assert for checking fundamental assumptions such \n * as sizeof values for specific data types. */\n#define CA_STATIC_ASSERT(expr, msg) typedef char CA_EXP_CONCAT(assert_failed__, msg) [(expr) ? (+1) : (-1)]\n\n#define CA_RETURN_IF_ERROR(errCode) if((errCode) != XIL_DATA_STREAM_SUCCESS) return (errCode)\n\n#include \"coder_assumptions_hwimpl.h\"\n\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* MemUnit_T can be any of uint8_T, uint16_T, uint32_T\n    * Just check it is consistent with MEM_UNIT_BYTES */\n   CA_STATIC_ASSERT(sizeof(MemUnit_T) == MEM_UNIT_BYTES, INVALID_MEMUNIT_T);\n#else\n   /* Verify MemUnit_T: sizeof must be 1 */\n   CA_STATIC_ASSERT(sizeof(MemUnit_T) == 1, MEMUNIT_T_NOT_SIZEOF_1);\n   /* Verify MEM_UNIT_BYTES: must match the size of the largest integer that has sizeof == 1 \n    * Only word addressable targets up to 32-bits are supported. */\n   CA_STATIC_ASSERT((sizeof(uint32_T) == 1) ? MEM_UNIT_BYTES == 4 : \n                 (sizeof(uint16_T) == 1) ? MEM_UNIT_BYTES == 2 :\n                 (sizeof(uint8_T) == 1) ? MEM_UNIT_BYTES == 1 : 0, INVALID_MEM_UNIT_BYTES);\n#endif\n                 \n#include \"coder_assumptions_shared_enums.h\"\n\nstatic MemUnit_T pwsEnabled;\n\n\nstatic XIL_DATA_STREAM_ERROR_CODE sendResult(const CA_TestResult result, \n                                             const MemUnit_T resultType, \n                                             const MemUnit_T actual, \n                                             const MemUnit_T assumed) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode;\n   MemUnit_T tmp;\n   /* send result type */\n   errorCode = coderAssumptionsWriteData(&resultType, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send result status */\n   tmp = (MemUnit_T) result.status;\n   errorCode = coderAssumptionsWriteData(&tmp, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* send result msg id */\n   tmp = (MemUnit_T) result.msg;\n   errorCode = coderAssumptionsWriteData(&tmp, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send actual */\n   errorCode = coderAssumptionsWriteData(&actual, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send assumed */\n   errorCode = coderAssumptionsWriteData(&assumed, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* final return */\n   return errorCode;\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE transmitMemUnitBytes(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode; \n   const MemUnit_T memUnitBytes = MEM_UNIT_BYTES;\n\n   /* send memUnitBytes */\n   errorCode = coderAssumptionsWriteData(&memUnitBytes, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n    \n   errorCode = coderAssumptionsSendWriteBuffer();  \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   return errorCode;\n}\n\n/* portable word sizes specified checks */\nstatic XIL_DATA_STREAM_ERROR_CODE sendPWS(void) {\n    XIL_DATA_STREAM_ERROR_CODE errorCode; \n    MemUnit_T commandId;  \n   \n    /* send CA_PWS */\n    commandId = CA_PWS;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n    \n    /* PWS enabled in build */\n    commandId = CA_PWS_ENABLED;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n    pwsEnabled = (MemUnit_T) CA_Actual_HWImpl.portableWordSizes;\n    errorCode = coderAssumptionsWriteData(&pwsEnabled, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* extended PWS checks */\n    if (pwsEnabled) {\n       /* config setting mismatch */\n       errorCode = sendResult(CA_PortableWordSizes_Results.configSetting, \n                                    (MemUnit_T) CA_PWS_CONFIG_SETTING,  \n                                    (MemUnit_T) CA_Actual_HWImpl.portableWordSizes, \n                                    (MemUnit_T) CA_Expected_HWImpl.portableWordSizes);\n       CA_RETURN_IF_ERROR(errorCode);\n    }\n\n\n    errorCode = coderAssumptionsSendWriteBuffer();  \n    CA_RETURN_IF_ERROR(errorCode);\n\n    return errorCode;\n}\n\n/* hardware implementation checks message 1 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl1(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;    \n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_1 */    \n   commandId = CA_HW_IMPL_SIZES_1;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per char */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerChar, \n         (MemUnit_T) CA_HW_IMPL_BIT_CHAR,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerChar, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerChar);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per short */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerShort, \n         (MemUnit_T) CA_HW_IMPL_BIT_SHORT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerShort, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerShort);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per int */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerInt, \n         (MemUnit_T) CA_HW_IMPL_BIT_INT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerInt, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerInt);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per long */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerLong, \n         (MemUnit_T) CA_HW_IMPL_BIT_LONG,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerLong, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation checks message 2 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl2(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n   \n   /* send CA_HW_IMPL_SIZES_2 */    \n   commandId = CA_HW_IMPL_SIZES_2;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* support long long */\n   errorCode = sendResult(CA_HWImpl_Results.supportLongLong, \n         (MemUnit_T) CA_HW_IMPL_SUPPORT_LONGLONG,  \n         (MemUnit_T) CA_Actual_HWImpl.supportLongLong, \n         (MemUnit_T) CA_Expected_HWImpl.supportLongLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per long long */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerLongLong, \n         (MemUnit_T) CA_HW_IMPL_BIT_LONGLONG,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerLongLong, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerLongLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per float */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerFloat, \n         (MemUnit_T) CA_HW_IMPL_BIT_FLOAT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerFloat, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerFloat);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per double */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerDouble, \n         (MemUnit_T) CA_HW_IMPL_BIT_DOUBLE,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerDouble, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerDouble);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation checks message 3 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl3(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_3 */    \n   commandId = CA_HW_IMPL_SIZES_3;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per pointer */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerPointer, \n         (MemUnit_T) CA_HW_IMPL_BIT_POINTER,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerPointer, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerPointer);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per size_t */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerSizeT, \n         (MemUnit_T) CA_HW_IMPL_BIT_SIZE_T,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerSizeT, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerSizeT);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per ptrdiff_t */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerPtrDiffT, \n         (MemUnit_T) CA_HW_IMPL_BIT_PTRDIFF_T,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerPtrDiffT, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerPtrDiffT);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n\n/* hardware implementation checks message 4 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl4(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_4 */\n   commandId = CA_HW_IMPL_SIZES_4;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* byte order */\n   errorCode = sendResult(CA_HWImpl_Results.byteOrder, \n         (MemUnit_T) CA_HW_IMPL_BYTE_ORDER,  \n         (MemUnit_T) CA_Actual_HWImpl.byteOrder, \n         (MemUnit_T) CA_Expected_HWImpl.byteOrder);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* integer division rounding */\n   errorCode = sendResult(CA_HWImpl_Results.intDivRoundTo, \n         (MemUnit_T) CA_HW_IMPL_INT_DIV_ROUND,  \n         (MemUnit_T) CA_Actual_HWImpl.intDivRoundTo, \n         (MemUnit_T) CA_Expected_HWImpl.intDivRoundTo);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* shift right on a signed integer */\n   errorCode = sendResult(CA_HWImpl_Results.shiftRightBehavior, \n         (MemUnit_T) CA_HW_IMPL_SHIFT_RIGHT,  \n         (MemUnit_T) CA_Actual_HWImpl.shiftRightBehavior, \n         (MemUnit_T) CA_Expected_HWImpl.shiftRightBehavior);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation, checks unrelated to sizes */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHardwareChecks(void){\n    XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n    MemUnit_T commandId;\n\n    commandId = CA_CHECKS_1;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n   /* memory at startup */\n   errorCode = sendResult(CA_HWImpl_Results.memoryAtStartup,\n         (MemUnit_T) CA_HW_IMPL_MEMORY_STARTUP,\n         (MemUnit_T) CA_Actual_HWImpl.memoryAtStartup,\n         (MemUnit_T) CA_Expected_HWImpl.memoryAtStartup);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* dynamic memory at startup */\n   errorCode = sendResult(CA_HWImpl_Results.dynamicMemoryAtStartup,\n         (MemUnit_T) CA_HW_IMPL_DYNAMIC_MEMORY,\n         (MemUnit_T) CA_Actual_HWImpl.dynamicMemoryAtStartup,\n         (MemUnit_T) CA_Expected_HWImpl.dynamicMemoryAtStartup);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* denormal flush to zero */\n   errorCode = sendResult(CA_HWImpl_Results.denormalFlushToZero,\n         (MemUnit_T) CA_HW_IMPL_DENORMAL_FTZ,\n         (MemUnit_T) CA_Actual_HWImpl.denormalFlushToZero,\n         (MemUnit_T) CA_Expected_HWImpl.denormalFlushToZero);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* denormal as zero */\n   errorCode = sendResult(CA_HWImpl_Results.denormalAsZero,\n         (MemUnit_T) CA_HW_IMPL_DENORMAL_DAZ,\n         (MemUnit_T) CA_Actual_HWImpl.denormalAsZero,\n         (MemUnit_T) CA_Expected_HWImpl.denormalAsZero);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE runChecks(void) {\n    XIL_DATA_STREAM_ERROR_CODE errorCode;\n    MemUnit_T endTransmission = CA_END_TRANSMIT;\n\n     /* first, run the coder assumptions checks */\n    CA_Run_Tests();\n\n    /* now send the results to the host */\n    errorCode = transmitMemUnitBytes();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    errorCode = sendPWS();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    errorCode = sendHWImpl1();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl2();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl3();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl4();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* send results of miscellaneous checks */\n    errorCode = sendHardwareChecks();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* let host know all tests have completed */\n    errorCode = coderAssumptionsWriteData(&endTransmission, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = coderAssumptionsSendWriteBuffer();\n    \n    /* final return */\n    return errorCode;\n}\n\n\n/* \n * XIL interface entry points \n *\n */\nXIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsRun(void) {\n   if (runChecks() != XIL_DATA_STREAM_SUCCESS) {\n      return XIL_INTERFACE_LIB_ERROR;\n   }\n   else {\n      return XIL_INTERFACE_LIB_SUCCESS;\n   }\n}\n"},{"name":"coder_assumptions_app.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015 The MathWorks, Inc. */\n\n/* \n * File: coder_assumptions_app.h\n *\n */\t\t\t\t\t \n\n#include \"xil_error_codes.h\"\n\nextern XIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsRun(void);\n"},{"name":"coder_assumptions_data_stream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#define USE_CODERASSUMPTGTAPPSVC_ERROR\n#define USE_CODERASSUMPTGTAPPSVC_SUCCESS\n#include \"coder_assumptions_data_stream.h\"\n#include \"xil_interface_lib.h\"\n#include \"CoderAssumpTgtAppSvc_CInterface.h\"\n\n#ifdef USING_CS_API    \n   #define CA_TX_BUFFER_MEMUNIT_SIZE coderAssumpTgtAppSvcGetMaxPayloadCapacity()\n   #define BUFFER_HEADER_SIZE 0    \n#else\n   #include \"rx_tx_buffer_sizes.h\"    \n#endif\n\nstatic void* pBuffer;\nstatic IOUnit_T* coderAssumptionsWriteDataPtr;\nstatic uint16_T coderAssumptionsWriteDataAvail;\n\nXIL_DATA_STREAM_ERROR_CODE coderAssumptionsWriteData(const void * src, const size_t size) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n\n   const size_t WRITE_BUFFER_SIZE = CA_TX_BUFFER_MEMUNIT_SIZE - BUFFER_HEADER_SIZE;\n   size_t sizeToTransfer = size;\n\n   /* check to see if buffer will overflow */\n   if ((coderAssumptionsWriteDataAvail + sizeToTransfer) > WRITE_BUFFER_SIZE) {\n      errorCode = XIL_WRITE_DATA_ERROR;\n      return errorCode;\n   }\n\n   /* copy data into write buffer */\n   memcpy((void *) coderAssumptionsWriteDataPtr, src, sizeToTransfer);\n   coderAssumptionsWriteDataAvail += (uint16_T) sizeToTransfer;\n   coderAssumptionsWriteDataPtr += sizeToTransfer;\n\n   return errorCode;\n}\n\n\n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetCoderAssumptionsWriteBuffer(void) {\n    \n    /* Ask the CS to allocate a buffer that the app will \n     * use for transmission\n     */\n    if (!coderAssumpTgtAppSvcAllocBuffer(&pBuffer, CA_TX_BUFFER_MEMUNIT_SIZE)) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    /* set coderAssumptionsWriteDataPtr pointer */\n    coderAssumptionsWriteDataPtr = coderAssumpTgtAppSvcGetBufferDataPtr(pBuffer); \n    \n    /* ready for next command */\n    coderAssumptionsWriteDataAvail = 0;\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* send pending writes */\nXIL_DATA_STREAM_ERROR_CODE coderAssumptionsSendWriteBuffer(void) {\n   /* send */\n   if (coderAssumpTgtAppSvcSend(pBuffer, coderAssumptionsWriteDataAvail) == CODERASSUMPTGTAPPSVC_ERROR) {             \n      return XIL_WRITE_DATA_ERROR;\n   }   \n   \n   /* reset */\n   if (resetCoderAssumptionsWriteBuffer()!= XIL_INTERFACE_LIB_SUCCESS) {\n\t   return XIL_WRITE_DATA_ERROR;\n   }\n   \n   return XIL_DATA_STREAM_SUCCESS;\n}\n\nXIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsInit(void) {    \n    /* Create coder assumptions app service */\n    if (coderAssumpTgtAppSvcCreate() != CODERASSUMPTGTAPPSVC_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n\n   /* Reset write buffer */\n   return resetCoderAssumptionsWriteBuffer();\n}\n\nvoid coderAssumptionsTerminate(void) {      \n   coderAssumpTgtAppSvcDestroy();\n}\n"},{"name":"coder_assumptions_data_stream.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2017 The MathWorks, Inc. */\n\n/* \n * File: coder_assumptions_data_stream.h\n *\n */\t\t\t\t\t \n\n#include \"xil_error_codes.h\"\n#include <stddef.h>\n\nextern XIL_DATA_STREAM_ERROR_CODE coderAssumptionsWriteData(const void * src, const size_t size);\nextern XIL_DATA_STREAM_ERROR_CODE coderAssumptionsSendWriteBuffer(void);\nextern XIL_INTERFACE_LIB_ERROR_CODE resetCoderAssumptionsWriteBuffer(void);\nextern XIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsInit(void);\nextern void coderAssumptionsTerminate(void);\n"},{"name":"coder_assumptions_rtiostream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_CODERASSUMPTGTAPPSVC_SUCCESS\n\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"CoderAssumpTgtAppSvc_CInterface.h\"\n\n/* coder assumptions buffer is statically allocated for rtiostream-based implementation */\nstatic IOUnit_T coderAssumpWriteBuffer[CA_TX_BUFFER_MEMUNIT_SIZE];\n\nextern uint8_T coderAssumpTgtAppSvcCreate(void) {\n    return CODERASSUMPTGTAPPSVC_SUCCESS;\n}\n\nextern void coderAssumpTgtAppSvcDestroy(void) {\n}\n\n/* Allocation method simply returns the statically allocated buffer */\nextern uint8_T coderAssumpTgtAppSvcAllocBuffer(\n        void** ppBuf,\n        const uint16_T dataSize) {\n    \n    /* buffer is already statically allocated */\n    *ppBuf = &coderAssumpWriteBuffer[APPLICATION_ID_IDX];\n    \n    UNUSED_PARAMETER(dataSize);\n    \n    /* nothing to do as buffer is already statically allocated */\n    return CODERASSUMPTGTAPPSVC_SUCCESS;\n}\n\n/* return pointer to the coder assumptions buffer data */\nextern IOUnit_T * coderAssumpTgtAppSvcGetBufferDataPtr(\n        void* const pBuf) {\n    \n    /* buffer is already statically allocated */\n    UNUSED_PARAMETER(pBuf);\n       \n    return &coderAssumpWriteBuffer[PAYLOAD_IDX];\n}\n\n/* send data over rtiostream */\nextern uint8_T coderAssumpTgtAppSvcSend(\n        void* const pBuf,        \n        const uint16_T dataSize) {\n    \n    return (uint8_T)commsEnqueueBuffer(pBuf, CODERASSUMP_RTIOSTREAM_BASED_SERVICE_ID, dataSize);\n}\n\n"},{"name":"coder_assumptions_shared_enums.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2017-2020 The MathWorks, Inc. */\n\n#ifndef __CODER_ASSUMPTIONS_SHARED_ENUMS_H__\n#define __CODER_ASSUMPTIONS_SHARED_ENUMS_H__\n\ntypedef enum {\n   CA_LITTLE_ENDIAN = 0, \n   CA_BIG_ENDIAN, \n   CA_UNSPECIFIED,\n   CA_UNABLE_TO_DETERMINE_ON_TARGET\n} CA_EndianessValue;\n\ntypedef enum {\n   CA_FLOOR = 0,\n   CA_ZERO, \n   CA_UNDEFINED\n} CA_IntDivRoundToValue;\n\ntypedef enum {\n   CA_NOT_RUN = 0,\n   CA_FAIL,\n   CA_PASS, \n   CA_WARN,\n   CA_INFO,\n   CA_SKIP\n} CA_TestResultStatus;\n\ntypedef enum {\n   CA_NO_MSG = 0,\n   CA_WARN_INT_DIV_UNDEFINED,\n   CA_WARN_BYTE_ORDER_UNSPECIFIED,\n   CA_ERROR_PWS_CONFIG_SETTING\n} CA_TestResultMsgId;\n\ntypedef enum {\n   CA_HW_IMPL_SIZES_1=0,\n   CA_HW_IMPL_SIZES_2, \n   CA_HW_IMPL_SIZES_3,\n   CA_HW_IMPL_SIZES_4,\n   CA_CHECKS_1,     /* Results of checks unrelated to hardware sizes. */\n   CA_PWS,\n   CA_END_TRANSMIT  /* Sent when CA transmissions have finished. */\n} CODERASSUMPTIONS_COMMAND;\n\ntypedef enum {\n   CA_HW_IMPL_BIT_CHAR = 0,\n   CA_HW_IMPL_BIT_SHORT,\n   CA_HW_IMPL_BIT_INT, \n   CA_HW_IMPL_BIT_LONG, \n   CA_HW_IMPL_BIT_LONGLONG, \n   CA_HW_IMPL_BIT_FLOAT, \n   CA_HW_IMPL_BIT_DOUBLE, \n   CA_HW_IMPL_BIT_POINTER, \n   CA_HW_IMPL_BIT_SIZE_T, \n   CA_HW_IMPL_BIT_PTRDIFF_T, \n   CA_HW_IMPL_SUPPORT_LONGLONG,\n   CA_HW_IMPL_SHIFT_RIGHT,\n   CA_HW_IMPL_INT_DIV_ROUND,\n   CA_HW_IMPL_BYTE_ORDER,\n   CA_HW_IMPL_MEMORY_STARTUP,\n   CA_HW_IMPL_DYNAMIC_MEMORY,\n   CA_HW_IMPL_DENORMAL_FTZ,\n   CA_HW_IMPL_DENORMAL_DAZ\n} CA_HW_IMPL_RESULT;\n\ntypedef enum {\n   CA_PWS_ENABLED = 0,\n   CA_PWS_CONFIG_SETTING\n} CA_PWS_RESULT;\n\n#endif\n\n"},{"name":"comms_interface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n#ifndef comms_interface_h\n#define comms_interface_h\n\n/* error codes */\n#ifdef USE_COMMS_ERROR\n    static const int COMMS_ERROR = 0;\n#endif\n#ifdef USE_COMMS_SUCCESS\n    static const int COMMS_SUCCESS = 1;\n#endif\n\n/* initialize comm service */\nextern int commsInit(const int argc, void * argv[]);\n\n/* terminate comm service */\nextern int commsTerminate(void);\n\n#endif\n"},{"name":"ctrl_ez_psf.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\pil","tag":"In-the-Loop:Host","groupDisplay":"SIL/PIL files","code":"/*\r\n * ctrl_ez_psf.c\r\n *\r\n * Automatically generated s-function with I/O interface for:\r\n * Component: ctrl_ez\r\n * Component Simulink Path: ctrl_ez\r\n * Simulation Mode: PIL\r\n *\r\n */\r\n\r\n#define S_FUNCTION_NAME                ctrl_ez_psf\r\n#define S_FUNCTION_LEVEL               2\r\n#if !defined(RTW_GENERATED_S_FUNCTION)\r\n#define RTW_GENERATED_S_FUNCTION\r\n#endif\r\n\r\n#define S_FUNCTION_EXPORTS_FUNCTION_CALLS\r\n#define MODELREF_EXPORTS_FUNCTION_CALLS\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"simstruc.h\"\r\n#include \"simtarget/slMdlrefSimTargetCoreHeaders.h\"\r\n#include \"simtarget/slMdlrefSimTargetInstrumentationHeaders.h\"\r\n#include \"fixedpoint.h\"\r\n#include \"coder/connectivity_core/xilutils/xilutils.h\"\r\n#include \"coder/simulinkcoder/xilutils_sl/xilutils_sl.h\"\r\n#include \"rtiostream_utils.h\"\r\n#include \"coder/connectivity/xilcomms_rtiostream/xilcomms_rtiostream.h\"\r\n#include \"coder/connectivity/XILHostAppSvc/XILHostAppSvc_CInterface.h\"\r\n#include \"messages/slMessagesSfcnBridge.h\"\r\n#include \"mwstringutil.h\"\r\n#include \"coder/connectivity/CodeInstrHostAppSvc/CodeInstrHostAppSvc_CInterface.h\"\r\n#include \"coder/connectivity/CoderAssumpHostAppSvc/CoderAssumpHostAppSvc_CInterface.h\"\r\n\r\nstatic real_T rtInf;\r\nstatic real_T rtMinusInf;\r\n\r\n/* Response case labels */\r\nenum ResponseIDs {\r\n  RESPONSE_ERROR = 0,\r\n  RESPONSE_OUTPUT_PRE_DATA = 1,\r\n  RESPONSE_OUTPUT_DATA = 2,\r\n  RESPONSE_PRINTF = 3,\r\n  RESPONSE_FOPEN = 4,\r\n  RESPONSE_FPRINTF = 5,\r\n  RESPONSE_SIGNAL_RAISED = 6,\r\n  RESPONSE_EXCEPTION = 7\r\n};\r\n\r\ntypedef struct {\r\n  FILE ** Fd;\r\n  mwSize size;\r\n  int32_T fidOffset;\r\n} targetIOFd_T;\r\n\r\ntypedef enum {\r\n  XIL_INIT_COMMAND = 0,\r\n  XIL_INITIALIZE_COMMAND,\r\n  XIL_SYSTEM_INITIALIZE_COMMAND,\r\n  XIL_OUTPUT_COMMAND,\r\n  XIL_TERMINATE_COMMAND,\r\n  XIL_ENABLE_COMMAND,\r\n  XIL_DISABLE_COMMAND,\r\n  XIL_CONST_OUTPUT_COMMAND,\r\n  XIL_PROCESS_PARAMS_COMMAND,\r\n  XIL_CLIENT_SERVER_COMMAND,\r\n  XIL_SHUTDOWN_COMMAND,\r\n  XIL_UPDATE_COMMAND,\r\n  XIL_SYSTEM_RESET_COMMAND,\r\n  XIL_PAUSE_COMMAND\r\n}\r\n  XIL_COMMAND_TYPE_ENUM;\r\n\r\nstatic RegMdlInfo rtMdlInfo_ctrl_ez[1] = { \"\", MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT,\r\n  0, 0, NULL };\r\n\r\nstatic char * getSimulinkBlockPath(SimStruct *S)\r\n{\r\n  char * simulinkBlockPath = NULL;\r\n  const char * origBlockPath = ssGetPath(S);\r\n  const char * searchString = \"TmpSFcnForModelReference_\";\r\n  const char * searchPtr;\r\n  size_t origLength, searchAndNameLength, copyAmount;\r\n  char * secondPart;\r\n  size_t nameLength;\r\n  origLength = strlen(origBlockPath);\r\n  searchPtr = strstr(origBlockPath, searchString);\r\n  if (searchPtr == NULL) {\r\n    return simulinkBlockPath;\r\n  }\r\n\r\n  searchAndNameLength = strlen(searchPtr);\r\n  copyAmount = origLength - searchAndNameLength;\r\n  simulinkBlockPath = (char *) mxCalloc((mwSize) (origLength + 1), sizeof(char));\r\n  simulinkBlockPath = strncpy(simulinkBlockPath, origBlockPath, copyAmount);\r\n  simulinkBlockPath[copyAmount] = '\\0';\r\n  nameLength = searchAndNameLength - strlen(searchString);\r\n  secondPart = &simulinkBlockPath[copyAmount];\r\n  secondPart = strncpy(secondPart, &origBlockPath[origLength - nameLength],\r\n                       nameLength);\r\n  secondPart[nameLength] = '\\0';\r\n  return simulinkBlockPath;\r\n}\r\n\r\nstatic void callStopHookAndFreeSFcnMemory(SimStruct *S);\r\nstatic void mdlTerminate(SimStruct *S);\r\nstatic void xilThrowException(void* pXILUtils);\r\n\r\n/* grow the buffer for target I/O Fd array\r\n * targetIOFd->Fd is NULL on failure */\r\nstatic void growTargetIOFd(SimStruct *S, targetIOFd_T * IOFd, mwSize\r\n  requiredSize)\r\n{\r\n  if (IOFd->size < requiredSize) {\r\n    IOFd->Fd = (FILE**)mxRealloc(IOFd->Fd, requiredSize * sizeof(FILE*));\r\n    if (IOFd->Fd == NULL) {\r\n      ssSetErrorStatus( S,\"growTargetIOFd: mxRealloc failed.\");\r\n    } else {\r\n      mexMakeMemoryPersistent(IOFd->Fd);\r\n      IOFd->size = requiredSize;\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic void closeAndFreeTargetIOFd(SimStruct *S)\r\n{\r\n  int i;\r\n  if (ssGetPWork(S) != NULL) {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n    if (targetIOFdPtr != NULL) {\r\n      if (targetIOFdPtr->Fd != NULL) {\r\n        for (i=0; i<targetIOFdPtr->size; i++) {\r\n          if (targetIOFdPtr->Fd[i] != NULL) {\r\n            fclose(targetIOFdPtr->Fd[i]);\r\n          }                            /* if */\r\n        }                              /* for */\r\n\r\n        mxFree(targetIOFdPtr->Fd);\r\n      }                                /* if */\r\n\r\n      mxFree(targetIOFdPtr);\r\n    }                                  /* if */\r\n\r\n    ssSetPWorkValue(S, 3, NULL);\r\n  }                                    /* if */\r\n}\r\n\r\n/* receive one packet of data and dispatch to owning application */\r\nstatic boolean_T recvData(SimStruct *S, void* pComms)\r\n{\r\n  int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n  void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n  if (pCommErrorOccurred == NULL) {\r\n    ssSetErrorStatus( S,\"pCommErrorOccurred is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  if (pXILUtils == NULL) {\r\n    ssSetErrorStatus( S,\"pXILUtils is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  *pCommErrorOccurred = (xilCommsRun(pComms, pXILUtils) !=\r\n    XILCOMMS_RTIOSTREAM_SUCCESS);\r\n  return (*pCommErrorOccurred?XILHOSTAPPSVC_ERROR:XILHOSTAPPSVC_SUCCESS);\r\n}\r\n\r\n/* send data via xil comms */\r\nstatic boolean_T sendData(SimStruct *S, void* pXILService, XIL_IOBuffer_T\r\n  * IOBuffer, mwSize sendSize)\r\n{\r\n  int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n  if (pCommErrorOccurred == NULL) {\r\n    ssSetErrorStatus( S,\"pCommErrorOccurred is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  *pCommErrorOccurred = (xilHostAppSvcSend(pXILService, IOBuffer->data, sendSize)\r\n    != XILHOSTAPPSVC_SUCCESS);\r\n  return (*pCommErrorOccurred?XILHOSTAPPSVC_ERROR:XILHOSTAPPSVC_SUCCESS);\r\n}\r\n\r\n/* implements command dispatch */\r\nstatic boolean_T commandDispatch(SimStruct *S, XIL_IOBuffer_T* IOBuffer, mwSize\r\n  dataOutSize)\r\n{\r\n  void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n  if (pXILService == NULL) {\r\n    ssSetErrorStatus( S,\"pXILService is NULL!\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  /* send the data */\r\n  if (sendData(S, pXILService, IOBuffer, dataOutSize) != XILHOSTAPPSVC_SUCCESS)\r\n  {\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\n/* implements command response */\r\nstatic boolean_T commandResponse(SimStruct *S, XIL_IOBuffer_T* IOBuffer,\r\n  XILCommandResponseType* commandType)\r\n{\r\n  void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n  if (pXILService == NULL) {\r\n    ssSetErrorStatus( S,\"pXILService is NULL!\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  {\r\n    /* receive the response data */\r\n    uint8_T COMMAND_COMPLETE = 0;\r\n    void * pComms = (void *) ssGetPWorkValue(S, 7);\r\n    if (pComms == NULL) {\r\n      ssSetErrorStatus( S,\"pComms is NULL!\");\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }                                  /* if */\r\n\r\n    while (!COMMAND_COMPLETE) {\r\n      xilHostAppSvcSetIsResponseComplete(pXILService, 0);\r\n      if (recvData(S, pComms) != XILHOSTAPPSVC_SUCCESS) {\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }                                /* if */\r\n\r\n      COMMAND_COMPLETE = xilHostAppSvcGetIsResponseComplete(pXILService);\r\n    }                                  /* while */\r\n\r\n    /* determine command response type */\r\n    *commandType = (XILCommandResponseType) COMMAND_COMPLETE;\r\n    IOBuffer->nextMemUnit = (void*)IOBuffer->data;\r\n    IOBuffer->bufferDataSize = xilHostAppSvcGetPayloadSizeForOneStep(pXILService)*\r\n      1;\r\n    IOBuffer->readData = ((IOBuffer->bufferDataSize>0)?true:false);\r\n    return XILHOSTAPPSVC_SUCCESS;\r\n  }\r\n}\r\n\r\nboolean_T xilReadData(SimStruct *S, uint8_T *dst, size_t numElements,\r\n                      mem_unit_type_T dataTypeId)\r\n{\r\n  XIL_IOBuffer_T* IOBufferPtr = NULL;\r\n  void* pMemUnitTransformer = NULL;\r\n  void* pXILService = NULL;\r\n  IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n  pMemUnitTransformer = (void *) ssGetPWorkValue(S, 14);\r\n  pXILService = (void *) ssGetPWorkValue(S, 9);\r\n  return xilReadDataInternal(dst, numElements, dataTypeId, true, IOBufferPtr,\r\n    pMemUnitTransformer, 1, pXILService);\r\n}\r\n\r\nboolean_T xilWriteData(SimStruct *S, const uint8_T *src, size_t numElements,\r\n  mem_unit_type_T dataTypeId)\r\n{\r\n  XIL_IOBuffer_T* IOBufferPtr = NULL;\r\n  void* pMemUnitTransformer = NULL;\r\n  void* pXILService = NULL;\r\n  IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n  pMemUnitTransformer = (void *) ssGetPWorkValue(S, 14);\r\n  pXILService = (void *) ssGetPWorkValue(S, 9);\r\n  return xilWriteDataInternal(src, numElements, dataTypeId, true, IOBufferPtr,\r\n    pMemUnitTransformer, 1, pXILService);\r\n}\r\n\r\nstatic boolean_T xilWriteStringData(SimStruct *S, uint8_T *srcPtr, size_t\r\n  numElements)\r\n{\r\n  size_t maxBytesConsumed;\r\n  void* dstPtr = NULL;\r\n  XIL_IOBuffer_T* IOBufferPtr = NULL;\r\n  IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n  maxBytesConsumed = numElements * sizeof(char_T);\r\n  dstPtr = IOBufferPtr->nextMemUnit;\r\n  suWriteSILStringInput((char *)dstPtr, (int32_T)numElements, srcPtr);\r\n  IOBufferPtr->nextMemUnit = (uint8_T*)IOBufferPtr->nextMemUnit +\r\n    (maxBytesConsumed/sizeof(uint8_T));\r\n  IOBufferPtr->bufferDataSize = (size_t) ((uint8_T*)IOBufferPtr->nextMemUnit -\r\n    (uint8_T*)IOBufferPtr->data);\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T xilReadStringData(SimStruct *S, uint8_T *dstPtr, size_t\r\n  numElements)\r\n{\r\n  size_t maxBytesConsumed;\r\n  void* srcPtr = NULL;\r\n  XIL_IOBuffer_T* IOBufferPtr = NULL;\r\n  IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n  maxBytesConsumed = numElements * sizeof(char_T);\r\n  srcPtr = IOBufferPtr->nextMemUnit;\r\n  suWriteSILStringOutput(dstPtr, (char *)srcPtr, (int32_T)numElements);\r\n  IOBufferPtr->nextMemUnit = (uint8_T*)IOBufferPtr->nextMemUnit +\r\n    (maxBytesConsumed/sizeof(uint8_T));\r\n  IOBufferPtr->bufferDataSize -= maxBytesConsumed;\r\n  IOBufferPtr->readData = ((IOBufferPtr->bufferDataSize>0)?true:false);\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\n/* returns data needed by code instrumentation service */\r\nstatic CodeInstrServiceData_T* codeInstrServiceData(SimStruct *S, uint8_T\r\n  memUnitSizeBytes)\r\n{\r\n  CodeInstrServiceData_T* pCodeInstrServiceData = (CodeInstrServiceData_T*)\r\n    mxCalloc(1, sizeof(CodeInstrServiceData_T));\r\n  char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n  if (simulinkBlockPath == NULL) {\r\n    ssSetErrorStatus(S,\r\n                     \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n    return NULL;\r\n  }\r\n\r\n  if (pCodeInstrServiceData == NULL) {\r\n    ssSetErrorStatus( S,\r\n                     \"Error in allocating memory for code instrumentation data through mxCalloc.\");\r\n    return NULL;\r\n  }                                    /* if */\r\n\r\n  char * pXilAppDir = (char *) ssGetPWorkValue(S, 12);\r\n  if (pXilAppDir == NULL) {\r\n    ssSetErrorStatus( S,\"pXilAppDir is NULL.\");\r\n    return NULL;\r\n  }                                    /* if */\r\n\r\n  pCodeInstrServiceData->infoPath = pXilAppDir;\r\n  pCodeInstrServiceData->blockPath = simulinkBlockPath;\r\n  pCodeInstrServiceData->rootModel = ssGetPath(_ssGetRootSS(S));\r\n  pCodeInstrServiceData->memUnitSize = memUnitSizeBytes;\r\n  pCodeInstrServiceData->isTimeProfilingEnabled = true;\r\n  pCodeInstrServiceData->isStackProfilingEnabled = false;\r\n  pCodeInstrServiceData->inTheLoopType = 1;\r\n  pCodeInstrServiceData->silPilInterfaceFcn =\r\n    \"@coder.connectivity.SimulinkInterface.getSILPILInterface\";\r\n  return pCodeInstrServiceData;\r\n}\r\n\r\nstatic void callStopHookAndFreeSFcnMemory(SimStruct *S)\r\n{\r\n  closeAndFreeTargetIOFd(S);\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    if ((pIsXILApplicationStarted != NULL) && (*pIsXILApplicationStarted == 1))\r\n    {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        if (pXILUtils) {\r\n          mxArray *rhs[3];\r\n          char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n          if (simulinkBlockPath == NULL) {\r\n            ssSetErrorStatus(S,\r\n                             \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n            return;\r\n          }\r\n\r\n          rhs[ 0 ] = mxCreateString(\r\n            \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n          rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n          rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n          xilUtilsCallMATLAB(pXILUtils, 0, NULL, 3, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionPILStopHook\");\r\n          mxFree((void *) simulinkBlockPath);\r\n        }                              /* if */\r\n      }\r\n    }                                  /* if */\r\n\r\n    if (pIsXILApplicationStarted != NULL) {\r\n      *pIsXILApplicationStarted = 0;\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    XIL_IOBuffer_T* IOBufferPtr;\r\n    XIL_RtIOStreamData_T * rtIOStreamDataPtr = (XIL_RtIOStreamData_T *)\r\n      ssGetPWorkValue(S, 0);\r\n    SIL_DEBUGGING_DATA_T * silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T *)\r\n      ssGetPWorkValue(S, 2);\r\n    if (rtIOStreamDataPtr != NULL) {\r\n      {\r\n        int errorStatus = rtIOStreamUnloadLib(&rtIOStreamDataPtr->libH);\r\n        if (errorStatus) {\r\n          ssSetErrorStatus( S,\"rtIOStreamUnloadLib failed.\");\r\n        }                              /* if */\r\n      }\r\n\r\n      mxFree(rtIOStreamDataPtr->lib);\r\n      mxDestroyArray(rtIOStreamDataPtr->MATLABObject);\r\n      mxFree(rtIOStreamDataPtr);\r\n      ssSetPWorkValue(S, 0, NULL);\r\n    }                                  /* if */\r\n\r\n    if (silDebuggingDataPtr != NULL) {\r\n      mxFree(silDebuggingDataPtr->componentBlockPath);\r\n      mxFree(silDebuggingDataPtr->SILPILInterfaceFcnStr);\r\n      mxFree(silDebuggingDataPtr);\r\n      ssSetPWorkValue(S, 2, NULL);\r\n    }                                  /* if */\r\n\r\n    IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      mxFree(IOBufferPtr->data);\r\n      mxFree(IOBufferPtr);\r\n      ssSetPWorkValue(S, 1, NULL);\r\n    }                                  /* if */\r\n\r\n    closeAndFreeTargetIOFd(S);\r\n    if (ssGetPWork(S) != NULL) {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      void * pComms = (void *) ssGetPWorkValue(S, 7);\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n      void * pCoderAssumptionsApp = (void *) ssGetPWorkValue(S, 13);\r\n      if (pCodeInstrService != NULL) {\r\n        uint8_T memUnitSizeBytes = 1;\r\n        CodeInstrServiceData_T* pCodeInstrServiceData = codeInstrServiceData(S,\r\n          memUnitSizeBytes);\r\n        codeInstrHostAppSvcDestroy(pCodeInstrService, pCodeInstrServiceData);\r\n        mxFree((void *)pCodeInstrServiceData->blockPath);\r\n        mxFree(pCodeInstrServiceData);\r\n      }                                /* if */\r\n\r\n      ssSetPWorkValue(S, 10, NULL);\r\n      if (pCoderAssumptionsApp != NULL) {\r\n        coderAssumpHostAppSvcDestroy(pCoderAssumptionsApp);\r\n        ssSetPWorkValue(S, 13, NULL);\r\n      }                                /* if */\r\n\r\n      if (pXILService != NULL) {\r\n        xilHostAppSvcDestroy(pXILService);\r\n        ssSetPWorkValue(S, 9, NULL);\r\n      }                                /* if */\r\n\r\n      if (pComms != NULL) {\r\n        xilCommsDestroy(pComms);\r\n        ssSetPWorkValue(S, 7, NULL);\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic boolean_T processResponseError(SimStruct * S)\r\n{\r\n  uint8_T errorId;\r\n  if (xilReadData(S, &errorId, 1, MEM_UNIT_UINT8_TYPE) != XILHOSTAPPSVC_SUCCESS)\r\n  {\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  if (errorId) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pilverification:PILError\");\r\n      rhs[1] = mxCreateDoubleScalar(errorId);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      mxDestroyArray(rhs[0]);\r\n      mxDestroyArray(rhs[1]);\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponsePrintf(SimStruct * S)\r\n{\r\n  const int TARGET_IO_SUCCESS = 0;\r\n  uint8_T PRINTF_ERROR;\r\n  uint16_T PRINTF_SIZE;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &PRINTF_ERROR;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                          MEM_UNIT_UINT8_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n            return XILHOSTAPPSVC_ERROR;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &PRINTF_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                          MEM_UNIT_UINT16_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n            return XILHOSTAPPSVC_ERROR;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (PRINTF_ERROR != TARGET_IO_SUCCESS) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pil:TargetIOError\");\r\n      rhs[1] = mxCreateDoubleScalar(PRINTF_ERROR);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      mxDestroyArray(rhs[0]);\r\n      mxDestroyArray(rhs[1]);\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  } else {\r\n    uint8_T *pPrintBuff;\r\n    pPrintBuff = (uint8_T *) mxCalloc(PRINTF_SIZE, sizeof(uint8_T));\r\n    if (pPrintBuff != NULL) {\r\n      if (xilReadData(S, &(pPrintBuff[0]), PRINTF_SIZE, MEM_UNIT_UINT8_TYPE) !=\r\n          XILHOSTAPPSVC_SUCCESS) {\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }                                /* if */\r\n\r\n      if (pPrintBuff[PRINTF_SIZE-1] == '\\0') {\r\n        mexPrintf(\"%s\", pPrintBuff);\r\n        mexEvalString(\"pause(0)\");\r\n      }                                /* if */\r\n\r\n      mxFree(pPrintBuff);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseFopen(SimStruct * S)\r\n{\r\n  uint16_T FOPEN_FID;\r\n  uint16_T FOPEN_NAME_SIZE;\r\n  targetIOFd_T *targetIOFdPtr;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FOPEN_FID;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                          MEM_UNIT_UINT16_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n            return XILHOSTAPPSVC_ERROR;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FOPEN_NAME_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                          MEM_UNIT_UINT16_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n            return XILHOSTAPPSVC_ERROR;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n  if (targetIOFdPtr != NULL) {\r\n    /* check fid increments by 1 */\r\n    if (targetIOFdPtr->fidOffset + 1 == FOPEN_FID) {\r\n      targetIOFdPtr->fidOffset = FOPEN_FID;\r\n      growTargetIOFd(S, targetIOFdPtr, targetIOFdPtr->fidOffset + 1);\r\n      if (targetIOFdPtr->Fd != NULL) {\r\n        uint8_T *pFopenBuff;\r\n        targetIOFdPtr->Fd[targetIOFdPtr->fidOffset] = NULL;\r\n        pFopenBuff = (uint8_T *) mxCalloc(FOPEN_NAME_SIZE, sizeof(uint8_T));\r\n        if (pFopenBuff != NULL) {\r\n          if (xilReadData(S, &(pFopenBuff[0]), FOPEN_NAME_SIZE,\r\n                          MEM_UNIT_UINT8_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n            return XILHOSTAPPSVC_ERROR;\r\n          }                            /* if */\r\n\r\n          if (pFopenBuff[FOPEN_NAME_SIZE-1] == '\\0') {\r\n            FILE * tmpFd = NULL;\r\n            tmpFd = fopen((char *) pFopenBuff,\"w\");\r\n            if (tmpFd != NULL) {\r\n              /* save the file descriptor */\r\n              targetIOFdPtr->Fd[targetIOFdPtr->fidOffset] = tmpFd;\r\n            } else {\r\n              {\r\n                void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                mxArray * rhs[ 2 ];\r\n                rhs[0] = mxCreateString(\"PIL:pil:TargetIOFopenError\");\r\n                rhs[1] = mxCreateString((char *) pFopenBuff);\r\n                xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                mxDestroyArray(rhs[0]);\r\n                mxDestroyArray(rhs[1]);\r\n                return XILHOSTAPPSVC_ERROR;\r\n              }\r\n            }                          /* if */\r\n          }                            /* if */\r\n\r\n          mxFree(pFopenBuff);\r\n        }                              /* if */\r\n      }                                /* if */\r\n    } else {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        mxArray * rhs[ 2 ];\r\n        rhs[0] = mxCreateString(\"PIL:pil:TargetIOFopenFidError\");\r\n        rhs[1] = mxCreateDoubleScalar(FOPEN_FID);\r\n        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n        mxDestroyArray(rhs[0]);\r\n        mxDestroyArray(rhs[1]);\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseFprintf(SimStruct * S)\r\n{\r\n  const int TARGET_IO_SUCCESS = 0;\r\n  uint8_T FPRINTF_ERROR;\r\n  uint16_T FPRINTF_FID;\r\n  uint16_T FPRINTF_SIZE;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_ERROR;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                          MEM_UNIT_UINT8_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n            return XILHOSTAPPSVC_ERROR;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_FID;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                          MEM_UNIT_UINT16_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n            return XILHOSTAPPSVC_ERROR;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                          MEM_UNIT_UINT16_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n            return XILHOSTAPPSVC_ERROR;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (FPRINTF_ERROR != TARGET_IO_SUCCESS) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pil:TargetIOError\");\r\n      rhs[1] = mxCreateDoubleScalar(FPRINTF_ERROR);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      mxDestroyArray(rhs[0]);\r\n      mxDestroyArray(rhs[1]);\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  } else {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n    if (targetIOFdPtr != NULL) {\r\n      if (targetIOFdPtr->size > FPRINTF_FID) {\r\n        if (targetIOFdPtr->Fd[FPRINTF_FID] != NULL) {\r\n          uint8_T *pFprintfBuff;\r\n          pFprintfBuff = (uint8_T *) mxCalloc(FPRINTF_SIZE, sizeof(uint8_T));\r\n          if (pFprintfBuff != NULL) {\r\n            if (xilReadData(S, &(pFprintfBuff[0]), FPRINTF_SIZE,\r\n                            MEM_UNIT_UINT8_TYPE) != XILHOSTAPPSVC_SUCCESS) {\r\n              return XILHOSTAPPSVC_ERROR;\r\n            }                          /* if */\r\n\r\n            if (pFprintfBuff[FPRINTF_SIZE-1] == '\\0') {\r\n              fprintf(targetIOFdPtr->Fd[FPRINTF_FID], \"%s\", pFprintfBuff);\r\n            }                          /* if */\r\n\r\n            mxFree(pFprintfBuff);\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseSignalRaised(SimStruct * S)\r\n{\r\n  const char *signalStr[6] = { \"SIGFPE\", \"SIGILL\", \"SIGABRT\", \"SIGSEGV\",\r\n    \"SIGEXIT\", \"Unknown Signal\" };\r\n\r\n  uint8_T errorId;\r\n  if (xilReadData(S, &errorId, 1, MEM_UNIT_UINT8_TYPE) != XILHOSTAPPSVC_SUCCESS)\r\n  {\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  if (strcmp(signalStr[errorId], \"SIGEXIT\")==0) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"Connectivity:target:CaughtTargetExitRequest\");\r\n      rhs[1] = mxCreateDoubleScalar(ssGetT(S));\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      mxDestroyArray(rhs[0]);\r\n      mxDestroyArray(rhs[1]);\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  } else {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 3 ];\r\n      rhs[0] = mxCreateString(\"Connectivity:target:CaughtTargetSignal\");\r\n      rhs[1] = mxCreateString(signalStr[errorId]);\r\n      rhs[2] = mxCreateDoubleScalar(ssGetT(S));\r\n      xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n      mxDestroyArray(rhs[0]);\r\n      mxDestroyArray(rhs[1]);\r\n      mxDestroyArray(rhs[2]);\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  }                                    /* if */\r\n}\r\n\r\nstatic boolean_T processErrorAndTargetIOResponseCases(SimStruct * S, const int\r\n  responseId)\r\n{\r\n  boolean_T processResponseStatus;\r\n  switch (responseId) {\r\n   case RESPONSE_ERROR:\r\n    {\r\n      processResponseStatus = processResponseError(S );\r\n      break;\r\n    }\r\n\r\n   case RESPONSE_PRINTF:\r\n    {\r\n      processResponseStatus = processResponsePrintf(S );\r\n      break;\r\n    }\r\n\r\n   case RESPONSE_FOPEN:\r\n    {\r\n      processResponseStatus = processResponseFopen(S );\r\n      break;\r\n    }\r\n\r\n   case RESPONSE_FPRINTF:\r\n    {\r\n      processResponseStatus = processResponseFprintf(S );\r\n      break;\r\n    }\r\n\r\n   case RESPONSE_SIGNAL_RAISED:\r\n    {\r\n      processResponseStatus = processResponseSignalRaised(S );\r\n      break;\r\n    }\r\n\r\n   default:\r\n    {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        mxArray * rhs[ 2 ];\r\n        rhs[0] = mxCreateString(\"PIL:pilverification:UnknownResponseId\");\r\n        rhs[1] = mxCreateDoubleScalar(responseId);\r\n        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n        mxDestroyArray(rhs[0]);\r\n        mxDestroyArray(rhs[1]);\r\n        processResponseStatus = XILHOSTAPPSVC_ERROR;\r\n      }\r\n    }\r\n  }                                    /* switch */\r\n\r\n  if (processResponseStatus == XILHOSTAPPSVC_ERROR) {\r\n    callStopHookAndFreeSFcnMemory(S);\r\n  }                                    /* if */\r\n\r\n  return processResponseStatus;\r\n}\r\n\r\n/* Convert Simulink Type ID to Mem Unit Type ID */\r\nstatic mem_unit_type_T simulinkToMemUnitType(SimStruct * S, DTypeId\r\n  simulinkTypeID)\r\n{\r\n  mem_unit_type_T memUnitType = MEM_UNIT_INVALID_TYPE;\r\n  switch (simulinkTypeID) {\r\n   case SS_DOUBLE:\r\n    {\r\n      memUnitType = MEM_UNIT_DOUBLE_TYPE;\r\n      break;\r\n    }\r\n\r\n   case SS_SINGLE:\r\n    {\r\n      memUnitType = MEM_UNIT_SINGLE_TYPE;\r\n      break;\r\n    }\r\n\r\n   case SS_INT8:\r\n    {\r\n      memUnitType = MEM_UNIT_INT8_TYPE;\r\n      break;\r\n    }\r\n\r\n   case SS_UINT8:\r\n    {\r\n      memUnitType = MEM_UNIT_UINT8_TYPE;\r\n      break;\r\n    }\r\n\r\n   case SS_INT16:\r\n    {\r\n      memUnitType = MEM_UNIT_INT16_TYPE;\r\n      break;\r\n    }\r\n\r\n   case SS_UINT16:\r\n    {\r\n      memUnitType = MEM_UNIT_UINT16_TYPE;\r\n      break;\r\n    }\r\n\r\n   case SS_INT32:\r\n    {\r\n      memUnitType = MEM_UNIT_INT32_TYPE;\r\n      break;\r\n    }\r\n\r\n   case SS_UINT32:\r\n    {\r\n      memUnitType = MEM_UNIT_UINT32_TYPE;\r\n      break;\r\n    }\r\n\r\n   case SS_BOOLEAN:\r\n    {\r\n      memUnitType = MEM_UNIT_BOOLEAN_TYPE;\r\n      break;\r\n    }\r\n\r\n   default:\r\n    {\r\n      if (ssGetDataTypeIsSpecifiedInteger(S,simulinkTypeID,0,64)) {\r\n        memUnitType = MEM_UNIT_UINT64_TYPE;\r\n        break;\r\n      }                                /* if */\r\n      else if (ssGetDataTypeIsSpecifiedInteger(S,simulinkTypeID,1,64)) {\r\n        memUnitType = MEM_UNIT_INT64_TYPE;\r\n        break;\r\n      } else if (ssGetDataTypeIsHalfPrecision(S,simulinkTypeID)) {\r\n        memUnitType = MEM_UNIT_UINT16_TYPE;\r\n        break;\r\n      } else if (ssGetDataTypeIsFixedPoint(S,simulinkTypeID) &&\r\n                 (ssGetDataTypeFxpContainWordLen(S,simulinkTypeID) == 64)) {\r\n        memUnitType = (ssGetDataTypeFxpIsSigned(S,simulinkTypeID)?\r\n                       MEM_UNIT_INT64_TYPE:MEM_UNIT_UINT64_TYPE);\r\n        break;\r\n      } else {\r\n        {\r\n          void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n          mxArray * rhs[ 2 ];\r\n          rhs[0] = mxCreateString(\"PIL:pilverification:UnknownDataType\");\r\n          rhs[1] = mxCreateDoubleScalar(simulinkTypeID);\r\n          xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n          mxDestroyArray(rhs[0]);\r\n          mxDestroyArray(rhs[1]);\r\n          return memUnitType;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }                                    /* switch */\r\n\r\n  return memUnitType;\r\n}\r\n\r\nstatic size_t getBusElementDimension(SimStruct * S, DTypeId dType, int_T\r\n  offsetIdx, const int_T ** dimsOut, int_T * numDims)\r\n{\r\n  int_T numDimensions = ssGetBusElementNumDimensions(S, dType, offsetIdx);\r\n  const int_T *dims = ssGetBusElementDimensions(S, dType, offsetIdx);\r\n  size_t numElements = 1;\r\n  int j = 0;\r\n  for (j = 0; j< numDimensions; j++) {\r\n    numElements *= dims[j];\r\n  }                                    /* for */\r\n\r\n  *dimsOut = dims;\r\n  *numDims = numDimensions;\r\n  return numElements;\r\n}\r\n\r\n/* Process params function shared between mdlStart and mdlProcessParams */\r\nstatic void processParams(SimStruct * S)\r\n{\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    if ((pIsXILApplicationStarted!=NULL) && (*pIsXILApplicationStarted==1)) {\r\n      /* update run time params */\r\n      ssUpdateAllTunableParamsAsRunTimeParams(S);\r\n\r\n      {\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return;\r\n            }                          /* if */\r\n\r\n            IOBufferPtr->bufferDataSize = 0;\r\n            if (IOBufferPtr->data != NULL) {\r\n              /* write command id */\r\n              {\r\n                uint8_T commandDataArg = (uint8_T) XIL_PROCESS_PARAMS_COMMAND;\r\n                if (xilWriteData(S, &commandDataArg, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                    XILHOSTAPPSVC_SUCCESS) {\r\n                  return;\r\n                }                      /* if */\r\n              }\r\n\r\n              {\r\n                {\r\n                  uint8_T * simDataMemUnitPtr;\r\n                  uint32_T commandDataFcnid = 0;\r\n                  simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                  {\r\n                    size_t num_elements = 1;\r\n\r\n                    {\r\n                      if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                       MEM_UNIT_UINT32_TYPE) !=\r\n                          XILHOSTAPPSVC_SUCCESS) {\r\n                        return;\r\n                      }                /* if */\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          /* provide the time information to the code instrumentation service */\r\n          {\r\n            void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n            time_T simTime = ssGetT(S);\r\n            if (pCodeInstrService != NULL) {\r\n              codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n            }                          /* if */\r\n          }\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, IOBufferPtr->bufferDataSize)!=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          {\r\n            XILCommandResponseType commandResponseType =\r\n              XIL_COMMAND_NOT_COMPLETE;\r\n            while (commandResponseType != XIL_STEP_COMPLETE) {\r\n              /* receive command from the target */\r\n              if (commandResponse(S, IOBufferPtr, &commandResponseType) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                return;\r\n              }                        /* if */\r\n\r\n              if (IOBufferPtr->readData) {\r\n                uint8_T responseId = 0;\r\n                while (IOBufferPtr->readData) {\r\n                  /* read response id */\r\n                  if (xilReadData(S, &responseId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                      XILHOSTAPPSVC_SUCCESS) {\r\n                    return;\r\n                  }                    /* if */\r\n\r\n                  switch (responseId) {\r\n                   case RESPONSE_ERROR:\r\n                   case RESPONSE_PRINTF:\r\n                   case RESPONSE_FOPEN:\r\n                   case RESPONSE_FPRINTF:\r\n                   case RESPONSE_SIGNAL_RAISED:\r\n                    {\r\n                      if (processErrorAndTargetIOResponseCases(S, responseId)==\r\n                          XILHOSTAPPSVC_ERROR) {\r\n                        return;\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownResponseId\");\r\n                        rhs[1] = mxCreateDoubleScalar(responseId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        mxDestroyArray(rhs[0]);\r\n                        mxDestroyArray(rhs[1]);\r\n                        return;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                }                      /* while */\r\n              }                        /* if */\r\n            }                          /* while */\r\n          }\r\n        }                              /* if */\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic boolean_T startAndSetupApplication(SimStruct *S)\r\n{\r\n  {\r\n    {\r\n      mxArray *rhs[4];\r\n      char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n      if (simulinkBlockPath == NULL) {\r\n        ssSetErrorStatus(S,\r\n                         \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n        return false;\r\n      }\r\n\r\n      rhs[ 0 ] = mxCreateString(\r\n        \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n      rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n      rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n      rhs[3] = mxCreateString(\"uint8\");\r\n\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        if (xilUtilsCallMATLAB(pXILUtils, 0, 0, 4, rhs,\r\n                               \"rtw.pil.SILPILInterface.sfunctionPILStartHook\")\r\n            !=XIL_UTILS_SUCCESS) {\r\n          return false;\r\n        }                              /* if */\r\n      }\r\n\r\n      mxFree((void *) simulinkBlockPath);\r\n    }\r\n\r\n    {                                  /* record that the XIL application has started */\r\n      int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n      *pIsXILApplicationStarted = 1;\r\n      ssSetPWorkValue(S, 5, pIsXILApplicationStarted);\r\n    }\r\n  }\r\n\r\n  {\r\n    mxArray *rhs[3];\r\n    mxArray *lhs[5];\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return false;\r\n    }\r\n\r\n    rhs[ 0 ] = mxCreateString(\r\n      \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n    rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (xilUtilsCallMATLAB(pXILUtils, 5, lhs, 3, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionGetRtIOStreamInfoHook\")\r\n          !=XIL_UTILS_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n    }\r\n\r\n    mxFree((void *) simulinkBlockPath);\r\n\r\n    {\r\n      XIL_RtIOStreamData_T* rtIOStreamDataPtr = (XIL_RtIOStreamData_T*) mxCalloc\r\n        (1, sizeof(XIL_RtIOStreamData_T));\r\n      if (rtIOStreamDataPtr == NULL) {\r\n        ssSetErrorStatus( S,\"Error in allocating memory through mxCalloc.\");\r\n        return false;\r\n      }                                /* if */\r\n\r\n      rtIOStreamDataPtr->lib = mxArrayToString(lhs[0]);\r\n      rtIOStreamDataPtr->MATLABObject = mxDuplicateArray(lhs[1]);\r\n      mexMakeMemoryPersistent(rtIOStreamDataPtr);\r\n      mexMakeMemoryPersistent(rtIOStreamDataPtr->lib);\r\n      mexMakeArrayPersistent(rtIOStreamDataPtr->MATLABObject);\r\n      rtIOStreamDataPtr->streamID = *mxGetPr(lhs[2]);\r\n      rtIOStreamDataPtr->recvTimeout = *mxGetPr(lhs[3]);\r\n      rtIOStreamDataPtr->sendTimeout = *mxGetPr(lhs[4]);\r\n      rtIOStreamDataPtr->isRtIOStreamCCall = 1;\r\n      rtIOStreamDataPtr->ioMxClassID = mxUINT8_CLASS;\r\n      rtIOStreamDataPtr->ioDataSize = sizeof(uint8_T);\r\n      rtIOStreamDataPtr->targetRecvBufferSizeBytes = 128;\r\n      rtIOStreamDataPtr->targetSendBufferSizeBytes = 128 + 1;\r\n\r\n      {\r\n        int errorStatus = rtIOStreamLoadLib(&rtIOStreamDataPtr->libH,\r\n          rtIOStreamDataPtr->lib);\r\n        if (errorStatus) {\r\n          ssSetErrorStatus( S,\"rtIOStreamLoadLib failed.\");\r\n          return false;\r\n        }                              /* if */\r\n      }\r\n\r\n      ssSetPWorkValue(S, 0, rtIOStreamDataPtr);\r\n    }\r\n\r\n    {\r\n      int i;\r\n      for (i=0; i<5; i++) {\r\n        mxDestroyArray(lhs[i]);\r\n      }                                /* for */\r\n    }\r\n  }\r\n\r\n  {\r\n    XIL_IOBuffer_T* IOBufferPtr = (XIL_IOBuffer_T *) mxCalloc(1, sizeof\r\n      (XIL_IOBuffer_T));\r\n    if (IOBufferPtr == NULL) {\r\n      ssSetErrorStatus( S,\"Error in allocating memory through mxCalloc.\");\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    mexMakeMemoryPersistent(IOBufferPtr);\r\n    ssSetPWorkValue(S, 1, IOBufferPtr);\r\n  }\r\n\r\n  {\r\n    SIL_DEBUGGING_DATA_T* silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T*) mxCalloc\r\n      (1, sizeof(SIL_DEBUGGING_DATA_T));\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return false;\r\n    }\r\n\r\n    if (silDebuggingDataPtr == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory through mxCalloc for SIL_DEBUGGING_DATA_T.\");\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    silDebuggingDataPtr->componentBlockPath = strcpy((char *) mxCalloc(strlen\r\n      (simulinkBlockPath)+1, sizeof(char)), simulinkBlockPath);\r\n    silDebuggingDataPtr->SILPILInterfaceFcnStr = strcpy((char*) mxCalloc(57,\r\n      sizeof(char)), \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    silDebuggingDataPtr->inTheLoopType = 1;\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr);\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr->componentBlockPath);\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr->SILPILInterfaceFcnStr);\r\n    ssSetPWorkValue(S, 2, silDebuggingDataPtr);\r\n    mxFree((void *) simulinkBlockPath);\r\n  }\r\n\r\n  {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) mxCalloc(1, sizeof\r\n      (targetIOFd_T));\r\n    if (targetIOFdPtr == NULL) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    mexMakeMemoryPersistent(targetIOFdPtr);\r\n    targetIOFdPtr->size = 0;\r\n    targetIOFdPtr->Fd = NULL;\r\n    targetIOFdPtr->fidOffset = -1;\r\n    ssSetPWorkValue(S, 3, targetIOFdPtr);\r\n  }\r\n\r\n  {\r\n    void* pConnectionOptions = NULL;\r\n    void* pComms = NULL;\r\n    void* pXILService = NULL;\r\n    void* pMemUnitTransformer = NULL;\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    uint8_T memUnitSizeBytes = 1;\r\n    uint8_T ioDataTypeSizeBytes = sizeof(uint8_T);\r\n    XIL_RtIOStreamData_T * rtIOStreamDataPtr = (XIL_RtIOStreamData_T *)\r\n      ssGetPWorkValue(S, 0);\r\n    SIL_DEBUGGING_DATA_T * silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T *)\r\n      ssGetPWorkValue(S, 2);\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    void* pCodeInstrService = NULL;\r\n    CodeInstrServiceData_T* pCodeInstrServiceData = codeInstrServiceData(S,\r\n      memUnitSizeBytes);\r\n    void * pCoderAssumptionsApp = NULL;\r\n    if (xilCommsCreate(&pComms, rtIOStreamDataPtr, silDebuggingDataPtr,\r\n                       memUnitSizeBytes, pMemUnitTransformer, pXILUtils, 0) !=\r\n        XILCOMMS_RTIOSTREAM_SUCCESS) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    if (xilHostAppSvcCreate(&pXILService, pComms, pXILUtils, IOBufferPtr,\r\n                            memUnitSizeBytes, ioDataTypeSizeBytes, 0) !=\r\n        XILHOSTAPPSVC_SUCCESS) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    {\r\n      void * pCodeInstrMultiRunData = NULL;\r\n      pCodeInstrMultiRunData = (void *) ssGetPWorkValue(S, 11);\r\n      if (codeInstrHostAppSvcCreate(&pCodeInstrService, pCodeInstrServiceData,\r\n           pComms, pMemUnitTransformer, 32, pXILUtils, memUnitSizeBytes, 0,\r\n           pCodeInstrMultiRunData) != CODEINSTRHOSTAPPSVC_SUCCESS) {\r\n        mxFree((void *)pCodeInstrServiceData->blockPath);\r\n        mxFree(pCodeInstrServiceData);\r\n        return false;\r\n      }                                /* if */\r\n\r\n      mxFree((void *)pCodeInstrServiceData->blockPath);\r\n      mxFree(pCodeInstrServiceData);\r\n    }\r\n\r\n    {\r\n      mxArray * codeGenComponent = mxCreateString(\"ctrl_ez\");\r\n      mxArray *rhs[3];\r\n      char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n      if (simulinkBlockPath == NULL) {\r\n        ssSetErrorStatus(S,\r\n                         \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n        return false;\r\n      }\r\n\r\n      rhs[ 0 ] = mxCreateString(\r\n        \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n      rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n      rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n      if (coderAssumpHostAppSvcCreate(&pCoderAssumptionsApp, pComms, pXILUtils,\r\n           0, 1, codeGenComponent, rhs[0], rhs[1], rhs[2], 1, 0, 0) !=\r\n          CODERASSUMPHOSTAPPSVC_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n\r\n      mxFree((void *) simulinkBlockPath);\r\n    }\r\n\r\n    xilCommsRegisterApplication(pComms, pXILService);\r\n    xilCommsRegisterApplication(pComms, pCodeInstrService);\r\n    xilCommsRegisterApplication(pComms, pCoderAssumptionsApp);\r\n    ssSetPWorkValue(S, 9, pXILService);\r\n    ssSetPWorkValue(S, 7, pComms);\r\n    ssSetPWorkValue(S, 6, pXILUtils);\r\n    ssSetPWorkValue(S, 10, pCodeInstrService);\r\n    ssSetPWorkValue(S, 13, pCoderAssumptionsApp);\r\n  }\r\n\r\n  {\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return false;\r\n        }                              /* if */\r\n\r\n        IOBufferPtr->bufferDataSize = 0;\r\n        if (IOBufferPtr->data != NULL) {\r\n          /* write command id */\r\n          {\r\n            uint8_T commandDataArg = (uint8_T) XIL_INIT_COMMAND;\r\n            if (xilWriteData(S, &commandDataArg, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return false;\r\n            }                          /* if */\r\n          }\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnid = 0;\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                   MEM_UNIT_UINT32_TYPE) !=\r\n                      XILHOSTAPPSVC_SUCCESS) {\r\n                    return false;\r\n                  }                    /* if */\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      /* provide the time information to the code instrumentation service */\r\n      {\r\n        void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n        time_T simTime = ssGetT(S);\r\n        if (pCodeInstrService != NULL) {\r\n          codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n        }                              /* if */\r\n      }\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, IOBufferPtr->bufferDataSize)!=\r\n          XILHOSTAPPSVC_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          if (commandResponse(S, IOBufferPtr, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return false;\r\n          }                            /* if */\r\n\r\n          if (IOBufferPtr->readData) {\r\n            uint8_T responseId = 0;\r\n\r\n#define RESPONSE_TYPE_SIZE             8\r\n\r\n            while (IOBufferPtr->readData) {\r\n              /* read response id */\r\n              if (xilReadData(S, &responseId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                return false;\r\n              }                        /* if */\r\n\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId)==\r\n                      XILHOSTAPPSVC_ERROR) {\r\n                    return false;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_TYPE_SIZE:\r\n                {\r\n                  uint8_T typeBytes;\r\n                  uint8_T typeId;\r\n                  if (xilReadData(S, &typeId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                      XILHOSTAPPSVC_SUCCESS) {\r\n                    return false;\r\n                  }                    /* if */\r\n\r\n                  if (xilReadData(S, &typeBytes, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                      XILHOSTAPPSVC_SUCCESS) {\r\n                    return false;\r\n                  }                    /* if */\r\n\r\n                  switch (typeId) {\r\n                   case SS_SINGLE:\r\n                    {\r\n                      if (typeBytes != 4) {\r\n                        {\r\n                          void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                          mxArray * rhs[ 3 ];\r\n                          rhs[0] = mxCreateString(\r\n                            \"PIL:pilverification:SingleUnsupported\");\r\n                          rhs[1] = mxCreateDoubleScalar(4);\r\n                          rhs[2] = mxCreateDoubleScalar(typeBytes);\r\n                          xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n                          mxDestroyArray(rhs[0]);\r\n                          mxDestroyArray(rhs[1]);\r\n                          mxDestroyArray(rhs[2]);\r\n                          return false;\r\n                        }\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   case SS_DOUBLE:\r\n                    {\r\n                      if (typeBytes != 8) {\r\n                        {\r\n                          void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                          mxArray * rhs[ 3 ];\r\n                          rhs[0] = mxCreateString(\r\n                            \"PIL:pilverification:DoubleUnsupported\");\r\n                          rhs[1] = mxCreateDoubleScalar(8);\r\n                          rhs[2] = mxCreateDoubleScalar(typeBytes);\r\n                          xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n                          mxDestroyArray(rhs[0]);\r\n                          mxDestroyArray(rhs[1]);\r\n                          mxDestroyArray(rhs[2]);\r\n                          return false;\r\n                        }\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownTypeId\");\r\n                        rhs[1] = mxCreateDoubleScalar(typeId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        mxDestroyArray(rhs[0]);\r\n                        mxDestroyArray(rhs[1]);\r\n                        return false;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    mxDestroyArray(rhs[0]);\r\n                    mxDestroyArray(rhs[1]);\r\n                    return false;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }                                  /* if */\r\n  }\r\n\r\n  /* initialize parameters */\r\n  processParams(S);\r\n  return true;\r\n}\r\n\r\nstatic void sendInitializeCommand(SimStruct *S)\r\n{\r\n  {\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return;\r\n        }                              /* if */\r\n\r\n        IOBufferPtr->bufferDataSize = 0;\r\n        if (IOBufferPtr->data != NULL) {\r\n          /* write command id */\r\n          {\r\n            uint8_T commandDataArg = (uint8_T) XIL_INITIALIZE_COMMAND;\r\n            if (xilWriteData(S, &commandDataArg, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return;\r\n            }                          /* if */\r\n          }\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnid = 0;\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                   MEM_UNIT_UINT32_TYPE) !=\r\n                      XILHOSTAPPSVC_SUCCESS) {\r\n                    return;\r\n                  }                    /* if */\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      /* provide the time information to the code instrumentation service */\r\n      {\r\n        void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n        time_T simTime = ssGetT(S);\r\n        if (pCodeInstrService != NULL) {\r\n          codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n        }                              /* if */\r\n      }\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, IOBufferPtr->bufferDataSize)!=\r\n          XILHOSTAPPSVC_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          if (commandResponse(S, IOBufferPtr, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          if (IOBufferPtr->readData) {\r\n            uint8_T responseId = 0;\r\n            while (IOBufferPtr->readData) {\r\n              /* read response id */\r\n              if (xilReadData(S, &responseId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                return;\r\n              }                        /* if */\r\n\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId)==\r\n                      XILHOSTAPPSVC_ERROR) {\r\n                    return;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    mxDestroyArray(rhs[0]);\r\n                    mxDestroyArray(rhs[1]);\r\n                    return;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }                                  /* if */\r\n  }\r\n}\r\n\r\nstatic void initializeInfAndMinusInf(void)\r\n{\r\n  typedef struct {\r\n    struct {\r\n      uint32_T wordL;\r\n      uint32_T wordH;\r\n    } words;\r\n  } LittleEndianIEEEDouble;\r\n\r\n  rtInf = 0.0;\r\n  rtMinusInf = 0.0;\r\n\r\n  {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal1;\r\n\r\n    tmpVal1.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal1.bitVal.words.wordL = 0x00000000U;\r\n    rtInf = tmpVal1.fltVal;\r\n  }\r\n\r\n  {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal2;\r\n\r\n    tmpVal2.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal2.bitVal.words.wordL = 0x00000000U;\r\n    rtMinusInf = tmpVal2.fltVal;\r\n  }\r\n}\r\n\r\nstatic void mdlSystemInitialize(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  {\r\n    int * pIsXILApplicationStartedLocal = (int *) ssGetPWorkValue(S, 5);\r\n    if (pIsXILApplicationStartedLocal == NULL || (*pIsXILApplicationStartedLocal)\r\n        == 0) {\r\n      boolean_T applicationStarted = startAndSetupApplication(S);\r\n      if (!applicationStarted) {\r\n        return;\r\n      }                                /* if */\r\n    }                                  /* if */\r\n\r\n    sendInitializeCommand(S);\r\n  }\r\n\r\n  {\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return;\r\n        }                              /* if */\r\n\r\n        IOBufferPtr->bufferDataSize = 0;\r\n        if (IOBufferPtr->data != NULL) {\r\n          /* write command id */\r\n          {\r\n            uint8_T commandDataArg = (uint8_T) XIL_SYSTEM_INITIALIZE_COMMAND;\r\n            if (xilWriteData(S, &commandDataArg, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return;\r\n            }                          /* if */\r\n          }\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnid = 0;\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                   MEM_UNIT_UINT32_TYPE) !=\r\n                      XILHOSTAPPSVC_SUCCESS) {\r\n                    return;\r\n                  }                    /* if */\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      /* provide the time information to the code instrumentation service */\r\n      {\r\n        void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n        time_T simTime = ssGetT(S);\r\n        if (pCodeInstrService != NULL) {\r\n          codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n        }                              /* if */\r\n      }\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, IOBufferPtr->bufferDataSize)!=\r\n          XILHOSTAPPSVC_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          if (commandResponse(S, IOBufferPtr, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          if (IOBufferPtr->readData) {\r\n            uint8_T responseId = 0;\r\n            while (IOBufferPtr->readData) {\r\n              /* read response id */\r\n              if (xilReadData(S, &responseId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                return;\r\n              }                        /* if */\r\n\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId)==\r\n                      XILHOSTAPPSVC_ERROR) {\r\n                    return;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_OUTPUT_PRE_DATA:\r\n                {\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_OUTPUT_DATA:\r\n                {\r\n                  {\r\n                    /* DataInterface: output, 1 */\r\n                    void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                      0);\r\n\r\n                    {\r\n                      uint8_T * simDataMemUnitPtr;\r\n\r\n                      /* DataInterface: output, 1 */\r\n                      simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                      {\r\n                        size_t num_elements = 1;\r\n\r\n                        {\r\n                          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                                          MEM_UNIT_SINGLE_TYPE) !=\r\n                              XILHOSTAPPSVC_SUCCESS) {\r\n                            return;\r\n                          }            /* if */\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  {\r\n                    /* DataInterface: output, 2 */\r\n                    void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                      1);\r\n\r\n                    {\r\n                      uint8_T * simDataMemUnitPtr;\r\n\r\n                      /* DataInterface: output, 2 */\r\n                      simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                      {\r\n                        size_t num_elements = 1;\r\n\r\n                        {\r\n                          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                                          MEM_UNIT_SINGLE_TYPE) !=\r\n                              XILHOSTAPPSVC_SUCCESS) {\r\n                            return;\r\n                          }            /* if */\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  {\r\n                    /* DataInterface: output, 3 */\r\n                    void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                      2);\r\n\r\n                    {\r\n                      uint8_T * simDataMemUnitPtr;\r\n\r\n                      /* DataInterface: output, 3 */\r\n                      simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                      {\r\n                        size_t num_elements = 1;\r\n\r\n                        {\r\n                          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                                          MEM_UNIT_SINGLE_TYPE) !=\r\n                              XILHOSTAPPSVC_SUCCESS) {\r\n                            return;\r\n                          }            /* if */\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  {\r\n                    /* DataInterface: output, 4 */\r\n                    void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                      3);\r\n\r\n                    {\r\n                      uint8_T * simDataMemUnitPtr;\r\n\r\n                      /* DataInterface: output, 4 */\r\n                      simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                      {\r\n                        size_t num_elements = 1;\r\n\r\n                        {\r\n                          if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                                          MEM_UNIT_BOOLEAN_TYPE) !=\r\n                              XILHOSTAPPSVC_SUCCESS) {\r\n                            return;\r\n                          }            /* if */\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    mxDestroyArray(rhs[0]);\r\n                    mxDestroyArray(rhs[1]);\r\n                    return;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }                                  /* if */\r\n  }\r\n}\r\n\r\nstatic void mdlSystemReset(SimStruct *S)\r\n{\r\n}\r\n\r\n/* This function checks the attributes of tunable parameters. */\r\n#define MDL_CHECK_PARAMETERS\r\n#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlCheckParameters(SimStruct *S)\r\n{\r\n}\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\n/*\r\n * This function is a wrapper around the \"output-update\" function for\r\n * system \"ctrl_ez_trigger_ctrl_ez\".\r\n * This function is explicitly called\r\n * by the function-call initiator which drives input port 0\r\n * of this S-Function.\r\n */\r\nstatic ssFcnCallErr_T ctrl_ez_trigger_ctrl_ez_sf(SimStruct *S, int_T ssEl, int_T\r\n  ssTid)\r\n{\r\n  /* Reserved arguments */\r\n  (void)ssEl;\r\n  (void)ssTid;\r\n\r\n  {\r\n    time_T taskTime = ssGetT(S);\r\n\r\n    {\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n      if (IOBufferPtr != NULL) {\r\n        void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n        if (pXILService != NULL) {\r\n          if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 53, 0)!=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return SS_FCNCALL_ERR;\r\n          }                            /* if */\r\n\r\n          IOBufferPtr->bufferDataSize = 0;\r\n          if (IOBufferPtr->data != NULL) {\r\n            /* write command id */\r\n            {\r\n              uint8_T commandDataArg = (uint8_T) XIL_OUTPUT_COMMAND;\r\n              if (xilWriteData(S, &commandDataArg, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                return SS_FCNCALL_ERR;\r\n              }                        /* if */\r\n            }\r\n\r\n            {\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n                uint32_T commandDataFcnidTID[2] = { 0, 1 };\r\n\r\n                simDataMemUnitPtr = (uint8_T *) &commandDataFcnidTID[0];\r\n\r\n                {\r\n                  size_t num_elements = 2;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_UINT32_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 1 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 1);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 1 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 2 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 2);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 2 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 3 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 3);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 3 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 4 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 4);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 4 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 5 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 5);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 5 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 6 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 6);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 6 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 7 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 7);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 7 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 8 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 8);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 8 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 9 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 9);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 9 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 10 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 10);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 10 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            {\r\n              /* DataInterface: input, 11 */\r\n              void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 11);\r\n\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n\r\n                /* DataInterface: input, 11 */\r\n                simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_SINGLE_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n      if (IOBufferPtr != NULL) {\r\n        /* provide the time information to the code instrumentation service */\r\n        {\r\n          void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n          if (pCodeInstrService != NULL) {\r\n            codeInstrHostAppSvcSetTime(pCodeInstrService, taskTime);\r\n          }                            /* if */\r\n        }\r\n\r\n        /* dispatch command to the target */\r\n        if (commandDispatch(S, IOBufferPtr, IOBufferPtr->bufferDataSize)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return SS_FCNCALL_ERR;\r\n        }                              /* if */\r\n\r\n        {\r\n          XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n          while (commandResponseType != XIL_STEP_COMPLETE) {\r\n            /* receive command from the target */\r\n            if (commandResponse(S, IOBufferPtr, &commandResponseType) !=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return SS_FCNCALL_ERR;\r\n            }                          /* if */\r\n\r\n            if (IOBufferPtr->readData) {\r\n              uint8_T responseId = 0;\r\n              while (IOBufferPtr->readData) {\r\n                /* read response id */\r\n                if (xilReadData(S, &responseId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                    XILHOSTAPPSVC_SUCCESS) {\r\n                  return SS_FCNCALL_ERR;\r\n                }                      /* if */\r\n\r\n                switch (responseId) {\r\n                 case RESPONSE_ERROR:\r\n                 case RESPONSE_PRINTF:\r\n                 case RESPONSE_FOPEN:\r\n                 case RESPONSE_FPRINTF:\r\n                 case RESPONSE_SIGNAL_RAISED:\r\n                  {\r\n                    if (processErrorAndTargetIOResponseCases(S, responseId)==\r\n                        XILHOSTAPPSVC_ERROR) {\r\n                      return SS_FCNCALL_ERR;\r\n                    }                  /* if */\r\n                    break;\r\n                  }\r\n\r\n                 case RESPONSE_OUTPUT_PRE_DATA:\r\n                  {\r\n                    break;\r\n                  }\r\n\r\n                 case RESPONSE_OUTPUT_DATA:\r\n                  {\r\n                    {\r\n                      /* DataInterface: output, 1 */\r\n                      void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                        0);\r\n\r\n                      {\r\n                        uint8_T * simDataMemUnitPtr;\r\n\r\n                        /* DataInterface: output, 1 */\r\n                        simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                        {\r\n                          size_t num_elements = 1;\r\n\r\n                          {\r\n                            if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                                            MEM_UNIT_SINGLE_TYPE) !=\r\n                                XILHOSTAPPSVC_SUCCESS) {\r\n                              return SS_FCNCALL_ERR;\r\n                            }          /* if */\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    {\r\n                      /* DataInterface: output, 2 */\r\n                      void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                        1);\r\n\r\n                      {\r\n                        uint8_T * simDataMemUnitPtr;\r\n\r\n                        /* DataInterface: output, 2 */\r\n                        simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                        {\r\n                          size_t num_elements = 1;\r\n\r\n                          {\r\n                            if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                                            MEM_UNIT_SINGLE_TYPE) !=\r\n                                XILHOSTAPPSVC_SUCCESS) {\r\n                              return SS_FCNCALL_ERR;\r\n                            }          /* if */\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    {\r\n                      /* DataInterface: output, 3 */\r\n                      void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                        2);\r\n\r\n                      {\r\n                        uint8_T * simDataMemUnitPtr;\r\n\r\n                        /* DataInterface: output, 3 */\r\n                        simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                        {\r\n                          size_t num_elements = 1;\r\n\r\n                          {\r\n                            if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                                            MEM_UNIT_SINGLE_TYPE) !=\r\n                                XILHOSTAPPSVC_SUCCESS) {\r\n                              return SS_FCNCALL_ERR;\r\n                            }          /* if */\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    {\r\n                      /* DataInterface: output, 4 */\r\n                      void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                        3);\r\n\r\n                      {\r\n                        uint8_T * simDataMemUnitPtr;\r\n\r\n                        /* DataInterface: output, 4 */\r\n                        simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                        {\r\n                          size_t num_elements = 1;\r\n\r\n                          {\r\n                            if (xilReadData(S, simDataMemUnitPtr, num_elements,\r\n                                            MEM_UNIT_BOOLEAN_TYPE) !=\r\n                                XILHOSTAPPSVC_SUCCESS) {\r\n                              return SS_FCNCALL_ERR;\r\n                            }          /* if */\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                    break;\r\n                  }\r\n\r\n                 default:\r\n                  {\r\n                    {\r\n                      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                      mxArray * rhs[ 2 ];\r\n                      rhs[0] = mxCreateString(\r\n                        \"PIL:pilverification:UnknownResponseId\");\r\n                      rhs[1] = mxCreateDoubleScalar(responseId);\r\n                      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                      mxDestroyArray(rhs[0]);\r\n                      mxDestroyArray(rhs[1]);\r\n                      return SS_FCNCALL_ERR;\r\n                    }\r\n                    break;\r\n                  }\r\n                }                      /* switch */\r\n              }                        /* while */\r\n            }                          /* if */\r\n          }                            /* while */\r\n        }\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n      if (IOBufferPtr->readData) {\r\n        uint8_T responseId = 0;\r\n        while (IOBufferPtr->readData) {\r\n          /* read response id */\r\n          if (xilReadData(S, &responseId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return SS_FCNCALL_ERR;\r\n          }                            /* if */\r\n\r\n          switch (responseId) {\r\n           case RESPONSE_ERROR:\r\n           case RESPONSE_PRINTF:\r\n           case RESPONSE_FOPEN:\r\n           case RESPONSE_FPRINTF:\r\n           case RESPONSE_SIGNAL_RAISED:\r\n            {\r\n              if (processErrorAndTargetIOResponseCases(S, responseId)==\r\n                  XILHOSTAPPSVC_ERROR) {\r\n                return SS_FCNCALL_ERR;\r\n              }                        /* if */\r\n              break;\r\n            }\r\n\r\n           default:\r\n            {\r\n              {\r\n                void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                mxArray * rhs[ 2 ];\r\n                rhs[0] = mxCreateString(\"PIL:pilverification:UnknownResponseId\");\r\n                rhs[1] = mxCreateDoubleScalar(responseId);\r\n                xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                mxDestroyArray(rhs[0]);\r\n                mxDestroyArray(rhs[1]);\r\n                return SS_FCNCALL_ERR;\r\n              }\r\n              break;\r\n            }\r\n          }                            /* switch */\r\n        }                              /* while */\r\n      }                                /* if */\r\n    }\r\n  }\r\n\r\n  /* Default return status. */\r\n  return(SS_FCNCALL_NO_ERR);\r\n}\r\n\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n  ssSetNumSFcnParams(S, 0);            /* Number of expected parameters */\r\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\r\n\r\n#if defined(MDL_CHECK_PARAMETERS)\r\n\r\n    mdlCheckParameters(S);\r\n\r\n#endif\r\n\r\n    if (ssGetErrorStatus(S) != (NULL))\r\n      return;\r\n  } else {\r\n    /* Parameter mismatch will be reported by Simulink */\r\n    return;\r\n  }\r\n\r\n  ssSetNumContStates(S, 0);\r\n  ssSetNumDiscStates(S, 0);\r\n\r\n  /* no support for SimState */\r\n  ssSetSimStateCompliance(S, DISALLOW_SIM_STATE);\r\n\r\n  /* Allow signal dimensions greater than 2 */\r\n  ssAllowSignalsWithMoreThan2D(S);\r\n\r\n  /* Allow fixed-point data types with 33 or more bits */\r\n  ssFxpSetU32BitRegionCompliant(S,1);\r\n  initializeInfAndMinusInf();\r\n  ssSetRTWGeneratedSFcn(S, 2);\r\n  if ((S->mdlInfo->genericFcn != (NULL)) && (!(S->mdlInfo->genericFcn)(S,\r\n        GEN_FCN_CHK_MODELREF_SFUN_HAS_MODEL_BLOCK, -1, (NULL)))) {\r\n    return;\r\n  }\r\n\r\n  slmrInitializeIOPortDataVectors(S, 12, 4);\r\n  if (!ssSetNumInputPorts(S, 12))\r\n    return;\r\n  if (!ssSetInputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 0, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 0, FRAME_NO);\r\n  ssSetInputPortDataType(S, 0, SS_FCN_CALL);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 0, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 0, 1);\r\n  ssSetInputPortRequiredContiguous(S, 0, 1);\r\n  ssSetInputPortOverWritable(S, 0, false);\r\n  ssSetInputPortSampleTime(S, 0, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 1, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 1, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 1, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 1, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 1, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 1, 1);\r\n  ssSetInputPortRequiredContiguous(S, 1, 1);\r\n  ssSetInputPortOverWritable(S, 1, false);\r\n  ssSetInputPortSampleTime(S, 1, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 2, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 2, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 2, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 2, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 2, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 2, 1);\r\n  ssSetInputPortRequiredContiguous(S, 2, 1);\r\n  ssSetInputPortOverWritable(S, 2, false);\r\n  ssSetInputPortSampleTime(S, 2, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 3, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 3, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 3, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 3, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 3, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 3, 1);\r\n  ssSetInputPortRequiredContiguous(S, 3, 1);\r\n  ssSetInputPortOverWritable(S, 3, false);\r\n  ssSetInputPortSampleTime(S, 3, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 4, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 4, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 4, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 4, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 4, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 4, 1);\r\n  ssSetInputPortRequiredContiguous(S, 4, 1);\r\n  ssSetInputPortOverWritable(S, 4, false);\r\n  ssSetInputPortSampleTime(S, 4, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 5, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 5, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 5, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 5, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 5, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 5, 1);\r\n  ssSetInputPortRequiredContiguous(S, 5, 1);\r\n  ssSetInputPortOverWritable(S, 5, false);\r\n  ssSetInputPortSampleTime(S, 5, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 6, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 6, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 6, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 6, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 6, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 6, 1);\r\n  ssSetInputPortRequiredContiguous(S, 6, 1);\r\n  ssSetInputPortOverWritable(S, 6, false);\r\n  ssSetInputPortSampleTime(S, 6, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 7, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 7, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 7, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 7, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 7, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 7, 1);\r\n  ssSetInputPortRequiredContiguous(S, 7, 1);\r\n  ssSetInputPortOverWritable(S, 7, false);\r\n  ssSetInputPortSampleTime(S, 7, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 8, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 8, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 8, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 8, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 8, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 8, 1);\r\n  ssSetInputPortRequiredContiguous(S, 8, 1);\r\n  ssSetInputPortOverWritable(S, 8, false);\r\n  ssSetInputPortSampleTime(S, 8, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 9, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 9, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 9, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 9, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 9, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 9, 1);\r\n  ssSetInputPortRequiredContiguous(S, 9, 1);\r\n  ssSetInputPortOverWritable(S, 9, false);\r\n  ssSetInputPortSampleTime(S, 9, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 10, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 10, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 10, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 10, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 10, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 10, 1);\r\n  ssSetInputPortRequiredContiguous(S, 10, 1);\r\n  ssSetInputPortOverWritable(S, 10, false);\r\n  ssSetInputPortSampleTime(S, 10, -1);\r\n  if (!ssSetInputPortVectorDimension(S, 11, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 11, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 11, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 11, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 11, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 11, 1);\r\n  ssSetInputPortRequiredContiguous(S, 11, 1);\r\n  ssSetInputPortOverWritable(S, 11, false);\r\n  ssSetInputPortSampleTime(S, 11, -1);\r\n  if (!ssSetNumOutputPorts(S, 4))\r\n    return;\r\n  if (!ssSetOutputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  ssSetOutputPortDimensionsMode(S, 0, FIXED_DIMS_MODE);\r\n  ssSetOutputPortFrameData(S, 0, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 0, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetOutputPortUnit(S, 0, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetOutputPortSampleTime(S, 0, -1);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S) ) {\r\n    ssSetOutputPortOkToMerge(S, 0, SS_OK_TO_MERGE);\r\n  }                                    /* if */\r\n\r\n  ssSetOutputPortICAttributes(S, 0, false, true, false);\r\n  if (!ssSetOutputPortVectorDimension(S, 1, 1))\r\n    return;\r\n  ssSetOutputPortDimensionsMode(S, 1, FIXED_DIMS_MODE);\r\n  ssSetOutputPortFrameData(S, 1, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 1, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetOutputPortUnit(S, 1, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetOutputPortSampleTime(S, 1, -1);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S) ) {\r\n    ssSetOutputPortOkToMerge(S, 1, SS_NOT_OK_TO_MERGE);\r\n  }                                    /* if */\r\n\r\n  ssSetOutputPortICAttributes(S, 1, false, true, false);\r\n  if (!ssSetOutputPortVectorDimension(S, 2, 1))\r\n    return;\r\n  ssSetOutputPortDimensionsMode(S, 2, FIXED_DIMS_MODE);\r\n  ssSetOutputPortFrameData(S, 2, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 2, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetOutputPortUnit(S, 2, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetOutputPortSampleTime(S, 2, -1);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S) ) {\r\n    ssSetOutputPortOkToMerge(S, 2, SS_NOT_OK_TO_MERGE);\r\n  }                                    /* if */\r\n\r\n  ssSetOutputPortICAttributes(S, 2, false, true, false);\r\n  if (!ssSetOutputPortVectorDimension(S, 3, 1))\r\n    return;\r\n  ssSetOutputPortDimensionsMode(S, 3, FIXED_DIMS_MODE);\r\n  ssSetOutputPortFrameData(S, 3, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 3, SS_BOOLEAN);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetOutputPortUnit(S, 3, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetOutputPortSampleTime(S, 3, -1);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S) ) {\r\n    ssSetOutputPortOkToMerge(S, 3, SS_NOT_OK_TO_MERGE);\r\n  }                                    /* if */\r\n\r\n  ssSetOutputPortICAttributes(S, 3, false, true, false);\r\n\r\n  {\r\n    int_T zcsIdx = 0;\r\n  }\r\n\r\n  ssSetOutputPortIsNonContinuous(S, 0, 0);\r\n  ssSetOutputPortIsFedByBlockWithModesNoZCs(S, 0, 0);\r\n  ssSetOutputPortIsNonContinuous(S, 1, 0);\r\n  ssSetOutputPortIsFedByBlockWithModesNoZCs(S, 1, 0);\r\n  ssSetOutputPortIsNonContinuous(S, 2, 0);\r\n  ssSetOutputPortIsFedByBlockWithModesNoZCs(S, 2, 0);\r\n  ssSetOutputPortIsNonContinuous(S, 3, 0);\r\n  ssSetOutputPortIsFedByBlockWithModesNoZCs(S, 3, 0);\r\n  ssSetInputPortIsNotDerivPort(S, 0, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 1, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 2, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 3, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 4, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 5, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 6, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 7, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 8, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 9, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 10, 1);\r\n  ssSetInputPortIsNotDerivPort(S, 11, 1);\r\n  ssSetModelReferenceSampleTimeInheritanceRule(S,\r\n    DISALLOW_SAMPLE_TIME_INHERITANCE);\r\n  ssSupportsMultipleExecInstances(S, false);\r\n  ssRegisterMsgForNotSupportingMultiExecInst(S,\r\n    \"<diag_root><diag id=\\\"Simulink:blocks:BlockDoesNotSupportMultiExecInstances\\\" pr=\\\"d\\\"><arguments><arg type=\\\"encoded\\\">YwB0AHIAbABfAGUAegAvAHQAcgBpAGcAZwBlAHIAXwBjAHQAcgBsAF8AZQB6AAAA</arg><arg type=\\\"encoded\\\">PABfAF8AaQBpAFMAUwBfAF8APgA8AC8AXwBfAGkAaQBTAFMAXwBfAD4AAAA=</arg><arg type=\\\"encoded\\\">PABfAF8AaQB0AGUAcgBCAGwAawBfAF8APgA8AC8AXwBfAGkAdABlAHIAQgBsAGsAXwBfAD4AAAA=</arg></arguments><hs><h>AAAACIAMyEAA</h></hs></diag></diag_root>\");\r\n  ssSetAcceptsFcnCallInputs(S);        /* All sample times are available through ports. Use port based sample times. */\r\n  ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES);\r\n  ssSetParameterTuningCompliance(S, true);\r\n  ssExportOutputFcn(S, 0, ctrl_ez_trigger_ctrl_ez_sf);\r\n  ssSetModelReferenceSampleTimeInheritanceRule(S,\r\n    DISALLOW_SAMPLE_TIME_INHERITANCE);\r\n  ssSetOptions(S, SS_OPTION_ALLOW_PORT_SAMPLE_TIME_IN_TRIGSS |\r\n               SS_OPTION_SUPPORTS_ALIAS_DATA_TYPES |\r\n               SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME |\r\n               SS_OPTION_CALL_TERMINATE_ON_EXIT);\r\n  slmrRegisterSystemInitializeMethod(S, mdlSystemInitialize);\r\n  slmrRegisterSystemResetMethod(S, mdlSystemReset);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S) ) {\r\n    ssSetNumPWork(S, 0);\r\n  } else {\r\n    ssSetNumPWork(S, 15);\r\n  }                                    /* if */\r\n\r\n  ssSetNumRWork(S, 0);\r\n  ssSetNumIWork(S, 0);\r\n  ssSetNumModes(S, 0);\r\n  ssSetNumNonsampledZCs(S, 0);\r\n  ssSetModelReferenceNormalModeSupport(S, MDL_START_AND_MDL_PROCESS_PARAMS_OK);\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n  if (S->mdlInfo->genericFcn != (NULL) &&\r\n      ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssRegModelRefMdlInfo(S, (char *)\"ctrl_ez\", rtMdlInfo_ctrl_ez, 0);\r\n  }\r\n\r\n#endif\r\n\r\n  /* DWork */\r\n  if (!ssRTWGenIsAccelerator(S)) {\r\n    ssSetNumDWork(S, 0);\r\n  }                                    /* if */\r\n}\r\n\r\n#define MDL_SET_INPUT_PORT_SAMPLE_TIME                           /* Change to #undef to remove function */\r\n#if defined(MDL_SET_INPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlSetInputPortSampleTime(SimStruct *S, int_T portIdx, real_T\r\n  sampleTime, real_T offsetTime)\r\n{\r\n  /* inherited sample times are set by the Model Block itself */\r\n}\r\n\r\n#endif                                 /* MDL_SET_INPUT_PORT_SAMPLE_TIME */\r\n\r\n#define MDL_SET_OUTPUT_PORT_SAMPLE_TIME                          /* Change to #undef to remove function */\r\n#if defined(MDL_SET_OUTPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlSetOutputPortSampleTime(SimStruct *S, int_T portIdx, real_T\r\n  sampleTime, real_T offsetTime)\r\n{\r\n  /* inherited sample times are set by the Model Block itself */\r\n}\r\n\r\n#endif                                 /* MDL_SET_OUTPUT_PORT_SAMPLE_TIME */\r\n\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n  /* This block has port based sample time. */\r\n  return;\r\n}\r\n\r\n#define MDL_SETUP_RUNTIME_RESOURCES                              /* Change to #undef to remove function */\r\n#if defined(MDL_SETUP_RUNTIME_RESOURCES)\r\n\r\nstatic void mdlSetupRuntimeResources(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  {\r\n    mxArray * error = NULL;\r\n    error = mexCallMATLABWithTrap( 0, NULL, 0, NULL,\r\n      \"rtw.pil.checkEmbeddedCoderInstalled\");\r\n    if (error != NULL) {\r\n      mexCallMATLAB( 0, NULL, 1, &error, \"throw\");\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    mxArray * lhs[1];\r\n    mxArray * error = NULL;\r\n    char * installVersion;\r\n    error = mexCallMATLABWithTrap(1, lhs, 0, NULL, \"rtw.pil.getPILVersion\");\r\n    if (error != NULL) {\r\n      mxDestroyArray(error);\r\n      ssSetErrorStatus( S,\r\n                       \"Failed to determine the installed In-the-Loop version for comparison against the In-the-Loop s-function version (release 24.2 (R2024b)_15). To avoid this error, remove the In-the-Loop s-function from your MATLAB path (e.g. delete it or move to a clean working directory).\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (mxIsEmpty(lhs[0])) {\r\n      ssSetErrorStatus( S,\"rtw.pil.getPILVersion returned empty!\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    installVersion = mxArrayToString(lhs[0]);\r\n    mxDestroyArray(lhs[0]);\r\n    if (installVersion == NULL) {\r\n      ssSetErrorStatus( S,\"Failed to determine installed In-the-Loop version.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (strcmp(installVersion, \"24.2 (R2024b)_15\") != 0) {\r\n      ssSetErrorStatus( S,\r\n                       \"The In-the-Loop s-function is incompatible with the installed In-the-Loop version (see ver('matlab')); it was generated for release 24.2 (R2024b)_15. To avoid this error, remove the In-the-Loop s-function from your MATLAB path (e.g. delete it or move to a clean working directory)\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    mxFree(installVersion);\r\n  }\r\n\r\n  {\r\n    int retValXILUtils = XIL_UTILS_SUCCESS;\r\n    void* pXILUtils = NULL;\r\n    retValXILUtils = xilSimulinkUtilsCreate(&pXILUtils, S);\r\n    if (retValXILUtils!=XIL_UTILS_SUCCESS) {\r\n      ssSetErrorStatus( S,\"Error instantiating XIL Utils!\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    ssSetPWorkValue(S, 6, pXILUtils);\r\n  }\r\n\r\n  {\r\n    ssSetPWorkValue(S, 14, NULL);\r\n  }\r\n\r\n  {\r\n    int * pCommErrorOccurred = (int *) mxCalloc(1, sizeof(int));\r\n    if (pCommErrorOccurred == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory for pCommErrorOccurred through mxCalloc.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    *pCommErrorOccurred = 0;\r\n    mexMakeMemoryPersistent(pCommErrorOccurred);\r\n    ssSetPWorkValue(S, 4, pCommErrorOccurred);\r\n  }\r\n\r\n  {\r\n    int * pIsXILApplicationStarted = (int *) mxCalloc(1, sizeof(int));\r\n    if (pIsXILApplicationStarted == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory for pIsXILApplicationStarted through mxCalloc.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    *pIsXILApplicationStarted = 0;\r\n    mexMakeMemoryPersistent(pIsXILApplicationStarted);\r\n    ssSetPWorkValue(S, 5, pIsXILApplicationStarted);\r\n  }\r\n\r\n  {\r\n    mxArray *rhs[4];\r\n    mxArray *lhs[2];\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return;\r\n    }\r\n\r\n    rhs[ 0 ] = mxCreateString(\r\n      \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n    rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n    rhs[3] = mxCreateString(ssGetPath(_ssGetRootSS(S)));\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (xilUtilsCallMATLAB(pXILUtils, 2, lhs, 4, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionInitializeHook\")\r\n          !=XIL_UTILS_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      mxFree((void *) simulinkBlockPath);\r\n    }\r\n\r\n    {\r\n      void * multiRunDataPtr = xilSimulinkUtilsStaticInitMultiRunInstrData();\r\n      ssSetPWorkValue(S, 11, multiRunDataPtr);\r\n    }\r\n\r\n    char * pXilAppDir;\r\n    pXilAppDir = mxArrayToString(lhs[0]);\r\n    mexMakeMemoryPersistent(pXilAppDir);\r\n    ssSetPWorkValue(S, 12, pXilAppDir);\r\n    mxDestroyArray(lhs[0]);\r\n    mxDestroyArray(lhs[1]);\r\n  }\r\n}\r\n\r\n#endif                                 /* MDL_SETUP_RUNTIME_RESOURCES */\r\n\r\n#define MDL_SIM_STATUS_CHANGE                                    /* Change to #undef to remove function */\r\n#if defined(MDL_SIM_STATUS_CHANGE)\r\n\r\nstatic void mdlSimStatusChange(SimStruct *S, ssSimStatusChangeType simStatus)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  if (simStatus == SIM_PAUSE) {\r\n    {\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n      if (IOBufferPtr != NULL) {\r\n        void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n        if (pXILService != NULL) {\r\n          if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return ;\r\n          }                            /* if */\r\n\r\n          IOBufferPtr->bufferDataSize = 0;\r\n          if (IOBufferPtr->data != NULL) {\r\n            /* write command id */\r\n            {\r\n              uint8_T commandDataArg = (uint8_T) XIL_PAUSE_COMMAND;\r\n              if (xilWriteData(S, &commandDataArg, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                return;\r\n              }                        /* if */\r\n            }\r\n\r\n            {\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n                uint32_T commandDataFcnid = 0;\r\n                simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                     MEM_UNIT_UINT32_TYPE) !=\r\n                        XILHOSTAPPSVC_SUCCESS) {\r\n                      return;\r\n                    }                  /* if */\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n      if (IOBufferPtr != NULL) {\r\n        /* provide the time information to the code instrumentation service */\r\n        {\r\n          void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n          time_T simTime = ssGetT(S);\r\n          if (pCodeInstrService != NULL) {\r\n            codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n          }                            /* if */\r\n        }\r\n\r\n        /* dispatch command to the target */\r\n        if (commandDispatch(S, IOBufferPtr, IOBufferPtr->bufferDataSize)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return ;\r\n        }                              /* if */\r\n\r\n        {\r\n          XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n          while (commandResponseType != XIL_STEP_COMPLETE) {\r\n            /* receive command from the target */\r\n            if (commandResponse(S, IOBufferPtr, &commandResponseType) !=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return ;\r\n            }                          /* if */\r\n\r\n            if (IOBufferPtr->readData) {\r\n              uint8_T responseId = 0;\r\n              while (IOBufferPtr->readData) {\r\n                /* read response id */\r\n                if (xilReadData(S, &responseId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                    XILHOSTAPPSVC_SUCCESS) {\r\n                  return;\r\n                }                      /* if */\r\n\r\n                switch (responseId) {\r\n                 case RESPONSE_ERROR:\r\n                 case RESPONSE_PRINTF:\r\n                 case RESPONSE_FOPEN:\r\n                 case RESPONSE_FPRINTF:\r\n                 case RESPONSE_SIGNAL_RAISED:\r\n                  {\r\n                    if (processErrorAndTargetIOResponseCases(S, responseId)==\r\n                        XILHOSTAPPSVC_ERROR) {\r\n                      return ;\r\n                    }                  /* if */\r\n                    break;\r\n                  }\r\n\r\n                 default:\r\n                  {\r\n                    {\r\n                      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                      mxArray * rhs[ 2 ];\r\n                      rhs[0] = mxCreateString(\r\n                        \"PIL:pilverification:UnknownResponseId\");\r\n                      rhs[1] = mxCreateDoubleScalar(responseId);\r\n                      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                      mxDestroyArray(rhs[0]);\r\n                      mxDestroyArray(rhs[1]);\r\n                      return ;\r\n                    }\r\n                    break;\r\n                  }\r\n                }                      /* switch */\r\n              }                        /* while */\r\n            }                          /* if */\r\n          }                            /* while */\r\n        }\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (pXILUtils) {\r\n        mxArray *rhs[3];\r\n        char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n        if (simulinkBlockPath == NULL) {\r\n          ssSetErrorStatus(S,\r\n                           \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n          return;\r\n        }\r\n\r\n        rhs[ 0 ] = mxCreateString(\r\n          \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n        rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n        rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n        if (xilUtilsCallMATLAB(pXILUtils, 0, NULL, 3, rhs,\r\n                               \"rtw.pil.SILPILInterface.sfunctionPILPauseHook\")\r\n            != XIL_UTILS_SUCCESS) {\r\n          return ;\r\n        }                              /* if */\r\n\r\n        mxFree((void *) simulinkBlockPath);\r\n      }                                /* if */\r\n    }\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_SIM_STATUS_CHANGE */\r\n\r\n#define MDL_PROCESS_PARAMETERS\r\n#if defined(MDL_PROCESS_PARAMETERS)\r\n\r\nstatic void mdlProcessParameters(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  processParams(S);\r\n}\r\n\r\n#endif                                 /* MDL_PROCESS_PARAMETERS */\r\n\r\n#define MDL_SET_WORK_WIDTHS                                      /* Change to #undef to remove function */\r\n#if defined(MDL_SET_WORK_WIDTHS)\r\n\r\nstatic void mdlSetWorkWidths(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    if (S->mdlInfo->genericFcn != (NULL)) {\r\n      _GenericFcn fcn = S->mdlInfo->genericFcn;\r\n      ssSetSignalSizesComputeType(S, SS_VARIABLE_SIZE_FROM_INPUT_VALUE_AND_SIZE);\r\n    }\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_SET_WORK_WIDTHS */\r\n\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n  return;\r\n}\r\n\r\nstatic void mdlTerminate(SimStruct *S)\r\n{\r\n  int commErrorOccurred = 0;\r\n  int isXILApplicationStarted = 0;\r\n\r\n  {\r\n    if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (ssGetPWork(S) != NULL) {\r\n      int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n      int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n      if (pCommErrorOccurred != NULL) {\r\n        commErrorOccurred = *pCommErrorOccurred;\r\n      }                                /* if */\r\n\r\n      if (pIsXILApplicationStarted != NULL) {\r\n        isXILApplicationStarted = *pIsXILApplicationStarted;\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  if (isXILApplicationStarted) {\r\n    if (!commErrorOccurred) {\r\n      {\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              callStopHookAndFreeSFcnMemory(S);\r\n              return;\r\n            }                          /* if */\r\n\r\n            IOBufferPtr->bufferDataSize = 0;\r\n            if (IOBufferPtr->data != NULL) {\r\n              /* write command id */\r\n              {\r\n                uint8_T commandDataArg = (uint8_T) XIL_TERMINATE_COMMAND;\r\n                if (xilWriteData(S, &commandDataArg, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                    XILHOSTAPPSVC_SUCCESS) {\r\n                  return;\r\n                }                      /* if */\r\n              }\r\n\r\n              {\r\n                {\r\n                  uint8_T * simDataMemUnitPtr;\r\n                  uint32_T commandDataFcnid = 0;\r\n                  simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                  {\r\n                    size_t num_elements = 1;\r\n\r\n                    {\r\n                      if (xilWriteData(S, simDataMemUnitPtr, num_elements,\r\n                                       MEM_UNIT_UINT32_TYPE) !=\r\n                          XILHOSTAPPSVC_SUCCESS) {\r\n                        return;\r\n                      }                /* if */\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          /* provide the time information to the code instrumentation service */\r\n          {\r\n            void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n            time_T simTime = ssGetT(S);\r\n            if (pCodeInstrService != NULL) {\r\n              codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n            }                          /* if */\r\n          }\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, IOBufferPtr->bufferDataSize)!=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            callStopHookAndFreeSFcnMemory(S);\r\n            return;\r\n          }                            /* if */\r\n\r\n          {\r\n            XILCommandResponseType commandResponseType =\r\n              XIL_COMMAND_NOT_COMPLETE;\r\n            while (commandResponseType != XIL_STEP_COMPLETE) {\r\n              /* receive command from the target */\r\n              if (commandResponse(S, IOBufferPtr, &commandResponseType) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                callStopHookAndFreeSFcnMemory(S);\r\n                return;\r\n              }                        /* if */\r\n\r\n              if (IOBufferPtr->readData) {\r\n                uint8_T responseId = 0;\r\n                while (IOBufferPtr->readData) {\r\n                  /* read response id */\r\n                  if (xilReadData(S, &responseId, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                      XILHOSTAPPSVC_SUCCESS) {\r\n                    return;\r\n                  }                    /* if */\r\n\r\n                  switch (responseId) {\r\n                   case RESPONSE_ERROR:\r\n                   case RESPONSE_PRINTF:\r\n                   case RESPONSE_FOPEN:\r\n                   case RESPONSE_FPRINTF:\r\n                   case RESPONSE_SIGNAL_RAISED:\r\n                    {\r\n                      if (processErrorAndTargetIOResponseCases(S, responseId)==\r\n                          XILHOSTAPPSVC_ERROR) {\r\n                        callStopHookAndFreeSFcnMemory(S);\r\n                        return;\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownResponseId\");\r\n                        rhs[1] = mxCreateDoubleScalar(responseId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        mxDestroyArray(rhs[0]);\r\n                        mxDestroyArray(rhs[1]);\r\n                        callStopHookAndFreeSFcnMemory(S);\r\n                        return;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                }                      /* while */\r\n              }                        /* if */\r\n            }                          /* while */\r\n          }\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 1, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              callStopHookAndFreeSFcnMemory(S);\r\n              return;\r\n            }                          /* if */\r\n\r\n            IOBufferPtr->bufferDataSize = 0;\r\n            if (IOBufferPtr->data != NULL) {\r\n              /* write command id */\r\n              {\r\n                uint8_T commandDataArg = (uint8_T) XIL_SHUTDOWN_COMMAND;\r\n                if (xilWriteData(S, &commandDataArg, 1, MEM_UNIT_UINT8_TYPE) !=\r\n                    XILHOSTAPPSVC_SUCCESS) {\r\n                  return;\r\n                }                      /* if */\r\n              }\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          /* provide the time information to the code instrumentation service */\r\n          {\r\n            void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n            time_T simTime = ssGetT(S);\r\n            if (pCodeInstrService != NULL) {\r\n              codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n            }                          /* if */\r\n          }\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, IOBufferPtr->bufferDataSize)!=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            callStopHookAndFreeSFcnMemory(S);\r\n            return;\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  callStopHookAndFreeSFcnMemory(S);\r\n}\r\n\r\n#define MDL_CLEANUP_RUNTIME_RESOURCES                            /* Change to #undef to remove function */\r\n#if defined(MDL_CLEANUP_RUNTIME_RESOURCES)\r\n\r\nstatic void mdlCleanupRuntimeResources(SimStruct *S)\r\n{\r\n  mdlTerminate(S);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  {\r\n    void * pCodeInstrMultiRunData = NULL;\r\n    pCodeInstrMultiRunData = (void *) ssGetPWorkValue(S, 11);\r\n    xilSimulinkUtilsStaticFreeMultiRunInstrData(pCodeInstrMultiRunData);\r\n  }\r\n\r\n  {\r\n    char * pXilAppDir = NULL;\r\n    pXilAppDir = (char *) ssGetPWorkValue(S, 12);\r\n    if (pXilAppDir != NULL) {\r\n      mxFree(pXilAppDir);\r\n      ssSetPWorkValue(S, 12, NULL);\r\n    }                                  /* if */\r\n  }\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n    if (pIsXILApplicationStarted != NULL) {\r\n      mxFree(pIsXILApplicationStarted);\r\n      ssSetPWorkValue(S, 5, NULL);\r\n    }                                  /* if */\r\n\r\n    if (pCommErrorOccurred != NULL) {\r\n      mxFree(pCommErrorOccurred);\r\n      ssSetPWorkValue(S, 4, NULL);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    if (pXILUtils != NULL) {\r\n      xilUtilsDestroy(pXILUtils);\r\n      ssSetPWorkValue(S, 6, NULL);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_CLEANUP_RUNTIME_RESOURCES */\r\n\r\n#define MDL_ENABLE\r\n#if defined(MDL_ENABLE)\r\n\r\nstatic void mdlEnable(SimStruct *S)\r\n{\r\n}\r\n\r\n#endif                                 /* MDL_ENABLE */\r\n\r\n#define MDL_DISABLE\r\n#if defined(MDL_DISABLE)\r\n\r\nstatic void mdlDisable(SimStruct *S)\r\n{\r\n}\r\n\r\n#endif                                 /* MDL_DISABLE */\r\n\r\n/* Required S-function trailer */\r\n#ifdef MATLAB_MEX_FILE                 /* Is this file being compiled as a MEX-file? */\r\n#include \"simulink.c\"                  /* MEX-file interface mechanism */\r\n#include \"fixedpoint.c\"\r\n#else\r\n#error Assertion failed: file must be compiled as a MEX-file\r\n#endif\r\n"},{"name":"main.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Core\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file           : main.c\r\n  * @brief          : Main program body\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2025 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n\r\n/* Private includes ----------------------------------------------------------*/\r\n/* USER CODE BEGIN Includes */\r\n\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN PTD */\r\n\r\n/* USER CODE END PTD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN PD */\r\n/* USER CODE END PD */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN PM */\r\n\r\n/* USER CODE END PM */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n\r\nPCD_HandleTypeDef hpcd_USB_OTG_FS;\r\n\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\nvoid SystemClock_Config(void);\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* Private user code ---------------------------------------------------------*/\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n\r\n/**\r\n  * @brief  The application entry point.\r\n  * @retval int\r\n  */\r\n\r\n/**\r\n  * @brief System Clock Configuration\r\n  * @retval None\r\n  */\r\nvoid SystemClock_Config(void)\r\n{\r\n  LL_FLASH_SetLatency(LL_FLASH_LATENCY_7);\r\n  while(LL_FLASH_GetLatency()!= LL_FLASH_LATENCY_7)\r\n  {\r\n  }\r\n  LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);\r\n  LL_PWR_EnableOverDriveMode();\r\n  LL_RCC_HSE_EnableBypass();\r\n  LL_RCC_HSE_Enable();\r\n\r\n   /* Wait till HSE is ready */\r\n  while(LL_RCC_HSE_IsReady() != 1)\r\n  {\r\n\r\n  }\r\n  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, LL_RCC_PLLM_DIV_4, 216, LL_RCC_PLLP_DIV_2);\r\n  LL_RCC_PLL_ConfigDomain_48M(LL_RCC_PLLSOURCE_HSE, LL_RCC_PLLM_DIV_4, 216, LL_RCC_PLLQ_DIV_9);\r\n  LL_RCC_PLL_Enable();\r\n\r\n   /* Wait till PLL is ready */\r\n  while(LL_RCC_PLL_IsReady() != 1)\r\n  {\r\n\r\n  }\r\n  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);\r\n  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_4);\r\n  LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_2);\r\n  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);\r\n\r\n   /* Wait till System clock is ready */\r\n  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)\r\n  {\r\n\r\n  }\r\n  LL_SetSystemCoreClock(216000000);\r\n\r\n   /* Update the time base */\r\n  if (HAL_InitTick (TICK_INT_PRIORITY) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief USART3 Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_USART3_UART_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN USART3_Init 0 */\r\n\r\n  /* USER CODE END USART3_Init 0 */\r\n\r\n  LL_USART_InitTypeDef USART_InitStruct = {0};\r\n\r\n  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n\r\n  LL_RCC_SetUSARTClockSource(LL_RCC_USART3_CLKSOURCE_PCLK1);\r\n\r\n  /* Peripheral clock enable */\r\n  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART3);\r\n\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);\r\n  /**USART3 GPIO Configuration\r\n  PD8   ------> USART3_TX\r\n  PD9   ------> USART3_RX\r\n  */\r\n  GPIO_InitStruct.Pin = STLK_RX_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;\r\n  LL_GPIO_Init(STLK_RX_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  GPIO_InitStruct.Pin = STLK_TX_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;\r\n  LL_GPIO_Init(STLK_TX_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /* USART3 DMA Init */\r\n\r\n  /* USART3_RX Init */\r\n  LL_DMA_SetChannelSelection(DMA1, LL_DMA_STREAM_1, LL_DMA_CHANNEL_4);\r\n\r\n  LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_STREAM_1, LL_DMA_DIRECTION_PERIPH_TO_MEMORY);\r\n\r\n  LL_DMA_SetStreamPriorityLevel(DMA1, LL_DMA_STREAM_1, LL_DMA_PRIORITY_LOW);\r\n\r\n  LL_DMA_SetMode(DMA1, LL_DMA_STREAM_1, LL_DMA_MODE_NORMAL);\r\n\r\n  LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_STREAM_1, LL_DMA_PERIPH_NOINCREMENT);\r\n\r\n  LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_STREAM_1, LL_DMA_MEMORY_INCREMENT);\r\n\r\n  LL_DMA_SetPeriphSize(DMA1, LL_DMA_STREAM_1, LL_DMA_PDATAALIGN_BYTE);\r\n\r\n  LL_DMA_SetMemorySize(DMA1, LL_DMA_STREAM_1, LL_DMA_MDATAALIGN_BYTE);\r\n\r\n  LL_DMA_DisableFifoMode(DMA1, LL_DMA_STREAM_1);\r\n\r\n  /* USER CODE BEGIN USART3_Init 1 */\r\n\r\n  /* USER CODE END USART3_Init 1 */\r\n  USART_InitStruct.BaudRate = 115200;\r\n  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;\r\n  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;\r\n  USART_InitStruct.Parity = LL_USART_PARITY_NONE;\r\n  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;\r\n  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\r\n  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;\r\n  LL_USART_Init(USART3, &USART_InitStruct);\r\n  LL_USART_ConfigAsyncMode(USART3);\r\n  LL_USART_Enable(USART3);\r\n  /* USER CODE BEGIN USART3_Init 2 */\r\n\r\n  /* USER CODE END USART3_Init 2 */\r\n\r\n}\r\n\r\n/**\r\n  * @brief USB_OTG_FS Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_USB_OTG_FS_PCD_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN USB_OTG_FS_Init 0 */\r\n\r\n  /* USER CODE END USB_OTG_FS_Init 0 */\r\n\r\n  /* USER CODE BEGIN USB_OTG_FS_Init 1 */\r\n\r\n  /* USER CODE END USB_OTG_FS_Init 1 */\r\n  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;\r\n  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;\r\n  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;\r\n  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;\r\n  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;\r\n  hpcd_USB_OTG_FS.Init.Sof_enable = ENABLE;\r\n  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;\r\n  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;\r\n  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;\r\n  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;\r\n  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  /* USER CODE BEGIN USB_OTG_FS_Init 2 */\r\n\r\n  /* USER CODE END USB_OTG_FS_Init 2 */\r\n\r\n}\r\n\r\n/**\r\n  * Enable DMA controller clock\r\n  */\r\nvoid MX_DMA_Init(void)\r\n{\r\n\r\n  /* Init with LL driver */\r\n  /* DMA controller clock enable */\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);\r\n\r\n  /* DMA interrupt init */\r\n  /* DMA1_Stream1_IRQn interrupt configuration */\r\n  NVIC_SetPriority(DMA1_Stream1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\r\n  NVIC_EnableIRQ(DMA1_Stream1_IRQn);\r\n\r\n}\r\n\r\n/**\r\n  * @brief GPIO Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_GPIO_Init(void)\r\n{\r\n  LL_EXTI_InitTypeDef EXTI_InitStruct = {0};\r\n  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n\r\n  /* GPIO Ports Clock Enable */\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOH);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOG);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(LD1_GPIO_Port, LD1_Pin);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(LD3_GPIO_Port, LD3_Pin);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(USB_PowerSwitchOn_GPIO_Port, USB_PowerSwitchOn_Pin);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(LD2_GPIO_Port, LD2_Pin);\r\n\r\n  /**/\r\n  LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTC, LL_SYSCFG_EXTI_LINE13);\r\n\r\n  /**/\r\n  EXTI_InitStruct.Line_0_31 = LL_EXTI_LINE_13;\r\n  EXTI_InitStruct.LineCommand = ENABLE;\r\n  EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;\r\n  EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING;\r\n  LL_EXTI_Init(&EXTI_InitStruct);\r\n\r\n  /**/\r\n  LL_GPIO_SetPinPull(USER_Btn_GPIO_Port, USER_Btn_Pin, LL_GPIO_PULL_NO);\r\n\r\n  /**/\r\n  LL_GPIO_SetPinMode(USER_Btn_GPIO_Port, USER_Btn_Pin, LL_GPIO_MODE_INPUT);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_MDC_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_MDC_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_REF_CLK_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_REF_CLK_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_MDIO_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_MDIO_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_CRS_DV_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_CRS_DV_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_RXD0_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_RXD0_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_RXD1_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_RXD1_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = LD1_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(LD1_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_TXD1_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_TXD1_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = LD3_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(LD3_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = USB_OverCurrent_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_TX_EN_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_TX_EN_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = RMII_TXD0_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_11;\r\n  LL_GPIO_Init(RMII_TXD0_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = LD2_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);\r\n\r\n}\r\n\r\n/* USER CODE BEGIN 4 */\r\n\r\n/* USER CODE END 4 */\r\n\r\n/**\r\n  * @brief  Period elapsed callback in non blocking mode\r\n  * @note   This function is called  when TIM5 interrupt took place, inside\r\n  * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment\r\n  * a global variable \"uwTick\" used as application time base.\r\n  * @param  htim : TIM handle\r\n  * @retval None\r\n  */\r\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* USER CODE BEGIN Callback 0 */\r\n\r\n  /* USER CODE END Callback 0 */\r\n  if (htim->Instance == TIM5) {\r\n    HAL_IncTick();\r\n  }\r\n  /* USER CODE BEGIN Callback 1 */\r\n\r\n  /* USER CODE END Callback 1 */\r\n}\r\n\r\n/**\r\n  * @brief  This function is executed in case of error occurrence.\r\n  * @retval None\r\n  */\r\nvoid Error_Handler(void)\r\n{\r\n  /* USER CODE BEGIN Error_Handler_Debug */\r\n  /* User can add his own implementation to report the HAL error return state */\r\n  __disable_irq();\r\n  while (1)\r\n  {\r\n  }\r\n  /* USER CODE END Error_Handler_Debug */\r\n}\r\n\r\n#ifdef  USE_FULL_ASSERT\r\n/**\r\n  * @brief  Reports the name of the source file and the source line number\r\n  *         where the assert_param error has occurred.\r\n  * @param  file: pointer to the source file name\r\n  * @param  line: assert_param error line source number\r\n  * @retval None\r\n  */\r\nvoid assert_failed(uint8_t *file, uint32_t line)\r\n{\r\n  /* USER CODE BEGIN 6 */\r\n  /* User can add his own implementation to report the file name and line number,\r\n     ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */\r\n  /* USER CODE END 6 */\r\n}\r\n#endif /* USE_FULL_ASSERT */\r\n\r\n\n/*SimulinkGeneratedCode*/\n"},{"name":"pil_main.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\pil","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2013 The MathWorks, Inc. */\n\n/* \n* File: pil_main.c\n*\n* PIL main\n*\n*/ \n\n#include \"xil_interface_lib.h\"\n\nint PILmain(void){\nXIL_INTERFACE_LIB_ERROR_CODE errorCode = XIL_INTERFACE_LIB_SUCCESS;\nint errorOccurred = 0;\n/* avoid warnings about infinite loops */\nvolatile int loop = 1;   \n\n/* XIL initialization */   \nconst int argc = 0;\nvoid * argv = (void *) 0;\nerrorCode = xilInit(argc, argv);\nerrorOccurred = (errorCode != XIL_INTERFACE_LIB_SUCCESS);\n\n/* main XIL loop */\nwhile(loop && !errorOccurred) {\nerrorCode = xilRun();\nif (errorCode != XIL_INTERFACE_LIB_SUCCESS) {\nif (errorCode == XIL_INTERFACE_LIB_TERMINATE) {\n/* orderly shutdown of rtiostream */\nerrorOccurred = (xilTerminateComms() != XIL_INTERFACE_LIB_SUCCESS);\n} else {\nerrorOccurred = 1;\n}\n}\n}\n\n/* trap error with infinite loop */\nif (errorOccurred)\nwhile (loop) { }\n\nreturn errorCode;\n}\n#include \"main.h\" \nint main(void){\nHAL_Init();\nSystemClock_Config();\nPeriphCommonClock_Config();\nMX_GPIO_Init();\nMX_DMA_Init();\nMX_USART3_UART_Init();\nMX_USB_OTG_FS_PCD_Init();\nint errorCode = PILmain(); \nreturn errorCode; } \n"},{"name":"platform_timer.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2021-2024 The MathWorks, Inc. */\n\n#include \"mw_stm32_types.h\"\n#include \"main.h\"\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x)  #x\n\n#define MW_StringifyDefineHeader(x) MW_StringifyDefineHeaderExpand(x)\n#define MW_StringifyDefineHeaderExpand(x)  x.h\n\n\nstatic volatile uint32_T timestampInitialized = 0;\nstatic volatile uint32_T timestampStartTime = 0;\n\n__weak void PeriphCommonClock_Config(void){};\n\n__attribute__((optimize(\"O3\"))) uint32_T getCurrentTimestampInMicros(void)\n{\n    uint32_T currentTime;\n    __IO uint32_T timeInMs;\n    __IO uint32_T timeInMicroTick;\n    \n    timeInMicroTick = (uint32_t)(MW_TIMEBASESOURCE->CNT);\n    timeInMs = GET_CURRENT_TIME();\n\n    /* Check timer is overrun before calculating time in micros */\n    if (timeInMicroTick > (uint32_t)((MW_TIMEBASESOURCE)->CNT))\n    {\n        currentTime = GET_CURRENT_TIME()*1000 + (uint32_t)((MW_TIMEBASESOURCE)->CNT);\n    }\n    else\n    {\n        currentTime = timeInMs*1000 + timeInMicroTick;\n    }\n\n    return currentTime;\n}\n\n__attribute__((optimize(\"O3\"))) uint32_T returnTimeElapsed(uint32_T timestampStartTime, boolean_T isTimeInMS)\n{\n    uint32_T currentTime;\n    uint32_T ret = 0;\n    \n    if(0 == isTimeInMS)\n    {\n        currentTime = getCurrentTimestampInMicros();\n    }\n    else\n    {\n        currentTime = GET_CURRENT_TIME();\n    }\n    \n    if (currentTime >= timestampStartTime)\n    {\n        ret = (uint32_T) (currentTime - timestampStartTime);\n    }\n    else\n    {\n        ret = (uint32_T) (UINT32_MAX - timestampStartTime + currentTime);\n    }\n    return ret ;\n}\n\n#if defined(EXT_MODE) && (EXT_MODE == 1) && !defined(XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME)\n#include MW_StringifyDefine(MW_StringifyDefineHeader(MODEL))\nstatic void timestampInit(void)\n{\n    if (0 == timestampInitialized)\n    {\n        timestampStartTime =  GET_CURRENT_TIME_IN_US();\n        timestampInitialized = 1;\n    }\n}\n\n__attribute__((optimize(\"O3\"))) uint32_t getCurrentTimestamp(void)\n{\n    uint32_T ret = 0;\n    if ((1 == runModel) || (1 == timestampInitialized))\n    {\n        if (0 == timestampInitialized)\n        {\n            timestampInit();\n        }\n        ret = returnTimeElapsed(timestampStartTime, 0);\n    }\n    else\n    {\n        timestampStartTime =  GET_CURRENT_TIME_IN_US();\n    }\n    return ret;\n}\n#endif\n\n/* LocalWords:  TIMEBASESOURCE\n */\n"},{"name":"profiler_timer.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\target\\shared\\armcortexmbase\\profile\\src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2022 The MathWorks, Inc. */\n\n#if !defined(MW_FREERTOS) && !defined(USE_RTX)\n\n#define MW_NVIC_SYSTICK_CTRL_CLK_SRC    0x00000004  // Clock Source\n#define MW_NVIC_SYSTICK_INT_ENABLE_SRC  0x00000002  // Interrupt enable \n#define MW_NVIC_SYSTICK_CTRL_ENABLE     0x00000001  // Enable\n\n#define MW_MAX_SYSTICK_COUNT\t\t\t0x00FFFFFF\n\n\n/* Define SYSTICK core registers */\nvolatile unsigned long* SYSTICK_RELOAD  = (volatile unsigned long*)0xE000E014;\nvolatile unsigned long* SYSTICK_CURRENT = (volatile unsigned long*)0xE000E018;\nvolatile unsigned long* SYSTICK_CTRL    = (volatile unsigned long*)0xE000E010;\n\n/* Flag to initialize the timer */\nunsigned char initTimer = 0;\n/* Counter to count sysTick reaching to zero */\nvolatile unsigned long sysTickZeroCount = 0;\n\nunsigned long profileTimerRead(void)\n{\n\tunsigned long timerVal = 0;\n\t\n\t/* Removing the sign extension add at the end of this function */\n\tif(0 == initTimer) {\n\t    /*When initTimer is null, it is xilProfilingSectionStart */\n\t\t*SYSTICK_RELOAD  = MW_MAX_SYSTICK_COUNT;\n\t\t*SYSTICK_CTRL    = MW_NVIC_SYSTICK_CTRL_CLK_SRC | MW_NVIC_SYSTICK_CTRL_ENABLE | MW_NVIC_SYSTICK_INT_ENABLE_SRC;\n\t\t*SYSTICK_CURRENT = MW_MAX_SYSTICK_COUNT;\n\t\t\n\t\tinitTimer = 1;\n\t} else {\n\t    /*When initTimer is NOT null, it is xilProfilingSectionEnd*/\n\t\t\t/* Up counting */\n\t\ttimerVal = (MW_MAX_SYSTICK_COUNT - *SYSTICK_CURRENT);\n\t}\n\t\n\ttimerVal = sysTickZeroCount + timerVal;\n\t\n    return(timerVal);\n}\n\nvoid SysTick_Handler(void)\n{\n\tsysTickZeroCount += (MW_MAX_SYSTICK_COUNT + 1);\n}\n\n#else\n\n/* In profile_timer.h file, the profileTimerRead() is mapped to osKernelSysTick(). */\n\n#endif\n\n/* EOF */\n"},{"name":"profiler_timer.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\target\\shared\\armcortexmbase\\profile\\include","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2022 The MathWorks, Inc. */\n#ifndef _PROFILER_TIMER_H_\n#define _PROFILER_TIMER_H_\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n    \n#if !defined(MW_FREERTOS) && !defined(USE_RTX)\n    extern unsigned long profileTimerRead(void);\n#else\n    #include \"cmsis_os.h\"\n    #define profileTimerRead() osKernelSysTick()\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* _PROFILER_TIMER_H_ */\n/* EOF */\n"},{"name":"rtiostream.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\coder\\rtiostream\\src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\n * Copyright 2007-2012 The MathWorks, Inc.\n *\n * File: rtiostream.h     \n *\n * Abstract:\n *  Function prototypes and defines for rtIOStream API.\n */\n\n#ifndef RTIOSTREAM_H\n#define RTIOSTREAM_H\n\n#include <stddef.h>\n\n#define RTIOSTREAM_ERROR (-1)\n#define RTIOSTREAM_NO_ERROR (0)\n\n/* Note: if the functions declared in this file should be compiled into a shared\n * library (e.g. a .dll file on Windows), you must ensure that the functions are\n * externally visible. The procedure to achieve this depends on the compiler and\n * linker you are using. For example, on Windows, you may need to provide an\n * exports definition .def file that lists all of the functions to be\n * exported; see ./rtiostream/rtiostream_pc.def for a suitable .def file.\n */\n\n#ifndef RTIOSTREAMAPI\n#define RTIOSTREAMAPI \n#endif \n\nRTIOSTREAMAPI int rtIOStreamOpen(\n    int    argc,\n    void * argv[]\n);\n\nRTIOSTREAMAPI int rtIOStreamSend(\n    int          streamID,\n    const void * src, \n    size_t       size,\n    size_t     * sizeSent\n    );\n\nRTIOSTREAMAPI int rtIOStreamRecv(\n    int      streamID,\n    void   * dst, \n    size_t   size,\n    size_t * sizeRecvd\n    );\n\nRTIOSTREAMAPI int rtIOStreamClose(\n    int streamID\n    );\n\n\n#endif /* #ifndef RTIOSTREAM_H */\n"},{"name":"rtiostream_serial.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\n* File: rtiostream_serial.c\n* Copyright 2021-2024 The MathWorks, Inc.\n*/\n\n#include \"stm_lpuart.h\"\n\n#ifndef _rtiostream\n\n#include \"rtiostream.h\"\n\n#define _rtiostream\n#endif\n\n#if defined(LPUART1) && (MW_CONNECTIVITY_UART == LPUART1_BASE)\n    #define MW_LPUART_RTIOSTREAM_USED 1\n#else\n    #define MW_LPUART_RTIOSTREAM_USED 0\n#endif\n\n\n#include \"MW_target_hardware_resources.h\"\n#ifndef MW_SERIAL_RX_BUFFER_SIZE\n#define MW_SERIAL_RX_BUFFER_SIZE 1024\n#endif\n#if defined(MW_CONNECTIVITY_TX_DMA) && !defined(MW_SERIAL_TX_BUFFER_SIZE)\n#define MW_SERIAL_TX_BUFFER_SIZE 1024\n#endif\n\nUART_Type_T * mw_ext_h;\nuint8_T * UARTTxBuffer;\nuint8_T * UARTRxBuffer;\n\nUART_Type_T uartObj = {\n\t\t\t.peripheralPtr                          = (void *)MW_CONNECTIVITY_UART,\n\t\t\t.rxdmaPeripheralPtr                     = (void *)MW_CONNECTIVITY_RX_DMA,\n\t\t#ifdef MW_CONNECTIVITY_TX_DMA\n\t\t\t.txdmaPeripheralPtr                     = (void *)MW_CONNECTIVITY_TX_DMA,\n\t\t#else\n\t\t\t.txdmaPeripheralPtr                     = NULL,\n\t\t#endif\n\t\t\t.txDMATransferLength                    = 0,\n\t\t\t.rxdmastream                            = (uint8_T)MW_CONNECTIVITY_RX_DMAStream,\n\t\t#ifdef MW_CONNECTIVITY_TX_DMA\n\t\t\t.txdmastream                            = (uint8_T)MW_CONNECTIVITY_TX_DMAStream,\n\t\t#else\n\t\t\t.txdmastream                            = 0,\n\t\t#endif\n\t\t\t.txeEnabled                             = 0,\n\t\t\t.txdmaEnabled                           = 0,\n\t\t\t.disableDMAIntOnError                   = 0,\n\t\t\t.enableRxOrTx                           = UART_ENABLE_BOTH,\n\t\t#ifdef MW_CONNECTIVITY_TX_DMA\n\t\t\t.mode                                   = (UART_RX_DMA_MODE | UART_TX_DMA_MODE),\n        #else\n\t\t\t.mode                                   = (UART_RX_DMA_MODE | UART_TX_POLLING_MODE),    \n        #endif\n\t\t\t.errorStatus                            = MW_SCI_SUCCESS,\n\t\t\t.uartStatus                             = MW_SCI_SUCCESS,\n\t\t\t.buffer                                 = {\n\t\t\t\t.rxBufferPtr                            = NULL,\n\t\t\t    .txBufferPtr                            = NULL,\n\t\t\t\t.rxBufferSize                           = MW_SERIAL_RX_BUFFER_SIZE, \n\t\t#ifdef MW_CONNECTIVITY_TX_DMA\n\t\t\t\t.txBufferSize                           = MW_SERIAL_TX_BUFFER_SIZE, \n\t\t#else\n\t\t\t\t.txBufferSize                           = 0,\n\t\t#endif\n\t\t\t\t.readPos                                = 0,\n\t\t\t\t.toReadPos                              = 0,\n\t\t\t\t.writePos                               = 0,\n\t\t\t\t.sentPos                                = 0,\n\t\t\t\t.writeRollOver                          = 0\n\t\t\t}\n\t};\n\n/* Function: rtIOStreamOpen =================================================\n* Abstract:\n*  Open the connection with the target.\n*/\nint rtIOStreamOpen(int argc, void * argv[])\n{\n    int result = RTIOSTREAM_NO_ERROR;\n\tUARTRxBuffer = MW_CONNECTIVITY_RX_BUFFER;\n\tuartObj.buffer.rxBufferPtr = UARTRxBuffer;\n\t\n\t#ifdef MW_CONNECTIVITY_TX_DMA   \n\t\tUARTTxBuffer = MW_CONNECTIVITY_TX_BUFFER;\n\t\tuartObj.buffer.txBufferPtr = UARTTxBuffer;\n\t#endif\n    #if (1 == MW_LPUART_RTIOSTREAM_USED)\n    mw_ext_h = MW_LPUART_Initialize(&uartObj);\n    #else\n    mw_ext_h = MW_UART_Initialize(&uartObj);\n    #endif\n\n    return result;\n}\n\n/* Function: rtIOStreamSend =====================================================\n* Abstract:\n*  Sends the specified number of bytes on the serial line. Returns the number of\n*  bytes sent (if successful) or a negative value if an error occurred.\n*/\nint rtIOStreamSend(\n    int          streamID,\n    const void * src,\n    size_t       size,\n    size_t     * sizeSent)\n{\n    *sizeSent = 0;\n\n    #ifdef MW_CONNECTIVITY_TX_DMA\n        #if 1 == MW_LPUART_RTIOSTREAM_USED\n        MW_LPUART_TransmitUsingDMA(mw_ext_h, (uint8_T *)src, (uint32_T)size, 0, sizeSent);\n        #else\n        MW_UART_TransmitUsingDMA(mw_ext_h, (uint8_T *)src, (uint32_T)size, 0, sizeSent);\n        #endif\n    #else\n        #if 1 == MW_LPUART_RTIOSTREAM_USED\n        MW_LPUART_TransmitUsingPolling(mw_ext_h, (uint8_T *)src, (uint32_T)size, 1000, sizeSent);\n        #else\n        MW_UART_TransmitUsingPolling(mw_ext_h, (uint8_T *)src, (uint32_T)size, 1000, sizeSent);\n        #endif\n    #endif\n\n    return RTIOSTREAM_NO_ERROR;\n}\n\n/* Function: rtIOStreamRecv ================================================\n* Abstract: receive data\n*\n*/\nint rtIOStreamRecv(\n    int      streamID,\n    void   * dst,\n    size_t   size,\n    size_t * sizeRecvd)\n{\n    *sizeRecvd = 0U;\n    uint32_T dataToRead = getBytesToBeReadFromBuffer(mw_ext_h,(uint32_T)size,0);\n\n    if(dataToRead > 0)\n    {\n        #if 1 == MW_LPUART_RTIOSTREAM_USED\n        MW_LPUART_ReceiveUsingBuffer(mw_ext_h, (uint8_T *)dst, dataToRead, sizeRecvd);\n        #else\n    \tMW_UART_ReceiveUsingBuffer(mw_ext_h, (uint8_T *)dst, dataToRead, sizeRecvd);\n        #endif\n    }\n    return RTIOSTREAM_NO_ERROR;\n}\n\n\n/* Function: rtIOStreamClose ================================================\n* Abstract: close the connection.\n*\n*/\nint rtIOStreamClose(int streamID)\n{\n    /* Killing comms explicitly.\n    * Destructor is safe.\n    */\n    #if 1 == MW_LPUART_RTIOSTREAM_USED\n    MW_LPUART_DeInit(mw_ext_h);\n    #else\n    MW_UART_DeInit(mw_ext_h);\n    #endif\n\n    return RTIOSTREAM_NO_ERROR;\n}\n\n/* LocalWords:  rtIOStreamRecv\n */\n"},{"name":"rtiostream_utils.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\coder\\rtiostream\\src\\utils","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n\n#include \"rtiostream_utils.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\" \n\n/* TARGET_CONNECTIVITY_TESTING might be defined by some MathWorks tests for\n * testing purposes only. In this case, we force SIZE_MAX to be 4 so we \n * could test the pointer arithmetic in rtIOStreamBlockingSend and\n * rtIOStreamBlockingRecv.\n */ \n#ifdef TARGET_CONNECTIVITY_TESTING\n    #define SIZE_MAX 4\n#else\n    /* define SIZE_MAX if not already defined (e.g. by a C99 compiler) */\n    #ifndef SIZE_MAX\n        #define SIZE_MAX ((size_t)-1)\n    #endif\n#endif\n\n#ifndef MemUnit_T\n   /* External Mode */\n   typedef unsigned char IOUnit_T; \n#else\n   /* SIL/PIL */\n   #ifdef HOST_WORD_ADDRESSABLE_TESTING\n      /* rtIOStream will handle data in single byte chunks \n       *\n       * uint8_T can be > 8-bits for certain portable word sizes \n       * cases (e.g. C2000) so use native type instead */\n      typedef unsigned char IOUnit_T;\n   #else\n      /* rtIOStream will handle data in MemUnit_T size chunks */\n      typedef MemUnit_T IOUnit_T;\n   #endif\n#endif\n\n/* Blocks until all requested outgoing data is sent */\nint rtIOStreamBlockingSend(const int streamID, \n                           const void * const src, \n                           uint32_T size) {\n\n    size_t transferAmount;\n    size_t sizeSent;\n    int errorCode      = RTIOSTREAM_NO_ERROR;   \n    const IOUnit_T * srcPtr = (const IOUnit_T *) src;\n    \n    /* use a variable to avoid SIZE_MAX being treated as a constant\n     * which leads to compiler warnings for \"MIN\" on platforms where\n     * SIZE_MAX > UINT32_MAX */\n    size_t sizeMax = SIZE_MAX;\n    while (size > 0) {\n        /* support full uint32 size */\n        transferAmount = (size_t) MIN(sizeMax, size);        \n        errorCode = rtIOStreamSend(streamID,\n                                   (const void *) srcPtr,\n                                   transferAmount,\n                                   &sizeSent);\n        if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n        }\n        else {            \n            size -= (uint32_T) sizeSent;\n            srcPtr += sizeSent;\n        }\n    }\n    return errorCode;\n}\n\n/* Blocks until all requested incoming data is received */\nint rtIOStreamBlockingRecv(const int streamID,\n                           void * const dst,\n                           uint32_T size) {\n\n   size_t transferAmount;\n   size_t sizeRecvd;\n   int errorCode      = RTIOSTREAM_NO_ERROR;\n   IOUnit_T * dstPtr = (IOUnit_T *) dst;\n   \n   /* use a variable to avoid SIZE_MAX being treated as a constant\n    * which leads to compiler warnings for \"MIN\" on platforms where \n    * SIZE_MAX > UINT32_MAX */\n   size_t sizeMax = SIZE_MAX;\n   while (size > 0) {\n      /* support full uint32 size */\n      transferAmount = (size_t) MIN(sizeMax, size);      \n      errorCode = rtIOStreamRecv(streamID, \n                                 (void *) dstPtr, \n                                 transferAmount, \n                                 &sizeRecvd);\n      if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n      }\n      else {          \n         size -= (uint32_T) sizeRecvd;\n         dstPtr += sizeRecvd;\n      }\n   }\n   return errorCode;\n}\n\n\n"},{"name":"rtiostream_utils.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\coder\\rtiostream\\src\\utils","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2012-2022 The MathWorks, Inc. */\n\n#ifndef _RTIOSTREAM_UTILS_H_\n#define _RTIOSTREAM_UTILS_H_\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \n/* Target-side rtIOStream utility APIs */\n\n#include \"rtwtypes.h\"\n\n#include <stddef.h>   /* include definition of size_t */\n\n/* MIN utility */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n          \n/* Blocks until all requested outgoing data is sent. */\nextern int rtIOStreamBlockingSend(const int streamID,\n                                  const void * const src,\n                                  uint32_T size);\n\n/* Blocks until all requested incoming data is received. */\nextern int rtIOStreamBlockingRecv(const int streamID,\n                                  void * const dst,\n                                  uint32_T size);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _RTIOSTREAM_UTILS_H_ */\n"},{"name":"rx_tx_buffer_sizes.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2022 The MathWorks, Inc. */\n\n/* \n * File: rx_tx_buffer_sizes.h\n *\n * Defines the buffer sizes for the various XIL services.\n * Make sure we are backwards compatible with PIL implementations that \n * define RTIOSTREAM_TX_BUFFER_BYTE_SIZE and RTIOSTREAM_RX_BUFFER_BYTE_SIZE\n * in their connectivity config. We will use these preprocessor defines to\n * derive both the RX and TX buffer sizes for the various XIL services and\n * make sure we don't incur more memory requirements.\n * @note: these buffer sizes are considered without headers. Each service will add the header size\n *        to its buffers.\n */\n\n#ifndef __RX_TX_BUFFER_SIZES_H__\n#define __RX_TX_BUFFER_SIZES_H__\n\n#include \"rtwtypes.h\"\n\n#if (RTIOSTREAM_TX_BUFFER_BYTE_SIZE < MEM_UNIT_BYTES) || (RTIOSTREAM_RX_BUFFER_BYTE_SIZE < MEM_UNIT_BYTES)\n#error \"RTIOSTREAM buffer sizes must be larger or equal to the minimum size of an object\"\n#endif\n\n/* transmit buffer size in mem units - no need to worry about fractions \n * as division in C always floors the result. \n */\n#define RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE (RTIOSTREAM_TX_BUFFER_BYTE_SIZE / MEM_UNIT_BYTES)\n\n/* Receive buffer size */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n#define RTIOSTREAM_RX_BUFFER_SIZE ((RTIOSTREAM_RX_BUFFER_BYTE_SIZE) + BUFFER_HEADER_SIZE)\n#else\n#define RTIOSTREAM_RX_BUFFER_SIZE ((RTIOSTREAM_RX_BUFFER_BYTE_SIZE / MEM_UNIT_BYTES) + BUFFER_HEADER_SIZE)\n#endif\n\n/* # app services sharing the TX buffer allocation */\n#ifdef CODE_INSTRUMENTATION_ENABLED\n   #define NUM_APPS_SHARING_TX 2\n#else\n   /* XIL */\n   #define NUM_APPS_SHARING_TX 1\n#endif\n\n/* send buffer sizes for applications */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* buffer is actually defined in terms of \"byte\" IOUnits \n    * so use BYTE_SIZE to make sure we have the same effective \n    * buffer size during PWS */\n   #define XIL_TX_BUFFER_MEMUNIT_SIZE ((RTIOSTREAM_TX_BUFFER_BYTE_SIZE / NUM_APPS_SHARING_TX) + BUFFER_HEADER_SIZE + COMMAND_COMPLETE_SIZE)\n#else\n   #define XIL_TX_BUFFER_MEMUNIT_SIZE ((RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE / NUM_APPS_SHARING_TX) + BUFFER_HEADER_SIZE + COMMAND_COMPLETE_SIZE)\n#endif\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n   #define CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE XIL_TX_BUFFER_MEMUNIT_SIZE\n#endif\n\n#if CODER_ASSUMPTIONS_ENABLED == 1\n/* buffer includes space for BUFFER_HEADER_SIZE */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* buffer is actually defined in terms of \"byte\" IOUnits \n    * so multiply up to make sure we have the same effective \n    * buffer size during PWS */\n   #define CA_TX_BUFFER_MEMUNIT_SIZE (32 * MEM_UNIT_BYTES)\n   #if CA_TX_BUFFER_MEMUNIT_SIZE > RTIOSTREAM_TX_BUFFER_BYTE_SIZE\n     #error \"Coder assumptions transmit buffer size must be less than or equal to the overall rtiostream transmit buffer size.   Increase RTIOSTREAM_TX_BUFFER_BYTE_SIZE accordingly.\"\n   #endif\n#else\n   /* simply reserve a 32 memunit buffer */\n   #define CA_TX_BUFFER_MEMUNIT_SIZE 32\n   #if CA_TX_BUFFER_MEMUNIT_SIZE > RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE\n     #error \"Coder assumptions transmit buffer size must be less than or equal to the overall rtiostream transmit buffer size.   Increase RTIOSTREAM_TX_BUFFER_BYTE_SIZE accordingly.\"\n   #endif\n#endif\n\n#endif\n\n#define APPLICATION_ID_SIZE (sizeof(MemUnit_T))\n#define WRITE_DATA_AVAIL_SIZE (sizeof(uint32_T))\n#define BUFFER_HEADER_SIZE  (APPLICATION_ID_SIZE + WRITE_DATA_AVAIL_SIZE)\n#define APPLICATION_ID_IDX 0\n#define PAYLOAD_SIZE_IDX (APPLICATION_ID_IDX + APPLICATION_ID_SIZE)\n#define PAYLOAD_IDX (PAYLOAD_SIZE_IDX + WRITE_DATA_AVAIL_SIZE)\n#define COMMAND_COMPLETE_SIZE (sizeof(MemUnit_T))\n\n#endif /*__RX_TX_BUFFER_SIZES_H__ */\n\n"},{"name":"startup_stm32f767zitx.s","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\STM32CubeIDE\\Application\\User\\Startup","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file      startup_stm32f767xx.s\r\n  * @author    MCD Application Team\r\n  * @brief     STM32F767xx Devices vector table for GCC based toolchain. \r\n  *            This module performs:\r\n  *                - Set the initial SP\r\n  *                - Set the initial PC == Reset_Handler,\r\n  *                - Set the vector table entries with the exceptions ISR address\r\n  *                - Branches to main in the C library (which eventually\r\n  *                  calls main()).\r\n  *            After Reset the Cortex-M7 processor is in Thread mode,\r\n  *            priority is Privileged, and the Stack is set to Main.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2016 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n    \r\n  .syntax unified\r\n  .cpu cortex-m7\r\n  .fpu softvfp\r\n  .thumb\r\n\r\n.global  g_pfnVectors\r\n.global  Default_Handler\r\n\r\n/* start address for the initialization values of the .data section. \r\ndefined in linker script */\r\n.word  _sidata\r\n/* start address for the .data section. defined in linker script */  \r\n.word  _sdata\r\n/* end address for the .data section. defined in linker script */\r\n.word  _edata\r\n/* start address for the .bss section. defined in linker script */\r\n.word  _sbss\r\n/* end address for the .bss section. defined in linker script */\r\n.word  _ebss\r\n/* stack used for SystemInit_ExtMemCtl; always internal RAM used */\r\n\r\n/**\r\n * @brief  This is the code that gets called when the processor first\r\n *          starts execution following a reset event. Only the absolutely\r\n *          necessary set is performed, after which the application\r\n *          supplied main() routine is called. \r\n * @param  None\r\n * @retval : None\r\n*/\r\n\r\n    .section  .text.Reset_Handler\r\n  .weak  Reset_Handler\r\n  .type  Reset_Handler, %function\r\nReset_Handler:  \r\n  ldr   sp, =_estack      /* set stack pointer */\r\n\r\n/* Copy the data segment initializers from flash to SRAM */  \r\n  ldr r0, =_sdata\r\n  ldr r1, =_edata\r\n  ldr r2, =_sidata\r\n  movs r3, #0\r\n  b LoopCopyDataInit\r\n\r\nCopyDataInit:\r\n  ldr r4, [r2, r3]\r\n  str r4, [r0, r3]\r\n  adds r3, r3, #4\r\n\r\nLoopCopyDataInit:\r\n  adds r4, r0, r3\r\n  cmp r4, r1\r\n  bcc CopyDataInit\r\n  \r\n/* Zero fill the bss segment. */\r\n  ldr r2, =_sbss\r\n  ldr r4, =_ebss\r\n  movs r3, #0\r\n  b LoopFillZerobss\r\n\r\nFillZerobss:\r\n  str  r3, [r2]\r\n  adds r2, r2, #4\r\n\r\nLoopFillZerobss:\r\n  cmp r2, r4\r\n  bcc FillZerobss\r\n\r\n/* Call the clock system initialization function.*/\r\n  bl  SystemInit   \r\n/* Call static constructors */\r\n    bl __libc_init_array\r\n/* Call the application's entry point.*/\r\n  bl  main\r\n  bx  lr    \r\n.size  Reset_Handler, .-Reset_Handler\r\n\r\n/**\r\n * @brief  This is the code that gets called when the processor receives an \r\n *         unexpected interrupt.  This simply enters an infinite loop, preserving\r\n *         the system state for examination by a debugger.\r\n * @param  None     \r\n * @retval None       \r\n*/\r\n    .section  .text.Default_Handler,\"ax\",%progbits\r\nDefault_Handler:\r\nInfinite_Loop:\r\n  b  Infinite_Loop\r\n  .size  Default_Handler, .-Default_Handler\r\n/******************************************************************************\r\n*\r\n* The minimal vector table for a Cortex M7. Note that the proper constructs\r\n* must be placed on this to ensure that it ends up at physical address\r\n* 0x0000.0000.\r\n* \r\n*******************************************************************************/\r\n   .section  .isr_vector,\"a\",%progbits\r\n  .type  g_pfnVectors, %object\r\n  .size  g_pfnVectors, .-g_pfnVectors\r\n   \r\n   \r\ng_pfnVectors:\r\n  .word  _estack\r\n  .word  Reset_Handler\r\n\r\n  .word  NMI_Handler\r\n  .word  HardFault_Handler\r\n  .word  MemManage_Handler\r\n  .word  BusFault_Handler\r\n  .word  UsageFault_Handler\r\n  .word  0\r\n  .word  0\r\n  .word  0\r\n  .word  0\r\n  .word  SVC_Handler\r\n  .word  DebugMon_Handler\r\n  .word  0\r\n  .word  PendSV_Handler\r\n  .word  SysTick_Handler\r\n  \r\n  /* External Interrupts */\r\n  .word     WWDG_IRQHandler                   /* Window WatchDog              */\r\n  .word     PVD_IRQHandler                    /* PVD through EXTI Line detection */\r\n  .word     TAMP_STAMP_IRQHandler             /* Tamper and TimeStamps through the EXTI line */\r\n  .word     RTC_WKUP_IRQHandler               /* RTC Wakeup through the EXTI line */\r\n  .word     FLASH_IRQHandler                  /* FLASH                        */\r\n  .word     RCC_IRQHandler                    /* RCC                          */\r\n  .word     EXTI0_IRQHandler                  /* EXTI Line0                   */\r\n  .word     EXTI1_IRQHandler                  /* EXTI Line1                   */\r\n  .word     EXTI2_IRQHandler                  /* EXTI Line2                   */\r\n  .word     EXTI3_IRQHandler                  /* EXTI Line3                   */\r\n  .word     EXTI4_IRQHandler                  /* EXTI Line4                   */\r\n  .word     DMA1_Stream0_IRQHandler           /* DMA1 Stream 0                */\r\n  .word     DMA1_Stream1_IRQHandler           /* DMA1 Stream 1                */\r\n  .word     DMA1_Stream2_IRQHandler           /* DMA1 Stream 2                */\r\n  .word     DMA1_Stream3_IRQHandler           /* DMA1 Stream 3                */\r\n  .word     DMA1_Stream4_IRQHandler           /* DMA1 Stream 4                */\r\n  .word     DMA1_Stream5_IRQHandler           /* DMA1 Stream 5                */\r\n  .word     DMA1_Stream6_IRQHandler           /* DMA1 Stream 6                */\r\n  .word     ADC_IRQHandler                    /* ADC1, ADC2 and ADC3s         */\r\n  .word     CAN1_TX_IRQHandler                /* CAN1 TX                      */\r\n  .word     CAN1_RX0_IRQHandler               /* CAN1 RX0                     */\r\n  .word     CAN1_RX1_IRQHandler               /* CAN1 RX1                     */\r\n  .word     CAN1_SCE_IRQHandler               /* CAN1 SCE                     */\r\n  .word     EXTI9_5_IRQHandler                /* External Line[9:5]s          */\r\n  .word     TIM1_BRK_TIM9_IRQHandler          /* TIM1 Break and TIM9          */\r\n  .word     TIM1_UP_TIM10_IRQHandler          /* TIM1 Update and TIM10        */\r\n  .word     TIM1_TRG_COM_TIM11_IRQHandler     /* TIM1 Trigger and Commutation and TIM11 */\r\n  .word     TIM1_CC_IRQHandler                /* TIM1 Capture Compare         */\r\n  .word     TIM2_IRQHandler                   /* TIM2                         */\r\n  .word     TIM3_IRQHandler                   /* TIM3                         */\r\n  .word     TIM4_IRQHandler                   /* TIM4                         */\r\n  .word     I2C1_EV_IRQHandler                /* I2C1 Event                   */\r\n  .word     I2C1_ER_IRQHandler                /* I2C1 Error                   */\r\n  .word     I2C2_EV_IRQHandler                /* I2C2 Event                   */\r\n  .word     I2C2_ER_IRQHandler                /* I2C2 Error                   */\r\n  .word     SPI1_IRQHandler                   /* SPI1                         */\r\n  .word     SPI2_IRQHandler                   /* SPI2                         */\r\n  .word     USART1_IRQHandler                 /* USART1                       */\r\n  .word     USART2_IRQHandler                 /* USART2                       */\r\n  .word     USART3_IRQHandler                 /* USART3                       */\r\n  .word     EXTI15_10_IRQHandler              /* External Line[15:10]s        */\r\n  .word     RTC_Alarm_IRQHandler              /* RTC Alarm (A and B) through EXTI Line */\r\n  .word     OTG_FS_WKUP_IRQHandler            /* USB OTG FS Wakeup through EXTI line */\r\n  .word     TIM8_BRK_TIM12_IRQHandler         /* TIM8 Break and TIM12         */\r\n  .word     TIM8_UP_TIM13_IRQHandler          /* TIM8 Update and TIM13        */\r\n  .word     TIM8_TRG_COM_TIM14_IRQHandler     /* TIM8 Trigger and Commutation and TIM14 */\r\n  .word     TIM8_CC_IRQHandler                /* TIM8 Capture Compare         */\r\n  .word     DMA1_Stream7_IRQHandler           /* DMA1 Stream7                 */\r\n  .word     FMC_IRQHandler                    /* FMC                          */\r\n  .word     SDMMC1_IRQHandler                 /* SDMMC1                       */\r\n  .word     TIM5_IRQHandler                   /* TIM5                         */\r\n  .word     SPI3_IRQHandler                   /* SPI3                         */\r\n  .word     UART4_IRQHandler                  /* UART4                        */\r\n  .word     UART5_IRQHandler                  /* UART5                        */\r\n  .word     TIM6_DAC_IRQHandler               /* TIM6 and DAC1&2 underrun errors */\r\n  .word     TIM7_IRQHandler                   /* TIM7                         */\r\n  .word     DMA2_Stream0_IRQHandler           /* DMA2 Stream 0                */\r\n  .word     DMA2_Stream1_IRQHandler           /* DMA2 Stream 1                */\r\n  .word     DMA2_Stream2_IRQHandler           /* DMA2 Stream 2                */\r\n  .word     DMA2_Stream3_IRQHandler           /* DMA2 Stream 3                */\r\n  .word     DMA2_Stream4_IRQHandler           /* DMA2 Stream 4                */\r\n  .word     ETH_IRQHandler                    /* Ethernet                     */\r\n  .word     ETH_WKUP_IRQHandler               /* Ethernet Wakeup through EXTI line */\r\n  .word     CAN2_TX_IRQHandler                /* CAN2 TX                      */\r\n  .word     CAN2_RX0_IRQHandler               /* CAN2 RX0                     */\r\n  .word     CAN2_RX1_IRQHandler               /* CAN2 RX1                     */\r\n  .word     CAN2_SCE_IRQHandler               /* CAN2 SCE                     */\r\n  .word     OTG_FS_IRQHandler                 /* USB OTG FS                   */\r\n  .word     DMA2_Stream5_IRQHandler           /* DMA2 Stream 5                */\r\n  .word     DMA2_Stream6_IRQHandler           /* DMA2 Stream 6                */\r\n  .word     DMA2_Stream7_IRQHandler           /* DMA2 Stream 7                */\r\n  .word     USART6_IRQHandler                 /* USART6                       */\r\n  .word     I2C3_EV_IRQHandler                /* I2C3 event                   */\r\n  .word     I2C3_ER_IRQHandler                /* I2C3 error                   */\r\n  .word     OTG_HS_EP1_OUT_IRQHandler         /* USB OTG HS End Point 1 Out   */\r\n  .word     OTG_HS_EP1_IN_IRQHandler          /* USB OTG HS End Point 1 In    */\r\n  .word     OTG_HS_WKUP_IRQHandler            /* USB OTG HS Wakeup through EXTI */\r\n  .word     OTG_HS_IRQHandler                 /* USB OTG HS                   */\r\n  .word     DCMI_IRQHandler                   /* DCMI                         */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     RNG_IRQHandler                    /* RNG                          */\r\n  .word     FPU_IRQHandler                    /* FPU                          */\r\n  .word     UART7_IRQHandler                  /* UART7                        */\r\n  .word     UART8_IRQHandler                  /* UART8                        */\r\n  .word     SPI4_IRQHandler                   /* SPI4                         */\r\n  .word     SPI5_IRQHandler                   /* SPI5                         */\r\n  .word     SPI6_IRQHandler                   /* SPI6                         */\r\n  .word     SAI1_IRQHandler                   /* SAI1                         */\r\n  .word     LTDC_IRQHandler                   /* LTDC                         */\r\n  .word     LTDC_ER_IRQHandler                /* LTDC error                   */\r\n  .word     DMA2D_IRQHandler                  /* DMA2D                        */\r\n  .word     SAI2_IRQHandler                   /* SAI2                         */\r\n  .word     QUADSPI_IRQHandler                /* QUADSPI                      */\r\n  .word     LPTIM1_IRQHandler                 /* LPTIM1                       */\r\n  .word     CEC_IRQHandler                    /* HDMI_CEC                     */\r\n  .word     I2C4_EV_IRQHandler                /* I2C4 Event                   */\r\n  .word     I2C4_ER_IRQHandler                /* I2C4 Error                   */\r\n  .word     SPDIF_RX_IRQHandler               /* SPDIF_RX                     */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     DFSDM1_FLT0_IRQHandler            /* DFSDM1 Filter 0 global Interrupt */\r\n  .word     DFSDM1_FLT1_IRQHandler            /* DFSDM1 Filter 1 global Interrupt */\r\n  .word     DFSDM1_FLT2_IRQHandler            /* DFSDM1 Filter 2 global Interrupt */\r\n  .word     DFSDM1_FLT3_IRQHandler            /* DFSDM1 Filter 3 global Interrupt */\r\n  .word     SDMMC2_IRQHandler                 /* SDMMC2                       */\r\n  .word     CAN3_TX_IRQHandler                /* CAN3 TX                      */\r\n  .word     CAN3_RX0_IRQHandler               /* CAN3 RX0                     */\r\n  .word     CAN3_RX1_IRQHandler               /* CAN3 RX1                     */\r\n  .word     CAN3_SCE_IRQHandler               /* CAN3 SCE                     */\r\n  .word     JPEG_IRQHandler                   /* JPEG                         */\r\n  .word     MDIOS_IRQHandler                  /* MDIOS                        */\r\n  \r\n/*******************************************************************************\r\n*\r\n* Provide weak aliases for each Exception handler to the Default_Handler. \r\n* As they are weak aliases, any function with the same name will override \r\n* this definition.\r\n* \r\n*******************************************************************************/\r\n   .weak      NMI_Handler\r\n   .thumb_set NMI_Handler,Default_Handler\r\n  \r\n   .weak      HardFault_Handler\r\n   .thumb_set HardFault_Handler,Default_Handler\r\n  \r\n   .weak      MemManage_Handler\r\n   .thumb_set MemManage_Handler,Default_Handler\r\n  \r\n   .weak      BusFault_Handler\r\n   .thumb_set BusFault_Handler,Default_Handler\r\n\r\n   .weak      UsageFault_Handler\r\n   .thumb_set UsageFault_Handler,Default_Handler\r\n\r\n   .weak      SVC_Handler\r\n   .thumb_set SVC_Handler,Default_Handler\r\n\r\n   .weak      DebugMon_Handler\r\n   .thumb_set DebugMon_Handler,Default_Handler\r\n\r\n   .weak      PendSV_Handler\r\n   .thumb_set PendSV_Handler,Default_Handler\r\n\r\n   .weak      SysTick_Handler\r\n   .thumb_set SysTick_Handler,Default_Handler              \r\n  \r\n   .weak      WWDG_IRQHandler                   \r\n   .thumb_set WWDG_IRQHandler,Default_Handler      \r\n                  \r\n   .weak      PVD_IRQHandler      \r\n   .thumb_set PVD_IRQHandler,Default_Handler\r\n               \r\n   .weak      TAMP_STAMP_IRQHandler            \r\n   .thumb_set TAMP_STAMP_IRQHandler,Default_Handler\r\n            \r\n   .weak      RTC_WKUP_IRQHandler                  \r\n   .thumb_set RTC_WKUP_IRQHandler,Default_Handler\r\n            \r\n   .weak      FLASH_IRQHandler         \r\n   .thumb_set FLASH_IRQHandler,Default_Handler\r\n                  \r\n   .weak      RCC_IRQHandler      \r\n   .thumb_set RCC_IRQHandler,Default_Handler\r\n                  \r\n   .weak      EXTI0_IRQHandler         \r\n   .thumb_set EXTI0_IRQHandler,Default_Handler\r\n                  \r\n   .weak      EXTI1_IRQHandler         \r\n   .thumb_set EXTI1_IRQHandler,Default_Handler\r\n                     \r\n   .weak      EXTI2_IRQHandler         \r\n   .thumb_set EXTI2_IRQHandler,Default_Handler \r\n                 \r\n   .weak      EXTI3_IRQHandler         \r\n   .thumb_set EXTI3_IRQHandler,Default_Handler\r\n                        \r\n   .weak      EXTI4_IRQHandler         \r\n   .thumb_set EXTI4_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream0_IRQHandler               \r\n   .thumb_set DMA1_Stream0_IRQHandler,Default_Handler\r\n         \r\n   .weak      DMA1_Stream1_IRQHandler               \r\n   .thumb_set DMA1_Stream1_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream2_IRQHandler               \r\n   .thumb_set DMA1_Stream2_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream3_IRQHandler               \r\n   .thumb_set DMA1_Stream3_IRQHandler,Default_Handler \r\n                 \r\n   .weak      DMA1_Stream4_IRQHandler              \r\n   .thumb_set DMA1_Stream4_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream5_IRQHandler               \r\n   .thumb_set DMA1_Stream5_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream6_IRQHandler               \r\n   .thumb_set DMA1_Stream6_IRQHandler,Default_Handler\r\n                  \r\n   .weak      ADC_IRQHandler      \r\n   .thumb_set ADC_IRQHandler,Default_Handler\r\n               \r\n   .weak      CAN1_TX_IRQHandler   \r\n   .thumb_set CAN1_TX_IRQHandler,Default_Handler\r\n            \r\n   .weak      CAN1_RX0_IRQHandler                  \r\n   .thumb_set CAN1_RX0_IRQHandler,Default_Handler\r\n                           \r\n   .weak      CAN1_RX1_IRQHandler                  \r\n   .thumb_set CAN1_RX1_IRQHandler,Default_Handler\r\n            \r\n   .weak      CAN1_SCE_IRQHandler                  \r\n   .thumb_set CAN1_SCE_IRQHandler,Default_Handler\r\n            \r\n   .weak      EXTI9_5_IRQHandler   \r\n   .thumb_set EXTI9_5_IRQHandler,Default_Handler\r\n            \r\n   .weak      TIM1_BRK_TIM9_IRQHandler            \r\n   .thumb_set TIM1_BRK_TIM9_IRQHandler,Default_Handler\r\n            \r\n   .weak      TIM1_UP_TIM10_IRQHandler            \r\n   .thumb_set TIM1_UP_TIM10_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM1_TRG_COM_TIM11_IRQHandler      \r\n   .thumb_set TIM1_TRG_COM_TIM11_IRQHandler,Default_Handler\r\n      \r\n   .weak      TIM1_CC_IRQHandler   \r\n   .thumb_set TIM1_CC_IRQHandler,Default_Handler\r\n                  \r\n   .weak      TIM2_IRQHandler            \r\n   .thumb_set TIM2_IRQHandler,Default_Handler\r\n                  \r\n   .weak      TIM3_IRQHandler            \r\n   .thumb_set TIM3_IRQHandler,Default_Handler\r\n                  \r\n   .weak      TIM4_IRQHandler            \r\n   .thumb_set TIM4_IRQHandler,Default_Handler\r\n                  \r\n   .weak      I2C1_EV_IRQHandler   \r\n   .thumb_set I2C1_EV_IRQHandler,Default_Handler\r\n                     \r\n   .weak      I2C1_ER_IRQHandler   \r\n   .thumb_set I2C1_ER_IRQHandler,Default_Handler\r\n                     \r\n   .weak      I2C2_EV_IRQHandler   \r\n   .thumb_set I2C2_EV_IRQHandler,Default_Handler\r\n                  \r\n   .weak      I2C2_ER_IRQHandler   \r\n   .thumb_set I2C2_ER_IRQHandler,Default_Handler\r\n                           \r\n   .weak      SPI1_IRQHandler            \r\n   .thumb_set SPI1_IRQHandler,Default_Handler\r\n                        \r\n   .weak      SPI2_IRQHandler            \r\n   .thumb_set SPI2_IRQHandler,Default_Handler\r\n                  \r\n   .weak      USART1_IRQHandler      \r\n   .thumb_set USART1_IRQHandler,Default_Handler\r\n                     \r\n   .weak      USART2_IRQHandler      \r\n   .thumb_set USART2_IRQHandler,Default_Handler\r\n                     \r\n   .weak      USART3_IRQHandler      \r\n   .thumb_set USART3_IRQHandler,Default_Handler\r\n                  \r\n   .weak      EXTI15_10_IRQHandler               \r\n   .thumb_set EXTI15_10_IRQHandler,Default_Handler\r\n               \r\n   .weak      RTC_Alarm_IRQHandler               \r\n   .thumb_set RTC_Alarm_IRQHandler,Default_Handler\r\n            \r\n   .weak      OTG_FS_WKUP_IRQHandler         \r\n   .thumb_set OTG_FS_WKUP_IRQHandler,Default_Handler\r\n            \r\n   .weak      TIM8_BRK_TIM12_IRQHandler         \r\n   .thumb_set TIM8_BRK_TIM12_IRQHandler,Default_Handler\r\n         \r\n   .weak      TIM8_UP_TIM13_IRQHandler            \r\n   .thumb_set TIM8_UP_TIM13_IRQHandler,Default_Handler\r\n         \r\n   .weak      TIM8_TRG_COM_TIM14_IRQHandler      \r\n   .thumb_set TIM8_TRG_COM_TIM14_IRQHandler,Default_Handler\r\n      \r\n   .weak      TIM8_CC_IRQHandler   \r\n   .thumb_set TIM8_CC_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream7_IRQHandler               \r\n   .thumb_set DMA1_Stream7_IRQHandler,Default_Handler\r\n                     \r\n   .weak      FMC_IRQHandler            \r\n   .thumb_set FMC_IRQHandler,Default_Handler\r\n                     \r\n   .weak      SDMMC1_IRQHandler            \r\n   .thumb_set SDMMC1_IRQHandler,Default_Handler\r\n                     \r\n   .weak      TIM5_IRQHandler            \r\n   .thumb_set TIM5_IRQHandler,Default_Handler\r\n                     \r\n   .weak      SPI3_IRQHandler            \r\n   .thumb_set SPI3_IRQHandler,Default_Handler\r\n                     \r\n   .weak      UART4_IRQHandler         \r\n   .thumb_set UART4_IRQHandler,Default_Handler\r\n                  \r\n   .weak      UART5_IRQHandler         \r\n   .thumb_set UART5_IRQHandler,Default_Handler\r\n                  \r\n   .weak      TIM6_DAC_IRQHandler                  \r\n   .thumb_set TIM6_DAC_IRQHandler,Default_Handler\r\n               \r\n   .weak      TIM7_IRQHandler            \r\n   .thumb_set TIM7_IRQHandler,Default_Handler\r\n         \r\n   .weak      DMA2_Stream0_IRQHandler               \r\n   .thumb_set DMA2_Stream0_IRQHandler,Default_Handler\r\n               \r\n   .weak      DMA2_Stream1_IRQHandler               \r\n   .thumb_set DMA2_Stream1_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA2_Stream2_IRQHandler               \r\n   .thumb_set DMA2_Stream2_IRQHandler,Default_Handler\r\n            \r\n   .weak      DMA2_Stream3_IRQHandler               \r\n   .thumb_set DMA2_Stream3_IRQHandler,Default_Handler\r\n            \r\n   .weak      DMA2_Stream4_IRQHandler               \r\n   .thumb_set DMA2_Stream4_IRQHandler,Default_Handler\r\n   \r\n   .weak      DMA2_Stream4_IRQHandler               \r\n   .thumb_set DMA2_Stream4_IRQHandler,Default_Handler   \r\n\r\n   .weak      ETH_IRQHandler   \r\n   .thumb_set ETH_IRQHandler,Default_Handler\r\n   \r\n   .weak      ETH_WKUP_IRQHandler   \r\n   .thumb_set ETH_WKUP_IRQHandler,Default_Handler\r\n\r\n   .weak      CAN2_TX_IRQHandler   \r\n   .thumb_set CAN2_TX_IRQHandler,Default_Handler   \r\n                           \r\n   .weak      CAN2_RX0_IRQHandler                  \r\n   .thumb_set CAN2_RX0_IRQHandler,Default_Handler\r\n                           \r\n   .weak      CAN2_RX1_IRQHandler                  \r\n   .thumb_set CAN2_RX1_IRQHandler,Default_Handler\r\n                           \r\n   .weak      CAN2_SCE_IRQHandler                  \r\n   .thumb_set CAN2_SCE_IRQHandler,Default_Handler\r\n                           \r\n   .weak      OTG_FS_IRQHandler      \r\n   .thumb_set OTG_FS_IRQHandler,Default_Handler\r\n                     \r\n   .weak      DMA2_Stream5_IRQHandler               \r\n   .thumb_set DMA2_Stream5_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA2_Stream6_IRQHandler               \r\n   .thumb_set DMA2_Stream6_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA2_Stream7_IRQHandler               \r\n   .thumb_set DMA2_Stream7_IRQHandler,Default_Handler\r\n                  \r\n   .weak      USART6_IRQHandler      \r\n   .thumb_set USART6_IRQHandler,Default_Handler\r\n                        \r\n   .weak      I2C3_EV_IRQHandler   \r\n   .thumb_set I2C3_EV_IRQHandler,Default_Handler\r\n                        \r\n   .weak      I2C3_ER_IRQHandler   \r\n   .thumb_set I2C3_ER_IRQHandler,Default_Handler\r\n                        \r\n   .weak      OTG_HS_EP1_OUT_IRQHandler         \r\n   .thumb_set OTG_HS_EP1_OUT_IRQHandler,Default_Handler\r\n               \r\n   .weak      OTG_HS_EP1_IN_IRQHandler            \r\n   .thumb_set OTG_HS_EP1_IN_IRQHandler,Default_Handler\r\n               \r\n   .weak      OTG_HS_WKUP_IRQHandler         \r\n   .thumb_set OTG_HS_WKUP_IRQHandler,Default_Handler\r\n            \r\n   .weak      OTG_HS_IRQHandler      \r\n   .thumb_set OTG_HS_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DCMI_IRQHandler            \r\n   .thumb_set DCMI_IRQHandler,Default_Handler\r\n\r\n   .weak      RNG_IRQHandler            \r\n   .thumb_set RNG_IRQHandler,Default_Handler   \r\n\r\n   .weak      FPU_IRQHandler                  \r\n   .thumb_set FPU_IRQHandler,Default_Handler\r\n\r\n   .weak      UART7_IRQHandler                  \r\n   .thumb_set UART7_IRQHandler,Default_Handler\r\n\r\n   .weak      UART8_IRQHandler                  \r\n   .thumb_set UART8_IRQHandler,Default_Handler   \r\n\r\n   .weak      SPI4_IRQHandler            \r\n   .thumb_set SPI4_IRQHandler,Default_Handler\r\n   \r\n   .weak      SPI5_IRQHandler            \r\n   .thumb_set SPI5_IRQHandler,Default_Handler\r\n\r\n   .weak      SPI6_IRQHandler            \r\n   .thumb_set SPI6_IRQHandler,Default_Handler   \r\n\r\n   .weak      SAI1_IRQHandler            \r\n   .thumb_set SAI1_IRQHandler,Default_Handler\r\n   \r\n   .weak      LTDC_IRQHandler            \r\n   .thumb_set LTDC_IRQHandler,Default_Handler\r\n\r\n   .weak      LTDC_ER_IRQHandler            \r\n   .thumb_set LTDC_ER_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2D_IRQHandler            \r\n   .thumb_set DMA2D_IRQHandler,Default_Handler   \r\n\r\n   .weak      SAI2_IRQHandler            \r\n   .thumb_set SAI2_IRQHandler,Default_Handler\r\n   \r\n   .weak      QUADSPI_IRQHandler            \r\n   .thumb_set QUADSPI_IRQHandler,Default_Handler\r\n \r\n   .weak      LPTIM1_IRQHandler            \r\n   .thumb_set LPTIM1_IRQHandler,Default_Handler\r\n\r\n   .weak      CEC_IRQHandler            \r\n   .thumb_set CEC_IRQHandler,Default_Handler\r\n   \r\n   .weak      I2C4_EV_IRQHandler            \r\n   .thumb_set I2C4_EV_IRQHandler,Default_Handler \r\n \r\n   .weak      I2C4_ER_IRQHandler            \r\n   .thumb_set I2C4_ER_IRQHandler,Default_Handler\r\n   \r\n   .weak      SPDIF_RX_IRQHandler            \r\n   .thumb_set SPDIF_RX_IRQHandler,Default_Handler\r\n\r\n   .weak      DFSDM1_FLT0_IRQHandler            \r\n   .thumb_set DFSDM1_FLT0_IRQHandler,Default_Handler\r\n\r\n   .weak      DFSDM1_FLT1_IRQHandler            \r\n   .thumb_set DFSDM1_FLT1_IRQHandler,Default_Handler\r\n\r\n   .weak      DFSDM1_FLT2_IRQHandler            \r\n   .thumb_set DFSDM1_FLT2_IRQHandler,Default_Handler\r\n\r\n   .weak      DFSDM1_FLT3_IRQHandler            \r\n   .thumb_set DFSDM1_FLT3_IRQHandler,Default_Handler\r\n\r\n   .weak      SDMMC2_IRQHandler            \r\n   .thumb_set SDMMC2_IRQHandler,Default_Handler\r\n\r\n   .weak      CAN3_TX_IRQHandler            \r\n   .thumb_set CAN3_TX_IRQHandler,Default_Handler\r\n\r\n   .weak      CAN3_RX0_IRQHandler            \r\n   .thumb_set CAN3_RX0_IRQHandler,Default_Handler\r\n\r\n   .weak      CAN3_RX1_IRQHandler            \r\n   .thumb_set CAN3_RX1_IRQHandler,Default_Handler\r\n\r\n   .weak      CAN3_SCE_IRQHandler            \r\n   .thumb_set CAN3_SCE_IRQHandler,Default_Handler\r\n\r\n   .weak      JPEG_IRQHandler            \r\n   .thumb_set JPEG_IRQHandler,Default_Handler\r\n\r\n   .weak      MDIOS_IRQHandler            \r\n   .thumb_set MDIOS_IRQHandler,Default_Handler   \r\n\r\n\r\n \r\n"},{"name":"stm32f7xx_hal.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal.c\r\n  * @author  MCD Application Team\r\n  * @brief   HAL module driver.\r\n  *          This is the common part of the HAL initialization\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n    The common HAL driver contains a set of generic and common APIs that can be\r\n    used by the PPP peripheral drivers and the user to start using the HAL. \r\n    [..]\r\n    The HAL contains two APIs' categories: \r\n         (+) Common HAL APIs\r\n         (+) Services HAL APIs\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup HAL HAL\r\n  * @brief HAL module driver.\r\n  * @{\r\n  */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup HAL_Private_Constants\r\n  * @{\r\n  */\r\n/**\r\n * @brief STM32F7xx HAL Driver version number V1.2.10\r\n   */\r\n#define __STM32F7xx_HAL_VERSION_MAIN   (0x01) /*!< [31:24] main version */\r\n#define __STM32F7xx_HAL_VERSION_SUB1   (0x02) /*!< [23:16] sub1 version */\r\n#define __STM32F7xx_HAL_VERSION_SUB2   (0x0A) /*!< [15:8]  sub2 version */\r\n#define __STM32F7xx_HAL_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ \r\n#define __STM32F7xx_HAL_VERSION         ((__STM32F7xx_HAL_VERSION_MAIN << 24)\\\r\n                                        |(__STM32F7xx_HAL_VERSION_SUB1 << 16)\\\r\n                                        |(__STM32F7xx_HAL_VERSION_SUB2 << 8 )\\\r\n                                        |(__STM32F7xx_HAL_VERSION_RC))\r\n                                        \r\n#define IDCODE_DEVID_MASK    ((uint32_t)0x00000FFF)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Exported variables ---------------------------------------------------------*/\r\n/** @addtogroup HAL_Exported_Variables\r\n  * @{\r\n  */\r\n__IO uint32_t uwTick;\r\nuint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); /* Invalid PRIO */\r\nHAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  /* 1KHz */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup HAL_Exported_Functions HAL Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup HAL_Exported_Functions_Group1 Initialization and de-initialization Functions \r\n *  @brief    Initialization and de-initialization functions\r\n *\r\n@verbatim    \r\n ===============================================================================\r\n              ##### Initialization and Configuration functions #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Initializes the Flash interface the NVIC allocation and initial clock \r\n          configuration. It initializes the systick also when timeout is needed \r\n          and the backup domain when enabled.\r\n      (+) De-Initializes common part of the HAL.\r\n      (+) Configure the time base source to have 1ms time base with a dedicated \r\n          Tick interrupt priority. \r\n        (++) SysTick timer is used by default as source of time base, but user\r\n             can eventually implement his proper time base source (a general purpose \r\n             timer for example or other time source), keeping in mind that Time base \r\n             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and \r\n             handled in milliseconds basis.\r\n        (++) Time base configuration function (HAL_InitTick ()) is called automatically \r\n             at the beginning of the program after reset by HAL_Init() or at any time \r\n             when clock is configured, by HAL_RCC_ClockConfig(). \r\n        (++) Source of time base is configured  to generate interrupts at regular \r\n             time intervals. Care must be taken if HAL_Delay() is called from a \r\n             peripheral ISR process, the Tick interrupt line must have higher priority \r\n            (numerically lower) than the peripheral interrupt. Otherwise the caller \r\n            ISR process will be blocked. \r\n       (++) functions affecting time base configurations are declared as __weak  \r\n             to make  override possible  in case of other  implementations in user file.\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function is used to initialize the HAL Library; it must be the first \r\n  *         instruction to be executed in the main program (before to call any other\r\n  *         HAL function), it performs the following:\r\n  *           Configure the Flash prefetch, and instruction cache through ART accelerator.\r\n  *           Configures the SysTick to generate an interrupt each 1 millisecond,\r\n  *           which is clocked by the HSI (at this stage, the clock is not yet\r\n  *           configured and thus the system is running from the internal HSI at 16 MHz).\r\n  *           Set NVIC Group Priority to 4.\r\n  *           Calls the HAL_MspInit() callback function defined in user file \r\n  *           \"stm32f7xx_hal_msp.c\" to do the global low level hardware initialization \r\n  *            \r\n  * @note   SysTick is used as time base for the HAL_Delay() function, the application\r\n  *         need to ensure that the SysTick time base is always set to 1 millisecond\r\n  *         to have correct HAL operation.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_Init(void)\r\n{\r\n  /* Configure Instruction cache through ART accelerator */ \r\n#if (ART_ACCLERATOR_ENABLE != 0)\r\n  __HAL_FLASH_ART_ENABLE();\r\n#endif /* ART_ACCLERATOR_ENABLE */\r\n\r\n  /* Configure Flash prefetch */\r\n#if (PREFETCH_ENABLE != 0U)\r\n  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();\r\n#endif /* PREFETCH_ENABLE */\r\n\r\n  /* Set Interrupt Group Priority */\r\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\r\n\r\n  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */\r\n  HAL_InitTick(TICK_INT_PRIORITY);\r\n\r\n  /* Init the low level hardware */\r\n  HAL_MspInit();\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function de-Initializes common part of the HAL and stops the systick.\r\n  *         This function is optional.   \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DeInit(void)\r\n{\r\n  /* Reset of all peripherals */\r\n  __HAL_RCC_APB1_FORCE_RESET();\r\n  __HAL_RCC_APB1_RELEASE_RESET();\r\n\r\n  __HAL_RCC_APB2_FORCE_RESET();\r\n  __HAL_RCC_APB2_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB1_FORCE_RESET();\r\n  __HAL_RCC_AHB1_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB2_FORCE_RESET();\r\n  __HAL_RCC_AHB2_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB3_FORCE_RESET();\r\n  __HAL_RCC_AHB3_RELEASE_RESET();\r\n\r\n  /* De-Init the low level hardware */\r\n  HAL_MspDeInit();\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize the MSP.\r\n  * @retval None\r\n  */\r\n__weak void HAL_MspInit(void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the MSP.\r\n  * @retval None\r\n  */\r\n__weak void HAL_MspDeInit(void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_MspDeInit could be implemented in the user file\r\n   */ \r\n}\r\n\r\n/**\r\n  * @brief This function configures the source of the time base.\r\n  *        The time source is configured  to have 1ms time base with a dedicated \r\n  *        Tick interrupt priority.\r\n  * @note This function is called  automatically at the beginning of program after\r\n  *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().\r\n  * @note In the default implementation, SysTick timer is the source of time base. \r\n  *       It is used to generate interrupts at regular time intervals. \r\n  *       Care must be taken if HAL_Delay() is called from a peripheral ISR process, \r\n  *       The SysTick interrupt must have higher priority (numerically lower)\r\n  *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.\r\n  *       The function is declared as __weak  to be overwritten  in case of other\r\n  *       implementation  in user file.\r\n  * @param TickPriority Tick interrupt priority.\r\n  * @retval HAL status\r\n  */\r\n__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\r\n{\r\n  /* Configure the SysTick to have interrupt in 1ms time basis*/\r\n  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Configure the SysTick IRQ priority */\r\n  if (TickPriority < (1UL << __NVIC_PRIO_BITS))\r\n  {\r\n    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);\r\n    uwTickPrio = TickPriority;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup HAL_Exported_Functions_Group2 HAL Control functions \r\n *  @brief    HAL Control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### HAL Control functions #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Provide a tick value in millisecond\r\n      (+) Provide a blocking delay in millisecond\r\n      (+) Suspend the time base source interrupt\r\n      (+) Resume the time base source interrupt\r\n      (+) Get the HAL API driver version\r\n      (+) Get the device identifier\r\n      (+) Get the device revision identifier\r\n      (+) Enable/Disable Debug module during SLEEP mode\r\n      (+) Enable/Disable Debug module during STOP mode\r\n      (+) Enable/Disable Debug module during STANDBY mode\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief This function is called to increment  a global variable \"uwTick\"\r\n  *        used as application time base.\r\n  * @note In the default implementation, this variable is incremented each 1ms\r\n  *       in SysTick ISR.\r\n * @note This function is declared as __weak to be overwritten in case of other \r\n  *      implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_IncTick(void)\r\n{\r\n  uwTick += uwTickFreq;\r\n}\r\n\r\n/**\r\n  * @brief Provides a tick value in millisecond.\r\n  * @note This function is declared as __weak to be overwritten in case of other \r\n  *       implementations in user file.\r\n  * @retval tick value\r\n  */\r\n__weak uint32_t HAL_GetTick(void)\r\n{\r\n  return uwTick;\r\n}\r\n\r\n/**\r\n  * @brief This function returns a tick priority.\r\n  * @retval tick priority\r\n  */\r\nuint32_t HAL_GetTickPrio(void)\r\n{\r\n  return uwTickPrio;\r\n}\r\n\r\n/**\r\n  * @brief Set new tick Freq.\r\n  * @retval Status\r\n  */\r\nHAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\r\n{\r\n  HAL_StatusTypeDef status  = HAL_OK;\r\n  HAL_TickFreqTypeDef prevTickFreq;\r\n\r\n  assert_param(IS_TICKFREQ(Freq));\r\n\r\n  if (uwTickFreq != Freq)\r\n  {\r\n    /* Back up uwTickFreq frequency */\r\n    prevTickFreq = uwTickFreq;\r\n\r\n    /* Update uwTickFreq global variable used by HAL_InitTick() */\r\n    uwTickFreq = Freq;\r\n\r\n    /* Apply the new tick Freq  */\r\n    status = HAL_InitTick(uwTickPrio);\r\n\r\n    if (status != HAL_OK)\r\n    {\r\n      /* Restore previous tick frequency */\r\n      uwTickFreq = prevTickFreq;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief Return tick frequency.\r\n  * @retval tick period in Hz\r\n  */\r\nHAL_TickFreqTypeDef HAL_GetTickFreq(void)\r\n{\r\n  return uwTickFreq;\r\n}\r\n\r\n/**\r\n  * @brief This function provides minimum delay (in milliseconds) based\r\n  *        on variable incremented.\r\n  * @note In the default implementation , SysTick timer is the source of time base.\r\n  *       It is used to generate interrupts at regular time intervals where uwTick\r\n  *       is incremented.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @param Delay  specifies the delay time length, in milliseconds.\r\n  * @retval None\r\n  */\r\n__weak void HAL_Delay(uint32_t Delay)\r\n{\r\n  uint32_t tickstart = HAL_GetTick();\r\n  uint32_t wait = Delay;\r\n\r\n  /* Add a freq to guarantee minimum wait */\r\n  if (wait < HAL_MAX_DELAY)\r\n  {\r\n    wait += (uint32_t)(uwTickFreq);\r\n  }\r\n\r\n  while ((HAL_GetTick() - tickstart) < wait)\r\n  {\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Suspend Tick increment.\r\n  * @note In the default implementation , SysTick timer is the source of time base. It is\r\n  *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()\r\n  *       is called, the SysTick interrupt will be disabled and so Tick increment \r\n  *       is suspended.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SuspendTick(void)\r\n{\r\n  /* Disable SysTick Interrupt */\r\n  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;\r\n}\r\n\r\n/**\r\n  * @brief Resume Tick increment.\r\n  * @note In the default implementation , SysTick timer is the source of time base. It is\r\n  *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()\r\n  *       is called, the SysTick interrupt will be enabled and so Tick increment \r\n  *       is resumed.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_ResumeTick(void)\r\n{\r\n  /* Enable SysTick Interrupt */\r\n  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the HAL revision\r\n  * @retval version : 0xXYZR (8bits for each decimal, R for RC)\r\n  */\r\nuint32_t HAL_GetHalVersion(void)\r\n{\r\n  return __STM32F7xx_HAL_VERSION;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the device revision identifier.\r\n  * @retval Device revision identifier\r\n  */\r\nuint32_t HAL_GetREVID(void)\r\n{\r\n   return((DBGMCU->IDCODE) >> 16U);\r\n}\r\n\r\n/**\r\n  * @brief  Returns the device identifier.\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetDEVID(void)\r\n{\r\n   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);\r\n}\r\n\r\n/**\r\n  * @brief  Returns first word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw0(void)\r\n{\r\n  return(READ_REG(*((uint32_t *)UID_BASE)));\r\n}\r\n\r\n/**\r\n  * @brief  Returns second word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw1(void)\r\n{\r\n  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));\r\n}\r\n\r\n/**\r\n  * @brief  Returns third word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw2(void)\r\n{\r\n  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during SLEEP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGSleepMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during SLEEP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGSleepMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGStopMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGStopMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGStandbyMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGStandbyMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);\r\n}\r\n\r\n/**\r\n  * @brief  Enables the I/O Compensation Cell.\r\n  * @note   The I/O compensation cell can be used only when the device supply\r\n  *         voltage ranges from 2.4 to 3.6 V.  \r\n  * @retval None\r\n  */\r\nvoid HAL_EnableCompensationCell(void)\r\n{\r\n  SYSCFG->CMPCR |= SYSCFG_CMPCR_CMP_PD;\r\n}\r\n\r\n/**\r\n  * @brief  Power-down the I/O Compensation Cell.\r\n  * @note   The I/O compensation cell can be used only when the device supply\r\n  *         voltage ranges from 2.4 to 3.6 V.  \r\n  * @retval None\r\n  */\r\nvoid HAL_DisableCompensationCell(void)\r\n{\r\n  SYSCFG->CMPCR &= (uint32_t)~((uint32_t)SYSCFG_CMPCR_CMP_PD);\r\n}\r\n\r\n/**\r\n  * @brief  Enables the FMC Memory Mapping Swapping.\r\n  *   \r\n  * @note   SDRAM is accessible at 0x60000000 \r\n  *         and NOR/RAM is accessible at 0xC0000000   \r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_EnableFMCMemorySwapping(void)\r\n{\r\n  SYSCFG->MEMRMP |= SYSCFG_MEMRMP_SWP_FMC_0;\r\n}\r\n\r\n/**\r\n  * @brief  Disables the FMC Memory Mapping Swapping\r\n  *   \r\n  * @note   SDRAM is accessible at 0xC0000000 (default mapping)  \r\n  *         and NOR/RAM is accessible at 0x60000000 (default mapping)    \r\n  *           \r\n  * @retval None\r\n  */\r\nvoid HAL_DisableFMCMemorySwapping(void)\r\n{\r\n  SYSCFG->MEMRMP &= (uint32_t)~((uint32_t)SYSCFG_MEMRMP_SWP_FMC);\r\n}\r\n\r\n#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)\r\n/**\r\n* @brief  Enable the Internal FLASH Bank Swapping.\r\n*   \r\n* @note   This function can be used only for STM32F77xx/STM32F76xx devices. \r\n*\r\n* @note   Flash Bank2 mapped at 0x08000000 (AXI) (aliased at 0x00200000 (TCM)) \r\n*         and Flash Bank1 mapped at 0x08100000 (AXI) (aliased at 0x00300000 (TCM))   \r\n*\r\n* @retval None\r\n*/\r\nvoid HAL_EnableMemorySwappingBank(void)\r\n{\r\n  SET_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_SWP_FB);\r\n}\r\n\r\n/**\r\n* @brief  Disable the Internal FLASH Bank Swapping.\r\n*   \r\n* @note   This function can be used only for STM32F77xx/STM32F76xx devices. \r\n*\r\n* @note   The default state : Flash Bank1 mapped at 0x08000000 (AXI) (aliased at 0x00200000 (TCM)) \r\n*         and Flash Bank2 mapped at 0x08100000 (AXI)( aliased at 0x00300000 (TCM)) \r\n*           \r\n* @retval None\r\n*/\r\nvoid HAL_DisableMemorySwappingBank(void)\r\n{\r\n  CLEAR_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_SWP_FB);\r\n}\r\n#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n"},{"name":"stm32f7xx_hal_cortex.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_cortex.c\r\n  * @author  MCD Application Team\r\n  * @brief   CORTEX HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the CORTEX:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions \r\n  *\r\n  @verbatim  \r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n\r\n    [..]  \r\n    *** How to configure Interrupts using CORTEX HAL driver ***\r\n    ===========================================================\r\n    [..]     \r\n    This section provides functions allowing to configure the NVIC interrupts (IRQ).\r\n    The Cortex-M4 exceptions are managed by CMSIS functions.\r\n   \r\n    (#) Configure the NVIC Priority Grouping using HAL_NVIC_SetPriorityGrouping()\r\n        function according to the following table.\r\n    (#) Configure the priority of the selected IRQ Channels using HAL_NVIC_SetPriority(). \r\n    (#) Enable the selected IRQ Channels using HAL_NVIC_EnableIRQ().\r\n    (#) please refer to programming manual for details in how to configure priority. \r\n      \r\n     -@- When the NVIC_PRIORITYGROUP_0 is selected, IRQ preemption is no more possible. \r\n         The pending IRQ priority will be managed only by the sub priority.\r\n   \r\n     -@- IRQ priority order (sorted by highest to lowest priority):\r\n        (+@) Lowest preemption priority\r\n        (+@) Lowest sub priority\r\n        (+@) Lowest hardware priority (IRQ number)\r\n \r\n    [..]  \r\n    *** How to configure Systick using CORTEX HAL driver ***\r\n    ========================================================\r\n    [..]\r\n    Setup SysTick Timer for time base.\r\n           \r\n   (+) The HAL_SYSTICK_Config() function calls the SysTick_Config() function which\r\n       is a CMSIS function that:\r\n        (++) Configures the SysTick Reload register with value passed as function parameter.\r\n        (++) Configures the SysTick IRQ priority to the lowest value (0x0F).\r\n        (++) Resets the SysTick Counter register.\r\n        (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).\r\n        (++) Enables the SysTick Interrupt.\r\n        (++) Starts the SysTick Counter.\r\n    \r\n   (+) You can change the SysTick Clock source to be HCLK_Div8 by calling the macro\r\n       __HAL_CORTEX_SYSTICKCLK_CONFIG(SYSTICK_CLKSOURCE_HCLK_DIV8) just after the\r\n       HAL_SYSTICK_Config() function call. The __HAL_CORTEX_SYSTICKCLK_CONFIG() macro is defined\r\n       inside the stm32f7xx_hal_cortex.h file.\r\n\r\n   (+) You can change the SysTick IRQ priority by calling the\r\n       HAL_NVIC_SetPriority(SysTick_IRQn,...) function just after the HAL_SYSTICK_Config() function \r\n       call. The HAL_NVIC_SetPriority() call the NVIC_SetPriority() function which is a CMSIS function.\r\n\r\n   (+) To adjust the SysTick time base, use the following formula:\r\n                            \r\n       Reload Value = SysTick Counter Clock (Hz) x  Desired Time base (s)\r\n       (++) Reload Value is the parameter to be passed for HAL_SYSTICK_Config() function\r\n       (++) Reload Value should not exceed 0xFFFFFF\r\n   \r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup CORTEX CORTEX\r\n  * @brief CORTEX HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_CORTEX_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup CORTEX_Exported_Functions CORTEX Exported Functions\r\n  * @{\r\n  */\r\n\r\n\r\n/** @defgroup CORTEX_Exported_Functions_Group1 Initialization and de-initialization functions\r\n *  @brief    Initialization and Configuration functions \r\n *\r\n@verbatim    \r\n  ==============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n  ==============================================================================\r\n    [..]\r\n      This section provides the CORTEX HAL driver functions allowing to configure Interrupts\r\n      Systick functionalities \r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Sets the priority grouping field (preemption priority and subpriority)\r\n  *         using the required unlock sequence.\r\n  * @param  PriorityGroup The priority grouping bits length. \r\n  *         This parameter can be one of the following values:\r\n  *         @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority\r\n  *                                    4 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority\r\n  *                                    3 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority\r\n  *                                    2 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority\r\n  *                                    1 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority\r\n  *                                    0 bits for subpriority\r\n  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. \r\n  *         The pending IRQ priority will be managed only by the subpriority. \r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\r\n  \r\n  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */\r\n  NVIC_SetPriorityGrouping(PriorityGroup);\r\n}\r\n\r\n/**\r\n  * @brief  Sets the priority of an interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))\r\n  * @param  PreemptPriority The preemption priority for the IRQn channel.\r\n  *         This parameter can be a value between 0 and 15\r\n  *         A lower priority value indicates a higher priority \r\n  * @param  SubPriority the subpriority level for the IRQ channel.\r\n  *         This parameter can be a value between 0 and 15\r\n  *         A lower priority value indicates a higher priority.          \r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\r\n{ \r\n  uint32_t prioritygroup = 0x00;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\r\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\r\n  \r\n  prioritygroup = NVIC_GetPriorityGrouping();\r\n  \r\n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\r\n}\r\n\r\n/**\r\n  * @brief  Enables a device specific interrupt in the NVIC interrupt controller.\r\n  * @note   To configure interrupts priority correctly, the NVIC_PriorityGroupConfig()\r\n  *         function should be called before. \r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Enable interrupt */\r\n  NVIC_EnableIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Disables a device specific interrupt in the NVIC interrupt controller.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Disable interrupt */\r\n  NVIC_DisableIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Initiates a system reset request to reset the MCU.\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SystemReset(void)\r\n{\r\n  /* System Reset */\r\n  NVIC_SystemReset();\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the System Timer and its interrupt, and starts the System Tick Timer.\r\n  *         Counter is in free running mode to generate periodic interrupts.\r\n  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.\r\n  * @retval status:  - 0  Function succeeded.\r\n  *                  - 1  Function failed.\r\n  */\r\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\r\n{\r\n   return SysTick_Config(TicksNumb);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup CORTEX_Exported_Functions_Group2 Peripheral Control functions\r\n *  @brief   Cortex control functions \r\n *\r\n@verbatim   \r\n  ==============================================================================\r\n                      ##### Peripheral Control functions #####\r\n  ==============================================================================  \r\n    [..]\r\n      This subsection provides a set of functions allowing to control the CORTEX\r\n      (NVIC, SYSTICK, MPU) functionalities. \r\n \r\n      \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n#if (__MPU_PRESENT == 1)\r\n/**\r\n  * @brief  Disables the MPU\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_Disable(void)\r\n{\r\n  /* Make sure outstanding transfers are done */\r\n  __DMB();\r\n\r\n  /* Disable fault exceptions */\r\n  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;\r\n  \r\n  /* Disable the MPU and clear the control register*/\r\n  MPU->CTRL = 0;\r\n}\r\n\r\n/**\r\n  * @brief  Enables the MPU\r\n  * @param  MPU_Control Specifies the control mode of the MPU during hard fault, \r\n  *          NMI, FAULTMASK and privileged access to the default memory \r\n  *          This parameter can be one of the following values:\r\n  *            @arg MPU_HFNMI_PRIVDEF_NONE\r\n  *            @arg MPU_HARDFAULT_NMI\r\n  *            @arg MPU_PRIVILEGED_DEFAULT\r\n  *            @arg MPU_HFNMI_PRIVDEF\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_Enable(uint32_t MPU_Control)\r\n{\r\n  /* Enable the MPU */\r\n  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;\r\n  \r\n  /* Enable fault exceptions */\r\n  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;\r\n  \r\n  /* Ensure MPU setting take effects */\r\n  __DSB();\r\n  __ISB();\r\n}\r\n\r\n/**\r\n  * @brief  Initializes and configures the Region and the memory to be protected.\r\n  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains\r\n  *                the initialization and configuration information.\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));\r\n  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));\r\n\r\n  /* Set the Region number */\r\n  MPU->RNR = MPU_Init->Number;\r\n\r\n  if ((MPU_Init->Enable) != RESET)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));\r\n    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));\r\n    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));\r\n    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));\r\n    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));\r\n    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));\r\n    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));\r\n    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));\r\n    \r\n    MPU->RBAR = MPU_Init->BaseAddress;\r\n    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |\r\n                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |\r\n                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |\r\n                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |\r\n                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |\r\n                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |\r\n                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |\r\n                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |\r\n                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);\r\n  }\r\n  else\r\n  {\r\n    MPU->RBAR = 0x00;\r\n    MPU->RASR = 0x00;\r\n  }\r\n}\r\n#endif /* __MPU_PRESENT */\r\n\r\n/**\r\n  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.\r\n  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)\r\n  */\r\nuint32_t HAL_NVIC_GetPriorityGrouping(void)\r\n{\r\n  /* Get the PRIGROUP[10:8] field value */\r\n  return NVIC_GetPriorityGrouping();\r\n}\r\n\r\n/**\r\n  * @brief  Gets the priority of an interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))\r\n  * @param   PriorityGroup the priority grouping bits length.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority\r\n  *                                      4 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority\r\n  *                                      3 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority\r\n  *                                      2 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority\r\n  *                                      1 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority\r\n  *                                      0 bits for subpriority\r\n  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).\r\n  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\r\n /* Get priority for Cortex-M system or device specific interrupts */\r\n  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);\r\n}\r\n\r\n/**\r\n  * @brief  Sets Pending bit of an external interrupt.\r\n  * @param  IRQn External interrupt number\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Set interrupt pending */\r\n  NVIC_SetPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Gets Pending Interrupt (reads the pending register in the NVIC \r\n  *         and returns the pending bit for the specified interrupt).\r\n  * @param  IRQn External interrupt number.\r\n  *          This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))\r\n  * @retval status: - 0  Interrupt status is not pending.\r\n  *                 - 1  Interrupt status is pending.\r\n  */\r\nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Return 1 if pending else 0 */\r\n  return NVIC_GetPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Clears the pending bit of an external interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Clear pending interrupt */\r\n  NVIC_ClearPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief Gets active interrupt ( reads the active register in NVIC and returns the active bit).\r\n  * @param IRQn External interrupt number\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))\r\n  * @retval status: - 0  Interrupt status is not pending.\r\n  *                 - 1  Interrupt status is pending.\r\n  */\r\nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Return 1 if active else 0 */\r\n  return NVIC_GetActive(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Configures the SysTick clock source.\r\n  * @param  CLKSource specifies the SysTick clock source.\r\n  *          This parameter can be one of the following values:\r\n  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.\r\n  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));\r\n  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)\r\n  {\r\n    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;\r\n  }\r\n  else\r\n  {\r\n    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  This function handles SYSTICK interrupt request.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSTICK_IRQHandler(void)\r\n{\r\n  HAL_SYSTICK_Callback();\r\n}\r\n\r\n/**\r\n  * @brief  SYSTICK callback.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SYSTICK_Callback(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_SYSTICK_Callback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_CORTEX_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_dma.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_dma.c\r\n  * @author  MCD Application Team\r\n  * @brief   DMA HAL module driver.\r\n  *    \r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the Direct Memory Access (DMA) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *           + Peripheral State and errors functions\r\n  @verbatim     \r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n   (#) Enable and configure the peripheral to be connected to the DMA Stream\r\n       (except for internal SRAM/FLASH memories: no initialization is \r\n       necessary) please refer to Reference manual for connection between peripherals\r\n       and DMA requests.\r\n\r\n   (#) For a given Stream, program the required configuration through the following parameters:\r\n       Transfer Direction, Source and Destination data formats, \r\n       Circular, Normal or peripheral flow control mode, Stream Priority level, \r\n       Source and Destination Increment mode, FIFO mode and its Threshold (if needed), \r\n       Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.\r\n\r\n   -@-   Prior to HAL_DMA_Init() the clock must be enabled for DMA through the following macros:\r\n         __HAL_RCC_DMA1_CLK_ENABLE() or __HAL_RCC_DMA2_CLK_ENABLE().\r\n\r\n     *** Polling mode IO operation ***\r\n     =================================\r\n    [..]\r\n          (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source \r\n              address and destination address and the Length of data to be transferred.\r\n          (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  \r\n              case a fixed Timeout can be configured by User depending from his application.\r\n          (+) Use HAL_DMA_Abort() function to abort the current transfer.\r\n\r\n     *** Interrupt mode IO operation ***\r\n     ===================================\r\n    [..]\r\n          (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()\r\n          (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()\r\n          (+) Select Callbacks functions using HAL_DMA_RegisterCallback()\r\n          (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  \r\n              Source address and destination address and the Length of data to be transferred. In this \r\n              case the DMA interrupt is configured \r\n          (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine\r\n          (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can \r\n              add his own function by customization of function pointer XferCpltCallback and \r\n              XferErrorCallback (i.e a member of DMA handle structure).\r\n    [..]\r\n     (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error \r\n         detection.\r\n\r\n     (#) Use HAL_DMA_Abort_IT() function to abort the current transfer\r\n\r\n     -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.\r\n\r\n     -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is\r\n           possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set\r\n           Half-Word data size for the peripheral to access its data register and set Word data size\r\n           for the Memory to gain in access time. Each two half words will be packed and written in\r\n           a single access to a Word in the Memory).\r\n\r\n     -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source\r\n           and Destination. In this case the Peripheral Data Size will be applied to both Source\r\n           and Destination.\r\n\r\n     *** DMA HAL driver macros list ***\r\n     =============================================\r\n     [..]\r\n       Below the list of most used macros in DMA HAL driver.\r\n       \r\n      (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.\r\n      (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.\r\n      (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. \r\n\r\n     [..]\r\n      (@) You can refer to the DMA HAL driver header file for more useful macros\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup DMA DMA\r\n  * @brief DMA HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_DMA_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\ntypedef struct\r\n{\r\n  __IO uint32_t ISR;   /*!< DMA interrupt status register */\r\n  __IO uint32_t Reserved0;\r\n  __IO uint32_t IFCR;  /*!< DMA interrupt flag clear register */\r\n} DMA_Base_Registers;\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Private_Constants\r\n * @{\r\n */\r\n #define HAL_TIMEOUT_DMA_ABORT    ((uint32_t)5)  /* 5 ms */\r\n/**\r\n  * @}\r\n  */\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Private_Functions\r\n  * @{\r\n  */\r\nstatic void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);\r\nstatic uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);\r\nstatic HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma);\r\n\r\n/**\r\n  * @}\r\n  */  \r\n\r\n/* Exported functions ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group1\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n             ##### Initialization and de-initialization functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This section provides functions allowing to initialize the DMA Stream source\r\n    and destination addresses, incrementation and data sizes, transfer direction, \r\n    circular/normal mode selection, memory-to-memory mode selection and Stream priority value.\r\n    [..]\r\n    The HAL_DMA_Init() function follows the DMA configuration procedures as described in\r\n    reference manual.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n  \r\n/**\r\n  * @brief  Initialize the DMA according to the specified\r\n  *         parameters in the DMA_InitTypeDef and create the associated handle.\r\n  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.  \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t tmp = 0U;\r\n  uint32_t tickstart = HAL_GetTick();\r\n  DMA_Base_Registers *regs;\r\n\r\n  /* Check the DMA peripheral state */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));\r\n  assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));\r\n  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));\r\n  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));\r\n  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));\r\n  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));\r\n  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));\r\n  assert_param(IS_DMA_MODE(hdma->Init.Mode));\r\n  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));\r\n  assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));\r\n  /* Check the memory burst, peripheral burst and FIFO threshold parameters only\r\n     when FIFO mode is enabled */\r\n  if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)\r\n  {\r\n    assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));\r\n    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));\r\n    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));\r\n  }\r\n  \r\n  /* Change DMA peripheral state */\r\n  hdma->State = HAL_DMA_STATE_BUSY;\r\n  \r\n  /* Allocate lock resource */\r\n  __HAL_UNLOCK(hdma);\r\n\r\n  \r\n  /* Disable the peripheral */\r\n  __HAL_DMA_DISABLE(hdma);\r\n  \r\n  /* Check if the DMA Stream is effectively disabled */\r\n  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)\r\n  {\r\n    /* Check for the Timeout */\r\n    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\r\n    {\r\n      /* Update error code */\r\n      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n      \r\n      /* Change the DMA state */\r\n      hdma->State = HAL_DMA_STATE_TIMEOUT;\r\n      \r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n  \r\n  /* Get the CR register value */\r\n  tmp = hdma->Instance->CR;\r\n\r\n  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */\r\n  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \\\r\n                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \\\r\n                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \\\r\n                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));\r\n\r\n  /* Prepare the DMA Stream configuration */\r\n  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |\r\n          hdma->Init.PeriphInc           | hdma->Init.MemInc           |\r\n          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |\r\n          hdma->Init.Mode                | hdma->Init.Priority;\r\n\r\n  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */\r\n  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)\r\n  {\r\n    /* Get memory burst and peripheral burst */\r\n    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;\r\n  }\r\n  \r\n  /* Write to DMA Stream CR register */\r\n  hdma->Instance->CR = tmp;  \r\n\r\n  /* Get the FCR register value */\r\n  tmp = hdma->Instance->FCR;\r\n\r\n  /* Clear Direct mode and FIFO threshold bits */\r\n  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);\r\n\r\n  /* Prepare the DMA Stream FIFO configuration */\r\n  tmp |= hdma->Init.FIFOMode;\r\n\r\n  /* The FIFO threshold is not used when the FIFO mode is disabled */\r\n  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)\r\n  {\r\n    /* Get the FIFO threshold */\r\n    tmp |= hdma->Init.FIFOThreshold;\r\n    \r\n    /* Check compatibility between FIFO threshold level and size of the memory burst */\r\n    /* for INCR4, INCR8, INCR16 bursts */\r\n    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)\r\n    {\r\n      if (DMA_CheckFifoParam(hdma) != HAL_OK)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\r\n        \r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_READY;\r\n        \r\n        return HAL_ERROR; \r\n      }\r\n    }\r\n  }\r\n  \r\n  /* Write to DMA Stream FCR */\r\n  hdma->Instance->FCR = tmp;\r\n\r\n  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate\r\n     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */\r\n  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\r\n  \r\n  /* Clear all interrupt flags */\r\n  regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n\r\n  /* Initialize the error code */\r\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n                                                                                     \r\n  /* Initialize the DMA state */\r\n  hdma->State = HAL_DMA_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the DMA peripheral \r\n  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.  \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)\r\n{\r\n  DMA_Base_Registers *regs;\r\n\r\n  /* Check the DMA peripheral state */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  \r\n  /* Check the DMA peripheral state */\r\n  if(hdma->State == HAL_DMA_STATE_BUSY)\r\n  {\r\n    /* Return error status */\r\n    return HAL_BUSY;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));\r\n\r\n  /* Disable the selected DMA Streamx */\r\n  __HAL_DMA_DISABLE(hdma);\r\n\r\n  /* Reset DMA Streamx control register */\r\n  hdma->Instance->CR   = 0U;\r\n\r\n  /* Reset DMA Streamx number of data to transfer register */\r\n  hdma->Instance->NDTR = 0U;\r\n\r\n  /* Reset DMA Streamx peripheral address register */\r\n  hdma->Instance->PAR  = 0U;\r\n\r\n  /* Reset DMA Streamx memory 0 address register */\r\n  hdma->Instance->M0AR = 0U;\r\n  \r\n  /* Reset DMA Streamx memory 1 address register */\r\n  hdma->Instance->M1AR = 0U;\r\n  \r\n  /* Reset DMA Streamx FIFO control register */\r\n  hdma->Instance->FCR  = (uint32_t)0x00000021U;\r\n  \r\n  /* Get DMA steam Base Address */  \r\n  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\r\n  \r\n  /* Clear all interrupt flags at correct offset within the register */\r\n  regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n  \r\n  /* Clean all callbacks */\r\n  hdma->XferCpltCallback = NULL;\r\n  hdma->XferHalfCpltCallback = NULL;\r\n  hdma->XferM1CpltCallback = NULL;\r\n  hdma->XferM1HalfCpltCallback = NULL;\r\n  hdma->XferErrorCallback = NULL;\r\n  hdma->XferAbortCallback = NULL;  \r\n\r\n  /* Reset the error code */\r\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n\r\n  /* Reset the DMA state */\r\n  hdma->State = HAL_DMA_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group2\r\n  *\r\n@verbatim   \r\n ===============================================================================\r\n                      #####  IO operation functions  #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Configure the source, destination address and data length and Start DMA transfer\r\n      (+) Configure the source, destination address and data length and \r\n          Start DMA transfer with interrupt\r\n      (+) Abort DMA transfer\r\n      (+) Poll for transfer complete\r\n      (+) Handle DMA interrupt request  \r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the DMA Transfer.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n    \r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n    \r\n    /* Configure the source, destination address and the data length */\r\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n\r\n    /* Enable the Peripheral */\r\n    __HAL_DMA_ENABLE(hdma);\r\n  }\r\n  else\r\n  {\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n    \r\n    /* Return error status */\r\n    status = HAL_BUSY;\r\n  } \r\n  return status; \r\n}\r\n\r\n/**\r\n  * @brief  Start the DMA Transfer with interrupt enabled.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n \r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n  \r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n    \r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n    \r\n    /* Configure the source, destination address and the data length */\r\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n    \r\n    /* Clear all interrupt flags at correct offset within the register */\r\n    regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n    \r\n    /* Enable Common interrupts*/\r\n    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;\r\n    hdma->Instance->FCR |= DMA_IT_FE;\r\n    \r\n    if(hdma->XferHalfCpltCallback != NULL)\r\n    {\r\n      hdma->Instance->CR  |= DMA_IT_HT;\r\n    }\r\n    \r\n    /* Enable the Peripheral */\r\n    __HAL_DMA_ENABLE(hdma);\r\n  }\r\n  else\r\n  {\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hdma);\t  \r\n    \r\n    /* Return error status */\r\n    status = HAL_BUSY;\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Aborts the DMA Transfer.\r\n  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified DMA Stream.\r\n  *                   \r\n  * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is \r\n  *        effectively disabled is added. If a Stream is disabled \r\n  *        while a data transfer is ongoing, the current data will be transferred\r\n  *        and the Stream will be effectively disabled only after the transfer of\r\n  *        this single data is finished.  \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n  \r\n  uint32_t tickstart = HAL_GetTick();\r\n  \r\n  if(hdma->State != HAL_DMA_STATE_BUSY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n    \r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n    \r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Disable all the transfer interrupts */\r\n    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);\r\n    hdma->Instance->FCR &= ~(DMA_IT_FE);\r\n    \r\n    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n    {\r\n      hdma->Instance->CR  &= ~(DMA_IT_HT);\r\n    }\r\n    \r\n    /* Disable the stream */\r\n    __HAL_DMA_DISABLE(hdma);\r\n    \r\n    /* Check if the DMA Stream is effectively disabled */\r\n    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)\r\n    {\r\n      /* Check for the Timeout */\r\n      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n        \r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_TIMEOUT;\r\n        \r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    \r\n    /* Clear all interrupt flags at correct offset within the register */\r\n    regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n    \r\n    /* Change the DMA state*/\r\n    hdma->State = HAL_DMA_STATE_READY;\r\n    \r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n    \r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Aborts the DMA Transfer in Interrupt mode.\r\n  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)\r\n{\r\n  if(hdma->State != HAL_DMA_STATE_BUSY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Set Abort State  */\r\n    hdma->State = HAL_DMA_STATE_ABORT;\r\n    \r\n    /* Disable the stream */\r\n    __HAL_DMA_DISABLE(hdma);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Polling for transfer complete.\r\n  * @param  hdma          pointer to a DMA_HandleTypeDef structure that contains\r\n  *                        the configuration information for the specified DMA Stream.\r\n  * @param  CompleteLevel Specifies the DMA level complete.\r\n  * @note   The polling mode is kept in this version for legacy. it is recommended to use the IT model instead.\r\n  *         This model could be used for debug purpose.\r\n  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). \r\n  * @param  Timeout       Timeout duration.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK; \r\n  uint32_t mask_cpltlevel;\r\n  uint32_t tickstart = HAL_GetTick(); \r\n  uint32_t tmpisr;\r\n  \r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs;\r\n\r\n  if(HAL_DMA_STATE_BUSY != hdma->State)\r\n  {\r\n    /* No transfer ongoing */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n    __HAL_UNLOCK(hdma);\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Polling mode not supported in circular mode and double buffering mode */\r\n  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n    return HAL_ERROR;\r\n  }\r\n  \r\n  /* Get the level transfer complete flag */\r\n  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\r\n  {\r\n    /* Transfer Complete flag */\r\n    mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;\r\n  }\r\n  else\r\n  {\r\n    /* Half Transfer Complete flag */\r\n    mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;\r\n  }\r\n  \r\n  regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n  tmpisr = regs->ISR;\r\n  \r\n  while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))\r\n  {\r\n    /* Check for the Timeout (Not applicable in circular mode)*/\r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n        \r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_READY;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Get the ISR register value */\r\n    tmpisr = regs->ISR;\r\n\r\n    if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)\r\n    {\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_TE;\r\n      \r\n      /* Clear the transfer error flag */\r\n      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;\r\n    }\r\n    \r\n    if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)\r\n    {\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_FE;\r\n      \r\n      /* Clear the FIFO error flag */\r\n      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;\r\n    }\r\n    \r\n    if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)\r\n    {\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_DME;\r\n      \r\n      /* Clear the Direct Mode error flag */\r\n      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;\r\n    }\r\n  }\r\n  \r\n  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)\r\n  {\r\n    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)\r\n    {\r\n      HAL_DMA_Abort(hdma);\r\n    \r\n      /* Clear the half transfer and transfer complete flags */\r\n      regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;\r\n    \r\n      /* Change the DMA state */\r\n      hdma->State= HAL_DMA_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hdma);\r\n\r\n      return HAL_ERROR;\r\n   }\r\n  }\r\n  \r\n  /* Get the level transfer complete flag */\r\n  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\r\n  {\r\n    /* Clear the half transfer and transfer complete flags */\r\n    regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;\r\n    \r\n    hdma->State = HAL_DMA_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n\r\n  }\r\n  else\r\n  {\r\n    /* Clear the half transfer flag */\r\n    regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Handles DMA interrupt request.\r\n  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.  \r\n  * @retval None\r\n  */\r\nvoid HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t tmpisr;\r\n  __IO uint32_t count = 0;\r\n  uint32_t timeout = SystemCoreClock / 9600;\r\n\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n\r\n  tmpisr = regs->ISR;\r\n\r\n  /* Transfer Error Interrupt management ***************************************/\r\n  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)\r\n    {\r\n      /* Disable the transfer error interrupt */\r\n      hdma->Instance->CR  &= ~(DMA_IT_TE);\r\n      \r\n      /* Clear the transfer error flag */\r\n      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;\r\n      \r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_TE;\r\n    }\r\n  }\r\n  /* FIFO Error Interrupt management ******************************************/\r\n  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)\r\n    {\r\n      /* Clear the FIFO error flag */\r\n      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;\r\n\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_FE;\r\n    }\r\n  }\r\n  /* Direct Mode Error Interrupt management ***********************************/\r\n  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)\r\n    {\r\n      /* Clear the direct mode error flag */\r\n      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;\r\n\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_DME;\r\n    }\r\n  }\r\n  /* Half Transfer Complete Interrupt management ******************************/\r\n  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)\r\n    {\r\n      /* Clear the half transfer complete flag */\r\n      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;\r\n      \r\n      /* Multi_Buffering mode enabled */\r\n      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)\r\n      {\r\n        /* Current memory buffer used is Memory 0 */\r\n        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)\r\n        {\r\n          if(hdma->XferHalfCpltCallback != NULL)\r\n          {\r\n            /* Half transfer callback */\r\n            hdma->XferHalfCpltCallback(hdma);\r\n          }\r\n        }\r\n        /* Current memory buffer used is Memory 1 */\r\n        else\r\n        {\r\n          if(hdma->XferM1HalfCpltCallback != NULL)\r\n          {\r\n            /* Half transfer callback */\r\n            hdma->XferM1HalfCpltCallback(hdma);\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */\r\n        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)\r\n        {\r\n          /* Disable the half transfer interrupt */\r\n          hdma->Instance->CR  &= ~(DMA_IT_HT);\r\n        }\r\n        \r\n        if(hdma->XferHalfCpltCallback != NULL)\r\n        {\r\n          /* Half transfer callback */\r\n          hdma->XferHalfCpltCallback(hdma);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /* Transfer Complete Interrupt management ***********************************/\r\n  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)\r\n    {\r\n      /* Clear the transfer complete flag */\r\n      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;\r\n      \r\n      if(HAL_DMA_STATE_ABORT == hdma->State)\r\n      {\r\n        /* Disable all the transfer interrupts */\r\n        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);\r\n        hdma->Instance->FCR &= ~(DMA_IT_FE);\r\n        \r\n        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n        {\r\n          hdma->Instance->CR  &= ~(DMA_IT_HT);\r\n        }\r\n\r\n        /* Clear all interrupt flags at correct offset within the register */\r\n        regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n\r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_READY;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n\r\n        if(hdma->XferAbortCallback != NULL)\r\n        {\r\n          hdma->XferAbortCallback(hdma);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)\r\n      {\r\n        /* Current memory buffer used is Memory 0 */\r\n        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)\r\n        {\r\n          if(hdma->XferM1CpltCallback != NULL)\r\n          {\r\n            /* Transfer complete Callback for memory1 */\r\n            hdma->XferM1CpltCallback(hdma);\r\n          }\r\n        }\r\n        /* Current memory buffer used is Memory 1 */\r\n        else\r\n        {\r\n          if(hdma->XferCpltCallback != NULL)\r\n          {\r\n            /* Transfer complete Callback for memory0 */\r\n            hdma->XferCpltCallback(hdma);\r\n          }\r\n        }\r\n      }\r\n      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */\r\n      else\r\n      {\r\n        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)\r\n        {\r\n          /* Disable the transfer complete interrupt */\r\n          hdma->Instance->CR  &= ~(DMA_IT_TC);\r\n\r\n          /* Change the DMA state */\r\n          hdma->State = HAL_DMA_STATE_READY;\r\n\r\n          /* Process Unlocked */\r\n          __HAL_UNLOCK(hdma);\r\n\r\n        }\r\n\r\n        if(hdma->XferCpltCallback != NULL)\r\n        {\r\n          /* Transfer complete callback */\r\n          hdma->XferCpltCallback(hdma);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  /* manage error case */\r\n  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)\r\n  {\r\n    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)\r\n    {\r\n      hdma->State = HAL_DMA_STATE_ABORT;\r\n\r\n      /* Disable the stream */\r\n      __HAL_DMA_DISABLE(hdma);\r\n\r\n      do\r\n      {\r\n        if (++count > timeout)\r\n        {\r\n          break;\r\n        }\r\n      }\r\n      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);\r\n\r\n      /* Change the DMA state */\r\n      hdma->State = HAL_DMA_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hdma);\r\n\r\n    }\r\n\r\n    if(hdma->XferErrorCallback != NULL)\r\n    {\r\n      /* Transfer error callback */\r\n      hdma->XferErrorCallback(hdma);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Register callbacks\r\n  * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified DMA Stream.\r\n  * @param  CallbackID           User Callback identifier\r\n  *                               a DMA_HandleTypeDef structure as parameter.\r\n  * @param  pCallback            pointer to private callbacsk function which has pointer to \r\n  *                               a DMA_HandleTypeDef structure as parameter.\r\n  * @retval HAL status\r\n  */                      \r\nHAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))\r\n{\r\n\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n    case  HAL_DMA_XFER_CPLT_CB_ID:\r\n      hdma->XferCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_HALFCPLT_CB_ID:\r\n      hdma->XferHalfCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_M1CPLT_CB_ID:\r\n      hdma->XferM1CpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:\r\n      hdma->XferM1HalfCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_ERROR_CB_ID:\r\n      hdma->XferErrorCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_ABORT_CB_ID:\r\n      hdma->XferAbortCallback = pCallback;\r\n      break;\r\n\r\n    default:\r\n      /* Return error status */\r\n      status =  HAL_ERROR;\r\n      break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  UnRegister callbacks\r\n  * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified DMA Stream.\r\n  * @param  CallbackID           User Callback identifier\r\n  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.\r\n  * @retval HAL status\r\n  */              \r\nHAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n  \r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n    case  HAL_DMA_XFER_CPLT_CB_ID:\r\n      hdma->XferCpltCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_HALFCPLT_CB_ID:\r\n      hdma->XferHalfCpltCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_M1CPLT_CB_ID:\r\n      hdma->XferM1CpltCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:\r\n      hdma->XferM1HalfCpltCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_ERROR_CB_ID:\r\n      hdma->XferErrorCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_ABORT_CB_ID:\r\n      hdma->XferAbortCallback = NULL;\r\n      break; \r\n      \r\n    case   HAL_DMA_XFER_ALL_CB_ID:\r\n      hdma->XferCpltCallback = NULL;\r\n      hdma->XferHalfCpltCallback = NULL;\r\n      hdma->XferM1CpltCallback = NULL;\r\n      hdma->XferM1HalfCpltCallback = NULL;\r\n      hdma->XferErrorCallback = NULL;\r\n      hdma->XferAbortCallback = NULL;\r\n      break; \r\n      \r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n  \r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group3\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                    ##### State and Errors functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides functions allowing to\r\n      (+) Check the DMA state\r\n      (+) Get error code\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Returns the DMA state.\r\n  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.\r\n  * @retval HAL state\r\n  */\r\nHAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)\r\n{\r\n  return hdma->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the DMA error code\r\n  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains\r\n  *              the configuration information for the specified DMA Stream.\r\n  * @retval DMA Error Code\r\n  */\r\nuint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)\r\n{\r\n  return hdma->ErrorCode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Sets the DMA Transfer parameter.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nstatic void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  /* Clear DBM bit */\r\n  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);\r\n\r\n  /* Configure DMA Stream data length */\r\n  hdma->Instance->NDTR = DataLength;\r\n\r\n  /* Memory to Peripheral */\r\n  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\r\n  {\r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->PAR = DstAddress;\r\n\r\n    /* Configure DMA Stream source address */\r\n    hdma->Instance->M0AR = SrcAddress;\r\n  }\r\n  /* Peripheral to Memory */\r\n  else\r\n  {\r\n    /* Configure DMA Stream source address */\r\n    hdma->Instance->PAR = SrcAddress;\r\n\r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->M0AR = DstAddress;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Returns the DMA Stream base address depending on stream number\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream. \r\n  * @retval Stream base address\r\n  */\r\nstatic uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;\r\n  \r\n  /* lookup table for necessary bitshift of flags within status registers */\r\n  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};\r\n  hdma->StreamIndex = flagBitshiftOffset[stream_number];\r\n  \r\n  if (stream_number > 3U)\r\n  {\r\n    /* return pointer to HISR and HIFCR */\r\n    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);\r\n  }\r\n  else\r\n  {\r\n    /* return pointer to LISR and LIFCR */\r\n    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));\r\n  }\r\n  \r\n  return hdma->StreamBaseAddress;\r\n}\r\n\r\n/**\r\n  * @brief  Check compatibility between FIFO threshold level and size of the memory burst\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream. \r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmp = hdma->Init.FIFOThreshold;\r\n  \r\n  /* Memory Data size equal to Byte */\r\n  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)\r\n  {\r\n    switch (tmp)\r\n    {\r\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_HALFFULL:\r\n      if (hdma->Init.MemBurst == DMA_MBURST_INC16)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_FULL:\r\n      break;\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  \r\n  /* Memory Data size equal to Half-Word */\r\n  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\r\n  {\r\n    switch (tmp)\r\n    {\r\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n      status = HAL_ERROR;\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_HALFFULL:\r\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_FULL:\r\n      if (hdma->Init.MemBurst == DMA_MBURST_INC16)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;   \r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  \r\n  /* Memory Data size equal to Word */\r\n  else\r\n  {\r\n    switch (tmp)\r\n    {\r\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n    case DMA_FIFO_THRESHOLD_HALFFULL:\r\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n      status = HAL_ERROR;\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_FULL:\r\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;\r\n    default:\r\n      break;\r\n    }\r\n  } \r\n  \r\n  return status; \r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_DMA_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_dma_ex.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_dma_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   DMA Extension HAL module driver\r\n  *         This file provides firmware functions to manage the following \r\n  *         functionalities of the DMA Extension peripheral:\r\n  *           + Extended features functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n  The DMA Extension HAL driver can be used as follows:\r\n   (+) Start a multi buffer transfer using the HAL_DMA_MultiBufferStart() function\r\n       for polling mode or HAL_DMA_MultiBufferStart_IT() for interrupt mode.\r\n\r\n     -@-  In Memory-to-Memory transfer mode, Multi (Double) Buffer mode is not allowed.\r\n     -@-  When Multi (Double) Buffer mode is enabled, the transfer is circular by default.\r\n     -@-  In Multi (Double) buffer mode, it is possible to update the base address for \r\n          the AHB memory port on the fly (DMA_SxM0AR or DMA_SxM1AR) when the stream is enabled.\r\n  \r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup DMAEx DMAEx\r\n  * @brief DMA Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_DMA_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private Constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @addtogroup DMAEx_Private_Functions\r\n  * @{\r\n  */\r\n\r\nstatic void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions ---------------------------------------------------------*/\r\n\r\n/** @addtogroup DMAEx_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n\r\n/** @addtogroup DMAEx_Exported_Functions_Group1\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                #####  Extended features functions  #####\r\n ===============================================================================  \r\n    [..]  This section provides functions allowing to:\r\n      (+) Configure the source, destination address and data length and \r\n          Start MultiBuffer DMA transfer\r\n      (+) Configure the source, destination address and data length and \r\n          Start MultiBuffer DMA transfer with interrupt\r\n      (+) Change on the fly the memory0 or memory1 address.\r\n      \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Starts the multi_buffer DMA Transfer.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  \r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n  \r\n  /* Memory-to-memory transfer not supported in double buffering mode */\r\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n    status = HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hdma);\r\n    \r\n    if(HAL_DMA_STATE_READY == hdma->State)\r\n    {\r\n      /* Change DMA peripheral state */\r\n      hdma->State = HAL_DMA_STATE_BUSY; \r\n      \r\n      /* Enable the double buffer mode */\r\n      hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\r\n      \r\n      /* Configure DMA Stream destination address */\r\n      hdma->Instance->M1AR = SecondMemAddress;\r\n      \r\n      /* Configure the source, destination address and the data length */\r\n      DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n      \r\n      /* Enable the peripheral */\r\n      __HAL_DMA_ENABLE(hdma);\r\n    }\r\n    else\r\n    {\r\n      /* Return error status */\r\n      status = HAL_BUSY;\r\n    }\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the multi_buffer DMA Transfer with interrupt enabled.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  \r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n  \r\n  /* Memory-to-memory transfer not supported in double buffering mode */\r\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n    return HAL_ERROR;\r\n  }\r\n  \r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n  \r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n    \r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n    \r\n    /* Enable the Double buffer mode */\r\n    hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\r\n    \r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->M1AR = SecondMemAddress;\r\n    \r\n    /* Configure the source, destination address and the data length */\r\n    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); \r\n    \r\n    /* Clear all flags */\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));\r\n    \r\n    /* Enable Common interrupts*/\r\n    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;\r\n    hdma->Instance->FCR |= DMA_IT_FE;\r\n    \r\n    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n    {\r\n      hdma->Instance->CR  |= DMA_IT_HT;\r\n    }\r\n    \r\n    /* Enable the peripheral */\r\n    __HAL_DMA_ENABLE(hdma); \r\n  }\r\n  else\r\n  {     \r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hdma);\t  \r\n    \r\n    /* Return error status */\r\n    status = HAL_BUSY;\r\n  }  \r\n  return status; \r\n}\r\n\r\n/**\r\n  * @brief  Change the memory0 or memory1 address on the fly.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  Address    The new address\r\n  * @param  memory     the memory to be changed, This parameter can be one of \r\n  *                     the following values:\r\n  *                      MEMORY0 /\r\n  *                      MEMORY1\r\n  * @note   The MEMORY0 address can be changed only when the current transfer use\r\n  *         MEMORY1 and the MEMORY1 address can be changed only when the current \r\n  *         transfer use MEMORY0.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)\r\n{\r\n  if(memory == MEMORY0)\r\n  {\r\n    /* change the memory0 address */\r\n    hdma->Instance->M0AR = Address;\r\n  }\r\n  else\r\n  {\r\n    /* change the memory1 address */\r\n    hdma->Instance->M1AR = Address;\r\n  }\r\n  \r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMAEx_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Set the DMA Transfer parameter.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nstatic void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  /* Configure DMA Stream data length */\r\n  hdma->Instance->NDTR = DataLength;\r\n  \r\n  /* Peripheral to Memory */\r\n  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\r\n  {\r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->PAR = DstAddress;\r\n    \r\n    /* Configure DMA Stream source address */\r\n    hdma->Instance->M0AR = SrcAddress;\r\n  }\r\n  /* Memory to Peripheral */\r\n  else\r\n  {\r\n    /* Configure DMA Stream source address */\r\n    hdma->Instance->PAR = SrcAddress;\r\n    \r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->M0AR = DstAddress;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_DMA_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_exti.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32F7xx_hal_exti.c\r\n  * @author  MCD Application Team\r\n  * @brief   EXTI HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Extended Interrupts and events controller (EXTI) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2018 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### EXTI Peripheral features #####\r\n  ==============================================================================\r\n  [..]\r\n    (+) Each Exti line can be configured within this driver.\r\n\r\n    (+) Exti line can be configured in 3 different modes\r\n        (++) Interrupt\r\n        (++) Event\r\n        (++) Both of them\r\n\r\n    (+) Configurable Exti lines can be configured with 3 different triggers\r\n        (++) Rising\r\n        (++) Falling\r\n        (++) Both of them\r\n\r\n    (+) When set in interrupt mode, configurable Exti lines have two different\r\n        interrupts pending registers which allow to distinguish which transition\r\n        occurs:\r\n        (++) Rising edge pending interrupt\r\n        (++) Falling\r\n\r\n    (+) Exti lines 0 to 15 are linked to gpio pin number 0 to 15. Gpio port can\r\n        be selected through multiplexer.\r\n\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n\r\n    (#) Configure the EXTI line using HAL_EXTI_SetConfigLine().\r\n        (++) Choose the interrupt line number by setting \"Line\" member from\r\n             EXTI_ConfigTypeDef structure.\r\n        (++) Configure the interrupt and/or event mode using \"Mode\" member from\r\n             EXTI_ConfigTypeDef structure.\r\n        (++) For configurable lines, configure rising and/or falling trigger\r\n             \"Trigger\" member from EXTI_ConfigTypeDef structure.\r\n        (++) For Exti lines linked to gpio, choose gpio port using \"GPIOSel\"\r\n             member from GPIO_InitTypeDef structure.\r\n\r\n    (#) Get current Exti configuration of a dedicated line using\r\n        HAL_EXTI_GetConfigLine().\r\n        (++) Provide exiting handle as parameter.\r\n        (++) Provide pointer on EXTI_ConfigTypeDef structure as second parameter.\r\n\r\n    (#) Clear Exti configuration of a dedicated line using HAL_EXTI_GetConfigLine().\r\n        (++) Provide exiting handle as parameter.\r\n\r\n    (#) Register callback to treat Exti interrupts using HAL_EXTI_RegisterCallback().\r\n        (++) Provide exiting handle as first parameter.\r\n        (++) Provide which callback will be registered using one value from\r\n             EXTI_CallbackIDTypeDef.\r\n        (++) Provide callback function pointer.\r\n\r\n    (#) Get interrupt pending bit using HAL_EXTI_GetPending().\r\n\r\n    (#) Clear interrupt pending bit using HAL_EXTI_GetPending().\r\n\r\n    (#) Generate software interrupt using HAL_EXTI_GenerateSWI().\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI\r\n  * @{\r\n  */\r\n/** MISRA C:2012 deviation rule has been granted for following rule:\r\n  * Rule-18.1_b - Medium: Array `EXTICR' 1st subscript interval [0,7] may be out\r\n  * of bounds [0,3] in following API :\r\n  * HAL_EXTI_SetConfigLine\r\n  * HAL_EXTI_GetConfigLine\r\n  * HAL_EXTI_ClearConfigLine\r\n  */\r\n\r\n#ifdef HAL_EXTI_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private defines -----------------------------------------------------------*/\r\n/** @defgroup EXTI_Private_Constants EXTI Private Constants\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @addtogroup EXTI_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI_Exported_Functions_Group1\r\n  *  @brief    Configuration functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Configuration functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Set configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  pExtiConfig Pointer on EXTI configuration to be set.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)\r\n{\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n\r\n  /* Check null pointer */\r\n  if ((hexti == NULL) || (pExtiConfig == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(pExtiConfig->Line));\r\n  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));\r\n\r\n  /* Assign line number to handle */\r\n  hexti->Line = pExtiConfig->Line;\r\n\r\n  /* Compute line mask */\r\n  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);\r\n  maskline = (1uL << linepos);\r\n\r\n  /* Configure triggers for configurable lines */\r\n  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00u)\r\n  {\r\n    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));\r\n\r\n    /* Configure rising trigger */\r\n    /* Mask or set line */\r\n    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00u)\r\n    {\r\n      EXTI->RTSR |= maskline;\r\n    }\r\n    else\r\n    {\r\n      EXTI->RTSR &= ~maskline;\r\n    }\r\n\r\n    /* Configure falling trigger */\r\n    /* Mask or set line */\r\n    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00u)\r\n    {\r\n      EXTI->FTSR |= maskline;\r\n    }\r\n    else\r\n    {\r\n      EXTI->FTSR &= ~maskline;\r\n    }\r\n\r\n\r\n    /* Configure gpio port selection in case of gpio exti line */\r\n    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[linepos >> 2u];\r\n      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));\r\n      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));\r\n      SYSCFG->EXTICR[linepos >> 2u] = regval;\r\n    }\r\n  }\r\n\r\n  /* Configure interrupt mode : read current mode */\r\n  /* Mask or set line */\r\n  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00u)\r\n  {\r\n    EXTI->IMR |= maskline;\r\n  }\r\n  else\r\n  {\r\n    EXTI->IMR &= ~maskline;\r\n  }\r\n\r\n  /* Configure event mode : read current mode */\r\n  /* Mask or set line */\r\n  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00u)\r\n  {\r\n    EXTI->EMR |= maskline;\r\n  }\r\n  else\r\n  {\r\n    EXTI->EMR &= ~maskline;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Get configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  pExtiConfig Pointer on structure to store Exti configuration.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)\r\n{\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n\r\n  /* Check null pointer */\r\n  if ((hexti == NULL) || (pExtiConfig == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n\r\n  /* Store handle line number to configuration structure */\r\n  pExtiConfig->Line = hexti->Line;\r\n\r\n  /* Compute line mask */\r\n  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);\r\n  maskline = (1uL << linepos);\r\n\r\n  /* 1] Get core mode : interrupt */\r\n\r\n  /* Check if selected line is enable */\r\n  if ((EXTI->IMR & maskline) != 0x00u)\r\n  {\r\n    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;\r\n  }\r\n  else\r\n  {\r\n    pExtiConfig->Mode = EXTI_MODE_NONE;\r\n  }\r\n\r\n  /* Get event mode */\r\n  /* Check if selected line is enable */\r\n  if ((EXTI->EMR & maskline) != 0x00u)\r\n  {\r\n    pExtiConfig->Mode |= EXTI_MODE_EVENT;\r\n  }\r\n\r\n  /* Get default Trigger and GPIOSel configuration */\r\n  pExtiConfig->Trigger = EXTI_TRIGGER_NONE;\r\n  pExtiConfig->GPIOSel = 0x00u;\r\n\r\n  /* 2] Get trigger for configurable lines : rising */\r\n  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00u)\r\n  {\r\n    /* Check if configuration of selected line is enable */\r\n    if ((EXTI->RTSR & maskline) != 0x00u)\r\n    {\r\n      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;\r\n    }\r\n\r\n    /* Get falling configuration */\r\n    /* Check if configuration of selected line is enable */\r\n    if ((EXTI->FTSR & maskline) != 0x00u)\r\n    {\r\n      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;\r\n    }\r\n\r\n    /* Get Gpio port selection for gpio lines */\r\n    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[linepos >> 2u];\r\n      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3uL - (linepos & 0x03u)))) >> 24);\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Clear whole configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)\r\n{\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n\r\n  /* Check null pointer */\r\n  if (hexti == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n\r\n  /* compute line mask */\r\n  linepos = (hexti->Line & EXTI_PIN_MASK);\r\n  maskline = (1uL << linepos);\r\n\r\n  /* 1] Clear interrupt mode */\r\n  EXTI->IMR = (EXTI->IMR & ~maskline);\r\n\r\n  /* 2] Clear event mode */\r\n  EXTI->EMR = (EXTI->EMR & ~maskline);\r\n\r\n  /* 3] Clear triggers in case of configurable lines */\r\n  if ((hexti->Line & EXTI_CONFIG) != 0x00u)\r\n  {\r\n    EXTI->RTSR = (EXTI->RTSR & ~maskline);\r\n    EXTI->FTSR = (EXTI->FTSR & ~maskline);\r\n\r\n    /* Get Gpio port selection for gpio lines */\r\n    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[linepos >> 2u];\r\n      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));\r\n      SYSCFG->EXTICR[linepos >> 2u] = regval;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Register callback for a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  CallbackID User callback identifier.\r\n  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.\r\n  * @param  pPendingCbfn function pointer to be stored as callback.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  switch (CallbackID)\r\n  {\r\n    case  HAL_EXTI_COMMON_CB_ID:\r\n      hexti->PendingCallback = pPendingCbfn;\r\n      break;\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Store line number as handle private field.\r\n  * @param  hexti Exti handle.\r\n  * @param  ExtiLine Exti line number.\r\n  *         This parameter can be from 0 to @ref EXTI_LINE_NB.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_EXTI_LINE(ExtiLine));\r\n\r\n  /* Check null pointer */\r\n  if (hexti == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Store line number as handle private field */\r\n    hexti->Line = ExtiLine;\r\n\r\n    return HAL_OK;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup EXTI_Exported_Functions_Group2\r\n  *  @brief EXTI IO functions.\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                       ##### IO operation functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Handle EXTI interrupt request.\r\n  * @param  hexti Exti handle.\r\n  * @retval none.\r\n  */\r\nvoid HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)\r\n{\r\n  uint32_t regval;\r\n  uint32_t maskline;\r\n\r\n  /* Compute line mask */\r\n  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n  /* Get pending bit  */\r\n  regval = (EXTI->PR & maskline);\r\n  if (regval != 0x00u)\r\n  {\r\n    /* Clear pending bit */\r\n    EXTI->PR = maskline;\r\n\r\n    /* Call callback */\r\n    if (hexti->PendingCallback != NULL)\r\n    {\r\n      hexti->PendingCallback();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Get interrupt pending bit of a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @param  Edge Specify which pending edge as to be checked.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref EXTI_TRIGGER_RISING_FALLING\r\n  *         This parameter is kept for compatibility with other series.\r\n  * @retval 1 if interrupt is pending else 0.\r\n  */\r\nuint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)\r\n{\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_PENDING_EDGE(Edge));\r\n\r\n  /* Compute line mask */\r\n  linepos = (hexti->Line & EXTI_PIN_MASK);\r\n  maskline = (1uL << linepos);\r\n\r\n  /* return 1 if bit is set else 0 */\r\n  regval = ((EXTI->PR & maskline) >> linepos);\r\n  return regval;\r\n}\r\n\r\n/**\r\n  * @brief  Clear interrupt pending bit of a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @param  Edge Specify which pending edge as to be clear.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref EXTI_TRIGGER_RISING_FALLING\r\n  *         This parameter is kept for compatibility with other series.\r\n  * @retval None.\r\n  */\r\nvoid HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)\r\n{\r\n  uint32_t maskline;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_PENDING_EDGE(Edge));\r\n\r\n  /* Compute line mask */\r\n  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n  /* Clear Pending bit */\r\n  EXTI->PR =  maskline;\r\n}\r\n\r\n/**\r\n  * @brief  Generate a software interrupt for a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @retval None.\r\n  */\r\nvoid HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)\r\n{\r\n  uint32_t maskline;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n\r\n  /* Compute line mask */\r\n  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n  /* Generate Software interrupt */\r\n  EXTI->SWIER = maskline;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_EXTI_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_flash.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_flash.c\r\n  * @author  MCD Application Team\r\n  * @brief   FLASH HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the internal FLASH memory:\r\n  *           + Program operations functions\r\n  *           + Memory Control functions \r\n  *           + Peripheral Errors functions\r\n  *         \r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### FLASH peripheral features #####\r\n  ==============================================================================\r\n           \r\n  [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses \r\n       to the Flash memory. It implements the erase and program Flash memory operations \r\n       and the read and write protection mechanisms.\r\n      \r\n  [..] The Flash memory interface accelerates code execution with a system of instruction\r\n       prefetch and cache lines. \r\n\r\n  [..] The FLASH main features are:\r\n      (+) Flash memory read operations\r\n      (+) Flash memory program/erase operations\r\n      (+) Read / write protections\r\n      (+) Prefetch on I-Code\r\n      (+) 64 cache lines of 128 bits on I-Code\r\n      (+) 8 cache lines of 128 bits on D-Code\r\n      \r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]                             \r\n      This driver provides functions and macros to configure and program the FLASH \r\n      memory of all STM32F7xx devices.\r\n    \r\n      (#) FLASH Memory IO Programming functions: \r\n           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and \r\n                HAL_FLASH_Lock() functions\r\n           (++) Program functions: byte, half word, word and double word\r\n           (++) There Two modes of programming :\r\n            (+++) Polling mode using HAL_FLASH_Program() function\r\n            (+++) Interrupt mode using HAL_FLASH_Program_IT() function\r\n    \r\n      (#) Interrupts and flags management functions : \r\n           (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()\r\n           (++) Wait for last FLASH operation according to its status\r\n           (++) Get error flag status by calling HAL_SetErrorCode()          \r\n    [..] \r\n      In addition to these functions, this driver includes a set of macros allowing\r\n      to handle the following operations:\r\n       (+) Set the latency\r\n       (+) Enable/Disable the prefetch buffer\r\n       (+) Enable/Disable the Instruction cache and the Data cache\r\n       (+) Reset the Instruction cache and the Data cache\r\n       (+) Enable/Disable the FLASH interrupts\r\n       (+) Monitor the FLASH flags status\r\n    [..]\t   \r\n\t(@) For any Flash memory program operation (erase or program), the CPU clock frequency\r\n        (HCLK) must be at least 1MHz. \r\n\t(@) The contents of the Flash memory are not guaranteed if a device reset occurs during \r\n\t    a Flash memory operation.\r\n    (@) Any attempt to read the Flash memory while it is being written or erased, causes the \r\n\t    bus to stall. Read operations are processed correctly once the program operation has \r\n\t\tcompleted. This means that code or data fetches cannot be performed while a write/erase \r\n\t\toperation is ongoing.\r\n          \r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASH FLASH\r\n  * @brief FLASH HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_FLASH_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup FLASH_Private_Constants\r\n  * @{\r\n  */\r\n#define SECTOR_MASK               ((uint32_t)0xFFFFFF07U)\r\n#define FLASH_TIMEOUT_VALUE       ((uint32_t)50000U)/* 50 s */\r\n/**\r\n  * @}\r\n  */         \r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @addtogroup FLASH_Private_Variables\r\n  * @{\r\n  */\r\n/* Variable used for Erase sectors under interruption */\r\nFLASH_ProcessTypeDef pFlash;\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup FLASH_Private_Functions\r\n  * @{\r\n  */\r\n/* Program operations */\r\nstatic void   FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);\r\nstatic void   FLASH_Program_Word(uint32_t Address, uint32_t Data);\r\nstatic void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);\r\nstatic void   FLASH_Program_Byte(uint32_t Address, uint8_t Data);\r\nstatic void   FLASH_SetErrorCode(void);\r\n\r\nHAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup FLASH_Exported_Functions FLASH Exported Functions\r\n  * @{\r\n  */\r\n  \r\n/** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions \r\n *  @brief   Programming operation functions \r\n *\r\n@verbatim   \r\n ===============================================================================\r\n                  ##### Programming operation functions #####\r\n ===============================================================================  \r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the FLASH \r\n    program operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Program byte, halfword, word or double word at a specified address\r\n  * @param  TypeProgram  Indicate the way to program at a specified address.\r\n  *                           This parameter can be a value of @ref FLASH_Type_Program\r\n  * @param  Address  specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed\r\n  * \r\n  * @retval HAL_StatusTypeDef HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)\r\n{\r\n  HAL_StatusTypeDef status = HAL_ERROR;\r\n  \r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n  \r\n  if(status == HAL_OK)\r\n  {\r\n    switch(TypeProgram)\r\n    {\r\n      case FLASH_TYPEPROGRAM_BYTE :\r\n      {\r\n        /*Program byte (8-bit) at a specified address.*/\r\n        FLASH_Program_Byte(Address, (uint8_t) Data);\r\n        break;\r\n      }\r\n      \r\n      case FLASH_TYPEPROGRAM_HALFWORD :\r\n      {\r\n        /*Program halfword (16-bit) at a specified address.*/\r\n        FLASH_Program_HalfWord(Address, (uint16_t) Data);\r\n        break;\r\n      }\r\n      \r\n      case FLASH_TYPEPROGRAM_WORD :\r\n      {\r\n        /*Program word (32-bit) at a specified address.*/\r\n        FLASH_Program_Word(Address, (uint32_t) Data);\r\n        break;\r\n      }\r\n      \r\n      case FLASH_TYPEPROGRAM_DOUBLEWORD :\r\n      {\r\n        /*Program double word (64-bit) at a specified address.*/\r\n        FLASH_Program_DoubleWord(Address, Data);\r\n        break;\r\n      }\r\n      default :\r\n        break;\r\n    }\r\n    /* Wait for last operation to be completed */\r\n    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n    \r\n    /* If the program operation is completed, disable the PG Bit */\r\n    FLASH->CR &= (~FLASH_CR_PG);\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.\r\n  * @param  TypeProgram  Indicate the way to program at a specified address.\r\n  *                           This parameter can be a value of @ref FLASH_Type_Program\r\n  * @param  Address  specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed\r\n  * \r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));\r\n\r\n  /* Enable End of FLASH Operation interrupt */\r\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);\r\n  \r\n  /* Enable Error source interrupt */\r\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);\r\n  \r\n  /* Clear pending flags (if any) */  \r\n  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\\\r\n                         FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  \r\n\r\n  pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;\r\n  pFlash.Address = Address;\r\n  \r\n  switch(TypeProgram)\r\n  {\r\n    case FLASH_TYPEPROGRAM_BYTE :\r\n    {\r\n      /*Program byte (8-bit) at a specified address.*/\r\n      FLASH_Program_Byte(Address, (uint8_t) Data);\r\n      break;\r\n    }\r\n    \r\n    case FLASH_TYPEPROGRAM_HALFWORD :\r\n    {\r\n      /*Program halfword (16-bit) at a specified address.*/\r\n      FLASH_Program_HalfWord(Address, (uint16_t) Data);\r\n      break;\r\n    }\r\n    \r\n    case FLASH_TYPEPROGRAM_WORD :\r\n    {\r\n      /*Program word (32-bit) at a specified address.*/\r\n      FLASH_Program_Word(Address, (uint32_t) Data);\r\n      break;\r\n    }\r\n    \r\n    case FLASH_TYPEPROGRAM_DOUBLEWORD :\r\n    {\r\n      /*Program double word (64-bit) at a specified address.*/\r\n      FLASH_Program_DoubleWord(Address, Data);\r\n      break;\r\n    }\r\n    default :\r\n      break;\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief This function handles FLASH interrupt request.\r\n  * @retval None\r\n  */\r\nvoid HAL_FLASH_IRQHandler(void)\r\n{\r\n  uint32_t temp = 0;\r\n  \r\n  /* If the program operation is completed, disable the PG Bit */\r\n  FLASH->CR &= (~FLASH_CR_PG);\r\n\r\n  /* If the erase operation is completed, disable the SER Bit */\r\n  FLASH->CR &= (~FLASH_CR_SER);\r\n  FLASH->CR &= SECTOR_MASK; \r\n\r\n  /* if the erase operation is completed, disable the MER Bit */\r\n  FLASH->CR &= (~FLASH_MER_BIT);\r\n\r\n  /* Check FLASH End of Operation flag  */\r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)\r\n  {\r\n    /* Clear FLASH End of Operation pending bit */\r\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);\r\n    \r\n    switch (pFlash.ProcedureOnGoing)\r\n    {\r\n      case FLASH_PROC_SECTERASE :\r\n      {\r\n        /* Nb of sector to erased can be decreased */\r\n        pFlash.NbSectorsToErase--;\r\n\r\n        /* Check if there are still sectors to erase */\r\n        if(pFlash.NbSectorsToErase != 0)\r\n        {\r\n          temp = pFlash.Sector;\r\n          /* Indicate user which sector has been erased */\r\n          HAL_FLASH_EndOfOperationCallback(temp);\r\n\r\n          /* Increment sector number */\r\n          temp = ++pFlash.Sector;\r\n          FLASH_Erase_Sector(temp, pFlash.VoltageForErase);\r\n        }\r\n        else\r\n        {\r\n          /* No more sectors to Erase, user callback can be called.*/\r\n          /* Reset Sector and stop Erase sectors procedure */\r\n          pFlash.Sector = temp = 0xFFFFFFFFU;\r\n          /* FLASH EOP interrupt user callback */\r\n          HAL_FLASH_EndOfOperationCallback(temp);\r\n          /* Sector Erase procedure is completed */\r\n          pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n        }\r\n        break;\r\n      }\r\n    \r\n      case FLASH_PROC_MASSERASE :\r\n      {\r\n        /* MassErase ended. Return the selected bank : in this product we don't have Banks */\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(0);\r\n        /* MAss Erase procedure is completed */\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n        break;\r\n      }\r\n\r\n      case FLASH_PROC_PROGRAM :\r\n      {\r\n        /*Program ended. Return the selected address*/\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Address);\r\n        /* Programming procedure is completed */\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n        break;\r\n      }\r\n      default :\r\n        break;\r\n    }\r\n  }\r\n  \r\n  /* Check FLASH operation error flags */\r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)\r\n  {\r\n    switch (pFlash.ProcedureOnGoing)\r\n    {\r\n      case FLASH_PROC_SECTERASE :\r\n      {\r\n        /* return the faulty sector */\r\n        temp = pFlash.Sector;\r\n        pFlash.Sector = 0xFFFFFFFFU;\r\n        break;\r\n      }\r\n      case FLASH_PROC_MASSERASE :\r\n      {\r\n        /* No return in case of Mass Erase */\r\n        temp = 0;\r\n        break;\r\n      }\r\n      case FLASH_PROC_PROGRAM :\r\n      {\r\n        /*return the faulty address*/\r\n        temp = pFlash.Address;\r\n        break;\r\n      }\r\n    default :\r\n      break;\r\n    }\r\n    /*Save the Error code*/\r\n    FLASH_SetErrorCode();\r\n\r\n    /* FLASH error interrupt user callback */\r\n    HAL_FLASH_OperationErrorCallback(temp);\r\n\r\n    /*Stop the procedure ongoing */\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n  }\r\n  \r\n  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)\r\n  {\r\n    /* Disable End of FLASH Operation interrupt */\r\n    __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);\r\n\r\n    /* Disable Error source interrupt */\r\n    __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(&pFlash);\r\n  }\r\n  \r\n}\r\n\r\n/**\r\n  * @brief  FLASH end of operation interrupt callback\r\n  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure\r\n  *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that \r\n  *                                  all the selected sectors have been erased)\r\n  *                 - Program      : Address which was selected for data program\r\n  *                 - Mass Erase   : No return value expected\r\n  * @retval None\r\n  */\r\n__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(ReturnValue);\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n  the HAL_FLASH_EndOfOperationCallback could be implemented in the user file\r\n  */ \r\n}\r\n\r\n/**\r\n  * @brief  FLASH operation error interrupt callback\r\n  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure\r\n  *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that \r\n  *                                  all the selected sectors have been erased)\r\n  *                 - Program      : Address which was selected for data program\r\n  *                 - Mass Erase   : No return value expected\r\n  * @retval None\r\n  */\r\n__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(ReturnValue);\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n  the HAL_FLASH_OperationErrorCallback could be implemented in the user file\r\n   */ \r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions \r\n *  @brief   management functions \r\n *\r\n@verbatim   \r\n ===============================================================================\r\n                      ##### Peripheral Control functions #####\r\n ===============================================================================  \r\n    [..]\r\n    This subsection provides a set of functions allowing to control the FLASH \r\n    memory operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Unlock the FLASH control register access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Unlock(void)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)\r\n  {\r\n    /* Authorize the FLASH Registers access */\r\n    WRITE_REG(FLASH->KEYR, FLASH_KEY1);\r\n    WRITE_REG(FLASH->KEYR, FLASH_KEY2);\r\n\r\n    /* Verify Flash is unlocked */\r\n    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)\r\n    {\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Locks the FLASH control register access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Lock(void)\r\n{\r\n  /* Set the LOCK Bit to lock the FLASH Registers access */\r\n  FLASH->CR |= FLASH_CR_LOCK;\r\n  \r\n  return HAL_OK;  \r\n}\r\n\r\n/**\r\n  * @brief  Unlock the FLASH Option Control Registers access.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)\r\n{\r\n  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)\r\n  {\r\n    /* Authorizes the Option Byte register programming */\r\n    FLASH->OPTKEYR = FLASH_OPT_KEY1;\r\n    FLASH->OPTKEYR = FLASH_OPT_KEY2;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }  \r\n  \r\n  return HAL_OK;  \r\n}\r\n\r\n/**\r\n  * @brief  Lock the FLASH Option Control Registers access.\r\n  * @retval HAL Status \r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Lock(void)\r\n{\r\n  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */\r\n  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;\r\n  \r\n  return HAL_OK;  \r\n}\r\n\r\n/**\r\n  * @brief  Launch the option byte loading.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Launch(void)\r\n{\r\n  /* Set the OPTSTRT bit in OPTCR register */\r\n  FLASH->OPTCR |= FLASH_OPTCR_OPTSTRT;\r\n\r\n  /* Wait for last operation to be completed */\r\n  return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); \r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions \r\n *  @brief   Peripheral Errors functions \r\n *\r\n@verbatim   \r\n ===============================================================================\r\n                ##### Peripheral Errors functions #####\r\n ===============================================================================  \r\n    [..]\r\n    This subsection permits to get in run-time Errors of the FLASH peripheral.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Get the specific FLASH error flag.\r\n  * @retval FLASH_ErrorCode: The returned value can be:\r\n  *            @arg FLASH_ERROR_ERS: FLASH Erasing Sequence error flag \r\n  *            @arg FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  \r\n  *            @arg FLASH_ERROR_PGA: FLASH Programming Alignment error flag\r\n  *            @arg FLASH_ERROR_WRP: FLASH Write protected error flag\r\n  *            @arg FLASH_ERROR_OPERATION: FLASH operation Error flag \r\n  */\r\nuint32_t HAL_FLASH_GetError(void)\r\n{ \r\n   return pFlash.ErrorCode;\r\n}  \r\n  \r\n/**\r\n  * @}\r\n  */    \r\n\r\n/**\r\n  * @brief  Wait for a FLASH operation to complete.\r\n  * @param  Timeout maximum flash operationtimeout\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)\r\n{ \r\n  uint32_t tickstart = 0;\r\n  \r\n  /* Clear Error Code */\r\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\r\n  \r\n  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.\r\n     Even if the FLASH operation fails, the BUSY flag will be reset and an error\r\n     flag will be set */\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) \r\n  { \r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    } \r\n  }\r\n  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)\r\n  {\r\n    /*Save the error code*/\r\n    FLASH_SetErrorCode();\r\n    return HAL_ERROR;\r\n  }\r\n  \r\n  /* Check FLASH End of Operation flag  */\r\n  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)\r\n  {\r\n    /* Clear FLASH End of Operation pending bit */\r\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);\r\n  }\r\n\r\n  /* If there is an error flag set */\r\n  return HAL_OK;\r\n  \r\n}  \r\n\r\n/**\r\n  * @brief  Program a double word (64-bit) at a specified address.\r\n  * @note   This function must be used when the device voltage range is from\r\n  *         2.7V to 3.6V and an External Vpp is present.\r\n  *\r\n  * @note   If an erase and a program operations are requested simultaneously,    \r\n  *         the erase operation is performed before the program one.\r\n  *  \r\n  * @param  Address specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_ADDRESS(Address));\r\n  \r\n  /* If the previous operation is completed, proceed to program the new data */\r\n  FLASH->CR &= CR_PSIZE_MASK;\r\n  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;\r\n  FLASH->CR |= FLASH_CR_PG;\r\n\r\n  /* Program first word */\r\n  *(__IO uint32_t*)Address = (uint32_t)Data;\r\n  /* Barrier to ensure programming is performed in 2 steps, in right order\r\n    (independently of compiler optimization behavior) */\r\n  __ISB();\r\n\r\n  /* Program second word */\r\n  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);\r\n\r\n  /* Data synchronous Barrier (DSB) Just after the write operation\r\n     This will force the CPU to respect the sequence of instruction (no optimization).*/\r\n  __DSB();\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Program word (32-bit) at a specified address.\r\n  * @note   This function must be used when the device voltage range is from\r\n  *         2.7V to 3.3V.\r\n  *\r\n  * @note   If an erase and a program operations are requested simultaneously,    \r\n  *         the erase operation is performed before the program one.\r\n  *  \r\n  * @param  Address specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_Program_Word(uint32_t Address, uint32_t Data)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_ADDRESS(Address));\r\n  \r\n  /* If the previous operation is completed, proceed to program the new data */\r\n  FLASH->CR &= CR_PSIZE_MASK;\r\n  FLASH->CR |= FLASH_PSIZE_WORD;\r\n  FLASH->CR |= FLASH_CR_PG;\r\n\r\n  *(__IO uint32_t*)Address = Data;\r\n  \r\n  /* Data synchronous Barrier (DSB) Just after the write operation\r\n     This will force the CPU to respect the sequence of instruction (no optimization).*/\r\n  __DSB();\r\n}\r\n\r\n/**\r\n  * @brief  Program a half-word (16-bit) at a specified address.\r\n  * @note   This function must be used when the device voltage range is from\r\n  *         2.1V to 3.6V.\r\n  *\r\n  * @note   If an erase and a program operations are requested simultaneously,    \r\n  *         the erase operation is performed before the program one.\r\n  *  \r\n  * @param  Address specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_ADDRESS(Address));\r\n  \r\n  /* If the previous operation is completed, proceed to program the new data */\r\n  FLASH->CR &= CR_PSIZE_MASK;\r\n  FLASH->CR |= FLASH_PSIZE_HALF_WORD;\r\n  FLASH->CR |= FLASH_CR_PG;\r\n\r\n  *(__IO uint16_t*)Address = Data;\r\n\r\n  /* Data synchronous Barrier (DSB) Just after the write operation\r\n     This will force the CPU to respect the sequence of instruction (no optimization).*/\r\n  __DSB();\r\n  \r\n}\r\n\r\n/**\r\n  * @brief  Program byte (8-bit) at a specified address.\r\n  * @note   This function must be used when the device voltage range is from\r\n  *         1.7V to 3.6V.\r\n  *\r\n  * @note   If an erase and a program operations are requested simultaneously,    \r\n  *         the erase operation is performed before the program one.\r\n  *  \r\n  * @param  Address specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_Program_Byte(uint32_t Address, uint8_t Data)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_ADDRESS(Address));\r\n  \r\n  /* If the previous operation is completed, proceed to program the new data */\r\n  FLASH->CR &= CR_PSIZE_MASK;\r\n  FLASH->CR |= FLASH_PSIZE_BYTE;\r\n  FLASH->CR |= FLASH_CR_PG;\r\n\r\n  *(__IO uint8_t*)Address = Data;\r\n\r\n  /* Data synchronous Barrier (DSB) Just after the write operation\r\n     This will force the CPU to respect the sequence of instruction (no optimization).*/\r\n  __DSB();\r\n}\r\n\r\n/**\r\n  * @brief  Set the specific FLASH error flag.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_SetErrorCode(void)\r\n{\r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)\r\n  {\r\n    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;\r\n  }\r\n  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)\r\n  {\r\n   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;\r\n  }\r\n  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)\r\n  {\r\n   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;\r\n  }\r\n  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)\r\n  {\r\n    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;\r\n  }\r\n  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)\r\n  {\r\n    pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;\r\n  }\r\n  \r\n#if defined (FLASH_OPTCR2_PCROP)\r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)\r\n  { \r\n   pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;\r\n  }  \r\n#endif /* FLASH_OPTCR2_PCROP */\r\n  \r\n  /* Clear error programming flags */\r\n  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_FLASH_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_flash_ex.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_flash_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended FLASH HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the FLASH extension peripheral:\r\n  *           + Extended programming operations functions\r\n  *  \r\n  @verbatim\r\n  ==============================================================================\r\n                   ##### Flash Extension features #####\r\n  ==============================================================================\r\n           \r\n  [..] Comparing to other previous devices, the FLASH interface for STM32F76xx/STM32F77xx \r\n       devices contains the following additional features \r\n       \r\n       (+) Capacity up to 2 Mbyte with dual bank architecture supporting read-while-write\r\n           capability (RWW)\r\n       (+) Dual bank memory organization       \r\n       (+) Dual boot mode\r\n   \r\n                      ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..] This driver provides functions to configure and program the FLASH memory \r\n       of all STM32F7xx devices. It includes\r\n      (#) FLASH Memory Erase functions: \r\n           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and \r\n                HAL_FLASH_Lock() functions\r\n           (++) Erase function: Erase sector, erase all sectors\r\n           (++) There are two modes of erase :\r\n             (+++) Polling Mode using HAL_FLASHEx_Erase()\r\n             (+++) Interrupt Mode using HAL_FLASHEx_Erase_IT()\r\n             \r\n      (#) Option Bytes Programming functions: Use HAL_FLASHEx_OBProgram() to :\r\n           (++) Set/Reset the write protection\r\n           (++) Set the Read protection Level\r\n           (++) Set the BOR level\r\n           (++) Program the user Option Bytes\r\n  \r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASHEx FLASHEx\r\n  * @brief FLASH HAL Extension module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_FLASH_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup FLASHEx_Private_Constants\r\n  * @{\r\n  */    \r\n#define SECTOR_MASK               0xFFFFFF07U\r\n#define FLASH_TIMEOUT_VALUE       50000U/* 50 s */\r\n/**\r\n  * @}\r\n  */\r\n    \r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @addtogroup FLASHEx_Private_Variables\r\n  * @{\r\n  */    \r\nextern FLASH_ProcessTypeDef pFlash;\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup FLASHEx_Private_Functions\r\n  * @{\r\n  */\r\n/* Option bytes control */\r\nstatic HAL_StatusTypeDef  FLASH_OB_EnableWRP(uint32_t WRPSector);\r\nstatic HAL_StatusTypeDef  FLASH_OB_DisableWRP(uint32_t WRPSector);\r\nstatic HAL_StatusTypeDef  FLASH_OB_RDP_LevelConfig(uint8_t Level);\r\nstatic HAL_StatusTypeDef  FLASH_OB_BOR_LevelConfig(uint8_t Level);\r\nstatic HAL_StatusTypeDef  FLASH_OB_BootAddressConfig(uint32_t BootOption, uint32_t Address);\r\nstatic uint32_t           FLASH_OB_GetUser(void);\r\nstatic uint32_t           FLASH_OB_GetWRP(void);\r\nstatic uint8_t            FLASH_OB_GetRDP(void);\r\nstatic uint32_t           FLASH_OB_GetBOR(void);\r\nstatic uint32_t           FLASH_OB_GetBootAddress(uint32_t BootOption);\r\n\r\n#if defined (FLASH_OPTCR_nDBANK)\r\nstatic void               FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks);\r\nstatic HAL_StatusTypeDef  FLASH_OB_UserConfig(uint32_t Wwdg, uint32_t Iwdg, uint32_t Stop, uint32_t Stdby, uint32_t Iwdgstop, \\\r\n                                              uint32_t Iwdgstdby, uint32_t NDBank, uint32_t NDBoot);\r\n#else\r\nstatic void               FLASH_MassErase(uint8_t VoltageRange);\r\nstatic HAL_StatusTypeDef  FLASH_OB_UserConfig(uint32_t Wwdg, uint32_t Iwdg, uint32_t Stop, uint32_t Stdby, uint32_t Iwdgstop, uint32_t Iwdgstdby);\r\n#endif /* FLASH_OPTCR_nDBANK */\r\n\r\n#if defined (FLASH_OPTCR2_PCROP)\r\nstatic HAL_StatusTypeDef  FLASH_OB_PCROP_Config(uint32_t PCROPSector);\r\nstatic HAL_StatusTypeDef  FLASH_OB_PCROP_RDP_Config(uint32_t Pcrop_Rdp);\r\nstatic uint32_t           FLASH_OB_GetPCROP(void);\r\nstatic uint32_t           FLASH_OB_GetPCROPRDP(void);\r\n#endif /* FLASH_OPTCR2_PCROP */\r\n\r\nextern HAL_StatusTypeDef  FLASH_WaitForLastOperation(uint32_t Timeout);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASHEx_Exported_Functions_Group1 Extended IO operation functions\r\n *  @brief   Extended IO operation functions \r\n *\r\n@verbatim   \r\n ===============================================================================\r\n                ##### Extended programming operation functions #####\r\n ===============================================================================  \r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the Extension FLASH \r\n    programming operations Operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Perform a mass erase or erase the specified FLASH memory sectors \r\n  * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that\r\n  *         contains the configuration information for the erasing.\r\n  * \r\n  * @param[out]  SectorError pointer to variable  that\r\n  *         contains the configuration information on faulty sector in case of error \r\n  *         (0xFFFFFFFF means that all the sectors have been correctly erased)\r\n  * \r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)\r\n{\r\n  HAL_StatusTypeDef status = HAL_ERROR;\r\n  uint32_t index = 0;\r\n  \r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if(status == HAL_OK)\r\n  {\r\n    /*Initialization of SectorError variable*/\r\n    *SectorError = 0xFFFFFFFFU;\r\n    \r\n    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\r\n    {\r\n      /*Mass erase to be done*/\r\n#if defined (FLASH_OPTCR_nDBANK)      \r\n      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);\r\n#else\r\n      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange);      \r\n#endif /* FLASH_OPTCR_nDBANK */\r\n                      \r\n      /* Wait for last operation to be completed */\r\n      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n      \r\n      /* if the erase operation is completed, disable the MER Bit */\r\n      FLASH->CR &= (~FLASH_MER_BIT);\r\n    }\r\n    else\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));\r\n\r\n      /* Erase by sector by sector to be done*/\r\n      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)\r\n      {\r\n        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);\r\n\r\n        /* Wait for last operation to be completed */\r\n        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n        \r\n        /* If the erase operation is completed, disable the SER Bit and SNB Bits */\r\n        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB)); \r\n\r\n        if(status != HAL_OK) \r\n        {\r\n          /* In case of error, stop erase procedure and return the faulty sector*/\r\n          *SectorError = index;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Perform a mass erase or erase the specified FLASH memory sectors  with interrupt enabled\r\n  * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that\r\n  *         contains the configuration information for the erasing.\r\n  * \r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\r\n\r\n  /* Enable End of FLASH Operation interrupt */\r\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);\r\n  \r\n  /* Enable Error source interrupt */\r\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);\r\n  \r\n  /* Clear pending flags (if any) */  \r\n  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\\\r\n                         FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  \r\n  \r\n  if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\r\n  {\r\n    /*Mass erase to be done*/\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;\r\n#if defined (FLASH_OPTCR_nDBANK)    \r\n    FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);\r\n#else\r\n    FLASH_MassErase((uint8_t) pEraseInit->VoltageRange);      \r\n#endif /* FLASH_OPTCR_nDBANK */    \r\n  }\r\n  else\r\n  {\r\n    /* Erase by sector to be done*/\r\n\r\n    /* Check the parameters */\r\n    assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));\r\n\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE;\r\n    pFlash.NbSectorsToErase = pEraseInit->NbSectors;\r\n    pFlash.Sector = pEraseInit->Sector;\r\n    pFlash.VoltageForErase = (uint8_t)pEraseInit->VoltageRange;\r\n\r\n    /*Erase 1st sector and wait for IT*/\r\n    FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->VoltageRange);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Program option bytes\r\n  * @param  pOBInit pointer to an FLASH_OBInitStruct structure that\r\n  *         contains the configuration information for the programming.\r\n  * \r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)\r\n{\r\n  HAL_StatusTypeDef status = HAL_ERROR;\r\n  \r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));\r\n\r\n  /* Write protection configuration */\r\n  if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)\r\n  {\r\n    assert_param(IS_WRPSTATE(pOBInit->WRPState));\r\n    if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)\r\n    {\r\n      /*Enable of Write protection on the selected Sector*/\r\n      status = FLASH_OB_EnableWRP(pOBInit->WRPSector);\r\n    }\r\n    else\r\n    {\r\n      /*Disable of Write protection on the selected Sector*/\r\n      status = FLASH_OB_DisableWRP(pOBInit->WRPSector);\r\n    }\r\n  }\r\n\r\n  /* Read protection configuration */\r\n  if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)\r\n  {\r\n    status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);\r\n  }\r\n\r\n  /* USER  configuration */\r\n  if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)\r\n  {\r\n#if defined (FLASH_OPTCR_nDBANK)\r\n    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, \r\n                                 pOBInit->USERConfig & OB_IWDG_SW,\r\n                                 pOBInit->USERConfig & OB_STOP_NO_RST,\r\n                                 pOBInit->USERConfig & OB_STDBY_NO_RST, \r\n                                 pOBInit->USERConfig & OB_IWDG_STOP_ACTIVE,\r\n                                 pOBInit->USERConfig & OB_IWDG_STDBY_ACTIVE,\r\n                                 pOBInit->USERConfig & OB_NDBANK_SINGLE_BANK,\r\n                                 pOBInit->USERConfig & OB_DUAL_BOOT_DISABLE);\r\n#else\r\n    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, \r\n                                 pOBInit->USERConfig & OB_IWDG_SW,\r\n                                 pOBInit->USERConfig & OB_STOP_NO_RST,\r\n                                 pOBInit->USERConfig & OB_STDBY_NO_RST, \r\n                                 pOBInit->USERConfig & OB_IWDG_STOP_ACTIVE,\r\n                                 pOBInit->USERConfig & OB_IWDG_STDBY_ACTIVE);    \r\n#endif /* FLASH_OPTCR_nDBANK */\r\n  }\r\n  \r\n  /* BOR Level  configuration */\r\n  if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)\r\n  {\r\n    status = FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);\r\n  }\r\n  \r\n  /* Boot 0 Address configuration */\r\n  if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR_0) == OPTIONBYTE_BOOTADDR_0)\r\n  {\r\n    status = FLASH_OB_BootAddressConfig(OPTIONBYTE_BOOTADDR_0, pOBInit->BootAddr0);\r\n  }\r\n  \r\n  /* Boot 1 Address configuration */\r\n  if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR_1) == OPTIONBYTE_BOOTADDR_1)\r\n  {\r\n    status = FLASH_OB_BootAddressConfig(OPTIONBYTE_BOOTADDR_1, pOBInit->BootAddr1);\r\n  }\r\n  \r\n#if defined (FLASH_OPTCR2_PCROP)\r\n  /* PCROP configuration */\r\n  if((pOBInit->OptionType & OPTIONBYTE_PCROP) == OPTIONBYTE_PCROP)\r\n  {\r\n    status = FLASH_OB_PCROP_Config(pOBInit->PCROPSector);\r\n  }\r\n  \r\n  /* PCROP_RDP configuration */\r\n  if((pOBInit->OptionType & OPTIONBYTE_PCROP_RDP) == OPTIONBYTE_PCROP_RDP)\r\n  {\r\n    status = FLASH_OB_PCROP_RDP_Config(pOBInit->PCROPRdp);\r\n  }\r\n#endif /* FLASH_OPTCR2_PCROP */\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Get the Option byte configuration\r\n  * @param  pOBInit pointer to an FLASH_OBInitStruct structure that\r\n  *         contains the configuration information for the programming.\r\n  * \r\n  * @retval None\r\n  */\r\nvoid HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)\r\n{\r\n  pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER |\\\r\n\t                OPTIONBYTE_BOR | OPTIONBYTE_BOOTADDR_0 | OPTIONBYTE_BOOTADDR_1;\r\n\r\n  /*Get WRP*/\r\n  pOBInit->WRPSector = FLASH_OB_GetWRP();\r\n\r\n  /*Get RDP Level*/\r\n  pOBInit->RDPLevel = FLASH_OB_GetRDP();\r\n\r\n  /*Get USER*/\r\n  pOBInit->USERConfig = FLASH_OB_GetUser();\r\n\r\n  /*Get BOR Level*/\r\n  pOBInit->BORLevel = FLASH_OB_GetBOR();\r\n  \r\n  /*Get Boot Address when Boot pin = 0 */\r\n  pOBInit->BootAddr0 = FLASH_OB_GetBootAddress(OPTIONBYTE_BOOTADDR_0);\r\n  \r\n  /*Get Boot Address when Boot pin = 1 */\r\n  pOBInit->BootAddr1 = FLASH_OB_GetBootAddress(OPTIONBYTE_BOOTADDR_1);\r\n\r\n#if defined (FLASH_OPTCR2_PCROP)\r\n  /*Get PCROP Sectors */\r\n  pOBInit->PCROPSector = FLASH_OB_GetPCROP();\r\n  \r\n  /*Get PCROP_RDP Value */\r\n  pOBInit->PCROPRdp = FLASH_OB_GetPCROPRDP();\r\n#endif /* FLASH_OPTCR2_PCROP */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n#if defined (FLASH_OPTCR_nDBANK)\r\n/**\r\n  * @brief  Full erase of FLASH memory sectors \r\n  * @param  VoltageRange The device voltage range which defines the erase parallelism.  \r\n  *          This parameter can be one of the following values:\r\n  *            @arg VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, \r\n  *                                  the operation will be done by byte (8-bit) \r\n  *            @arg VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,\r\n  *                                  the operation will be done by half word (16-bit)\r\n  *            @arg VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,\r\n  *                                  the operation will be done by word (32-bit)\r\n  *            @arg VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, \r\n  *                                  the operation will be done by double word (64-bit)\r\n  * @param  Banks Banks to be erased\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: Bank1 to be erased\r\n  *            @arg FLASH_BANK_2: Bank2 to be erased\r\n  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* if the previous operation is completed, proceed to erase all sectors */\r\n  FLASH->CR &= CR_PSIZE_MASK;\r\n  if(Banks == FLASH_BANK_BOTH)\r\n  {\r\n    /* bank1 & bank2 will be erased*/\r\n    FLASH->CR |= FLASH_MER_BIT;\r\n  }\r\n  else if(Banks == FLASH_BANK_2)\r\n  {\r\n    /*Only bank2 will be erased*/\r\n    FLASH->CR |= FLASH_CR_MER2;\r\n  }\r\n  else\r\n  {\r\n    /*Only bank1 will be erased*/\r\n    FLASH->CR |= FLASH_CR_MER1;    \r\n  }\r\n  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8);\r\n  /* Data synchronous Barrier (DSB) Just after the write operation\r\n     This will force the CPU to respect the sequence of instruction (no optimization).*/\r\n  __DSB();\r\n}\r\n\r\n/**\r\n  * @brief  Erase the specified FLASH memory sector\r\n  * @param  Sector FLASH sector to erase\r\n  *         The value of this parameter depend on device used within the same series      \r\n  * @param  VoltageRange The device voltage range which defines the erase parallelism.  \r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, \r\n  *                                  the operation will be done by byte (8-bit) \r\n  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,\r\n  *                                  the operation will be done by half word (16-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,\r\n  *                                  the operation will be done by word (32-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, \r\n  *                                  the operation will be done by double word (64-bit)\r\n  * \r\n  * @retval None\r\n  */\r\nvoid FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)\r\n{\r\n  uint32_t tmp_psize = 0;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_SECTOR(Sector));\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n  \r\n  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)\r\n  {\r\n     tmp_psize = FLASH_PSIZE_BYTE;\r\n  }\r\n  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_HALF_WORD;\r\n  }\r\n  else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_WORD;\r\n  }\r\n  else\r\n  {\r\n    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;\r\n  }\r\n  \r\n  /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */\r\n  if(Sector > FLASH_SECTOR_11) \r\n  {\r\n    Sector += 4;\r\n  }  \r\n\r\n  /* If the previous operation is completed, proceed to erase the sector */\r\n  FLASH->CR &= CR_PSIZE_MASK;\r\n  FLASH->CR |= tmp_psize;\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);\r\n  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);\r\n  FLASH->CR |= FLASH_CR_STRT;\r\n  \r\n  /* Data synchronous Barrier (DSB) Just after the write operation\r\n     This will force the CPU to respect the sequence of instruction (no optimization).*/\r\n  __DSB();\r\n}\r\n\r\n/**\r\n  * @brief  Return the FLASH Write Protection Option Bytes value.\r\n  * @retval uint32_t FLASH Write Protection Option Bytes value\r\n  */\r\nstatic uint32_t FLASH_OB_GetWRP(void)\r\n{\r\n  /* Return the FLASH write protection Register value */\r\n  return ((uint32_t)(FLASH->OPTCR & 0x0FFF0000));\r\n}\r\n\r\n/**\r\n  * @brief  Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    \r\n  * @param  Wwdg Selects the IWDG mode\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_WWDG_SW: Software WWDG selected\r\n  *            @arg OB_WWDG_HW: Hardware WWDG selected\r\n  * @param  Iwdg Selects the WWDG mode\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_IWDG_SW: Software IWDG selected\r\n  *            @arg OB_IWDG_HW: Hardware IWDG selected\r\n  * @param  Stop Reset event when entering STOP mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_STOP_NO_RST: No reset generated when entering in STOP\r\n  *            @arg OB_STOP_RST: Reset generated when entering in STOP\r\n  * @param  Stdby Reset event when entering Standby mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_STDBY_NO_RST: No reset generated when entering in STANDBY\r\n  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY\r\n  * @param  Iwdgstop Independent watchdog counter freeze in Stop mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_IWDG_STOP_FREEZE: Freeze IWDG counter in STOP\r\n  *            @arg OB_IWDG_STOP_ACTIVE: IWDG counter active in STOP\r\n  * @param  Iwdgstdby Independent watchdog counter freeze in standby mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_IWDG_STDBY_FREEZE: Freeze IWDG counter in STANDBY\r\n  *            @arg OB_IWDG_STDBY_ACTIVE: IWDG counter active in STANDBY\r\n  * @param  NDBank Flash Single Bank mode enabled.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_NDBANK_SINGLE_BANK: enable 256 bits mode (Flash is a single bank)\r\n  *            @arg OB_NDBANK_DUAL_BANK: disable 256 bits mode (Flash is a dual bank in 128 bits mode)  \r\n  * @param  NDBoot Flash Dual boot mode disable.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_DUAL_BOOT_DISABLE: Disable Dual Boot\r\n  *            @arg OB_DUAL_BOOT_ENABLE: Enable Dual Boot\r\n\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_UserConfig(uint32_t Wwdg, uint32_t Iwdg, uint32_t Stop, uint32_t Stdby, uint32_t Iwdgstop, \\\r\n                                             uint32_t Iwdgstdby, uint32_t NDBank, uint32_t NDBoot)\r\n{\r\n  uint32_t useroptionmask = 0x00;\r\n  uint32_t useroptionvalue = 0x00;\r\n\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WWDG_SOURCE(Wwdg));\r\n  assert_param(IS_OB_IWDG_SOURCE(Iwdg));\r\n  assert_param(IS_OB_STOP_SOURCE(Stop));\r\n  assert_param(IS_OB_STDBY_SOURCE(Stdby));\r\n  assert_param(IS_OB_IWDG_STOP_FREEZE(Iwdgstop));\r\n  assert_param(IS_OB_IWDG_STDBY_FREEZE(Iwdgstdby));\r\n  assert_param(IS_OB_NDBANK(NDBank));\r\n  assert_param(IS_OB_NDBOOT(NDBoot));\r\n  \r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n  \r\n  if(status == HAL_OK)\r\n  {\r\n    useroptionmask = (FLASH_OPTCR_WWDG_SW | FLASH_OPTCR_IWDG_SW | FLASH_OPTCR_nRST_STOP | \\\r\n                      FLASH_OPTCR_nRST_STDBY | FLASH_OPTCR_IWDG_STOP | FLASH_OPTCR_IWDG_STDBY | \\\r\n                      FLASH_OPTCR_nDBOOT | FLASH_OPTCR_nDBANK);\r\n                      \r\n    useroptionvalue = (Iwdg | Wwdg | Stop | Stdby | Iwdgstop | Iwdgstdby | NDBoot | NDBank);\r\n        \r\n    /* Update User Option Byte */               \r\n    MODIFY_REG(FLASH->OPTCR, useroptionmask, useroptionvalue);\r\n  }\r\n  \r\n  return status; \r\n}\r\n\r\n/**\r\n  * @brief  Return the FLASH User Option Byte value.\r\n  * @retval uint32_t FLASH User Option Bytes values: WWDG_SW(Bit4), IWDG_SW(Bit5), nRST_STOP(Bit6), \r\n  *         nRST_STDBY(Bit7), nDBOOT(Bit28), nDBANK(Bit29), IWDG_STDBY(Bit30) and IWDG_STOP(Bit31).\r\n  */\r\nstatic uint32_t FLASH_OB_GetUser(void)\r\n{\r\n  /* Return the User Option Byte */\r\n  return ((uint32_t)(FLASH->OPTCR & 0xF00000F0U));\r\n}\r\n#else\r\n\r\n/**\r\n  * @brief  Full erase of FLASH memory sectors \r\n  * @param  VoltageRange The device voltage range which defines the erase parallelism.  \r\n  *          This parameter can be one of the following values:\r\n  *            @arg VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, \r\n  *                                  the operation will be done by byte (8-bit) \r\n  *            @arg VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,\r\n  *                                  the operation will be done by half word (16-bit)\r\n  *            @arg VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,\r\n  *                                  the operation will be done by word (32-bit)\r\n  *            @arg VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, \r\n  *                                  the operation will be done by double word (64-bit)\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic void FLASH_MassErase(uint8_t VoltageRange)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n\r\n  /* if the previous operation is completed, proceed to erase all sectors */\r\n  FLASH->CR &= CR_PSIZE_MASK;\r\n  FLASH->CR |= FLASH_CR_MER;\r\n  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8);\r\n  /* Data synchronous Barrier (DSB) Just after the write operation\r\n     This will force the CPU to respect the sequence of instruction (no optimization).*/\r\n  __DSB();\r\n}\r\n\r\n/**\r\n  * @brief  Erase the specified FLASH memory sector\r\n  * @param  Sector FLASH sector to erase\r\n  *         The value of this parameter depend on device used within the same series      \r\n  * @param  VoltageRange The device voltage range which defines the erase parallelism.  \r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, \r\n  *                                  the operation will be done by byte (8-bit) \r\n  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,\r\n  *                                  the operation will be done by half word (16-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,\r\n  *                                  the operation will be done by word (32-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, \r\n  *                                  the operation will be done by double word (64-bit)\r\n  * \r\n  * @retval None\r\n  */\r\nvoid FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)\r\n{\r\n  uint32_t tmp_psize = 0;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_SECTOR(Sector));\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n  \r\n  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)\r\n  {\r\n     tmp_psize = FLASH_PSIZE_BYTE;\r\n  }\r\n  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_HALF_WORD;\r\n  }\r\n  else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_WORD;\r\n  }\r\n  else\r\n  {\r\n    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;\r\n  }\r\n\r\n  /* If the previous operation is completed, proceed to erase the sector */\r\n  FLASH->CR &= CR_PSIZE_MASK;\r\n  FLASH->CR |= tmp_psize;\r\n  FLASH->CR &= SECTOR_MASK;\r\n  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);\r\n  FLASH->CR |= FLASH_CR_STRT;\r\n  \r\n  /* Data synchronous Barrier (DSB) Just after the write operation\r\n     This will force the CPU to respect the sequence of instruction (no optimization).*/\r\n  __DSB();\r\n}\r\n\r\n/**\r\n  * @brief  Return the FLASH Write Protection Option Bytes value.\r\n  * @retval uint32_t FLASH Write Protection Option Bytes value\r\n  */\r\nstatic uint32_t FLASH_OB_GetWRP(void)\r\n{\r\n  /* Return the FLASH write protection Register value */\r\n  return ((uint32_t)(FLASH->OPTCR & 0x00FF0000));\r\n}\r\n\r\n/**\r\n  * @brief  Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    \r\n  * @param  Wwdg Selects the IWDG mode\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_WWDG_SW: Software WWDG selected\r\n  *            @arg OB_WWDG_HW: Hardware WWDG selected\r\n  * @param  Iwdg Selects the WWDG mode\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_IWDG_SW: Software IWDG selected\r\n  *            @arg OB_IWDG_HW: Hardware IWDG selected\r\n  * @param  Stop Reset event when entering STOP mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_STOP_NO_RST: No reset generated when entering in STOP\r\n  *            @arg OB_STOP_RST: Reset generated when entering in STOP\r\n  * @param  Stdby Reset event when entering Standby mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_STDBY_NO_RST: No reset generated when entering in STANDBY\r\n  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY\r\n  * @param  Iwdgstop Independent watchdog counter freeze in Stop mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_IWDG_STOP_FREEZE: Freeze IWDG counter in STOP\r\n  *            @arg OB_IWDG_STOP_ACTIVE: IWDG counter active in STOP\r\n  * @param  Iwdgstdby Independent watchdog counter freeze in standby mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_IWDG_STDBY_FREEZE: Freeze IWDG counter in STANDBY\r\n  *            @arg OB_IWDG_STDBY_ACTIVE: IWDG counter active in STANDBY           \r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_UserConfig(uint32_t Wwdg, uint32_t Iwdg, uint32_t Stop, uint32_t Stdby, uint32_t Iwdgstop, uint32_t Iwdgstdby)\r\n{\r\n  uint32_t useroptionmask = 0x00;\r\n  uint32_t useroptionvalue = 0x00;\r\n\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WWDG_SOURCE(Wwdg));\r\n  assert_param(IS_OB_IWDG_SOURCE(Iwdg));\r\n  assert_param(IS_OB_STOP_SOURCE(Stop));\r\n  assert_param(IS_OB_STDBY_SOURCE(Stdby));\r\n  assert_param(IS_OB_IWDG_STOP_FREEZE(Iwdgstop));\r\n  assert_param(IS_OB_IWDG_STDBY_FREEZE(Iwdgstdby));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n  \r\n  if(status == HAL_OK)\r\n  {\r\n    useroptionmask = (FLASH_OPTCR_WWDG_SW | FLASH_OPTCR_IWDG_SW | FLASH_OPTCR_nRST_STOP | \\\r\n                      FLASH_OPTCR_nRST_STDBY | FLASH_OPTCR_IWDG_STOP | FLASH_OPTCR_IWDG_STDBY);\r\n                      \r\n    useroptionvalue = (Iwdg | Wwdg | Stop | Stdby | Iwdgstop | Iwdgstdby);\r\n        \r\n    /* Update User Option Byte */               \r\n    MODIFY_REG(FLASH->OPTCR, useroptionmask, useroptionvalue);\r\n  }\r\n  \r\n  return status; \r\n\r\n}\r\n\r\n/**\r\n  * @brief  Return the FLASH User Option Byte value.\r\n  * @retval uint32_t FLASH User Option Bytes values: WWDG_SW(Bit4), IWDG_SW(Bit5), nRST_STOP(Bit6), \r\n  *         nRST_STDBY(Bit7), IWDG_STDBY(Bit30) and IWDG_STOP(Bit31).\r\n  */\r\nstatic uint32_t FLASH_OB_GetUser(void)\r\n{\r\n  /* Return the User Option Byte */\r\n  return ((uint32_t)(FLASH->OPTCR & 0xC00000F0U));\r\n}\r\n#endif /* FLASH_OPTCR_nDBANK */\r\n\r\n/**\r\n  * @brief  Enable the write protection of the desired bank1 or bank2 sectors\r\n  *\r\n  * @note   When the memory read protection level is selected (RDP level = 1), \r\n  *         it is not possible to program or erase the flash sector i if CortexM7  \r\n  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1    \r\n  * \r\n  * @param  WRPSector specifies the sector(s) to be write protected.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_7 (for STM32F74xxx/STM32F75xxx devices)\r\n  *              or a value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_11 (in Single Bank mode for STM32F76xxx/STM32F77xxx devices)\r\n  *              or a value between OB_WRP_DB_SECTOR_0 and OB_WRP_DB_SECTOR_23 (in Dual Bank mode for STM32F76xxx/STM32F77xxx devices)\r\n  *            @arg OB_WRP_SECTOR_All\r\n  *\r\n  * @retval HAL FLASH State   \r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\r\n    \r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if(status == HAL_OK)\r\n  {\r\n    /*Write protection enabled on sectors */\r\n    FLASH->OPTCR &= (~WRPSector);  \r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Disable the write protection of the desired bank1 or bank 2 sectors\r\n  *\r\n  * @note   When the memory read protection level is selected (RDP level = 1), \r\n  *         it is not possible to program or erase the flash sector i if CortexM4  \r\n  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1  \r\n  * \r\n  * @param  WRPSector specifies the sector(s) to be write protected.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_7 (for STM32F74xxx/STM32F75xxx devices)\r\n  *              or a value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_11 (in Single Bank mode for STM32F76xxx/STM32F77xxx devices)\r\n  *              or a value between OB_WRP_DB_SECTOR_0 and OB_WRP_DB_SECTOR_23 (in Dual Bank mode for STM32F76xxx/STM32F77xxx devices)                      \r\n  *            @arg OB_WRP_Sector_All\r\n  *\r\n  *\r\n  * @retval HAL Status   \r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\r\n    \r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if(status == HAL_OK)\r\n  {\r\n    /* Write protection disabled on sectors */\r\n    FLASH->OPTCR |= (WRPSector); \r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set the read protection level.\r\n  * @param  Level specifies the read protection level.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_RDP_LEVEL_0: No protection\r\n  *            @arg OB_RDP_LEVEL_1: Read protection of the memory\r\n  *            @arg OB_RDP_LEVEL_2: Full chip protection\r\n  *   \r\n  * @note WARNING: When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0\r\n  *    \r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t Level)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_OB_RDP_LEVEL(Level));\r\n    \r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if(status == HAL_OK)\r\n  { \r\n    *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = Level;\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set the BOR Level. \r\n  * @param  Level specifies the Option Bytes BOR Reset Level.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V\r\n  *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V\r\n  *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V\r\n  *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_BOR_LevelConfig(uint8_t Level)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_BOR_LEVEL(Level));\r\n\r\n  /* Set the BOR Level */\r\n  MODIFY_REG(FLASH->OPTCR, FLASH_OPTCR_BOR_LEV, Level);\r\n  \r\n  return HAL_OK;\r\n  \r\n}\r\n\r\n/**\r\n  * @brief  Configure Boot base address.\r\n  * \r\n  * @param   BootOption  specifies Boot base address depending from Boot pin = 0 or pin = 1\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OPTIONBYTE_BOOTADDR_0 : Boot address based when Boot pin = 0                 \r\n  *            @arg OPTIONBYTE_BOOTADDR_1 : Boot address based when Boot pin = 1  \r\n  * @param   Address specifies Boot base address\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_BOOTADDR_ITCM_RAM : Boot from ITCM RAM (0x00000000)                 \r\n  *            @arg OB_BOOTADDR_SYSTEM : Boot from System memory bootloader (0x00100000) \r\n  *            @arg OB_BOOTADDR_ITCM_FLASH : Boot from Flash on ITCM interface (0x00200000)  \r\n  *            @arg OB_BOOTADDR_AXIM_FLASH : Boot from Flash on AXIM interface (0x08000000)  \r\n  *            @arg OB_BOOTADDR_DTCM_RAM : Boot from DTCM RAM (0x20000000)                 \r\n  *            @arg OB_BOOTADDR_SRAM1 : Boot from SRAM1 (0x20010000)                    \r\n  *            @arg OB_BOOTADDR_SRAM2 : Boot from SRAM2 (0x2004C000)              \r\n  *    \r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_BootAddressConfig(uint32_t BootOption, uint32_t Address)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_OB_BOOT_ADDRESS(Address));\r\n    \r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n  \r\n  if(status == HAL_OK)\r\n  {\r\n    if(BootOption == OPTIONBYTE_BOOTADDR_0)\r\n    {\t\t\t\r\n      MODIFY_REG(FLASH->OPTCR1, FLASH_OPTCR1_BOOT_ADD0, Address);\r\n    }\r\n    else\r\n    {\r\n      MODIFY_REG(FLASH->OPTCR1, FLASH_OPTCR1_BOOT_ADD1, (Address << 16));\r\n    }\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the FLASH Read Protection level.\r\n  * @retval FlagStatus FLASH ReadOut Protection Status:\r\n  *         This parameter can be one of the following values:\r\n  *            @arg OB_RDP_LEVEL_0: No protection\r\n  *            @arg OB_RDP_LEVEL_1: Read protection of the memory\r\n  *            @arg OB_RDP_LEVEL_2: Full chip protection\r\n  */\r\nstatic uint8_t FLASH_OB_GetRDP(void)\r\n{\r\n  uint8_t readstatus = OB_RDP_LEVEL_0;\r\n  \r\n  if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS)) == OB_RDP_LEVEL_0)\r\n  {\r\n    readstatus = OB_RDP_LEVEL_0;\r\n  }\r\n  else if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS)) == OB_RDP_LEVEL_2)\r\n  {\r\n    readstatus = OB_RDP_LEVEL_2;\r\n  }\r\n  else \r\n  {\r\n    readstatus = OB_RDP_LEVEL_1;\r\n  }\r\n\r\n  return readstatus;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the FLASH BOR level.\r\n  * @retval uint32_t The FLASH BOR level:\r\n  *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V\r\n  *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V\r\n  *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V\r\n  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  \r\n  */\r\nstatic uint32_t FLASH_OB_GetBOR(void)\r\n{\r\n  /* Return the FLASH BOR level */\r\n  return ((uint32_t)(FLASH->OPTCR & 0x0C));\r\n}\r\n\r\n/**\r\n  * @brief  Configure Boot base address.\r\n  * \r\n  * @param   BootOption  specifies Boot base address depending from Boot pin = 0 or pin = 1\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OPTIONBYTE_BOOTADDR_0 : Boot address based when Boot pin = 0                 \r\n  *            @arg OPTIONBYTE_BOOTADDR_1 : Boot address based when Boot pin = 1       \r\n  *    \r\n  * @retval uint32_t Boot Base Address:\r\n  *            - OB_BOOTADDR_ITCM_RAM : Boot from ITCM RAM (0x00000000)                 \r\n  *            - OB_BOOTADDR_SYSTEM : Boot from System memory bootloader (0x00100000) \r\n  *            - OB_BOOTADDR_ITCM_FLASH : Boot from Flash on ITCM interface (0x00200000)  \r\n  *            - OB_BOOTADDR_AXIM_FLASH : Boot from Flash on AXIM interface (0x08000000)  \r\n  *            - OB_BOOTADDR_DTCM_RAM : Boot from DTCM RAM (0x20000000)                 \r\n  *            - OB_BOOTADDR_SRAM1 : Boot from SRAM1 (0x20010000)                    \r\n  *            - OB_BOOTADDR_SRAM2 : Boot from SRAM2 (0x2004C000) \r\n  */\r\nstatic uint32_t FLASH_OB_GetBootAddress(uint32_t BootOption)\r\n{  \r\n  uint32_t Address = 0;\r\n    \r\n\t/* Return the Boot base Address */\r\n  if(BootOption == OPTIONBYTE_BOOTADDR_0)\r\n  {\t\t\t\r\n    Address = FLASH->OPTCR1 & FLASH_OPTCR1_BOOT_ADD0;\r\n\t}\r\n  else\r\n\t{\r\n\t\tAddress = ((FLASH->OPTCR1 & FLASH_OPTCR1_BOOT_ADD1) >> 16);\r\n\t}\r\n\r\n  return Address;\r\n}\r\n\r\n#if defined (FLASH_OPTCR2_PCROP)\r\n/**\r\n  * @brief  Set the PCROP protection for sectors.\r\n  * @param  PCROPSector specifies the sector(s) to be PCROP protected.\r\n  *         This parameter can be one of the following values:\r\n  *            @arg OB_PCROP_SECTOR_x: A value between OB_PCROP_SECTOR_0 and OB_PCROP_SECTOR_7\r\n  *            @arg OB_PCROP_SECTOR_ALL\r\n  *    \r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_PCROP_Config(uint32_t PCROPSector)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_OB_PCROP_SECTOR(PCROPSector));\r\n    \r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if(status == HAL_OK)\r\n  { \r\n    MODIFY_REG(FLASH->OPTCR2, FLASH_OPTCR2_PCROP, PCROPSector);\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set the PCROP_RDP value\r\n  * @param  Pcrop_Rdp specifies the PCROP_RDP bit value.\r\n  *    \r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_PCROP_RDP_Config(uint32_t Pcrop_Rdp)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_OB_PCROP_RDP_VALUE(Pcrop_Rdp));\r\n    \r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if(status == HAL_OK)\r\n  { \r\n    MODIFY_REG(FLASH->OPTCR2, FLASH_OPTCR2_PCROP_RDP, Pcrop_Rdp);\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Return the FLASH PCROP Protection Option Bytes value.\r\n  * @retval uint32_t FLASH PCROP Protection Option Bytes value\r\n  */\r\nstatic uint32_t FLASH_OB_GetPCROP(void)\r\n{\r\n  /* Return the FLASH write protection Register value */\r\n  return ((uint32_t)(FLASH->OPTCR2 & FLASH_OPTCR2_PCROP));\r\n}\r\n\r\n/**\r\n  * @brief  Return the FLASH PCROP_RDP option byte value.\r\n  * @retval uint32_t FLASH PCROP_RDP option byte value\r\n  */\r\nstatic uint32_t FLASH_OB_GetPCROPRDP(void)\r\n{\r\n  /* Return the FLASH write protection Register value */\r\n  return ((uint32_t)(FLASH->OPTCR2 & FLASH_OPTCR2_PCROP_RDP));\r\n}\r\n#endif /* FLASH_OPTCR2_PCROP */\r\n\r\n/**\r\n  * @}\r\n  */\r\n  \r\n#endif /* HAL_FLASH_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_gpio.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_gpio.c\r\n  * @author  MCD Application Team\r\n  * @brief   GPIO HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the General Purpose Input/Output (GPIO) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### GPIO Peripheral features #####\r\n  ==============================================================================\r\n  [..] \r\n  Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each\r\n  port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software\r\n  in several modes:\r\n  (+) Input mode \r\n  (+) Analog mode\r\n  (+) Output mode\r\n  (+) Alternate function mode\r\n  (+) External interrupt/event lines\r\n\r\n  [..]  \r\n  During and just after reset, the alternate functions and external interrupt  \r\n  lines are not active and the I/O ports are configured in input floating mode.\r\n  \r\n  [..]   \r\n  All GPIO pins have weak internal pull-up and pull-down resistors, which can be \r\n  activated or not.\r\n\r\n  [..]\r\n  In Output or Alternate mode, each IO can be configured on open-drain or push-pull\r\n  type and the IO speed can be selected depending on the VDD value.\r\n\r\n  [..]  \r\n  All ports have external interrupt/event capability. To use external interrupt \r\n  lines, the port must be configured in input mode. All available GPIO pins are \r\n  connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.\r\n  \r\n  [..]\r\n  The external interrupt/event controller consists of up to 23 edge detectors \r\n  (16 lines are connected to GPIO) for generating event/interrupt requests (each \r\n  input line can be independently configured to select the type (interrupt or event) \r\n  and the corresponding trigger event (rising or falling or both). Each line can \r\n  also be masked independently. \r\n\r\n                     ##### How to use this driver #####\r\n  ==============================================================================  \r\n  [..]\r\n    (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). \r\n\r\n    (#) Configure the GPIO pin(s) using HAL_GPIO_Init().\r\n        (++) Configure the IO mode using \"Mode\" member from GPIO_InitTypeDef structure\r\n        (++) Activate Pull-up, Pull-down resistor using \"Pull\" member from GPIO_InitTypeDef \r\n             structure.\r\n        (++) In case of Output or alternate function mode selection: the speed is \r\n             configured through \"Speed\" member from GPIO_InitTypeDef structure.\r\n        (++) In alternate mode is selection, the alternate function connected to the IO\r\n             is configured through \"Alternate\" member from GPIO_InitTypeDef structure.\r\n        (++) Analog mode is required when a pin is to be used as ADC channel \r\n             or DAC output.\r\n        (++) In case of external interrupt/event selection the \"Mode\" member from \r\n             GPIO_InitTypeDef structure select the type (interrupt or event) and \r\n             the corresponding trigger event (rising or falling or both).\r\n\r\n    (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority \r\n        mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using\r\n        HAL_NVIC_EnableIRQ().\r\n         \r\n    (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().\r\n            \r\n    (#) To set/reset the level of a pin configured in output mode use \r\n        HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().\r\n    \r\n    (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().\r\n\r\n                 \r\n    (#) During and just after reset, the alternate functions are not \r\n        active and the GPIO pins are configured in input floating mode (except JTAG\r\n        pins).\r\n  \r\n    (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose \r\n        (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has \r\n        priority over the GPIO function.\r\n  \r\n    (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as \r\n        general purpose PH0 and PH1, respectively, when the HSE oscillator is off. \r\n        The HSE has priority over the GPIO function.\r\n  \r\n  @endverbatim\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup GPIO GPIO\r\n  * @brief GPIO HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_GPIO_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup GPIO_Private_Constants GPIO Private Constants\r\n  * @{\r\n  */\r\n\r\n#define GPIO_NUMBER           ((uint32_t)16U)\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup GPIO_Exported_Functions GPIO Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions\r\n *  @brief    Initialization and Configuration functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n  [..]\r\n    This section provides functions allowing to initialize and de-initialize the GPIOs\r\n    to be ready for use.\r\n \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.\r\n  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains\r\n  *         the configuration information for the specified GPIO peripheral.\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)\r\n{\r\n  uint32_t position = 0x00;\r\n  uint32_t ioposition = 0x00;\r\n  uint32_t iocurrent = 0x00;\r\n  uint32_t temp = 0x00;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));\r\n  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));\r\n\r\n  /* Configure the port pins */\r\n  for(position = 0; position < GPIO_NUMBER; position++)\r\n  {\r\n    /* Get the IO position */\r\n    ioposition = ((uint32_t)0x01) << position;\r\n    /* Get the current IO position */\r\n    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;\r\n\r\n    if(iocurrent == ioposition)\r\n    {\r\n      /*--------------------- GPIO Mode Configuration ------------------------*/\r\n      /* In case of Output or Alternate function mode selection */\r\n      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))\r\n      {\r\n        /* Check the Speed parameter */\r\n        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\r\n        /* Configure the IO Speed */\r\n        temp = GPIOx->OSPEEDR; \r\n        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));\r\n        temp |= (GPIO_Init->Speed << (position * 2));\r\n        GPIOx->OSPEEDR = temp;\r\n\r\n        /* Configure the IO Output Type */\r\n        temp = GPIOx->OTYPER;\r\n        temp &= ~(GPIO_OTYPER_OT_0 << position) ;\r\n        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);\r\n        GPIOx->OTYPER = temp;\r\n      }\r\n      \r\n      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)\r\n      {\r\n        /* Check the Pull parameter */\r\n        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));\r\n\r\n        /* Activate the Pull-up or Pull down resistor for the current IO */\r\n        temp = GPIOx->PUPDR;\r\n        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));\r\n        temp |= ((GPIO_Init->Pull) << (position * 2));\r\n        GPIOx->PUPDR = temp;\r\n      }\r\n\r\n      /* In case of Alternate function mode selection */\r\n      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)\r\n      {\r\n        /* Check the Alternate function parameter */\r\n        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));\r\n\r\n        /* Configure Alternate function mapped with the current IO */\r\n        temp = GPIOx->AFR[position >> 3];\r\n        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;\r\n        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));\r\n        GPIOx->AFR[position >> 3] = temp;\r\n      }\r\n      \r\n      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */\r\n      temp = GPIOx->MODER;\r\n      temp &= ~(GPIO_MODER_MODER0 << (position * 2));\r\n      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));\r\n      GPIOx->MODER = temp;\r\n\r\n      /*--------------------- EXTI Mode Configuration ------------------------*/\r\n      /* Configure the External Interrupt or event for the current IO */\r\n      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)\r\n      {\r\n        /* Enable SYSCFG Clock */\r\n        __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n        temp = SYSCFG->EXTICR[position >> 2];\r\n        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));\r\n        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));\r\n        SYSCFG->EXTICR[position >> 2] = temp;\r\n\r\n        /* Clear Rising Falling edge configuration */\r\n        temp = EXTI->RTSR;\r\n        temp &= ~((uint32_t)iocurrent);\r\n        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->RTSR = temp;\r\n\r\n        temp = EXTI->FTSR;\r\n        temp &= ~((uint32_t)iocurrent);\r\n        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->FTSR = temp;\r\n\r\n        temp = EXTI->EMR;\r\n        temp &= ~((uint32_t)iocurrent);\r\n        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->EMR = temp;\r\n\r\n        /* Clear EXTI line configuration */\r\n        temp = EXTI->IMR;\r\n        temp &= ~((uint32_t)iocurrent);\r\n        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->IMR = temp;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  De-initializes the GPIOx peripheral registers to their default reset values.\r\n  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Pin specifies the port bit to be written.\r\n  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)\r\n{\r\n  uint32_t position;\r\n  uint32_t ioposition = 0x00;\r\n  uint32_t iocurrent = 0x00;\r\n  uint32_t tmp = 0x00;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n\r\n  /* Configure the port pins */\r\n  for(position = 0; position < GPIO_NUMBER; position++)\r\n  {\r\n    /* Get the IO position */\r\n    ioposition = ((uint32_t)0x01) << position;\r\n    /* Get the current IO position */\r\n    iocurrent = (GPIO_Pin) & ioposition;\r\n\r\n    if(iocurrent == ioposition)\r\n    {\r\n      /*------------------------- EXTI Mode Configuration --------------------*/\r\n      tmp = SYSCFG->EXTICR[position >> 2];\r\n      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));\r\n      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))\r\n      {\r\n        /* Clear EXTI line configuration */\r\n        EXTI->IMR &= ~((uint32_t)iocurrent);\r\n        EXTI->EMR &= ~((uint32_t)iocurrent);\r\n\r\n        /* Clear Rising Falling edge configuration */\r\n        EXTI->FTSR &= ~((uint32_t)iocurrent);\r\n        EXTI->RTSR &= ~((uint32_t)iocurrent);\r\n\r\n        /* Configure the External Interrupt or event for the current IO */\r\n        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));\r\n        SYSCFG->EXTICR[position >> 2] &= ~tmp;\r\n      }\r\n      /*------------------------- GPIO Mode Configuration --------------------*/\r\n      /* Configure IO Direction in Input Floating Mode */\r\n      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));\r\n\r\n      /* Configure the default Alternate Function in current IO */\r\n      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;\r\n\r\n      /* Deactivate the Pull-up and Pull-down resistor for the current IO */\r\n      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));\r\n\r\n      /* Configure the default value IO Output Type */\r\n      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;\r\n\r\n      /* Configure the default value for IO Speed */\r\n      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup GPIO_Exported_Functions_Group2 IO operation functions \r\n *  @brief   GPIO Read and Write\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                       ##### IO operation functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Reads the specified input port pin.\r\n  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Pin specifies the port bit to read.\r\n  *         This parameter can be GPIO_PIN_x where x can be (0..15).\r\n  * @retval The input port pin value.\r\n  */\r\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  GPIO_PinState bitstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)\r\n  {\r\n    bitstatus = GPIO_PIN_SET;\r\n  }\r\n  else\r\n  {\r\n    bitstatus = GPIO_PIN_RESET;\r\n  }\r\n  return bitstatus;\r\n}\r\n\r\n/**\r\n  * @brief  Sets or clears the selected data port bit.\r\n  *\r\n  * @note   This function uses GPIOx_BSRR register to allow atomic read/modify\r\n  *         accesses. In this way, there is no risk of an IRQ occurring between\r\n  *         the read and the modify access.\r\n  *\r\n  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Pin specifies the port bit to be written.\r\n  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).\r\n  * @param  PinState specifies the value to be written to the selected bit.\r\n  *          This parameter can be one of the GPIO_PinState enum values:\r\n  *            @arg GPIO_PIN_RESET: to clear the port pin\r\n  *            @arg GPIO_PIN_SET: to set the port pin\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\r\n\r\n  if(PinState != GPIO_PIN_RESET)\r\n  {\r\n    GPIOx->BSRR = GPIO_Pin;\r\n  }\r\n  else\r\n  {\r\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Toggles the specified GPIO pins.\r\n  * @param  GPIOx Where x can be (A..I) to select the GPIO peripheral.\r\n  * @param  GPIO_Pin Specifies the pins to be toggled.\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  uint32_t odr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  /* get current Output Data Register value */\r\n  odr = GPIOx->ODR;\r\n\r\n  /* Set selected pins that were at low level, and reset ones that were high */\r\n  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);\r\n}\r\n\r\n/**\r\n  * @brief  Locks GPIO Pins configuration registers.\r\n  * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,\r\n  *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.\r\n  * @note   The configuration of the locked GPIO pins can no longer be modified\r\n  *         until the next reset.\r\n  * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F7 family\r\n  * @param  GPIO_Pin specifies the port bit to be locked.\r\n  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  __IO uint32_t tmp = GPIO_LCKR_LCKK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  /* Apply lock key write sequence */\r\n  tmp |= GPIO_Pin;\r\n  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */\r\n  GPIOx->LCKR = tmp;\r\n  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */\r\n  GPIOx->LCKR = GPIO_Pin;\r\n  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */\r\n  GPIOx->LCKR = tmp;\r\n  /* Read LCKR register. This read is mandatory to complete key lock sequence */\r\n  tmp = GPIOx->LCKR;\r\n\r\n  /* Read again in order to confirm lock is active */\r\n  if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)\r\n  {\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  This function handles EXTI interrupt request.\r\n  * @param  GPIO_Pin Specifies the pins connected EXTI line\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\r\n{\r\n  /* EXTI line interrupt detected */\r\n  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)\r\n  {\r\n    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);\r\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  EXTI line detection callbacks.\r\n  * @param  GPIO_Pin Specifies the pins connected EXTI line\r\n  * @retval None\r\n  */\r\n__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(GPIO_Pin);\r\n  \r\n  /* NOTE: This function Should not be modified, when the callback is needed,\r\n           the HAL_GPIO_EXTI_Callback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_GPIO_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_i2c.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_i2c.c\r\n  * @author  MCD Application Team\r\n  * @brief   I2C HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Inter Integrated Circuit (I2C) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *           + Peripheral State and Errors functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n    The I2C HAL driver can be used as follows:\r\n\r\n    (#) Declare a I2C_HandleTypeDef handle structure, for example:\r\n        I2C_HandleTypeDef  hi2c;\r\n\r\n    (#)Initialize the I2C low level resources by implementing the HAL_I2C_MspInit() API:\r\n        (##) Enable the I2Cx interface clock\r\n        (##) I2C pins configuration\r\n            (+++) Enable the clock for the I2C GPIOs\r\n            (+++) Configure I2C pins as alternate function open-drain\r\n        (##) NVIC configuration if you need to use interrupt process\r\n            (+++) Configure the I2Cx interrupt priority\r\n            (+++) Enable the NVIC I2C IRQ Channel\r\n        (##) DMA Configuration if you need to use DMA process\r\n            (+++) Declare a DMA_HandleTypeDef handle structure for\r\n                  the transmit or receive stream\r\n            (+++) Enable the DMAx interface clock using\r\n            (+++) Configure the DMA handle parameters\r\n            (+++) Configure the DMA Tx or Rx stream\r\n            (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle\r\n            (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on\r\n                  the DMA Tx or Rx stream\r\n\r\n    (#) Configure the Communication Clock Timing, Own Address1, Master Addressing mode, Dual Addressing mode,\r\n        Own Address2, Own Address2 Mask, General call and Nostretch mode in the hi2c Init structure.\r\n\r\n    (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware\r\n        (GPIO, CLOCK, NVIC...etc) by calling the customized HAL_I2C_MspInit(&hi2c) API.\r\n\r\n    (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()\r\n\r\n    (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :\r\n\r\n    *** Polling mode IO operation ***\r\n    =================================\r\n    [..]\r\n      (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()\r\n      (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()\r\n      (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()\r\n      (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()\r\n\r\n    *** Polling mode IO MEM operation ***\r\n    =====================================\r\n    [..]\r\n      (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()\r\n      (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()\r\n\r\n\r\n    *** Interrupt mode IO operation ***\r\n    ===================================\r\n    [..]\r\n      (+) Transmit in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Transmit_IT()\r\n      (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()\r\n      (+) Receive in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Receive_IT()\r\n      (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()\r\n      (+) Transmit in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Transmit_IT()\r\n      (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()\r\n      (+) Receive in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Receive_IT()\r\n      (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()\r\n      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n      (+) Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()\r\n      (+) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()\r\n      (+) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.\r\n           This action will inform Master to generate a Stop condition to discard the communication.\r\n\r\n\r\n    *** Interrupt mode or DMA mode IO sequential operation ***\r\n    ==========================================================\r\n    [..]\r\n      (@) These interfaces allow to manage a sequential transfer with a repeated start condition\r\n          when a direction change during transfer\r\n    [..]\r\n      (+) A specific option field manage the different steps of a sequential transfer\r\n      (+) Option field values are defined through I2C_XFEROPTIONS and are listed below:\r\n      (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functional is same as associated interfaces in\r\n           no sequential mode\r\n      (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address\r\n                            and data to transfer without a final stop condition\r\n      (++) I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage a sequence with\r\n                            start condition, address and data to transfer without a final stop condition,\r\n                            an then permit a call the same master sequential interface several times\r\n                            (like HAL_I2C_Master_Seq_Transmit_IT() then HAL_I2C_Master_Seq_Transmit_IT()\r\n                            or HAL_I2C_Master_Seq_Transmit_DMA() then HAL_I2C_Master_Seq_Transmit_DMA())\r\n      (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address\r\n                            and with new data to transfer if the direction change or manage only the new data to\r\n                            transfer\r\n                            if no direction change and without a final stop condition in both cases\r\n      (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address\r\n                            and with new data to transfer if the direction change or manage only the new data to\r\n                            transfer\r\n                            if no direction change and with a final stop condition in both cases\r\n      (++) I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restart condition\r\n                            after several call of the same master sequential interface several times\r\n                            (link with option I2C_FIRST_AND_NEXT_FRAME).\r\n                            Usage can, transfer several bytes one by one using\r\n                              HAL_I2C_Master_Seq_Transmit_IT\r\n                              or HAL_I2C_Master_Seq_Receive_IT\r\n                              or HAL_I2C_Master_Seq_Transmit_DMA\r\n                              or HAL_I2C_Master_Seq_Receive_DMA\r\n                              with option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME.\r\n                             Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit or\r\n                              Receive sequence permit to call the opposite interface Receive or Transmit\r\n                              without stopping the communication and so generate a restart condition.\r\n      (++) I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart condition after\r\n                            each call of the same master sequential\r\n                            interface.\r\n                            Usage can, transfer several bytes one by one with a restart with slave address between\r\n                            each bytes using\r\n                              HAL_I2C_Master_Seq_Transmit_IT\r\n                              or HAL_I2C_Master_Seq_Receive_IT\r\n                              or HAL_I2C_Master_Seq_Transmit_DMA\r\n                              or HAL_I2C_Master_Seq_Receive_DMA\r\n                              with option I2C_FIRST_FRAME then I2C_OTHER_FRAME.\r\n                            Then usage of this option I2C_OTHER_AND_LAST_FRAME at the last frame to help automatic\r\n                            generation of STOP condition.\r\n\r\n      (+) Different sequential I2C interfaces are listed below:\r\n      (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using\r\n            HAL_I2C_Master_Seq_Transmit_IT() or using HAL_I2C_Master_Seq_Transmit_DMA()\r\n      (+++) At transmission end of current frame transfer, HAL_I2C_MasterTxCpltCallback() is executed and\r\n            users can add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()\r\n      (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using\r\n            HAL_I2C_Master_Seq_Receive_IT() or using HAL_I2C_Master_Seq_Receive_DMA()\r\n      (+++) At reception end of current frame transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()\r\n      (++) Abort a master IT or DMA I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()\r\n      (+++) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()\r\n      (++) Enable/disable the Address listen mode in slave I2C mode using HAL_I2C_EnableListen_IT()\r\n            HAL_I2C_DisableListen_IT()\r\n      (+++) When address slave I2C match, HAL_I2C_AddrCallback() is executed and users can\r\n           add their own code to check the Address Match Code and the transmission direction request by master\r\n           (Write/Read).\r\n      (+++) At Listen mode end HAL_I2C_ListenCpltCallback() is executed and users can\r\n          add their own code by customization of function pointer HAL_I2C_ListenCpltCallback()\r\n      (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using\r\n            HAL_I2C_Slave_Seq_Transmit_IT() or using HAL_I2C_Slave_Seq_Transmit_DMA()\r\n      (+++) At transmission end of current frame transfer, HAL_I2C_SlaveTxCpltCallback() is executed and\r\n            users can add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()\r\n      (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using\r\n            HAL_I2C_Slave_Seq_Receive_IT() or using HAL_I2C_Slave_Seq_Receive_DMA()\r\n      (+++) At reception end of current frame transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()\r\n      (++) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n      (++) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.\r\n           This action will inform Master to generate a Stop condition to discard the communication.\r\n\r\n    *** Interrupt mode IO MEM operation ***\r\n    =======================================\r\n    [..]\r\n      (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using\r\n          HAL_I2C_Mem_Write_IT()\r\n      (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MemTxCpltCallback()\r\n      (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using\r\n          HAL_I2C_Mem_Read_IT()\r\n      (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MemRxCpltCallback()\r\n      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n\r\n    *** DMA mode IO operation ***\r\n    ==============================\r\n    [..]\r\n      (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using\r\n          HAL_I2C_Master_Transmit_DMA()\r\n      (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()\r\n      (+) Receive in master mode an amount of data in non-blocking mode (DMA) using\r\n          HAL_I2C_Master_Receive_DMA()\r\n      (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()\r\n      (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using\r\n          HAL_I2C_Slave_Transmit_DMA()\r\n      (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()\r\n      (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using\r\n          HAL_I2C_Slave_Receive_DMA()\r\n      (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()\r\n      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n      (+) Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()\r\n      (+) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()\r\n      (+) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.\r\n           This action will inform Master to generate a Stop condition to discard the communication.\r\n\r\n    *** DMA mode IO MEM operation ***\r\n    =================================\r\n    [..]\r\n      (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using\r\n          HAL_I2C_Mem_Write_DMA()\r\n      (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MemTxCpltCallback()\r\n      (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using\r\n          HAL_I2C_Mem_Read_DMA()\r\n      (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MemRxCpltCallback()\r\n      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n\r\n\r\n     *** I2C HAL driver macros list ***\r\n     ==================================\r\n     [..]\r\n       Below the list of most used macros in I2C HAL driver.\r\n\r\n      (+) __HAL_I2C_ENABLE: Enable the I2C peripheral\r\n      (+) __HAL_I2C_DISABLE: Disable the I2C peripheral\r\n      (+) __HAL_I2C_GENERATE_NACK: Generate a Non-Acknowledge I2C peripheral in Slave mode\r\n      (+) __HAL_I2C_GET_FLAG: Check whether the specified I2C flag is set or not\r\n      (+) __HAL_I2C_CLEAR_FLAG: Clear the specified I2C pending flag\r\n      (+) __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt\r\n      (+) __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt\r\n\r\n     *** Callback registration ***\r\n     =============================================\r\n    [..]\r\n     The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1\r\n     allows the user to configure dynamically the driver callbacks.\r\n     Use Functions HAL_I2C_RegisterCallback() or HAL_I2C_RegisterAddrCallback()\r\n     to register an interrupt callback.\r\n    [..]\r\n     Function HAL_I2C_RegisterCallback() allows to register following callbacks:\r\n       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.\r\n       (+) MasterRxCpltCallback : callback for Master reception end of transfer.\r\n       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.\r\n       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.\r\n       (+) ListenCpltCallback   : callback for end of listen mode.\r\n       (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.\r\n       (+) MemRxCpltCallback    : callback for Memory reception end of transfer.\r\n       (+) ErrorCallback        : callback for error detection.\r\n       (+) AbortCpltCallback    : callback for abort completion process.\r\n       (+) MspInitCallback      : callback for Msp Init.\r\n       (+) MspDeInitCallback    : callback for Msp DeInit.\r\n     This function takes as parameters the HAL peripheral handle, the Callback ID\r\n     and a pointer to the user callback function.\r\n    [..]\r\n     For specific callback AddrCallback use dedicated register callbacks : HAL_I2C_RegisterAddrCallback().\r\n    [..]\r\n     Use function HAL_I2C_UnRegisterCallback to reset a callback to the default\r\n     weak function.\r\n     HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,\r\n     and the Callback ID.\r\n     This function allows to reset following callbacks:\r\n       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.\r\n       (+) MasterRxCpltCallback : callback for Master reception end of transfer.\r\n       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.\r\n       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.\r\n       (+) ListenCpltCallback   : callback for end of listen mode.\r\n       (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.\r\n       (+) MemRxCpltCallback    : callback for Memory reception end of transfer.\r\n       (+) ErrorCallback        : callback for error detection.\r\n       (+) AbortCpltCallback    : callback for abort completion process.\r\n       (+) MspInitCallback      : callback for Msp Init.\r\n       (+) MspDeInitCallback    : callback for Msp DeInit.\r\n    [..]\r\n     For callback AddrCallback use dedicated register callbacks : HAL_I2C_UnRegisterAddrCallback().\r\n    [..]\r\n     By default, after the HAL_I2C_Init() and when the state is HAL_I2C_STATE_RESET\r\n     all callbacks are set to the corresponding weak functions:\r\n     examples HAL_I2C_MasterTxCpltCallback(), HAL_I2C_MasterRxCpltCallback().\r\n     Exception done for MspInit and MspDeInit functions that are\r\n     reset to the legacy weak functions in the HAL_I2C_Init()/ HAL_I2C_DeInit() only when\r\n     these callbacks are null (not registered beforehand).\r\n     If MspInit or MspDeInit are not null, the HAL_I2C_Init()/ HAL_I2C_DeInit()\r\n     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.\r\n    [..]\r\n     Callbacks can be registered/unregistered in HAL_I2C_STATE_READY state only.\r\n     Exception done MspInit/MspDeInit functions that can be registered/unregistered\r\n     in HAL_I2C_STATE_READY or HAL_I2C_STATE_RESET state,\r\n     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.\r\n     Then, the user first registers the MspInit/MspDeInit user callbacks\r\n     using HAL_I2C_RegisterCallback() before calling HAL_I2C_DeInit()\r\n     or HAL_I2C_Init() function.\r\n    [..]\r\n     When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or\r\n     not defined, the callback registration feature is not available and all callbacks\r\n     are set to the corresponding weak functions.\r\n\r\n     [..]\r\n       (@) You can refer to the I2C HAL driver header file for more useful macros\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup I2C I2C\r\n  * @brief I2C HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_I2C_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n\r\n/** @defgroup I2C_Private_Define I2C Private Define\r\n  * @{\r\n  */\r\n#define TIMING_CLEAR_MASK   (0xF0FFFFFFU)  /*!< I2C TIMING clear register Mask */\r\n#define I2C_TIMEOUT_ADDR    (10000U)       /*!< 10 s  */\r\n#define I2C_TIMEOUT_BUSY    (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_DIR     (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_RXNE    (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_STOPF   (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_TC      (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_TCR     (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_TXIS    (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_FLAG    (25U)          /*!< 25 ms */\r\n\r\n#define MAX_NBYTE_SIZE      255U\r\n#define SLAVE_ADDR_SHIFT     7U\r\n#define SLAVE_ADDR_MSK       0x06U\r\n\r\n/* Private define for @ref PreviousState usage */\r\n#define I2C_STATE_MSK             ((uint32_t)((uint32_t)((uint32_t)HAL_I2C_STATE_BUSY_TX | \\\r\n                                                         (uint32_t)HAL_I2C_STATE_BUSY_RX) & \\\r\n                                              (uint32_t)(~((uint32_t)HAL_I2C_STATE_READY))))\r\n/*!< Mask State define, keep only RX and TX bits */\r\n#define I2C_STATE_NONE            ((uint32_t)(HAL_I2C_MODE_NONE))\r\n/*!< Default Value */\r\n#define I2C_STATE_MASTER_BUSY_TX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_MASTER))\r\n/*!< Master Busy TX, combinaison of State LSB and Mode enum */\r\n#define I2C_STATE_MASTER_BUSY_RX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_MASTER))\r\n/*!< Master Busy RX, combinaison of State LSB and Mode enum */\r\n#define I2C_STATE_SLAVE_BUSY_TX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_SLAVE))\r\n/*!< Slave Busy TX, combinaison of State LSB and Mode enum */\r\n#define I2C_STATE_SLAVE_BUSY_RX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_SLAVE))\r\n/*!< Slave Busy RX, combinaison of State LSB and Mode enum  */\r\n#define I2C_STATE_MEM_BUSY_TX     ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_MEM))\r\n/*!< Memory Busy TX, combinaison of State LSB and Mode enum */\r\n#define I2C_STATE_MEM_BUSY_RX     ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_MEM))\r\n/*!< Memory Busy RX, combinaison of State LSB and Mode enum */\r\n\r\n\r\n/* Private define to centralize the enable/disable of Interrupts */\r\n#define I2C_XFER_TX_IT          (uint16_t)(0x0001U)   /*!< Bit field can be combinated with\r\n                                                         @ref I2C_XFER_LISTEN_IT */\r\n#define I2C_XFER_RX_IT          (uint16_t)(0x0002U)   /*!< Bit field can be combinated with\r\n                                                         @ref I2C_XFER_LISTEN_IT */\r\n#define I2C_XFER_LISTEN_IT      (uint16_t)(0x8000U)   /*!< Bit field can be combinated with @ref I2C_XFER_TX_IT\r\n                                                         and @ref I2C_XFER_RX_IT */\r\n\r\n#define I2C_XFER_ERROR_IT       (uint16_t)(0x0010U)   /*!< Bit definition to manage addition of global Error\r\n                                                         and NACK treatment */\r\n#define I2C_XFER_CPLT_IT        (uint16_t)(0x0020U)   /*!< Bit definition to manage only STOP evenement */\r\n#define I2C_XFER_RELOAD_IT      (uint16_t)(0x0040U)   /*!< Bit definition to manage only Reload of NBYTE */\r\n\r\n/* Private define Sequential Transfer Options default/reset value */\r\n#define I2C_NO_OPTION_FRAME     (0xFFFF0000U)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Macro to get remaining data to transfer on DMA side */\r\n#define I2C_GET_DMA_REMAIN_DATA(__HANDLE__)     __HAL_DMA_GET_COUNTER(__HANDLE__)\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/** @defgroup I2C_Private_Functions I2C Private Functions\r\n  * @{\r\n  */\r\n/* Private functions to handle DMA transfer */\r\nstatic void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMAError(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMAAbort(DMA_HandleTypeDef *hdma);\r\n\r\n/* Private functions to handle IT transfer */\r\nstatic void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);\r\nstatic void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c);\r\nstatic void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c);\r\nstatic void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);\r\nstatic void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);\r\nstatic void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);\r\nstatic void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode);\r\n\r\n/* Private functions to handle IT transfer */\r\nstatic HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,\r\n                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,\r\n                                                uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,\r\n                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,\r\n                                               uint32_t Tickstart);\r\n\r\n/* Private functions for I2C transfer IRQ handler */\r\nstatic HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                           uint32_t ITSources);\r\nstatic HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                          uint32_t ITSources);\r\nstatic HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                            uint32_t ITSources);\r\nstatic HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                           uint32_t ITSources);\r\n\r\n/* Private functions to handle flags during polling transfer */\r\nstatic HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,\r\n                                                    uint32_t Timeout, uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                             uint32_t Tickstart);\r\n\r\n/* Private functions to centralize the enable/disable of Interrupts */\r\nstatic void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest);\r\nstatic void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest);\r\n\r\n/* Private function to treat different error callback */\r\nstatic void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c);\r\n\r\n/* Private function to flush TXDR register */\r\nstatic void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c);\r\n\r\n/* Private function to handle  start, restart or stop a transfer */\r\nstatic void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,\r\n                               uint32_t Request);\r\n\r\n/* Private function to Convert Specific options */\r\nstatic void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup I2C_Exported_Functions I2C Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions\r\n  *  @brief    Initialization and Configuration functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]  This subsection provides a set of functions allowing to initialize and\r\n          deinitialize the I2Cx peripheral:\r\n\r\n      (+) User must Implement HAL_I2C_MspInit() function in which he configures\r\n          all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).\r\n\r\n      (+) Call the function HAL_I2C_Init() to configure the selected device with\r\n          the selected configuration:\r\n        (++) Clock Timing\r\n        (++) Own Address 1\r\n        (++) Addressing mode (Master, Slave)\r\n        (++) Dual Addressing mode\r\n        (++) Own Address 2\r\n        (++) Own Address 2 Mask\r\n        (++) General call mode\r\n        (++) Nostretch mode\r\n\r\n      (+) Call the function HAL_I2C_DeInit() to restore the default configuration\r\n          of the selected I2Cx peripheral.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the I2C according to the specified parameters\r\n  *         in the I2C_InitTypeDef and initialize the associated handle.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Check the I2C handle allocation */\r\n  if (hi2c == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));\r\n  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));\r\n  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));\r\n  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));\r\n  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));\r\n  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));\r\n  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    hi2c->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    /* Init the I2C Callback settings */\r\n    hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */\r\n    hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */\r\n    hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */\r\n    hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */\r\n    hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */\r\n    hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */\r\n    hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */\r\n    hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */\r\n    hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */\r\n    hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */\r\n\r\n    if (hi2c->MspInitCallback == NULL)\r\n    {\r\n      hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */\r\n    }\r\n\r\n    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */\r\n    hi2c->MspInitCallback(hi2c);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */\r\n    HAL_I2C_MspInit(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n  /* Disable the selected I2C peripheral */\r\n  __HAL_I2C_DISABLE(hi2c);\r\n\r\n  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/\r\n  /* Configure I2Cx: Frequency range */\r\n  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;\r\n\r\n  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/\r\n  /* Disable Own Address1 before set the Own Address1 configuration */\r\n  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;\r\n\r\n  /* Configure I2Cx: Own Address1 and ack own address1 mode */\r\n  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)\r\n  {\r\n    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);\r\n  }\r\n  else /* I2C_ADDRESSINGMODE_10BIT */\r\n  {\r\n    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);\r\n  }\r\n\r\n  /*---------------------------- I2Cx CR2 Configuration ----------------------*/\r\n  /* Configure I2Cx: Addressing Master mode */\r\n  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)\r\n  {\r\n    hi2c->Instance->CR2 = (I2C_CR2_ADD10);\r\n  }\r\n  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */\r\n  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);\r\n\r\n  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/\r\n  /* Disable Own Address2 before set the Own Address2 configuration */\r\n  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;\r\n\r\n  /* Configure I2Cx: Dual mode and Own Address2 */\r\n  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \\\r\n                          (hi2c->Init.OwnAddress2Masks << 8));\r\n\r\n  /*---------------------------- I2Cx CR1 Configuration ----------------------*/\r\n  /* Configure I2Cx: Generalcall and NoStretch mode */\r\n  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);\r\n\r\n  /* Enable the selected I2C peripheral */\r\n  __HAL_I2C_ENABLE(hi2c);\r\n\r\n  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n  hi2c->State = HAL_I2C_STATE_READY;\r\n  hi2c->PreviousState = I2C_STATE_NONE;\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitialize the I2C peripheral.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Check the I2C handle allocation */\r\n  if (hi2c == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n\r\n  hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n  /* Disable the I2C Peripheral Clock */\r\n  __HAL_I2C_DISABLE(hi2c);\r\n\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n  if (hi2c->MspDeInitCallback == NULL)\r\n  {\r\n    hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */\r\n  }\r\n\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  hi2c->MspDeInitCallback(hi2c);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_I2C_MspDeInit(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n\r\n  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n  hi2c->State = HAL_I2C_STATE_RESET;\r\n  hi2c->PreviousState = I2C_STATE_NONE;\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Initialize the I2C MSP.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief DeInitialize the I2C MSP.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Register a User I2C Callback\r\n  *         To be used instead of the weak predefined callback\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  CallbackID ID of the callback to be registered\r\n  *         This parameter can be one of the following values:\r\n  *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID\r\n  *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID\r\n  *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID\r\n  *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID\r\n  *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID\r\n  *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID\r\n  * @param  pCallback pointer to the Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_RegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID,\r\n                                           pI2C_CallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if (HAL_I2C_STATE_READY == hi2c->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :\r\n        hi2c->MasterTxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :\r\n        hi2c->MasterRxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :\r\n        hi2c->SlaveTxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :\r\n        hi2c->SlaveRxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_LISTEN_COMPLETE_CB_ID :\r\n        hi2c->ListenCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MEM_TX_COMPLETE_CB_ID :\r\n        hi2c->MemTxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MEM_RX_COMPLETE_CB_ID :\r\n        hi2c->MemRxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_ERROR_CB_ID :\r\n        hi2c->ErrorCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_ABORT_CB_ID :\r\n        hi2c->AbortCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MSPINIT_CB_ID :\r\n        hi2c->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MSPDEINIT_CB_ID :\r\n        hi2c->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (HAL_I2C_STATE_RESET == hi2c->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_I2C_MSPINIT_CB_ID :\r\n        hi2c->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MSPDEINIT_CB_ID :\r\n        hi2c->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister an I2C Callback\r\n  *         I2C callback is redirected to the weak predefined callback\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  CallbackID ID of the callback to be unregistered\r\n  *         This parameter can be one of the following values:\r\n  *         This parameter can be one of the following values:\r\n  *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID\r\n  *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID\r\n  *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID\r\n  *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID\r\n  *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID\r\n  *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_UnRegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if (HAL_I2C_STATE_READY == hi2c->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :\r\n        hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */\r\n        break;\r\n\r\n      case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :\r\n        hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */\r\n        break;\r\n\r\n      case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :\r\n        hi2c->SlaveTxCpltCallback = HAL_I2C_SlaveTxCpltCallback;   /* Legacy weak SlaveTxCpltCallback  */\r\n        break;\r\n\r\n      case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :\r\n        hi2c->SlaveRxCpltCallback = HAL_I2C_SlaveRxCpltCallback;   /* Legacy weak SlaveRxCpltCallback  */\r\n        break;\r\n\r\n      case HAL_I2C_LISTEN_COMPLETE_CB_ID :\r\n        hi2c->ListenCpltCallback = HAL_I2C_ListenCpltCallback;     /* Legacy weak ListenCpltCallback   */\r\n        break;\r\n\r\n      case HAL_I2C_MEM_TX_COMPLETE_CB_ID :\r\n        hi2c->MemTxCpltCallback = HAL_I2C_MemTxCpltCallback;       /* Legacy weak MemTxCpltCallback    */\r\n        break;\r\n\r\n      case HAL_I2C_MEM_RX_COMPLETE_CB_ID :\r\n        hi2c->MemRxCpltCallback = HAL_I2C_MemRxCpltCallback;       /* Legacy weak MemRxCpltCallback    */\r\n        break;\r\n\r\n      case HAL_I2C_ERROR_CB_ID :\r\n        hi2c->ErrorCallback = HAL_I2C_ErrorCallback;               /* Legacy weak ErrorCallback        */\r\n        break;\r\n\r\n      case HAL_I2C_ABORT_CB_ID :\r\n        hi2c->AbortCpltCallback = HAL_I2C_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */\r\n        break;\r\n\r\n      case HAL_I2C_MSPINIT_CB_ID :\r\n        hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */\r\n        break;\r\n\r\n      case HAL_I2C_MSPDEINIT_CB_ID :\r\n        hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (HAL_I2C_STATE_RESET == hi2c->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_I2C_MSPINIT_CB_ID :\r\n        hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */\r\n        break;\r\n\r\n      case HAL_I2C_MSPDEINIT_CB_ID :\r\n        hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register the Slave Address Match I2C Callback\r\n  *         To be used instead of the weak HAL_I2C_AddrCallback() predefined callback\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pCallback pointer to the Address Match Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_RegisterAddrCallback(I2C_HandleTypeDef *hi2c, pI2C_AddrCallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if (HAL_I2C_STATE_READY == hi2c->State)\r\n  {\r\n    hi2c->AddrCallback = pCallback;\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  UnRegister the Slave Address Match I2C Callback\r\n  *         Info Ready I2C Callback is redirected to the weak HAL_I2C_AddrCallback() predefined callback\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_UnRegisterAddrCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if (HAL_I2C_STATE_READY == hi2c->State)\r\n  {\r\n    hi2c->AddrCallback = HAL_I2C_AddrCallback; /* Legacy weak AddrCallback  */\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n  return status;\r\n}\r\n\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions\r\n  *  @brief   Data transfers functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### IO operation functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the I2C data\r\n    transfers.\r\n\r\n    (#) There are two modes of transfer:\r\n       (++) Blocking mode : The communication is performed in the polling mode.\r\n            The status of all data processing is returned by the same function\r\n            after finishing transfer.\r\n       (++) No-Blocking mode : The communication is performed using Interrupts\r\n            or DMA. These functions return the status of the transfer startup.\r\n            The end of the data processing will be indicated through the\r\n            dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when\r\n            using DMA mode.\r\n\r\n    (#) Blocking mode functions are :\r\n        (++) HAL_I2C_Master_Transmit()\r\n        (++) HAL_I2C_Master_Receive()\r\n        (++) HAL_I2C_Slave_Transmit()\r\n        (++) HAL_I2C_Slave_Receive()\r\n        (++) HAL_I2C_Mem_Write()\r\n        (++) HAL_I2C_Mem_Read()\r\n        (++) HAL_I2C_IsDeviceReady()\r\n\r\n    (#) No-Blocking mode functions with Interrupt are :\r\n        (++) HAL_I2C_Master_Transmit_IT()\r\n        (++) HAL_I2C_Master_Receive_IT()\r\n        (++) HAL_I2C_Slave_Transmit_IT()\r\n        (++) HAL_I2C_Slave_Receive_IT()\r\n        (++) HAL_I2C_Mem_Write_IT()\r\n        (++) HAL_I2C_Mem_Read_IT()\r\n        (++) HAL_I2C_Master_Seq_Transmit_IT()\r\n        (++) HAL_I2C_Master_Seq_Receive_IT()\r\n        (++) HAL_I2C_Slave_Seq_Transmit_IT()\r\n        (++) HAL_I2C_Slave_Seq_Receive_IT()\r\n        (++) HAL_I2C_EnableListen_IT()\r\n        (++) HAL_I2C_DisableListen_IT()\r\n        (++) HAL_I2C_Master_Abort_IT()\r\n\r\n    (#) No-Blocking mode functions with DMA are :\r\n        (++) HAL_I2C_Master_Transmit_DMA()\r\n        (++) HAL_I2C_Master_Receive_DMA()\r\n        (++) HAL_I2C_Slave_Transmit_DMA()\r\n        (++) HAL_I2C_Slave_Receive_DMA()\r\n        (++) HAL_I2C_Mem_Write_DMA()\r\n        (++) HAL_I2C_Mem_Read_DMA()\r\n        (++) HAL_I2C_Master_Seq_Transmit_DMA()\r\n        (++) HAL_I2C_Master_Seq_Receive_DMA()\r\n        (++) HAL_I2C_Slave_Seq_Transmit_DMA()\r\n        (++) HAL_I2C_Slave_Seq_Receive_DMA()\r\n\r\n    (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:\r\n        (++) HAL_I2C_MasterTxCpltCallback()\r\n        (++) HAL_I2C_MasterRxCpltCallback()\r\n        (++) HAL_I2C_SlaveTxCpltCallback()\r\n        (++) HAL_I2C_SlaveRxCpltCallback()\r\n        (++) HAL_I2C_MemTxCpltCallback()\r\n        (++) HAL_I2C_MemRxCpltCallback()\r\n        (++) HAL_I2C_AddrCallback()\r\n        (++) HAL_I2C_ListenCpltCallback()\r\n        (++) HAL_I2C_ErrorCallback()\r\n        (++) HAL_I2C_AbortCpltCallback()\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Transmits in master mode an amount of data in blocking mode.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                          uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                         I2C_GENERATE_START_WRITE);\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_WRITE);\r\n    }\r\n\r\n    while (hi2c->XferCount > 0U)\r\n    {\r\n      /* Wait until TXIS flag is set */\r\n      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      /* Write data to TXDR */\r\n      hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n      hi2c->XferSize--;\r\n\r\n      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n      {\r\n        /* Wait until TCR flag is set */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n        {\r\n          hi2c->XferSize = MAX_NBYTE_SIZE;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          hi2c->XferSize = hi2c->XferCount;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n    }\r\n\r\n    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n    /* Wait until STOPF flag is set */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receives in master mode an amount of data in blocking mode.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                         uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n    }\r\n\r\n    while (hi2c->XferCount > 0U)\r\n    {\r\n      /* Wait until RXNE flag is set */\r\n      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Read data from RXDR */\r\n      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n\r\n      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n      {\r\n        /* Wait until TCR flag is set */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n        {\r\n          hi2c->XferSize = MAX_NBYTE_SIZE;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          hi2c->XferSize = hi2c->XferCount;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n    }\r\n\r\n    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n    /* Wait until STOPF flag is set */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmits in slave mode an amount of data in blocking mode.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                         uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Wait until ADDR flag is set */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear ADDR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n\r\n    /* If 10bit addressing mode is selected */\r\n    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)\r\n    {\r\n      /* Wait until ADDR flag is set */\r\n      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        /* Disable Address Acknowledge */\r\n        hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Clear ADDR flag */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Wait until DIR flag is set Transmitter mode */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    while (hi2c->XferCount > 0U)\r\n    {\r\n      /* Wait until TXIS flag is set */\r\n      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        /* Disable Address Acknowledge */\r\n        hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Write data to TXDR */\r\n      hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n    }\r\n\r\n    /* Wait until AF flag is set */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Flush TX register */\r\n    I2C_Flush_TXDR(hi2c);\r\n\r\n    /* Clear AF flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Wait until STOP flag is set */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Wait until BUSY flag is reset */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Address Acknowledge */\r\n    hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in slave mode an amount of data in blocking mode\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                        uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferSize = hi2c->XferCount;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Wait until ADDR flag is set */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear ADDR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n\r\n    /* Wait until DIR flag is reset Receiver mode */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    while (hi2c->XferCount > 0U)\r\n    {\r\n      /* Wait until RXNE flag is set */\r\n      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        /* Disable Address Acknowledge */\r\n        hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n        /* Store Last receive data if any */\r\n        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)\r\n        {\r\n          /* Read data from RXDR */\r\n          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n          /* Increment Buffer pointer */\r\n          hi2c->pBuffPtr++;\r\n\r\n          hi2c->XferCount--;\r\n          hi2c->XferSize--;\r\n        }\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Read data from RXDR */\r\n      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n      hi2c->XferSize--;\r\n    }\r\n\r\n    /* Wait until STOP flag is set */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Wait until BUSY flag is reset */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Address Acknowledge */\r\n    hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                             uint16_t Size)\r\n{\r\n  uint32_t xfermode;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                            uint16_t Size)\r\n{\r\n  uint32_t xfermode;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, RXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)\r\n{\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Slave_ISR_IT;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)\r\n{\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Slave_ISR_IT;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, RXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                              uint16_t Size)\r\n{\r\n  uint32_t xfermode;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    if (hi2c->XferSize > 0U)\r\n    {\r\n      if (hi2c->hdmatx != NULL)\r\n      {\r\n        /* Set the I2C DMA transfer complete callback */\r\n        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;\r\n\r\n        /* Set the DMA error callback */\r\n        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n        /* Set the unused DMA callbacks to NULL */\r\n        hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n        hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n        /* Enable the DMA stream */\r\n        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                         hi2c->XferSize);\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      if (dmaxferstatus == HAL_OK)\r\n      {\r\n        /* Send Slave Address */\r\n        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);\r\n\r\n        /* Update XferCount value */\r\n        hi2c->XferCount -= hi2c->XferSize;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                  to avoid the risk of I2C interrupt handle execution before current\r\n                  process unlock */\r\n        /* Enable ERR and NACK interrupts */\r\n        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n        /* Enable DMA Request */\r\n        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Update Transfer ISR function pointer */\r\n      hi2c->XferISR = I2C_Master_ISR_IT;\r\n\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to write and generate START condition */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_WRITE);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n      /* possible to enable all of these */\r\n      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in master mode an amount of data in non-blocking mode with DMA\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                             uint16_t Size)\r\n{\r\n  uint32_t xfermode;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    if (hi2c->XferSize > 0U)\r\n    {\r\n      if (hi2c->hdmarx != NULL)\r\n      {\r\n        /* Set the I2C DMA transfer complete callback */\r\n        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;\r\n\r\n        /* Set the DMA error callback */\r\n        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n        /* Set the unused DMA callbacks to NULL */\r\n        hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n        hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n        /* Enable the DMA stream */\r\n        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,\r\n                                         hi2c->XferSize);\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      if (dmaxferstatus == HAL_OK)\r\n      {\r\n        /* Send Slave Address */\r\n        /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);\r\n\r\n        /* Update XferCount value */\r\n        hi2c->XferCount -= hi2c->XferSize;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                  to avoid the risk of I2C interrupt handle execution before current\r\n                  process unlock */\r\n        /* Enable ERR and NACK interrupts */\r\n        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n        /* Enable DMA Request */\r\n        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Update Transfer ISR function pointer */\r\n      hi2c->XferISR = I2C_Master_ISR_IT;\r\n\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to read and generate START condition */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n      /* possible to enable all of these */\r\n      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Slave_ISR_DMA;\r\n\r\n    if (hi2c->hdmatx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Enable Address Acknowledge */\r\n      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, STOP, NACK, ADDR interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n      /* Enable DMA Request */\r\n      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Slave_ISR_DMA;\r\n\r\n    if (hi2c->hdmarx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Enable Address Acknowledge */\r\n      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, STOP, NACK, ADDR interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n      /* Enable DMA Request */\r\n      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @brief  Write an amount of data in blocking mode to a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);\r\n    }\r\n\r\n    do\r\n    {\r\n      /* Wait until TXIS flag is set */\r\n      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Write data to TXDR */\r\n      hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n      hi2c->XferSize--;\r\n\r\n      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n      {\r\n        /* Wait until TCR flag is set */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n        {\r\n          hi2c->XferSize = MAX_NBYTE_SIZE;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          hi2c->XferSize = hi2c->XferCount;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n\r\n    } while (hi2c->XferCount > 0U);\r\n\r\n    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n    /* Wait until STOPF flag is reset */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Read an amount of data in blocking mode from a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n    }\r\n\r\n    do\r\n    {\r\n      /* Wait until RXNE flag is set */\r\n      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Read data from RXDR */\r\n      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n\r\n      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n      {\r\n        /* Wait until TCR flag is set */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n        {\r\n          hi2c->XferSize = MAX_NBYTE_SIZE;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          hi2c->XferSize = hi2c->XferCount;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n    } while (hi2c->XferCount > 0U);\r\n\r\n    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n    /* Wait until STOPF flag is reset */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t xfermode;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart)\r\n        != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                      uint16_t MemAddSize, uint8_t *pData, uint16_t Size)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t xfermode;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, RXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                        uint16_t MemAddSize, uint8_t *pData, uint16_t Size)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t xfermode;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart)\r\n        != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n\r\n    if (hi2c->hdmatx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_READY;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);\r\n\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR and NACK interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n      /* Enable DMA Request */\r\n      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_READY;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be read\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t xfermode;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (hi2c->hdmarx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_READY;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);\r\n\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR and NACK interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n      /* Enable DMA Request */\r\n      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_READY;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Checks if target device is ready for communication.\r\n  * @note   This function is used with Memory devices\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  Trials Number of trials\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials,\r\n                                        uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  __IO uint32_t I2C_Trials = 0UL;\r\n\r\n  FlagStatus tmp1;\r\n  FlagStatus tmp2;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_BUSY;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    do\r\n    {\r\n      /* Generate Start */\r\n      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);\r\n\r\n      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n      /* Wait until STOPF flag is set or a NACK flag is set*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);\r\n      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n      while ((tmp1 == RESET) && (tmp2 == RESET))\r\n      {\r\n        if (Timeout != HAL_MAX_DELAY)\r\n        {\r\n          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n          {\r\n            /* Update I2C state */\r\n            hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n            /* Update I2C error code */\r\n            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n\r\n            /* Process Unlocked */\r\n            __HAL_UNLOCK(hi2c);\r\n\r\n            return HAL_ERROR;\r\n          }\r\n        }\r\n\r\n        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);\r\n        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);\r\n      }\r\n\r\n      /* Check if the NACKF flag has not been set */\r\n      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)\r\n      {\r\n        /* Wait until STOPF flag is reset */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        /* Clear STOP Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n        /* Device is ready */\r\n        hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_OK;\r\n      }\r\n      else\r\n      {\r\n        /* Wait until STOPF flag is reset */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        /* Clear NACK Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n        /* Clear STOP Flag, auto generated with autoend*/\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n      }\r\n\r\n      /* Check if the maximum allowed number of trials has been reached */\r\n      if (I2C_Trials == Trials)\r\n      {\r\n        /* Generate Stop */\r\n        hi2c->Instance->CR2 |= I2C_CR2_STOP;\r\n\r\n        /* Wait until STOPF flag is reset */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        /* Clear STOP Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n      }\r\n\r\n      /* Increment Trials */\r\n      I2C_Trials++;\r\n    } while (I2C_Trials < Trials);\r\n\r\n    /* Update I2C state */\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n    /* Update I2C error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with Interrupt.\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                                 uint16_t Size, uint32_t XferOptions)\r\n{\r\n  uint32_t xfermode;\r\n  uint32_t xferrequest = I2C_GENERATE_START_WRITE;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = hi2c->XferOptions;\r\n    }\r\n\r\n    /* If transfer direction not change and there is no request to start another frame,\r\n       do not generate Restart Condition */\r\n    /* Mean Previous state is same as current state */\r\n    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \\\r\n        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))\r\n    {\r\n      xferrequest = I2C_NO_STARTSTOP;\r\n    }\r\n    else\r\n    {\r\n      /* Convert OTHER_xxx XferOptions if any */\r\n      I2C_ConvertOtherXferOptions(hi2c);\r\n\r\n      /* Update xfermode accordingly if no reload is necessary */\r\n      if (hi2c->XferCount <= MAX_NBYTE_SIZE)\r\n      {\r\n        xfermode = hi2c->XferOptions;\r\n      }\r\n    }\r\n\r\n    /* Send Slave Address and set NBYTES to write */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with DMA.\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                                  uint16_t Size, uint32_t XferOptions)\r\n{\r\n  uint32_t xfermode;\r\n  uint32_t xferrequest = I2C_GENERATE_START_WRITE;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = hi2c->XferOptions;\r\n    }\r\n\r\n    /* If transfer direction not change and there is no request to start another frame,\r\n       do not generate Restart Condition */\r\n    /* Mean Previous state is same as current state */\r\n    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \\\r\n        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))\r\n    {\r\n      xferrequest = I2C_NO_STARTSTOP;\r\n    }\r\n    else\r\n    {\r\n      /* Convert OTHER_xxx XferOptions if any */\r\n      I2C_ConvertOtherXferOptions(hi2c);\r\n\r\n      /* Update xfermode accordingly if no reload is necessary */\r\n      if (hi2c->XferCount <= MAX_NBYTE_SIZE)\r\n      {\r\n        xfermode = hi2c->XferOptions;\r\n      }\r\n    }\r\n\r\n    if (hi2c->XferSize > 0U)\r\n    {\r\n      if (hi2c->hdmatx != NULL)\r\n      {\r\n        /* Set the I2C DMA transfer complete callback */\r\n        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;\r\n\r\n        /* Set the DMA error callback */\r\n        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n        /* Set the unused DMA callbacks to NULL */\r\n        hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n        hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n        /* Enable the DMA stream */\r\n        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                         hi2c->XferSize);\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      if (dmaxferstatus == HAL_OK)\r\n      {\r\n        /* Send Slave Address and set NBYTES to write */\r\n        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);\r\n\r\n        /* Update XferCount value */\r\n        hi2c->XferCount -= hi2c->XferSize;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                  to avoid the risk of I2C interrupt handle execution before current\r\n                  process unlock */\r\n        /* Enable ERR and NACK interrupts */\r\n        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n        /* Enable DMA Request */\r\n        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Update Transfer ISR function pointer */\r\n      hi2c->XferISR = I2C_Master_ISR_IT;\r\n\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to write and generate START condition */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_WRITE);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n      /* possible to enable all of these */\r\n      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with Interrupt\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                                uint16_t Size, uint32_t XferOptions)\r\n{\r\n  uint32_t xfermode;\r\n  uint32_t xferrequest = I2C_GENERATE_START_READ;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = hi2c->XferOptions;\r\n    }\r\n\r\n    /* If transfer direction not change and there is no request to start another frame,\r\n       do not generate Restart Condition */\r\n    /* Mean Previous state is same as current state */\r\n    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \\\r\n        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))\r\n    {\r\n      xferrequest = I2C_NO_STARTSTOP;\r\n    }\r\n    else\r\n    {\r\n      /* Convert OTHER_xxx XferOptions if any */\r\n      I2C_ConvertOtherXferOptions(hi2c);\r\n\r\n      /* Update xfermode accordingly if no reload is necessary */\r\n      if (hi2c->XferCount <= MAX_NBYTE_SIZE)\r\n      {\r\n        xfermode = hi2c->XferOptions;\r\n      }\r\n    }\r\n\r\n    /* Send Slave Address and set NBYTES to read */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with DMA\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                                 uint16_t Size, uint32_t XferOptions)\r\n{\r\n  uint32_t xfermode;\r\n  uint32_t xferrequest = I2C_GENERATE_START_READ;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = hi2c->XferOptions;\r\n    }\r\n\r\n    /* If transfer direction not change and there is no request to start another frame,\r\n       do not generate Restart Condition */\r\n    /* Mean Previous state is same as current state */\r\n    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \\\r\n        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))\r\n    {\r\n      xferrequest = I2C_NO_STARTSTOP;\r\n    }\r\n    else\r\n    {\r\n      /* Convert OTHER_xxx XferOptions if any */\r\n      I2C_ConvertOtherXferOptions(hi2c);\r\n\r\n      /* Update xfermode accordingly if no reload is necessary */\r\n      if (hi2c->XferCount <= MAX_NBYTE_SIZE)\r\n      {\r\n        xfermode = hi2c->XferOptions;\r\n      }\r\n    }\r\n\r\n    if (hi2c->XferSize > 0U)\r\n    {\r\n      if (hi2c->hdmarx != NULL)\r\n      {\r\n        /* Set the I2C DMA transfer complete callback */\r\n        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;\r\n\r\n        /* Set the DMA error callback */\r\n        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n        /* Set the unused DMA callbacks to NULL */\r\n        hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n        hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n        /* Enable the DMA stream */\r\n        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,\r\n                                         hi2c->XferSize);\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      if (dmaxferstatus == HAL_OK)\r\n      {\r\n        /* Send Slave Address and set NBYTES to read */\r\n        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);\r\n\r\n        /* Update XferCount value */\r\n        hi2c->XferCount -= hi2c->XferSize;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                  to avoid the risk of I2C interrupt handle execution before current\r\n                  process unlock */\r\n        /* Enable ERR and NACK interrupts */\r\n        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n        /* Enable DMA Request */\r\n        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Update Transfer ISR function pointer */\r\n      hi2c->XferISR = I2C_Master_ISR_IT;\r\n\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to read and generate START condition */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n      /* possible to enable all of these */\r\n      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with Interrupt\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                                uint32_t XferOptions)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */\r\n    /* and then toggle the HAL slave RX state to TX state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)\r\n    {\r\n      /* Disable associated Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n      /* Abort DMA Xfer if any */\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)\r\n      {\r\n        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n        if (hi2c->hdmarx != NULL)\r\n        {\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA RX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Slave_ISR_IT;\r\n\r\n    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)\r\n    {\r\n      /* Clear ADDR flag after prepare the transfer parameters */\r\n      /* This action will generate an acknowledge to the Master */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n    to avoid the risk of I2C interrupt handle execution before current\r\n    process unlock */\r\n    /* REnable ADDR interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with DMA\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                                 uint32_t XferOptions)\r\n{\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);\r\n\r\n    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */\r\n    /* and then toggle the HAL slave RX state to TX state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)\r\n    {\r\n      /* Disable associated Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)\r\n      {\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmarx != NULL)\r\n        {\r\n          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA RX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)\r\n    {\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)\r\n      {\r\n        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmatx != NULL)\r\n        {\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA TX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Nothing to do */\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Slave_ISR_DMA;\r\n\r\n    if (hi2c->hdmatx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Reset XferSize */\r\n      hi2c->XferSize = 0;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)\r\n    {\r\n      /* Clear ADDR flag after prepare the transfer parameters */\r\n      /* This action will generate an acknowledge to the Master */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Enable DMA Request */\r\n    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n    to avoid the risk of I2C interrupt handle execution before current\r\n    process unlock */\r\n    /* Enable ERR, STOP, NACK, ADDR interrupts */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with Interrupt\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                               uint32_t XferOptions)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */\r\n    /* and then toggle the HAL slave TX state to RX state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)\r\n    {\r\n      /* Disable associated Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)\r\n      {\r\n        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmatx != NULL)\r\n        {\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA TX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Slave_ISR_IT;\r\n\r\n    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)\r\n    {\r\n      /* Clear ADDR flag after prepare the transfer parameters */\r\n      /* This action will generate an acknowledge to the Master */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n    to avoid the risk of I2C interrupt handle execution before current\r\n    process unlock */\r\n    /* REnable ADDR interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with DMA\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                                uint32_t XferOptions)\r\n{\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */\r\n    /* and then toggle the HAL slave TX state to RX state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)\r\n    {\r\n      /* Disable associated Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)\r\n      {\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmatx != NULL)\r\n        {\r\n          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA TX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)\r\n    {\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)\r\n      {\r\n        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmarx != NULL)\r\n        {\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA RX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Nothing to do */\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Slave_ISR_DMA;\r\n\r\n    if (hi2c->hdmarx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR,\r\n                                       (uint32_t)pData, hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Reset XferSize */\r\n      hi2c->XferSize = 0;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)\r\n    {\r\n      /* Clear ADDR flag after prepare the transfer parameters */\r\n      /* This action will generate an acknowledge to the Master */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Enable DMA Request */\r\n    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n    to avoid the risk of I2C interrupt handle execution before current\r\n    process unlock */\r\n    /* REnable ADDR interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Address listen mode with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)\r\n{\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_LISTEN;\r\n    hi2c->XferISR = I2C_Slave_ISR_IT;\r\n\r\n    /* Enable the Address Match interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Address listen mode with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Declaration of tmp to prevent undefined behavior of volatile usage */\r\n  uint32_t tmp;\r\n\r\n  /* Disable Address listen mode only if a transfer is not ongoing */\r\n  if (hi2c->State == HAL_I2C_STATE_LISTEN)\r\n  {\r\n    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;\r\n    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode = HAL_I2C_MODE_NONE;\r\n    hi2c->XferISR = NULL;\r\n\r\n    /* Disable the Address Match interrupt */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Abort a master I2C IT or DMA process communication with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)\r\n{\r\n  if (hi2c->Mode == HAL_I2C_MODE_MASTER)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Disable Interrupts and Store Previous state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)\r\n    {\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;\r\n    }\r\n    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n    {\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;\r\n    }\r\n    else\r\n    {\r\n      /* Do nothing */\r\n    }\r\n\r\n    /* Set State at HAL_I2C_STATE_ABORT */\r\n    hi2c->State = HAL_I2C_STATE_ABORT;\r\n\r\n    /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */\r\n    /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */\r\n    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Wrong usage of abort function */\r\n    /* This function should be used only in case of abort monitored by master device */\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function handles I2C event interrupt request.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Get current IT Flags and IT sources value */\r\n  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);\r\n  uint32_t itsources = READ_REG(hi2c->Instance->CR1);\r\n\r\n  /* I2C events treatment -------------------------------------*/\r\n  if (hi2c->XferISR != NULL)\r\n  {\r\n    hi2c->XferISR(hi2c, itflags, itsources);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C error interrupt request.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)\r\n{\r\n  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);\r\n  uint32_t itsources = READ_REG(hi2c->Instance->CR1);\r\n  uint32_t tmperror;\r\n\r\n  /* I2C Bus error interrupt occurred ------------------------------------*/\r\n  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))\r\n  {\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;\r\n\r\n    /* Clear BERR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);\r\n  }\r\n\r\n  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/\r\n  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))\r\n  {\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;\r\n\r\n    /* Clear OVR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);\r\n  }\r\n\r\n  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/\r\n  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))\r\n  {\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;\r\n\r\n    /* Clear ARLO flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);\r\n  }\r\n\r\n  /* Store current volatile hi2c->ErrorCode, misra rule */\r\n  tmperror = hi2c->ErrorCode;\r\n\r\n  /* Call the Error Callback in case of Error detected */\r\n  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)\r\n  {\r\n    I2C_ITError(hi2c, tmperror);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Master Tx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Master Rx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/** @brief  Slave Tx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Slave Rx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Slave Address Match callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION\r\n  * @param  AddrMatchCode Address Match Code\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n  UNUSED(TransferDirection);\r\n  UNUSED(AddrMatchCode);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_AddrCallback() could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Listen Complete callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_ListenCpltCallback() could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Memory Tx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MemTxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Memory Rx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MemRxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  I2C error callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_ErrorCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  I2C abort callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_AbortCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions\r\n  *  @brief   Peripheral State, Mode and Error functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n            ##### Peripheral State, Mode and Error functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection permit to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the I2C handle state.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL state\r\n  */\r\nHAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Return I2C handle state */\r\n  return hi2c->State;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the I2C Master, Slave, Memory or no mode.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *         the configuration information for I2C module\r\n  * @retval HAL mode\r\n  */\r\nHAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)\r\n{\r\n  return hi2c->Mode;\r\n}\r\n\r\n/**\r\n  * @brief  Return the I2C error code.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *              the configuration information for the specified I2C.\r\n  * @retval I2C Error Code\r\n  */\r\nuint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)\r\n{\r\n  return hi2c->ErrorCode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup I2C_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @param  ITSources Interrupt sources enabled.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                           uint32_t ITSources)\r\n{\r\n  uint16_t devaddress;\r\n  uint32_t tmpITFlags = ITFlags;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))\r\n  {\r\n    /* Clear NACK Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Set corresponding Error Code */\r\n    /* No need to generate STOP, it is automatically done */\r\n    /* Error callback will be send during stop flag treatment */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n\r\n    /* Flush TX register */\r\n    I2C_Flush_TXDR(hi2c);\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))\r\n  {\r\n    /* Remove RXNE flag on temporary variable as read done */\r\n    tmpITFlags &= ~I2C_FLAG_RXNE;\r\n\r\n    /* Read data from RXDR */\r\n    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n    /* Increment Buffer pointer */\r\n    hi2c->pBuffPtr++;\r\n\r\n    hi2c->XferSize--;\r\n    hi2c->XferCount--;\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))\r\n  {\r\n    /* Write data to TXDR */\r\n    hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n    /* Increment Buffer pointer */\r\n    hi2c->pBuffPtr++;\r\n\r\n    hi2c->XferSize--;\r\n    hi2c->XferCount--;\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))\r\n  {\r\n    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n    {\r\n      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);\r\n\r\n      if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n      {\r\n        hi2c->XferSize = MAX_NBYTE_SIZE;\r\n        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);\r\n      }\r\n      else\r\n      {\r\n        hi2c->XferSize = hi2c->XferCount;\r\n        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)\r\n        {\r\n          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,\r\n                             hi2c->XferOptions, I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,\r\n                             I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Call TxCpltCallback() if no stop mode is set */\r\n      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)\r\n      {\r\n        /* Call I2C Master Sequential complete process */\r\n        I2C_ITMasterSeqCplt(hi2c);\r\n      }\r\n      else\r\n      {\r\n        /* Wrong size Status regarding TCR flag event */\r\n        /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);\r\n      }\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))\r\n  {\r\n    if (hi2c->XferCount == 0U)\r\n    {\r\n      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)\r\n      {\r\n        /* Generate a stop condition in case of no transfer option */\r\n        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)\r\n        {\r\n          /* Generate Stop */\r\n          hi2c->Instance->CR2 |= I2C_CR2_STOP;\r\n        }\r\n        else\r\n        {\r\n          /* Call I2C Master Sequential complete process */\r\n          I2C_ITMasterSeqCplt(hi2c);\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Wrong size Status regarding TC flag event */\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n\r\n  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))\r\n  {\r\n    /* Call I2C Master complete process */\r\n    I2C_ITMasterCplt(hi2c, tmpITFlags);\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @param  ITSources Interrupt sources enabled.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                          uint32_t ITSources)\r\n{\r\n  uint32_t tmpoptions = hi2c->XferOptions;\r\n  uint32_t tmpITFlags = ITFlags;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  /* Check if STOPF is set */\r\n  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))\r\n  {\r\n    /* Call I2C Slave complete process */\r\n    I2C_ITSlaveCplt(hi2c, tmpITFlags);\r\n  }\r\n\r\n  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))\r\n  {\r\n    /* Check that I2C transfer finished */\r\n    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */\r\n    /* Mean XferCount == 0*/\r\n    /* So clear Flag NACKF only */\r\n    if (hi2c->XferCount == 0U)\r\n    {\r\n      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))\r\n        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for\r\n           Warning[Pa134]: left and right operands are identical */\r\n      {\r\n        /* Call I2C Listen complete process */\r\n        I2C_ITListenCplt(hi2c, tmpITFlags);\r\n      }\r\n      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))\r\n      {\r\n        /* Clear NACK Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n        /* Flush TX register */\r\n        I2C_Flush_TXDR(hi2c);\r\n\r\n        /* Last Byte is Transmitted */\r\n        /* Call I2C Slave Sequential complete process */\r\n        I2C_ITSlaveSeqCplt(hi2c);\r\n      }\r\n      else\r\n      {\r\n        /* Clear NACK Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/\r\n      /* Clear NACK Flag */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n      /* Set ErrorCode corresponding to a Non-Acknowledge */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n\r\n      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))\r\n      {\r\n        /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n        I2C_ITError(hi2c, hi2c->ErrorCode);\r\n      }\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))\r\n  {\r\n    if (hi2c->XferCount > 0U)\r\n    {\r\n      /* Read data from RXDR */\r\n      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n    }\r\n\r\n    if ((hi2c->XferCount == 0U) && \\\r\n        (tmpoptions != I2C_NO_OPTION_FRAME))\r\n    {\r\n      /* Call I2C Slave Sequential complete process */\r\n      I2C_ITSlaveSeqCplt(hi2c);\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))\r\n  {\r\n    I2C_ITAddrCplt(hi2c, tmpITFlags);\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))\r\n  {\r\n    /* Write data to TXDR only if XferCount not reach \"0\" */\r\n    /* A TXIS flag can be set, during STOP treatment      */\r\n    /* Check if all Data have already been sent */\r\n    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */\r\n    if (hi2c->XferCount > 0U)\r\n    {\r\n      /* Write data to TXDR */\r\n      hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n      hi2c->XferSize--;\r\n    }\r\n    else\r\n    {\r\n      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))\r\n      {\r\n        /* Last Byte is Transmitted */\r\n        /* Call I2C Slave Sequential complete process */\r\n        I2C_ITSlaveSeqCplt(hi2c);\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with DMA.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @param  ITSources Interrupt sources enabled.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                            uint32_t ITSources)\r\n{\r\n  uint16_t devaddress;\r\n  uint32_t xfermode;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))\r\n  {\r\n    /* Clear NACK Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Set corresponding Error Code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n\r\n    /* No need to generate STOP, it is automatically done */\r\n    /* But enable STOP interrupt, to treat it */\r\n    /* Error callback will be send during stop flag treatment */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);\r\n\r\n    /* Flush TX register */\r\n    I2C_Flush_TXDR(hi2c);\r\n  }\r\n  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))\r\n  {\r\n    /* Disable TC interrupt */\r\n    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);\r\n\r\n    if (hi2c->XferCount != 0U)\r\n    {\r\n      /* Recover Slave address */\r\n      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);\r\n\r\n      /* Prepare the new XferSize to transfer */\r\n      if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n      {\r\n        hi2c->XferSize = MAX_NBYTE_SIZE;\r\n        xfermode = I2C_RELOAD_MODE;\r\n      }\r\n      else\r\n      {\r\n        hi2c->XferSize = hi2c->XferCount;\r\n        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)\r\n        {\r\n          xfermode = hi2c->XferOptions;\r\n        }\r\n        else\r\n        {\r\n          xfermode = I2C_AUTOEND_MODE;\r\n        }\r\n      }\r\n\r\n      /* Set the new XferSize in Nbytes register */\r\n      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);\r\n\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Enable DMA Request */\r\n      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n      {\r\n        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Call TxCpltCallback() if no stop mode is set */\r\n      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)\r\n      {\r\n        /* Call I2C Master Sequential complete process */\r\n        I2C_ITMasterSeqCplt(hi2c);\r\n      }\r\n      else\r\n      {\r\n        /* Wrong size Status regarding TCR flag event */\r\n        /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);\r\n      }\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))\r\n  {\r\n    if (hi2c->XferCount == 0U)\r\n    {\r\n      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)\r\n      {\r\n        /* Generate a stop condition in case of no transfer option */\r\n        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)\r\n        {\r\n          /* Generate Stop */\r\n          hi2c->Instance->CR2 |= I2C_CR2_STOP;\r\n        }\r\n        else\r\n        {\r\n          /* Call I2C Master Sequential complete process */\r\n          I2C_ITMasterSeqCplt(hi2c);\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Wrong size Status regarding TC flag event */\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))\r\n  {\r\n    /* Call I2C Master complete process */\r\n    I2C_ITMasterCplt(hi2c, ITFlags);\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with DMA.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @param  ITSources Interrupt sources enabled.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                           uint32_t ITSources)\r\n{\r\n  uint32_t tmpoptions = hi2c->XferOptions;\r\n  uint32_t treatdmanack = 0U;\r\n  HAL_I2C_StateTypeDef tmpstate;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  /* Check if STOPF is set */\r\n  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))\r\n  {\r\n    /* Call I2C Slave complete process */\r\n    I2C_ITSlaveCplt(hi2c, ITFlags);\r\n  }\r\n\r\n  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))\r\n  {\r\n    /* Check that I2C transfer finished */\r\n    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */\r\n    /* Mean XferCount == 0 */\r\n    /* So clear Flag NACKF only */\r\n    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||\r\n        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))\r\n    {\r\n      /* Split check of hdmarx, for MISRA compliance */\r\n      if (hi2c->hdmarx != NULL)\r\n      {\r\n        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)\r\n        {\r\n          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)\r\n          {\r\n            treatdmanack = 1U;\r\n          }\r\n        }\r\n      }\r\n\r\n      /* Split check of hdmatx, for MISRA compliance  */\r\n      if (hi2c->hdmatx != NULL)\r\n      {\r\n        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)\r\n        {\r\n          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)\r\n          {\r\n            treatdmanack = 1U;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (treatdmanack == 1U)\r\n      {\r\n        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))\r\n          /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for\r\n             Warning[Pa134]: left and right operands are identical */\r\n        {\r\n          /* Call I2C Listen complete process */\r\n          I2C_ITListenCplt(hi2c, ITFlags);\r\n        }\r\n        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))\r\n        {\r\n          /* Clear NACK Flag */\r\n          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n          /* Flush TX register */\r\n          I2C_Flush_TXDR(hi2c);\r\n\r\n          /* Last Byte is Transmitted */\r\n          /* Call I2C Slave Sequential complete process */\r\n          I2C_ITSlaveSeqCplt(hi2c);\r\n        }\r\n        else\r\n        {\r\n          /* Clear NACK Flag */\r\n          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/\r\n        /* Clear NACK Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n        /* Set ErrorCode corresponding to a Non-Acknowledge */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n\r\n        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */\r\n        tmpstate = hi2c->State;\r\n\r\n        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))\r\n        {\r\n          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))\r\n          {\r\n            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;\r\n          }\r\n          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))\r\n          {\r\n            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;\r\n          }\r\n          else\r\n          {\r\n            /* Do nothing */\r\n          }\r\n\r\n          /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n          I2C_ITError(hi2c, hi2c->ErrorCode);\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Only Clear NACK Flag, no DMA treatment is pending */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))\r\n  {\r\n    I2C_ITAddrCplt(hi2c, ITFlags);\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Master sends target device address followed by internal memory address for write request.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,\r\n                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,\r\n                                                uint32_t Tickstart)\r\n{\r\n  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);\r\n\r\n  /* Wait until TXIS flag is set */\r\n  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* If Memory address size is 8Bit */\r\n  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)\r\n  {\r\n    /* Send Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);\r\n  }\r\n  /* If Memory address size is 16Bit */\r\n  else\r\n  {\r\n    /* Send MSB of Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);\r\n\r\n    /* Wait until TXIS flag is set */\r\n    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Send LSB of Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);\r\n  }\r\n\r\n  /* Wait until TCR flag is set */\r\n  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Master sends target device address followed by internal memory address for read request.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,\r\n                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,\r\n                                               uint32_t Tickstart)\r\n{\r\n  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);\r\n\r\n  /* Wait until TXIS flag is set */\r\n  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* If Memory address size is 8Bit */\r\n  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)\r\n  {\r\n    /* Send Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);\r\n  }\r\n  /* If Memory address size is 16Bit */\r\n  else\r\n  {\r\n    /* Send MSB of Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);\r\n\r\n    /* Wait until TXIS flag is set */\r\n    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Send LSB of Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);\r\n  }\r\n\r\n  /* Wait until TC flag is set */\r\n  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  I2C Address complete process callback.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)\r\n{\r\n  uint8_t transferdirection;\r\n  uint16_t slaveaddrcode;\r\n  uint16_t ownadd1code;\r\n  uint16_t ownadd2code;\r\n\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(ITFlags);\r\n\r\n  /* In case of Listen state, need to inform upper layer of address match code event */\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    transferdirection = I2C_GET_DIR(hi2c);\r\n    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);\r\n    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);\r\n    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);\r\n\r\n    /* If 10bits addressing mode is selected */\r\n    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)\r\n    {\r\n      if ((slaveaddrcode & SLAVE_ADDR_MSK) == ((ownadd1code >> SLAVE_ADDR_SHIFT) & SLAVE_ADDR_MSK))\r\n      {\r\n        slaveaddrcode = ownadd1code;\r\n        hi2c->AddrEventCount++;\r\n        if (hi2c->AddrEventCount == 2U)\r\n        {\r\n          /* Reset Address Event counter */\r\n          hi2c->AddrEventCount = 0U;\r\n\r\n          /* Clear ADDR flag */\r\n          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n\r\n          /* Process Unlocked */\r\n          __HAL_UNLOCK(hi2c);\r\n\r\n          /* Call Slave Addr callback */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#else\r\n          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n        }\r\n      }\r\n      else\r\n      {\r\n        slaveaddrcode = ownadd2code;\r\n\r\n        /* Disable ADDR Interrupts */\r\n        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Call Slave Addr callback */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n        hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#else\r\n        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n      }\r\n    }\r\n    /* else 7 bits addressing mode is selected */\r\n    else\r\n    {\r\n      /* Disable ADDR Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call Slave Addr callback */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#else\r\n      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* Else clear address flag only */\r\n  else\r\n  {\r\n    /* Clear ADDR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Master sequential complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Reset I2C handle mode */\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n  /* No Generate Stop, to permit restart mode */\r\n  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */\r\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)\r\n  {\r\n    hi2c->State         = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;\r\n    hi2c->XferISR       = NULL;\r\n\r\n    /* Disable Interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->MasterTxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_MasterTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  /* hi2c->State == HAL_I2C_STATE_BUSY_RX */\r\n  else\r\n  {\r\n    hi2c->State         = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;\r\n    hi2c->XferISR       = NULL;\r\n\r\n    /* Disable Interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->MasterRxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_MasterRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Slave sequential complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)\r\n{\r\n  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);\r\n\r\n  /* Reset I2C handle mode */\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n  /* If a DMA is ongoing, Update handle size context */\r\n  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n  }\r\n  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n  }\r\n  else\r\n  {\r\n    /* Do nothing */\r\n  }\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)\r\n  {\r\n    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */\r\n    hi2c->State         = HAL_I2C_STATE_LISTEN;\r\n    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;\r\n\r\n    /* Disable Interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->SlaveTxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)\r\n  {\r\n    /* Remove HAL_I2C_STATE_SLAVE_BUSY_RX, keep only HAL_I2C_STATE_LISTEN */\r\n    hi2c->State         = HAL_I2C_STATE_LISTEN;\r\n    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;\r\n\r\n    /* Disable Interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->SlaveRxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_SlaveRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Master complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)\r\n{\r\n  uint32_t tmperror;\r\n  uint32_t tmpITFlags = ITFlags;\r\n  __IO uint32_t tmpreg;\r\n\r\n  /* Clear STOP Flag */\r\n  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n  /* Disable Interrupts and Store Previous state */\r\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)\r\n  {\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;\r\n  }\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n  {\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;\r\n  }\r\n  else\r\n  {\r\n    /* Do nothing */\r\n  }\r\n\r\n  /* Clear Configuration Register 2 */\r\n  I2C_RESET_CR2(hi2c);\r\n\r\n  /* Reset handle parameters */\r\n  hi2c->XferISR       = NULL;\r\n  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;\r\n\r\n  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)\r\n  {\r\n    /* Clear NACK Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Set acknowledge error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n  }\r\n\r\n  /* Fetch Last receive data if any */\r\n  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))\r\n  {\r\n    /* Read data from RXDR */\r\n    tmpreg = (uint8_t)hi2c->Instance->RXDR;\r\n    UNUSED(tmpreg);\r\n  }\r\n\r\n  /* Flush TX register */\r\n  I2C_Flush_TXDR(hi2c);\r\n\r\n  /* Store current volatile hi2c->ErrorCode, misra rule */\r\n  tmperror = hi2c->ErrorCode;\r\n\r\n  /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))\r\n  {\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n    I2C_ITError(hi2c, hi2c->ErrorCode);\r\n  }\r\n  /* hi2c->State == HAL_I2C_STATE_BUSY_TX */\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    if (hi2c->Mode == HAL_I2C_MODE_MEM)\r\n    {\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->MemTxCpltCallback(hi2c);\r\n#else\r\n      HAL_I2C_MemTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n    else\r\n    {\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->MasterTxCpltCallback(hi2c);\r\n#else\r\n      HAL_I2C_MasterTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* hi2c->State == HAL_I2C_STATE_BUSY_RX */\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    if (hi2c->Mode == HAL_I2C_MODE_MEM)\r\n    {\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->MemRxCpltCallback(hi2c);\r\n#else\r\n      HAL_I2C_MemRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n    else\r\n    {\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->MasterRxCpltCallback(hi2c);\r\n#else\r\n      HAL_I2C_MasterRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Slave complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)\r\n{\r\n  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);\r\n  uint32_t tmpITFlags = ITFlags;\r\n  HAL_I2C_StateTypeDef tmpstate = hi2c->State;\r\n\r\n  /* Clear STOP Flag */\r\n  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n  /* Disable Interrupts and Store Previous state */\r\n  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))\r\n  {\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);\r\n    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;\r\n  }\r\n  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))\r\n  {\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);\r\n    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;\r\n  }\r\n  else\r\n  {\r\n    /* Do nothing */\r\n  }\r\n\r\n  /* Disable Address Acknowledge */\r\n  hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n  /* Clear Configuration Register 2 */\r\n  I2C_RESET_CR2(hi2c);\r\n\r\n  /* Flush TX register */\r\n  I2C_Flush_TXDR(hi2c);\r\n\r\n  /* If a DMA is ongoing, Update handle size context */\r\n  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n    if (hi2c->hdmatx != NULL)\r\n    {\r\n      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx);\r\n    }\r\n  }\r\n  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n    if (hi2c->hdmarx != NULL)\r\n    {\r\n      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Do nothing */\r\n  }\r\n\r\n  /* Store Last receive data if any */\r\n  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)\r\n  {\r\n    /* Remove RXNE flag on temporary variable as read done */\r\n    tmpITFlags &= ~I2C_FLAG_RXNE;\r\n\r\n    /* Read data from RXDR */\r\n    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n    /* Increment Buffer pointer */\r\n    hi2c->pBuffPtr++;\r\n\r\n    if ((hi2c->XferSize > 0U))\r\n    {\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n    }\r\n  }\r\n\r\n  /* All data are not transferred, so set error code accordingly */\r\n  if (hi2c->XferCount != 0U)\r\n  {\r\n    /* Set ErrorCode corresponding to a Non-Acknowledge */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n  }\r\n\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n  hi2c->XferISR = NULL;\r\n\r\n  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)\r\n  {\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n    I2C_ITError(hi2c, hi2c->ErrorCode);\r\n\r\n    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */\r\n    if (hi2c->State == HAL_I2C_STATE_LISTEN)\r\n    {\r\n      /* Call I2C Listen complete process */\r\n      I2C_ITListenCplt(hi2c, tmpITFlags);\r\n    }\r\n  }\r\n  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)\r\n  {\r\n    /* Call the Sequential Complete callback, to inform upper layer of the end of Transfer */\r\n    I2C_ITSlaveSeqCplt(hi2c);\r\n\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->ListenCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_ListenCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->SlaveRxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_SlaveRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  else\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->SlaveTxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Listen complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)\r\n{\r\n  /* Reset handle parameters */\r\n  hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n  hi2c->PreviousState = I2C_STATE_NONE;\r\n  hi2c->State = HAL_I2C_STATE_READY;\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n  hi2c->XferISR = NULL;\r\n\r\n  /* Store Last receive data if any */\r\n  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)\r\n  {\r\n    /* Read data from RXDR */\r\n    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n    /* Increment Buffer pointer */\r\n    hi2c->pBuffPtr++;\r\n\r\n    if ((hi2c->XferSize > 0U))\r\n    {\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n\r\n      /* Set ErrorCode corresponding to a Non-Acknowledge */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n    }\r\n  }\r\n\r\n  /* Disable all Interrupts*/\r\n  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);\r\n\r\n  /* Clear NACK Flag */\r\n  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n  hi2c->ListenCpltCallback(hi2c);\r\n#else\r\n  HAL_I2C_ListenCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  I2C interrupts error process.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ErrorCode Error code to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)\r\n{\r\n  HAL_I2C_StateTypeDef tmpstate = hi2c->State;\r\n  uint32_t tmppreviousstate;\r\n\r\n  /* Reset handle parameters */\r\n  hi2c->Mode          = HAL_I2C_MODE_NONE;\r\n  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;\r\n  hi2c->XferCount     = 0U;\r\n\r\n  /* Set new error code */\r\n  hi2c->ErrorCode |= ErrorCode;\r\n\r\n  /* Disable Interrupts */\r\n  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||\r\n      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||\r\n      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))\r\n  {\r\n    /* Disable all interrupts, except interrupts related to LISTEN state */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);\r\n\r\n    /* keep HAL_I2C_STATE_LISTEN if set */\r\n    hi2c->State         = HAL_I2C_STATE_LISTEN;\r\n    hi2c->XferISR       = I2C_Slave_ISR_IT;\r\n  }\r\n  else\r\n  {\r\n    /* Disable all interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);\r\n\r\n    /* If state is an abort treatment on going, don't change state */\r\n    /* This change will be do later */\r\n    if (hi2c->State != HAL_I2C_STATE_ABORT)\r\n    {\r\n      /* Set HAL_I2C_STATE_READY */\r\n      hi2c->State         = HAL_I2C_STATE_READY;\r\n    }\r\n    hi2c->XferISR       = NULL;\r\n  }\r\n\r\n  /* Abort DMA TX transfer if any */\r\n  tmppreviousstate = hi2c->PreviousState;\r\n  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \\\r\n                                 (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))\r\n  {\r\n    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)\r\n    {\r\n      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n    }\r\n\r\n    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)\r\n    {\r\n      /* Set the I2C DMA Abort callback :\r\n       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Abort DMA TX */\r\n      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)\r\n      {\r\n        /* Call Directly XferAbortCallback function in case of error */\r\n        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      I2C_TreatErrorCallback(hi2c);\r\n    }\r\n  }\r\n  /* Abort DMA RX transfer if any */\r\n  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \\\r\n                                      (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))\r\n  {\r\n    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)\r\n    {\r\n      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n    }\r\n\r\n    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)\r\n    {\r\n      /* Set the I2C DMA Abort callback :\r\n        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Abort DMA RX */\r\n      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)\r\n      {\r\n        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */\r\n        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      I2C_TreatErrorCallback(hi2c);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    I2C_TreatErrorCallback(hi2c);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Error callback treatment.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  if (hi2c->State == HAL_I2C_STATE_ABORT)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->AbortCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_AbortCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  else\r\n  {\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->ErrorCallback(hi2c);\r\n#else\r\n    HAL_I2C_ErrorCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Tx data register flush process.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* If a pending TXIS flag is set */\r\n  /* Write a dummy data in TXDR to clear it */\r\n  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)\r\n  {\r\n    hi2c->Instance->TXDR = 0x00U;\r\n  }\r\n\r\n  /* Flush TX register if not empty */\r\n  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)\r\n  {\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA I2C master transmit process complete callback.\r\n  * @param  hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n\r\n  /* Disable DMA Request */\r\n  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n  /* If last transfer, enable STOP interrupt */\r\n  if (hi2c->XferCount == 0U)\r\n  {\r\n    /* Enable STOP interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);\r\n  }\r\n  /* else prepare a new DMA transfer and enable TCReload interrupt */\r\n  else\r\n  {\r\n    /* Update Buffer pointer */\r\n    hi2c->pBuffPtr += hi2c->XferSize;\r\n\r\n    /* Set the XferSize to transfer */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n    }\r\n\r\n    /* Enable the DMA stream */\r\n    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR,\r\n                         hi2c->XferSize) != HAL_OK)\r\n    {\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);\r\n    }\r\n    else\r\n    {\r\n      /* Enable TC interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA I2C slave transmit process complete callback.\r\n  * @param  hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n  uint32_t tmpoptions = hi2c->XferOptions;\r\n\r\n  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n    /* Last Byte is Transmitted */\r\n    /* Call I2C Slave Sequential complete process */\r\n    I2C_ITSlaveSeqCplt(hi2c);\r\n  }\r\n  else\r\n  {\r\n    /* No specific action, Master fully manage the generation of STOP condition */\r\n    /* Mean that this generation can arrive at any time, at the end or during DMA process */\r\n    /* So STOP condition should be manage through Interrupt treatment */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief DMA I2C master receive process complete callback.\r\n  * @param  hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n\r\n  /* Disable DMA Request */\r\n  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n  /* If last transfer, enable STOP interrupt */\r\n  if (hi2c->XferCount == 0U)\r\n  {\r\n    /* Enable STOP interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);\r\n  }\r\n  /* else prepare a new DMA transfer and enable TCReload interrupt */\r\n  else\r\n  {\r\n    /* Update Buffer pointer */\r\n    hi2c->pBuffPtr += hi2c->XferSize;\r\n\r\n    /* Set the XferSize to transfer */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n    }\r\n\r\n    /* Enable the DMA stream */\r\n    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr,\r\n                         hi2c->XferSize) != HAL_OK)\r\n    {\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);\r\n    }\r\n    else\r\n    {\r\n      /* Enable TC interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA I2C slave receive process complete callback.\r\n  * @param  hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n  uint32_t tmpoptions = hi2c->XferOptions;\r\n\r\n  if ((I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U) && \\\r\n      (tmpoptions != I2C_NO_OPTION_FRAME))\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n    /* Call I2C Slave Sequential complete process */\r\n    I2C_ITSlaveSeqCplt(hi2c);\r\n  }\r\n  else\r\n  {\r\n    /* No specific action, Master fully manage the generation of STOP condition */\r\n    /* Mean that this generation can arrive at any time, at the end or during DMA process */\r\n    /* So STOP condition should be manage through Interrupt treatment */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA I2C communication error callback.\r\n  * @param hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMAError(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t treatdmaerror = 0U;\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n\r\n  if (hi2c->hdmatx != NULL)\r\n  {\r\n    if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)\r\n    {\r\n      treatdmaerror = 1U;\r\n    }\r\n  }\r\n\r\n  if (hi2c->hdmarx != NULL)\r\n  {\r\n    if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)\r\n    {\r\n      treatdmaerror = 1U;\r\n    }\r\n  }\r\n\r\n  /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */\r\n  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))\r\n  {\r\n    /* Disable Acknowledge */\r\n    hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief DMA I2C communication abort callback\r\n  *        (To be called at end of DMA Abort procedure).\r\n  * @param hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMAAbort(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n\r\n  /* Reset AbortCpltCallback */\r\n  if (hi2c->hdmatx != NULL)\r\n  {\r\n    hi2c->hdmatx->XferAbortCallback = NULL;\r\n  }\r\n  if (hi2c->hdmarx != NULL)\r\n  {\r\n    hi2c->hdmarx->XferAbortCallback = NULL;\r\n  }\r\n\r\n  I2C_TreatErrorCallback(hi2c);\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C Communication Timeout. It waits\r\n  *                until a flag is no longer in the specified status.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Flag Specifies the I2C flag to check.\r\n  * @param  Status The actual Flag status (SET or RESET).\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,\r\n                                                    uint32_t Timeout, uint32_t Tickstart)\r\n{\r\n  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)\r\n  {\r\n    /* Check for the Timeout */\r\n    if (Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n        hi2c->State = HAL_I2C_STATE_READY;\r\n        hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C Communication Timeout for specific usage of TXIS flag.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart)\r\n{\r\n  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)\r\n  {\r\n    /* Check if an error is detected */\r\n    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Check for the Timeout */\r\n    if (Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n        hi2c->State = HAL_I2C_STATE_READY;\r\n        hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart)\r\n{\r\n  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)\r\n  {\r\n    /* Check if an error is detected */\r\n    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Check for the Timeout */\r\n    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n    {\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n      hi2c->State = HAL_I2C_STATE_READY;\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart)\r\n{\r\n  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)\r\n  {\r\n    /* Check if an error is detected */\r\n    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Check if a STOPF is detected */\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)\r\n    {\r\n      /* Check if an RXNE is pending */\r\n      /* Store Last receive data if any */\r\n      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))\r\n      {\r\n        /* Return HAL_OK */\r\n        /* The Reading of data from RXDR will be done in caller function */\r\n        return HAL_OK;\r\n      }\r\n      else\r\n      {\r\n        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)\r\n        {\r\n          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n          hi2c->ErrorCode = HAL_I2C_ERROR_AF;\r\n        }\r\n        else\r\n        {\r\n          hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n        }\r\n\r\n        /* Clear STOP Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n        /* Clear Configuration Register 2 */\r\n        I2C_RESET_CR2(hi2c);\r\n\r\n        hi2c->State = HAL_I2C_STATE_READY;\r\n        hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Check for the Timeout */\r\n    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n    {\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n      hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles errors detection during an I2C Communication.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t itflag   = hi2c->Instance->ISR;\r\n  uint32_t error_code = 0;\r\n  uint32_t tickstart = Tickstart;\r\n  uint32_t tmp1;\r\n  HAL_I2C_ModeTypeDef tmp2;\r\n\r\n  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))\r\n  {\r\n    /* Clear NACKF Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Wait until STOP Flag is set or timeout occurred */\r\n    /* AutoEnd should be initiate after AF */\r\n    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))\r\n    {\r\n      /* Check for the Timeout */\r\n      if (Timeout != HAL_MAX_DELAY)\r\n      {\r\n        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n        {\r\n          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);\r\n          tmp2 = hi2c->Mode;\r\n\r\n          /* In case of I2C still busy, try to regenerate a STOP manually */\r\n          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \\\r\n              (tmp1 != I2C_CR2_STOP) && \\\r\n              (tmp2 != HAL_I2C_MODE_SLAVE))\r\n          {\r\n            /* Generate Stop */\r\n            hi2c->Instance->CR2 |= I2C_CR2_STOP;\r\n            \r\n            /* Update Tick with new reference */\r\n            tickstart = HAL_GetTick();\r\n          }\r\n          \r\n          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)\r\n          {\r\n            /* Check for the Timeout */\r\n            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)\r\n            {\r\n              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n              hi2c->State = HAL_I2C_STATE_READY;\r\n              hi2c->Mode = HAL_I2C_MODE_NONE;\r\n              \r\n              /* Process Unlocked */\r\n              __HAL_UNLOCK(hi2c);\r\n              \r\n              status = HAL_ERROR;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* In case STOP Flag is detected, clear it */\r\n    if (status == HAL_OK)\r\n    {\r\n      /* Clear STOP Flag */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n    }\r\n\r\n    error_code |= HAL_I2C_ERROR_AF;\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Refresh Content of Status register */\r\n  itflag = hi2c->Instance->ISR;\r\n\r\n  /* Then verify if an additional errors occurs */\r\n  /* Check if a Bus error occurred */\r\n  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))\r\n  {\r\n    error_code |= HAL_I2C_ERROR_BERR;\r\n\r\n    /* Clear BERR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Check if an Over-Run/Under-Run error occurred */\r\n  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))\r\n  {\r\n    error_code |= HAL_I2C_ERROR_OVR;\r\n\r\n    /* Clear OVR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Check if an Arbitration Loss error occurred */\r\n  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))\r\n  {\r\n    error_code |= HAL_I2C_ERROR_ARLO;\r\n\r\n    /* Clear ARLO flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  if (status != HAL_OK)\r\n  {\r\n    /* Flush TX register */\r\n    I2C_Flush_TXDR(hi2c);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->ErrorCode |= error_code;\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).\r\n  * @param  hi2c I2C handle.\r\n  * @param  DevAddress Specifies the slave address to be programmed.\r\n  * @param  Size Specifies the number of bytes to be programmed.\r\n  *   This parameter must be a value between 0 and 255.\r\n  * @param  Mode New state of the I2C START condition generation.\r\n  *   This parameter can be one of the following values:\r\n  *     @arg @ref I2C_RELOAD_MODE Enable Reload mode .\r\n  *     @arg @ref I2C_AUTOEND_MODE Enable Automatic end mode.\r\n  *     @arg @ref I2C_SOFTEND_MODE Enable Software end mode.\r\n  * @param  Request New state of the I2C START condition generation.\r\n  *   This parameter can be one of the following values:\r\n  *     @arg @ref I2C_NO_STARTSTOP Don't Generate stop and start condition.\r\n  *     @arg @ref I2C_GENERATE_STOP Generate stop condition (Size should be set to 0).\r\n  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.\r\n  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.\r\n  * @retval None\r\n  */\r\nstatic void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,\r\n                               uint32_t Request)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n  assert_param(IS_TRANSFER_MODE(Mode));\r\n  assert_param(IS_TRANSFER_REQUEST(Request));\r\n\r\n  /* Declaration of tmp to prevent undefined behavior of volatile usage */\r\n  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \\\r\n                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \\\r\n                              (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));\r\n\r\n  /* update CR2 register */\r\n  MODIFY_REG(hi2c->Instance->CR2, \\\r\n             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \\\r\n               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \\\r\n                I2C_CR2_START | I2C_CR2_STOP)), tmp);\r\n}\r\n\r\n/**\r\n  * @brief  Manage the enabling of Interrupts.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.\r\n  * @retval None\r\n  */\r\nstatic void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)\r\n{\r\n  uint32_t tmpisr = 0U;\r\n\r\n  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \\\r\n      (hi2c->XferISR == I2C_Slave_ISR_DMA))\r\n  {\r\n    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)\r\n    {\r\n      /* Enable ERR, STOP, NACK and ADDR interrupts */\r\n      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n    }\r\n\r\n    if (InterruptRequest == I2C_XFER_ERROR_IT)\r\n    {\r\n      /* Enable ERR and NACK interrupts */\r\n      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;\r\n    }\r\n\r\n    if (InterruptRequest == I2C_XFER_CPLT_IT)\r\n    {\r\n      /* Enable STOP interrupts */\r\n      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);\r\n    }\r\n\r\n    if (InterruptRequest == I2C_XFER_RELOAD_IT)\r\n    {\r\n      /* Enable TC interrupts */\r\n      tmpisr |= I2C_IT_TCI;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)\r\n    {\r\n      /* Enable ERR, STOP, NACK, and ADDR interrupts */\r\n      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n    }\r\n\r\n    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)\r\n    {\r\n      /* Enable ERR, TC, STOP, NACK and RXI interrupts */\r\n      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;\r\n    }\r\n\r\n    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)\r\n    {\r\n      /* Enable ERR, TC, STOP, NACK and TXI interrupts */\r\n      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;\r\n    }\r\n\r\n    if (InterruptRequest == I2C_XFER_CPLT_IT)\r\n    {\r\n      /* Enable STOP interrupts */\r\n      tmpisr |= I2C_IT_STOPI;\r\n    }\r\n  }\r\n\r\n  /* Enable interrupts only at the end */\r\n  /* to avoid the risk of I2C interrupt handle execution before */\r\n  /* all interrupts requested done */\r\n  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);\r\n}\r\n\r\n/**\r\n  * @brief  Manage the disabling of Interrupts.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.\r\n  * @retval None\r\n  */\r\nstatic void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)\r\n{\r\n  uint32_t tmpisr = 0U;\r\n\r\n  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)\r\n  {\r\n    /* Disable TC and TXI interrupts */\r\n    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;\r\n\r\n    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)\r\n    {\r\n      /* Disable NACK and STOP interrupts */\r\n      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n    }\r\n  }\r\n\r\n  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)\r\n  {\r\n    /* Disable TC and RXI interrupts */\r\n    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;\r\n\r\n    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)\r\n    {\r\n      /* Disable NACK and STOP interrupts */\r\n      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n    }\r\n  }\r\n\r\n  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)\r\n  {\r\n    /* Disable ADDR, NACK and STOP interrupts */\r\n    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n  }\r\n\r\n  if (InterruptRequest == I2C_XFER_ERROR_IT)\r\n  {\r\n    /* Enable ERR and NACK interrupts */\r\n    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;\r\n  }\r\n\r\n  if (InterruptRequest == I2C_XFER_CPLT_IT)\r\n  {\r\n    /* Enable STOP interrupts */\r\n    tmpisr |= I2C_IT_STOPI;\r\n  }\r\n\r\n  if (InterruptRequest == I2C_XFER_RELOAD_IT)\r\n  {\r\n    /* Enable TC interrupts */\r\n    tmpisr |= I2C_IT_TCI;\r\n  }\r\n\r\n  /* Disable interrupts only at the end */\r\n  /* to avoid a breaking situation like at \"t\" time */\r\n  /* all disable interrupts request are not done */\r\n  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);\r\n}\r\n\r\n/**\r\n  * @brief  Convert I2Cx OTHER_xxx XferOptions to functional XferOptions.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* if user set XferOptions to I2C_OTHER_FRAME            */\r\n  /* it request implicitly to generate a restart condition */\r\n  /* set XferOptions to I2C_FIRST_FRAME                    */\r\n  if (hi2c->XferOptions == I2C_OTHER_FRAME)\r\n  {\r\n    hi2c->XferOptions = I2C_FIRST_FRAME;\r\n  }\r\n  /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */\r\n  /* it request implicitly to generate a restart condition    */\r\n  /* then generate a stop condition at the end of transfer    */\r\n  /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */\r\n  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)\r\n  {\r\n    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_I2C_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32f7xx_hal_i2c_ex.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_i2c_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   I2C Extended HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of I2C Extended peripheral:\r\n  *           + Filter Mode Functions\r\n  *           + FastModePlus Functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n               ##### I2C peripheral Extended features  #####\r\n  ==============================================================================\r\n\r\n  [..] Comparing to other previous devices, the I2C interface for STM32F7xx\r\n       devices contains the following additional features\r\n\r\n       (+) Possibility to disable or enable Analog Noise Filter\r\n       (+) Use of a configured Digital Noise Filter\r\n       (+) Disable or enable Fast Mode Plus\r\n\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..] This driver provides functions to:\r\n    (#) Configure I2C Analog noise filter using the function HAL_I2CEx_ConfigAnalogFilter()\r\n    (#) Configure I2C Digital noise filter using the function HAL_I2CEx_ConfigDigitalFilter()\r\n    (#) Configure the enable or disable of fast mode plus driving capability using the functions :\r\n          (++) HAL_I2CEx_EnableFastModePlus()\r\n          (++) HAL_I2CEx_DisableFastModePlus()\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup I2CEx I2CEx\r\n  * @brief I2C Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_I2C_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup I2CEx_Exported_Functions I2C Extended Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup I2CEx_Exported_Functions_Group1 Filter Mode Functions\r\n  * @brief    Filter Mode Functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Filter Mode Functions #####\r\n ===============================================================================\r\n    [..] This section provides functions allowing to:\r\n      (+) Configure Noise Filters\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Configure I2C Analog noise filter.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2Cx peripheral.\r\n  * @param  AnalogFilter New state of the Analog filter.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n    /* Disable the selected I2C peripheral */\r\n    __HAL_I2C_DISABLE(hi2c);\r\n\r\n    /* Reset I2Cx ANOFF bit */\r\n    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);\r\n\r\n    /* Set analog filter bit*/\r\n    hi2c->Instance->CR1 |= AnalogFilter;\r\n\r\n    __HAL_I2C_ENABLE(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Configure I2C Digital noise filter.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2Cx peripheral.\r\n  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)\r\n{\r\n  uint32_t tmpreg;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n    /* Disable the selected I2C peripheral */\r\n    __HAL_I2C_DISABLE(hi2c);\r\n\r\n    /* Get the old register value */\r\n    tmpreg = hi2c->Instance->CR1;\r\n\r\n    /* Reset I2Cx DNF bits [11:8] */\r\n    tmpreg &= ~(I2C_CR1_DNF);\r\n\r\n    /* Set I2Cx DNF coefficient */\r\n    tmpreg |= DigitalFilter << 8U;\r\n\r\n    /* Store the new register value */\r\n    hi2c->Instance->CR1 = tmpreg;\r\n\r\n    __HAL_I2C_ENABLE(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @}\r\n  */\r\n#if  (defined(SYSCFG_PMC_I2C_PB6_FMP) || defined(SYSCFG_PMC_I2C_PB7_FMP)) || (defined(SYSCFG_PMC_I2C_PB8_FMP) || defined(SYSCFG_PMC_I2C_PB9_FMP)) || (defined(SYSCFG_PMC_I2C1_FMP)) || (defined(SYSCFG_PMC_I2C2_FMP)) || defined(SYSCFG_PMC_I2C3_FMP) || defined(SYSCFG_PMC_I2C4_FMP)\r\n\r\n/** @defgroup I2CEx_Exported_Functions_Group3 Fast Mode Plus Functions\r\n  * @brief    Fast Mode Plus Functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Fast Mode Plus Functions #####\r\n ===============================================================================\r\n    [..] This section provides functions allowing to:\r\n      (+) Configure Fast Mode Plus\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Enable the I2C fast mode plus driving capability.\r\n  * @param ConfigFastModePlus Selects the pin.\r\n  *   This parameter can be one of the @ref I2CEx_FastModePlus values\r\n  * @note  For I2C1, fast mode plus driving capability can be enabled on all selected\r\n  *        I2C1 pins using I2C_FASTMODEPLUS_I2C1 parameter or independently\r\n  *        on each one of the following pins PB6, PB7, PB8 and PB9.\r\n  * @note  For remaining I2C1 pins (PA14, PA15...) fast mode plus driving capability\r\n  *        can be enabled only by using I2C_FASTMODEPLUS_I2C1 parameter.\r\n  * @note  For all I2C2 pins fast mode plus driving capability can be enabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C2 parameter.\r\n  * @note  For all I2C3 pins fast mode plus driving capability can be enabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C3 parameter.\r\n  * @note  For all I2C4 pins fast mode plus driving capability can be enabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.\r\n  * @retval None\r\n  */\r\nvoid HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));\r\n\r\n  /* Enable SYSCFG clock */\r\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n  /* Enable fast mode plus driving capability for selected pin */\r\n  SET_BIT(SYSCFG->PMC, (uint32_t)ConfigFastModePlus);\r\n}\r\n\r\n/**\r\n  * @brief Disable the I2C fast mode plus driving capability.\r\n  * @param ConfigFastModePlus Selects the pin.\r\n  *   This parameter can be one of the @ref I2CEx_FastModePlus values\r\n  * @note  For I2C1, fast mode plus driving capability can be disabled on all selected\r\n  *        I2C1 pins using I2C_FASTMODEPLUS_I2C1 parameter or independently\r\n  *        on each one of the following pins PB6, PB7, PB8 and PB9.\r\n  * @note  For remaining I2C1 pins (PA14, PA15...) fast mode plus driving capability\r\n  *        can be disabled only by using I2C_FASTMODEPLUS_I2C1 parameter.\r\n  * @note  For all I2C2 pins fast mode plus driving capability can be disabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C2 parameter.\r\n  * @note  For all I2C3 pins fast mode plus driving capability can be disabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C3 parameter.\r\n  * @note  For all I2C4 pins fast mode plus driving capability can be disabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.\r\n  * @retval None\r\n  */\r\nvoid HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));\r\n\r\n  /* Enable SYSCFG clock */\r\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n  /* Disable fast mode plus driving capability for selected pin */\r\n  CLEAR_BIT(SYSCFG->PMC, (uint32_t)ConfigFastModePlus);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n#endif /* Fast Mode Plus Availability */\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_I2C_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32f7xx_hal_msp.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Core\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file         stm32f7xx_hal_msp.c\r\n  * @brief        This file provides code for the MSP Initialization\r\n  *               and de-Initialization codes.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2025 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n/* USER CODE BEGIN Includes */\r\n\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN TD */\r\n\r\n/* USER CODE END TD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN Define */\r\n\r\n/* USER CODE END Define */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN Macro */\r\n\r\n/* USER CODE END Macro */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* External functions --------------------------------------------------------*/\r\n/* USER CODE BEGIN ExternalFunctions */\r\n\r\n/* USER CODE END ExternalFunctions */\r\n\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n/**\r\n  * Initializes the Global MSP.\r\n  */\r\nvoid HAL_MspInit(void)\r\n{\r\n  /* USER CODE BEGIN MspInit 0 */\r\n\r\n  /* USER CODE END MspInit 0 */\r\n\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n  /* System interrupt init*/\r\n\r\n  /* USER CODE BEGIN MspInit 1 */\r\n\r\n  /* USER CODE END MspInit 1 */\r\n}\r\n\r\n/**\r\n* @brief PCD MSP Initialization\r\n* This function configures the hardware resources used in this example\r\n* @param hpcd: PCD handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)\r\n{\r\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n  if(hpcd->Instance==USB_OTG_FS)\r\n  {\r\n  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */\r\n\r\n  /* USER CODE END USB_OTG_FS_MspInit 0 */\r\n    LL_RCC_SetUSBClockSource(LL_RCC_USB_CLKSOURCE_PLL);\r\n\r\n    __HAL_RCC_GPIOA_CLK_ENABLE();\r\n    /**USB_OTG_FS GPIO Configuration\r\n    PA8     ------> USB_OTG_FS_SOF\r\n    PA9     ------> USB_OTG_FS_VBUS\r\n    PA10     ------> USB_OTG_FS_ID\r\n    PA11     ------> USB_OTG_FS_DM\r\n    PA12     ------> USB_OTG_FS_DP\r\n    */\r\n    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\r\n    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;\r\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\r\n\r\n    GPIO_InitStruct.Pin = GPIO_PIN_9;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\r\n\r\n    /* Peripheral clock enable */\r\n    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();\r\n  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */\r\n\r\n  /* USER CODE END USB_OTG_FS_MspInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @brief PCD MSP De-Initialization\r\n* This function freeze the hardware resources used in this example\r\n* @param hpcd: PCD handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_PCD_MspDeInit(PCD_HandleTypeDef* hpcd)\r\n{\r\n  if(hpcd->Instance==USB_OTG_FS)\r\n  {\r\n  /* USER CODE BEGIN USB_OTG_FS_MspDeInit 0 */\r\n\r\n  /* USER CODE END USB_OTG_FS_MspDeInit 0 */\r\n    /* Peripheral clock disable */\r\n    __HAL_RCC_USB_OTG_FS_CLK_DISABLE();\r\n\r\n    /**USB_OTG_FS GPIO Configuration\r\n    PA8     ------> USB_OTG_FS_SOF\r\n    PA9     ------> USB_OTG_FS_VBUS\r\n    PA10     ------> USB_OTG_FS_ID\r\n    PA11     ------> USB_OTG_FS_DM\r\n    PA12     ------> USB_OTG_FS_DP\r\n    */\r\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11\r\n                          |GPIO_PIN_12);\r\n\r\n  /* USER CODE BEGIN USB_OTG_FS_MspDeInit 1 */\r\n\r\n  /* USER CODE END USB_OTG_FS_MspDeInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/* USER CODE BEGIN 1 */\r\n\r\n/* USER CODE END 1 */\r\n\r\n"},{"name":"stm32f7xx_hal_pcd.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_pcd.c\r\n  * @author  MCD Application Team\r\n  * @brief   PCD HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the USB Peripheral Controller:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *           + Peripheral Control functions\r\n  *           + Peripheral State functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n      The PCD HAL driver can be used as follows:\r\n\r\n     (#) Declare a PCD_HandleTypeDef handle structure, for example:\r\n         PCD_HandleTypeDef  hpcd;\r\n\r\n     (#) Fill parameters of Init structure in HCD handle\r\n\r\n     (#) Call HAL_PCD_Init() API to initialize the PCD peripheral (Core, Device core, ...)\r\n\r\n     (#) Initialize the PCD low level resources through the HAL_PCD_MspInit() API:\r\n         (##) Enable the PCD/USB Low Level interface clock using\r\n              (+++) __HAL_RCC_USB_OTG_FS_CLK_ENABLE();\r\n              (+++) __HAL_RCC_USB_OTG_HS_CLK_ENABLE(); (For High Speed Mode)\r\n\r\n         (##) Initialize the related GPIO clocks\r\n         (##) Configure PCD pin-out\r\n         (##) Configure PCD NVIC interrupt\r\n\r\n     (#)Associate the Upper USB device stack to the HAL PCD Driver:\r\n         (##) hpcd.pData = pdev;\r\n\r\n     (#)Enable PCD transmission and reception:\r\n         (##) HAL_PCD_Start();\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PCD PCD\r\n  * @brief PCD HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_PCD_MODULE_ENABLED\r\n\r\n#if defined (USB_OTG_FS) || defined (USB_OTG_HS)\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @defgroup PCD_Private_Macros PCD Private Macros\r\n  * @{\r\n  */\r\n#define PCD_MIN(a, b)  (((a) < (b)) ? (a) : (b))\r\n#define PCD_MAX(a, b)  (((a) > (b)) ? (a) : (b))\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private functions prototypes ----------------------------------------------*/\r\n/** @defgroup PCD_Private_Functions PCD Private Functions\r\n  * @{\r\n  */\r\n#if defined (USB_OTG_FS) || defined (USB_OTG_HS)\r\nstatic HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum);\r\nstatic HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum);\r\nstatic HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum);\r\n#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup PCD_Exported_Functions PCD Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions\r\n  *  @brief    Initialization and Configuration functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n            ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the PCD according to the specified\r\n  *         parameters in the PCD_InitTypeDef and initialize the associated handle.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx;\r\n  uint8_t i;\r\n\r\n  /* Check the PCD handle allocation */\r\n  if (hpcd == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));\r\n\r\n  USBx = hpcd->Instance;\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    hpcd->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n    hpcd->SOFCallback = HAL_PCD_SOFCallback;\r\n    hpcd->SetupStageCallback = HAL_PCD_SetupStageCallback;\r\n    hpcd->ResetCallback = HAL_PCD_ResetCallback;\r\n    hpcd->SuspendCallback = HAL_PCD_SuspendCallback;\r\n    hpcd->ResumeCallback = HAL_PCD_ResumeCallback;\r\n    hpcd->ConnectCallback = HAL_PCD_ConnectCallback;\r\n    hpcd->DisconnectCallback = HAL_PCD_DisconnectCallback;\r\n    hpcd->DataOutStageCallback = HAL_PCD_DataOutStageCallback;\r\n    hpcd->DataInStageCallback = HAL_PCD_DataInStageCallback;\r\n    hpcd->ISOOUTIncompleteCallback = HAL_PCD_ISOOUTIncompleteCallback;\r\n    hpcd->ISOINIncompleteCallback = HAL_PCD_ISOINIncompleteCallback;\r\n\r\n    if (hpcd->MspInitCallback == NULL)\r\n    {\r\n      hpcd->MspInitCallback = HAL_PCD_MspInit;\r\n    }\r\n\r\n    /* Init the low level hardware */\r\n    hpcd->MspInitCallback(hpcd);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC... */\r\n    HAL_PCD_MspInit(hpcd);\r\n#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */\r\n  }\r\n\r\n  hpcd->State = HAL_PCD_STATE_BUSY;\r\n\r\n  /* Disable DMA mode for FS instance */\r\n  if ((USBx->CID & (0x1U << 8)) == 0U)\r\n  {\r\n    hpcd->Init.dma_enable = 0U;\r\n  }\r\n\r\n  /* Disable the Interrupts */\r\n  __HAL_PCD_DISABLE(hpcd);\r\n\r\n  /*Init the Core (common init.) */\r\n  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)\r\n  {\r\n    hpcd->State = HAL_PCD_STATE_ERROR;\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Force Device Mode*/\r\n  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);\r\n\r\n  /* Init endpoints structures */\r\n  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)\r\n  {\r\n    /* Init ep structure */\r\n    hpcd->IN_ep[i].is_in = 1U;\r\n    hpcd->IN_ep[i].num = i;\r\n    hpcd->IN_ep[i].tx_fifo_num = i;\r\n    /* Control until ep is activated */\r\n    hpcd->IN_ep[i].type = EP_TYPE_CTRL;\r\n    hpcd->IN_ep[i].maxpacket = 0U;\r\n    hpcd->IN_ep[i].xfer_buff = 0U;\r\n    hpcd->IN_ep[i].xfer_len = 0U;\r\n  }\r\n\r\n  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)\r\n  {\r\n    hpcd->OUT_ep[i].is_in = 0U;\r\n    hpcd->OUT_ep[i].num = i;\r\n    /* Control until ep is activated */\r\n    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;\r\n    hpcd->OUT_ep[i].maxpacket = 0U;\r\n    hpcd->OUT_ep[i].xfer_buff = 0U;\r\n    hpcd->OUT_ep[i].xfer_len = 0U;\r\n  }\r\n\r\n  /* Init Device */\r\n  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)\r\n  {\r\n    hpcd->State = HAL_PCD_STATE_ERROR;\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  hpcd->USB_Address = 0U;\r\n  hpcd->State = HAL_PCD_STATE_READY;\r\n\r\n  /* Activate LPM */\r\n  if (hpcd->Init.lpm_enable == 1U)\r\n  {\r\n    (void)HAL_PCDEx_ActivateLPM(hpcd);\r\n  }\r\n\r\n  (void)USB_DevDisconnect(hpcd->Instance);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the PCD peripheral.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Check the PCD handle allocation */\r\n  if (hpcd == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  hpcd->State = HAL_PCD_STATE_BUSY;\r\n\r\n  /* Stop Device */\r\n  if (USB_StopDevice(hpcd->Instance) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n  if (hpcd->MspDeInitCallback == NULL)\r\n  {\r\n    hpcd->MspDeInitCallback = HAL_PCD_MspDeInit; /* Legacy weak MspDeInit  */\r\n  }\r\n\r\n  /* DeInit the low level hardware */\r\n  hpcd->MspDeInitCallback(hpcd);\r\n#else\r\n  /* DeInit the low level hardware: CLOCK, NVIC.*/\r\n  HAL_PCD_MspDeInit(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n\r\n  hpcd->State = HAL_PCD_STATE_RESET;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the PCD MSP.\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes PCD MSP.\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n/**\r\n  * @brief  Register a User USB PCD Callback\r\n  *         To be used instead of the weak predefined callback\r\n  * @param  hpcd USB PCD handle\r\n  * @param  CallbackID ID of the callback to be registered\r\n  *         This parameter can be one of the following values:\r\n  *          @arg @ref HAL_PCD_SOF_CB_ID USB PCD SOF callback ID\r\n  *          @arg @ref HAL_PCD_SETUPSTAGE_CB_ID USB PCD Setup callback ID\r\n  *          @arg @ref HAL_PCD_RESET_CB_ID USB PCD Reset callback ID\r\n  *          @arg @ref HAL_PCD_SUSPEND_CB_ID USB PCD Suspend callback ID\r\n  *          @arg @ref HAL_PCD_RESUME_CB_ID USB PCD Resume callback ID\r\n  *          @arg @ref HAL_PCD_CONNECT_CB_ID USB PCD Connect callback ID\r\n  *          @arg @ref HAL_PCD_DISCONNECT_CB_ID OTG PCD Disconnect callback ID\r\n  *          @arg @ref HAL_PCD_MSPINIT_CB_ID MspDeInit callback ID\r\n  *          @arg @ref HAL_PCD_MSPDEINIT_CB_ID MspDeInit callback ID\r\n  * @param  pCallback pointer to the Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_RegisterCallback(PCD_HandleTypeDef *hpcd,\r\n                                           HAL_PCD_CallbackIDTypeDef CallbackID,\r\n                                           pPCD_CallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n    return HAL_ERROR;\r\n  }\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_PCD_SOF_CB_ID :\r\n        hpcd->SOFCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_SETUPSTAGE_CB_ID :\r\n        hpcd->SetupStageCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_RESET_CB_ID :\r\n        hpcd->ResetCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_SUSPEND_CB_ID :\r\n        hpcd->SuspendCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_RESUME_CB_ID :\r\n        hpcd->ResumeCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_CONNECT_CB_ID :\r\n        hpcd->ConnectCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_DISCONNECT_CB_ID :\r\n        hpcd->DisconnectCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_MSPINIT_CB_ID :\r\n        hpcd->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_MSPDEINIT_CB_ID :\r\n        hpcd->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (hpcd->State == HAL_PCD_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_PCD_MSPINIT_CB_ID :\r\n        hpcd->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_PCD_MSPDEINIT_CB_ID :\r\n        hpcd->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister an USB PCD Callback\r\n  *         USB PCD callabck is redirected to the weak predefined callback\r\n  * @param  hpcd USB PCD handle\r\n  * @param  CallbackID ID of the callback to be unregistered\r\n  *         This parameter can be one of the following values:\r\n  *          @arg @ref HAL_PCD_SOF_CB_ID USB PCD SOF callback ID\r\n  *          @arg @ref HAL_PCD_SETUPSTAGE_CB_ID USB PCD Setup callback ID\r\n  *          @arg @ref HAL_PCD_RESET_CB_ID USB PCD Reset callback ID\r\n  *          @arg @ref HAL_PCD_SUSPEND_CB_ID USB PCD Suspend callback ID\r\n  *          @arg @ref HAL_PCD_RESUME_CB_ID USB PCD Resume callback ID\r\n  *          @arg @ref HAL_PCD_CONNECT_CB_ID USB PCD Connect callback ID\r\n  *          @arg @ref HAL_PCD_DISCONNECT_CB_ID OTG PCD Disconnect callback ID\r\n  *          @arg @ref HAL_PCD_MSPINIT_CB_ID MspDeInit callback ID\r\n  *          @arg @ref HAL_PCD_MSPDEINIT_CB_ID MspDeInit callback ID\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_UnRegisterCallback(PCD_HandleTypeDef *hpcd, HAL_PCD_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  /* Setup Legacy weak Callbacks  */\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_PCD_SOF_CB_ID :\r\n        hpcd->SOFCallback = HAL_PCD_SOFCallback;\r\n        break;\r\n\r\n      case HAL_PCD_SETUPSTAGE_CB_ID :\r\n        hpcd->SetupStageCallback = HAL_PCD_SetupStageCallback;\r\n        break;\r\n\r\n      case HAL_PCD_RESET_CB_ID :\r\n        hpcd->ResetCallback = HAL_PCD_ResetCallback;\r\n        break;\r\n\r\n      case HAL_PCD_SUSPEND_CB_ID :\r\n        hpcd->SuspendCallback = HAL_PCD_SuspendCallback;\r\n        break;\r\n\r\n      case HAL_PCD_RESUME_CB_ID :\r\n        hpcd->ResumeCallback = HAL_PCD_ResumeCallback;\r\n        break;\r\n\r\n      case HAL_PCD_CONNECT_CB_ID :\r\n        hpcd->ConnectCallback = HAL_PCD_ConnectCallback;\r\n        break;\r\n\r\n      case HAL_PCD_DISCONNECT_CB_ID :\r\n        hpcd->DisconnectCallback = HAL_PCD_DisconnectCallback;\r\n        break;\r\n\r\n      case HAL_PCD_MSPINIT_CB_ID :\r\n        hpcd->MspInitCallback = HAL_PCD_MspInit;\r\n        break;\r\n\r\n      case HAL_PCD_MSPDEINIT_CB_ID :\r\n        hpcd->MspDeInitCallback = HAL_PCD_MspDeInit;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (hpcd->State == HAL_PCD_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_PCD_MSPINIT_CB_ID :\r\n        hpcd->MspInitCallback = HAL_PCD_MspInit;\r\n        break;\r\n\r\n      case HAL_PCD_MSPDEINIT_CB_ID :\r\n        hpcd->MspDeInitCallback = HAL_PCD_MspDeInit;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register USB PCD Data OUT Stage Callback\r\n  *         To be used instead of the weak HAL_PCD_DataOutStageCallback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @param  pCallback pointer to the USB PCD Data OUT Stage Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_RegisterDataOutStageCallback(PCD_HandleTypeDef *hpcd,\r\n                                                       pPCD_DataOutStageCallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->DataOutStageCallback = pCallback;\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister the USB PCD Data OUT Stage Callback\r\n  *         USB PCD Data OUT Stage Callback is redirected to the weak HAL_PCD_DataOutStageCallback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_UnRegisterDataOutStageCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->DataOutStageCallback = HAL_PCD_DataOutStageCallback; /* Legacy weak DataOutStageCallback  */\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register USB PCD Data IN Stage Callback\r\n  *         To be used instead of the weak HAL_PCD_DataInStageCallback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @param  pCallback pointer to the USB PCD Data IN Stage Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_RegisterDataInStageCallback(PCD_HandleTypeDef *hpcd,\r\n                                                      pPCD_DataInStageCallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->DataInStageCallback = pCallback;\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister the USB PCD Data IN Stage Callback\r\n  *         USB PCD Data OUT Stage Callback is redirected to the weak HAL_PCD_DataInStageCallback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_UnRegisterDataInStageCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->DataInStageCallback = HAL_PCD_DataInStageCallback; /* Legacy weak DataInStageCallback  */\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register USB PCD Iso OUT incomplete Callback\r\n  *         To be used instead of the weak HAL_PCD_ISOOUTIncompleteCallback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @param  pCallback pointer to the USB PCD Iso OUT incomplete Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_RegisterIsoOutIncpltCallback(PCD_HandleTypeDef *hpcd,\r\n                                                       pPCD_IsoOutIncpltCallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->ISOOUTIncompleteCallback = pCallback;\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister the USB PCD Iso OUT incomplete Callback\r\n  *         USB PCD Iso OUT incomplete Callback is redirected\r\n  *         to the weak HAL_PCD_ISOOUTIncompleteCallback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_UnRegisterIsoOutIncpltCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->ISOOUTIncompleteCallback = HAL_PCD_ISOOUTIncompleteCallback; /* Legacy weak ISOOUTIncompleteCallback  */\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register USB PCD Iso IN incomplete Callback\r\n  *         To be used instead of the weak HAL_PCD_ISOINIncompleteCallback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @param  pCallback pointer to the USB PCD Iso IN incomplete Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_RegisterIsoInIncpltCallback(PCD_HandleTypeDef *hpcd,\r\n                                                      pPCD_IsoInIncpltCallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->ISOINIncompleteCallback = pCallback;\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister the USB PCD Iso IN incomplete Callback\r\n  *         USB PCD Iso IN incomplete Callback is redirected\r\n  *         to the weak HAL_PCD_ISOINIncompleteCallback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_UnRegisterIsoInIncpltCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->ISOINIncompleteCallback = HAL_PCD_ISOINIncompleteCallback; /* Legacy weak ISOINIncompleteCallback  */\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register USB PCD LPM Callback\r\n  *         To be used instead of the weak HAL_PCDEx_LPM_Callback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @param  pCallback pointer to the USB PCD LPM Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_RegisterLpmCallback(PCD_HandleTypeDef *hpcd, pPCD_LpmCallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->LPMCallback = pCallback;\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister the USB PCD LPM Callback\r\n  *         USB LPM Callback is redirected to the weak HAL_PCDEx_LPM_Callback() predefined callback\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_UnRegisterLpmCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if (hpcd->State == HAL_PCD_STATE_READY)\r\n  {\r\n    hpcd->LPMCallback = HAL_PCDEx_LPM_Callback; /* Legacy weak HAL_PCDEx_LPM_Callback  */\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return status;\r\n}\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PCD_Exported_Functions_Group2 Input and Output operation functions\r\n  *  @brief   Data transfers functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### IO operation functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the PCD data\r\n    transfers.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Start the USB device\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)\r\n{\r\n  __HAL_LOCK(hpcd);\r\n  __HAL_PCD_ENABLE(hpcd);\r\n  (void)USB_DevConnect(hpcd->Instance);\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stop the USB device.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)\r\n{\r\n  __HAL_LOCK(hpcd);\r\n  __HAL_PCD_DISABLE(hpcd);\r\n  (void)USB_DevDisconnect(hpcd->Instance);\r\n\r\n  (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);\r\n\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n#if defined (USB_OTG_FS) || defined (USB_OTG_HS)\r\n/**\r\n  * @brief  Handles PCD interrupt request.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nvoid HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  USB_OTG_EPTypeDef *ep;\r\n  uint32_t i;\r\n  uint32_t ep_intr;\r\n  uint32_t epint;\r\n  uint32_t epnum;\r\n  uint32_t fifoemptymsk;\r\n  uint32_t temp;\r\n\r\n  /* ensure that we are in device mode */\r\n  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)\r\n  {\r\n    /* avoid spurious interrupt */\r\n    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))\r\n    {\r\n      return;\r\n    }\r\n\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))\r\n    {\r\n      /* incorrect mode, acknowledge the interrupt */\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);\r\n    }\r\n\r\n    /* Handle RxQLevel Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))\r\n    {\r\n      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);\r\n\r\n      temp = USBx->GRXSTSP;\r\n\r\n      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];\r\n\r\n      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)\r\n      {\r\n        if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)\r\n        {\r\n          (void)USB_ReadPacket(USBx, ep->xfer_buff,\r\n                               (uint16_t)((temp & USB_OTG_GRXSTSP_BCNT) >> 4));\r\n\r\n          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;\r\n          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;\r\n        }\r\n      }\r\n      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)\r\n      {\r\n        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);\r\n        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;\r\n      }\r\n      else\r\n      {\r\n        /* ... */\r\n      }\r\n\r\n      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);\r\n    }\r\n\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))\r\n    {\r\n      epnum = 0U;\r\n\r\n      /* Read in the device interrupt bits */\r\n      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);\r\n\r\n      while (ep_intr != 0U)\r\n      {\r\n        if ((ep_intr & 0x1U) != 0U)\r\n        {\r\n          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);\r\n\r\n          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)\r\n          {\r\n            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);\r\n            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);\r\n          }\r\n\r\n          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)\r\n          {\r\n            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);\r\n            /* Class B setup phase done for previous decoded setup */\r\n            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);\r\n          }\r\n\r\n          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)\r\n          {\r\n            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);\r\n          }\r\n\r\n          /* Clear Status Phase Received interrupt */\r\n          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)\r\n          {\r\n            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);\r\n          }\r\n\r\n          /* Clear OUT NAK interrupt */\r\n          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)\r\n          {\r\n            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);\r\n          }\r\n        }\r\n        epnum++;\r\n        ep_intr >>= 1U;\r\n      }\r\n    }\r\n\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))\r\n    {\r\n      /* Read in the device interrupt bits */\r\n      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);\r\n\r\n      epnum = 0U;\r\n\r\n      while (ep_intr != 0U)\r\n      {\r\n        if ((ep_intr & 0x1U) != 0U) /* In ITR */\r\n        {\r\n          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);\r\n\r\n          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)\r\n          {\r\n            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));\r\n            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;\r\n\r\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);\r\n\r\n            if (hpcd->Init.dma_enable == 1U)\r\n            {\r\n              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;\r\n\r\n              /* this is ZLP, so prepare EP0 for next setup */\r\n              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))\r\n              {\r\n                /* prepare to rx more setup packets */\r\n                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);\r\n              }\r\n            }\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);\r\n#else\r\n            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n          }\r\n          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)\r\n          {\r\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);\r\n          }\r\n          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)\r\n          {\r\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);\r\n          }\r\n          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)\r\n          {\r\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);\r\n          }\r\n          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)\r\n          {\r\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);\r\n          }\r\n          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)\r\n          {\r\n            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);\r\n          }\r\n        }\r\n        epnum++;\r\n        ep_intr >>= 1U;\r\n      }\r\n    }\r\n\r\n    /* Handle Resume Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))\r\n    {\r\n      /* Clear the Remote Wake-up Signaling */\r\n      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;\r\n\r\n      if (hpcd->LPM_State == LPM_L1)\r\n      {\r\n        hpcd->LPM_State = LPM_L0;\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);\r\n#else\r\n        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n      }\r\n      else\r\n      {\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n        hpcd->ResumeCallback(hpcd);\r\n#else\r\n        HAL_PCD_ResumeCallback(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n      }\r\n\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);\r\n    }\r\n\r\n    /* Handle Suspend Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))\r\n    {\r\n      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)\r\n      {\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n        hpcd->SuspendCallback(hpcd);\r\n#else\r\n        HAL_PCD_SuspendCallback(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n      }\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);\r\n    }\r\n\r\n    /* Handle LPM Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))\r\n    {\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);\r\n\r\n      if (hpcd->LPM_State == LPM_L0)\r\n      {\r\n        hpcd->LPM_State = LPM_L1;\r\n        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n        hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);\r\n#else\r\n        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n      }\r\n      else\r\n      {\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n        hpcd->SuspendCallback(hpcd);\r\n#else\r\n        HAL_PCD_SuspendCallback(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n      }\r\n    }\r\n\r\n    /* Handle Reset Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))\r\n    {\r\n      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;\r\n      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);\r\n\r\n      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)\r\n      {\r\n        USBx_INEP(i)->DIEPINT = 0xFB7FU;\r\n        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;\r\n        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;\r\n        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;\r\n        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;\r\n      }\r\n      USBx_DEVICE->DAINTMSK |= 0x10001U;\r\n\r\n      if (hpcd->Init.use_dedicated_ep1 != 0U)\r\n      {\r\n        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |\r\n                                   USB_OTG_DOEPMSK_XFRCM |\r\n                                   USB_OTG_DOEPMSK_EPDM;\r\n\r\n        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |\r\n                                  USB_OTG_DIEPMSK_XFRCM |\r\n                                  USB_OTG_DIEPMSK_EPDM;\r\n      }\r\n      else\r\n      {\r\n        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |\r\n                                USB_OTG_DOEPMSK_XFRCM |\r\n                                USB_OTG_DOEPMSK_EPDM |\r\n                                USB_OTG_DOEPMSK_OTEPSPRM |\r\n                                USB_OTG_DOEPMSK_NAKM;\r\n\r\n        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |\r\n                                USB_OTG_DIEPMSK_XFRCM |\r\n                                USB_OTG_DIEPMSK_EPDM;\r\n      }\r\n\r\n      /* Set Default Address to 0 */\r\n      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;\r\n\r\n      /* setup EP0 to receive SETUP packets */\r\n      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,\r\n                             (uint8_t *)hpcd->Setup);\r\n\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);\r\n    }\r\n\r\n    /* Handle Enumeration done Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))\r\n    {\r\n      (void)USB_ActivateSetup(hpcd->Instance);\r\n      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);\r\n\r\n      /* Set USB Turnaround time */\r\n      (void)USB_SetTurnaroundTime(hpcd->Instance,\r\n                                  HAL_RCC_GetHCLKFreq(),\r\n                                  (uint8_t)hpcd->Init.speed);\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n      hpcd->ResetCallback(hpcd);\r\n#else\r\n      HAL_PCD_ResetCallback(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);\r\n    }\r\n\r\n    /* Handle SOF Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))\r\n    {\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n      hpcd->SOFCallback(hpcd);\r\n#else\r\n      HAL_PCD_SOFCallback(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);\r\n    }\r\n\r\n    /* Handle Incomplete ISO IN Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))\r\n    {\r\n      /* Keep application checking the corresponding Iso IN endpoint\r\n      causing the incomplete Interrupt */\r\n      epnum = 0U;\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n      hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);\r\n#else\r\n      HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);\r\n    }\r\n\r\n    /* Handle Incomplete ISO OUT Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))\r\n    {\r\n      /* Keep application checking the corresponding Iso OUT endpoint\r\n      causing the incomplete Interrupt */\r\n      epnum = 0U;\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n      hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);\r\n#else\r\n      HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);\r\n    }\r\n\r\n    /* Handle Connection event Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))\r\n    {\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n      hpcd->ConnectCallback(hpcd);\r\n#else\r\n      HAL_PCD_ConnectCallback(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n\r\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);\r\n    }\r\n\r\n    /* Handle Disconnection event Interrupt */\r\n    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))\r\n    {\r\n      temp = hpcd->Instance->GOTGINT;\r\n\r\n      if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)\r\n      {\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n        hpcd->DisconnectCallback(hpcd);\r\n#else\r\n        HAL_PCD_DisconnectCallback(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n      }\r\n      hpcd->Instance->GOTGINT |= temp;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Handles PCD Wakeup interrupt request.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nvoid HAL_PCD_WKUP_IRQHandler(PCD_HandleTypeDef *hpcd)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx;\r\n\r\n  USBx = hpcd->Instance;\r\n\r\n  if ((USBx->CID & (0x1U << 8)) == 0U)\r\n  {\r\n    /* Clear EXTI pending Bit */\r\n    __HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG();\r\n  }\r\n  else\r\n  {\r\n    /* Clear EXTI pending Bit */\r\n    __HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG();\r\n  }\r\n}\r\n#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */\r\n\r\n\r\n/**\r\n  * @brief  Data OUT stage callback.\r\n  * @param  hpcd PCD handle\r\n  * @param  epnum endpoint number\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n  UNUSED(epnum);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_DataOutStageCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Data IN stage callback\r\n  * @param  hpcd PCD handle\r\n  * @param  epnum endpoint number\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n  UNUSED(epnum);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_DataInStageCallback could be implemented in the user file\r\n   */\r\n}\r\n/**\r\n  * @brief  Setup stage callback\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_SetupStageCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  USB Start Of Frame callback.\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_SOFCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  USB Reset callback.\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_ResetCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Suspend event callback.\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_SuspendCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Resume event callback.\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_ResumeCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Incomplete ISO OUT callback.\r\n  * @param  hpcd PCD handle\r\n  * @param  epnum endpoint number\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n  UNUSED(epnum);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Incomplete ISO IN callback.\r\n  * @param  hpcd PCD handle\r\n  * @param  epnum endpoint number\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n  UNUSED(epnum);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Connection event callback.\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_ConnectCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Disconnection event callback.\r\n  * @param  hpcd PCD handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCD_DisconnectCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PCD_Exported_Functions_Group3 Peripheral Control functions\r\n  *  @brief   management functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Peripheral Control functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the PCD data\r\n    transfers.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Connect the USB device\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)\r\n{\r\n  __HAL_LOCK(hpcd);\r\n  (void)USB_DevConnect(hpcd->Instance);\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Disconnect the USB device.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)\r\n{\r\n  __HAL_LOCK(hpcd);\r\n  (void)USB_DevDisconnect(hpcd->Instance);\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Set the USB Device address.\r\n  * @param  hpcd PCD handle\r\n  * @param  address new device address\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)\r\n{\r\n  __HAL_LOCK(hpcd);\r\n  hpcd->USB_Address = address;\r\n  (void)USB_SetDevAddress(hpcd->Instance, address);\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return HAL_OK;\r\n}\r\n/**\r\n  * @brief  Open and configure an endpoint.\r\n  * @param  hpcd PCD handle\r\n  * @param  ep_addr endpoint address\r\n  * @param  ep_mps endpoint max packet size\r\n  * @param  ep_type endpoint type\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,\r\n                                  uint16_t ep_mps, uint8_t ep_type)\r\n{\r\n  HAL_StatusTypeDef  ret = HAL_OK;\r\n  PCD_EPTypeDef *ep;\r\n\r\n  if ((ep_addr & 0x80U) == 0x80U)\r\n  {\r\n    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];\r\n    ep->is_in = 1U;\r\n  }\r\n  else\r\n  {\r\n    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];\r\n    ep->is_in = 0U;\r\n  }\r\n\r\n  ep->num = ep_addr & EP_ADDR_MSK;\r\n  ep->maxpacket = ep_mps;\r\n  ep->type = ep_type;\r\n\r\n  if (ep->is_in != 0U)\r\n  {\r\n    /* Assign a Tx FIFO */\r\n    ep->tx_fifo_num = ep->num;\r\n  }\r\n  /* Set initial data PID. */\r\n  if (ep_type == EP_TYPE_BULK)\r\n  {\r\n    ep->data_pid_start = 0U;\r\n  }\r\n\r\n  __HAL_LOCK(hpcd);\r\n  (void)USB_ActivateEndpoint(hpcd->Instance, ep);\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n  * @brief  Deactivate an endpoint.\r\n  * @param  hpcd PCD handle\r\n  * @param  ep_addr endpoint address\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)\r\n{\r\n  PCD_EPTypeDef *ep;\r\n\r\n  if ((ep_addr & 0x80U) == 0x80U)\r\n  {\r\n    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];\r\n    ep->is_in = 1U;\r\n  }\r\n  else\r\n  {\r\n    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];\r\n    ep->is_in = 0U;\r\n  }\r\n  ep->num   = ep_addr & EP_ADDR_MSK;\r\n\r\n  __HAL_LOCK(hpcd);\r\n  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);\r\n  __HAL_UNLOCK(hpcd);\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Receive an amount of data.\r\n  * @param  hpcd PCD handle\r\n  * @param  ep_addr endpoint address\r\n  * @param  pBuf pointer to the reception buffer\r\n  * @param  len amount of data to be received\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)\r\n{\r\n  PCD_EPTypeDef *ep;\r\n\r\n  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];\r\n\r\n  /*setup and start the Xfer */\r\n  ep->xfer_buff = pBuf;\r\n  ep->xfer_len = len;\r\n  ep->xfer_count = 0U;\r\n  ep->is_in = 0U;\r\n  ep->num = ep_addr & EP_ADDR_MSK;\r\n\r\n  if (hpcd->Init.dma_enable == 1U)\r\n  {\r\n    ep->dma_addr = (uint32_t)pBuf;\r\n  }\r\n\r\n  if ((ep_addr & EP_ADDR_MSK) == 0U)\r\n  {\r\n    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);\r\n  }\r\n  else\r\n  {\r\n    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Get Received Data Size\r\n  * @param  hpcd PCD handle\r\n  * @param  ep_addr endpoint address\r\n  * @retval Data Size\r\n  */\r\nuint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)\r\n{\r\n  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;\r\n}\r\n/**\r\n  * @brief  Send an amount of data\r\n  * @param  hpcd PCD handle\r\n  * @param  ep_addr endpoint address\r\n  * @param  pBuf pointer to the transmission buffer\r\n  * @param  len amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)\r\n{\r\n  PCD_EPTypeDef *ep;\r\n\r\n  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];\r\n\r\n  /*setup and start the Xfer */\r\n  ep->xfer_buff = pBuf;\r\n  ep->xfer_len = len;\r\n  ep->xfer_count = 0U;\r\n  ep->is_in = 1U;\r\n  ep->num = ep_addr & EP_ADDR_MSK;\r\n\r\n  if (hpcd->Init.dma_enable == 1U)\r\n  {\r\n    ep->dma_addr = (uint32_t)pBuf;\r\n  }\r\n\r\n  if ((ep_addr & EP_ADDR_MSK) == 0U)\r\n  {\r\n    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);\r\n  }\r\n  else\r\n  {\r\n    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Set a STALL condition over an endpoint\r\n  * @param  hpcd PCD handle\r\n  * @param  ep_addr endpoint address\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)\r\n{\r\n  PCD_EPTypeDef *ep;\r\n\r\n  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if ((0x80U & ep_addr) == 0x80U)\r\n  {\r\n    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];\r\n    ep->is_in = 1U;\r\n  }\r\n  else\r\n  {\r\n    ep = &hpcd->OUT_ep[ep_addr];\r\n    ep->is_in = 0U;\r\n  }\r\n\r\n  ep->is_stall = 1U;\r\n  ep->num = ep_addr & EP_ADDR_MSK;\r\n\r\n  __HAL_LOCK(hpcd);\r\n\r\n  (void)USB_EPSetStall(hpcd->Instance, ep);\r\n\r\n  if ((ep_addr & EP_ADDR_MSK) == 0U)\r\n  {\r\n    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);\r\n  }\r\n\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Clear a STALL condition over in an endpoint\r\n  * @param  hpcd PCD handle\r\n  * @param  ep_addr endpoint address\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)\r\n{\r\n  PCD_EPTypeDef *ep;\r\n\r\n  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if ((0x80U & ep_addr) == 0x80U)\r\n  {\r\n    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];\r\n    ep->is_in = 1U;\r\n  }\r\n  else\r\n  {\r\n    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];\r\n    ep->is_in = 0U;\r\n  }\r\n\r\n  ep->is_stall = 0U;\r\n  ep->num = ep_addr & EP_ADDR_MSK;\r\n\r\n  __HAL_LOCK(hpcd);\r\n  (void)USB_EPClearStall(hpcd->Instance, ep);\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Flush an endpoint\r\n  * @param  hpcd PCD handle\r\n  * @param  ep_addr endpoint address\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)\r\n{\r\n  __HAL_LOCK(hpcd);\r\n\r\n  if ((ep_addr & 0x80U) == 0x80U)\r\n  {\r\n    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);\r\n  }\r\n  else\r\n  {\r\n    (void)USB_FlushRxFifo(hpcd->Instance);\r\n  }\r\n\r\n  __HAL_UNLOCK(hpcd);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Activate remote wakeup signalling\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)\r\n{\r\n  return (USB_ActivateRemoteWakeup(hpcd->Instance));\r\n}\r\n\r\n/**\r\n  * @brief  De-activate remote wakeup signalling.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)\r\n{\r\n  return (USB_DeActivateRemoteWakeup(hpcd->Instance));\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PCD_Exported_Functions_Group4 Peripheral State functions\r\n  *  @brief   Peripheral State functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Peripheral State functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection permits to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the PCD handle state.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL state\r\n  */\r\nPCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)\r\n{\r\n  return hpcd->State;\r\n}\r\n\r\n/**\r\n  * @brief  Set the USB Device high speed test mode.\r\n  * @param  hpcd PCD handle\r\n  * @param  address test mode\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCD_SetTestMode(PCD_HandleTypeDef *hpcd, uint8_t testmode)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  switch (testmode)\r\n  {\r\n    case TEST_J:\r\n    case TEST_K:\r\n    case TEST_SE0_NAK:\r\n    case TEST_PACKET:\r\n    case TEST_FORCE_EN:\r\n      USBx_DEVICE->DCTL |= testmode << 4;\r\n      break;\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @addtogroup PCD_Private_Functions\r\n  * @{\r\n  */\r\n#if defined (USB_OTG_FS) || defined (USB_OTG_HS)\r\n/**\r\n  * @brief  Check FIFO for the next packet to be loaded.\r\n  * @param  hpcd PCD handle\r\n  * @param  epnum endpoint number\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  USB_OTG_EPTypeDef *ep;\r\n  uint32_t len;\r\n  uint32_t len32b;\r\n  uint32_t fifoemptymsk;\r\n\r\n  ep = &hpcd->IN_ep[epnum];\r\n\r\n  if (ep->xfer_count > ep->xfer_len)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  len = ep->xfer_len - ep->xfer_count;\r\n\r\n  if (len > ep->maxpacket)\r\n  {\r\n    len = ep->maxpacket;\r\n  }\r\n\r\n  len32b = (len + 3U) / 4U;\r\n\r\n  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&\r\n         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))\r\n  {\r\n    /* Write the FIFO */\r\n    len = ep->xfer_len - ep->xfer_count;\r\n\r\n    if (len > ep->maxpacket)\r\n    {\r\n      len = ep->maxpacket;\r\n    }\r\n    len32b = (len + 3U) / 4U;\r\n\r\n    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,\r\n                          (uint8_t)hpcd->Init.dma_enable);\r\n\r\n    ep->xfer_buff  += len;\r\n    ep->xfer_count += len;\r\n  }\r\n\r\n  if (ep->xfer_len <= ep->xfer_count)\r\n  {\r\n    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));\r\n    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  process EP OUT transfer complete interrupt.\r\n  * @param  hpcd PCD handle\r\n  * @param  epnum endpoint number\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);\r\n  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;\r\n\r\n  if (hpcd->Init.dma_enable == 1U)\r\n  {\r\n    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */\r\n    {\r\n      /* StupPktRcvd = 1 this is a setup packet */\r\n      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&\r\n          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))\r\n      {\r\n        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);\r\n      }\r\n    }\r\n    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */\r\n    {\r\n      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);\r\n    }\r\n    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)\r\n    {\r\n      /* StupPktRcvd = 1 this is a setup packet */\r\n      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&\r\n          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))\r\n      {\r\n        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);\r\n      }\r\n      else\r\n      {\r\n        /* out data packet received over EP0 */\r\n        hpcd->OUT_ep[epnum].xfer_count =\r\n          hpcd->OUT_ep[epnum].maxpacket -\r\n          (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);\r\n\r\n        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;\r\n\r\n        if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))\r\n        {\r\n          /* this is ZLP, so prepare EP0 for next setup */\r\n          (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);\r\n        }\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);\r\n#else\r\n        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* ... */\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (gSNPSiD == USB_OTG_CORE_ID_310A)\r\n    {\r\n      /* StupPktRcvd = 1 this is a setup packet */\r\n      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)\r\n      {\r\n        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);\r\n      }\r\n      else\r\n      {\r\n        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)\r\n        {\r\n          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);\r\n        }\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);\r\n#else\r\n        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n      }\r\n    }\r\n    else\r\n    {\r\n      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))\r\n      {\r\n        /* this is ZLP, so prepare EP0 for next setup */\r\n        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);\r\n      }\r\n\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);\r\n#else\r\n      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  process EP OUT setup packet received interrupt.\r\n  * @param  hpcd PCD handle\r\n  * @param  epnum endpoint number\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);\r\n  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;\r\n\r\n  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&\r\n      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))\r\n  {\r\n    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);\r\n  }\r\n\r\n  /* Inform the upper layer that a setup packet is available */\r\n#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)\r\n  hpcd->SetupStageCallback(hpcd);\r\n#else\r\n  HAL_PCD_SetupStageCallback(hpcd);\r\n#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */\r\n\r\n  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))\r\n  {\r\n    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */\r\n#endif /* HAL_PCD_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32f7xx_hal_pcd_ex.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_pcd_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   PCD Extended HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the USB Peripheral Controller:\r\n  *           + Extended features functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PCDEx PCDEx\r\n  * @brief PCD Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_PCD_MODULE_ENABLED\r\n\r\n#if defined (USB_OTG_FS) || defined (USB_OTG_HS)\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup PCDEx_Exported_Functions PCDEx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PCDEx_Exported_Functions_Group1 Peripheral Control functions\r\n  * @brief    PCDEx control functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                 ##### Extended features functions #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Update FIFO configuration\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n#if defined (USB_OTG_FS) || defined (USB_OTG_HS)\r\n/**\r\n  * @brief  Set Tx FIFO\r\n  * @param  hpcd PCD handle\r\n  * @param  fifo The number of Tx fifo\r\n  * @param  size Fifo size\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)\r\n{\r\n  uint8_t i;\r\n  uint32_t Tx_Offset;\r\n\r\n  /*  TXn min size = 16 words. (n  : Transmit FIFO index)\r\n      When a TxFIFO is not used, the Configuration should be as follows:\r\n          case 1 :  n > m    and Txn is not used    (n,m  : Transmit FIFO indexes)\r\n         --> Txm can use the space allocated for Txn.\r\n         case2  :  n < m    and Txn is not used    (n,m  : Transmit FIFO indexes)\r\n         --> Txn should be configured with the minimum space of 16 words\r\n     The FIFO is used optimally when used TxFIFOs are allocated in the top\r\n         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.\r\n     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */\r\n\r\n  Tx_Offset = hpcd->Instance->GRXFSIZ;\r\n\r\n  if (fifo == 0U)\r\n  {\r\n    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;\r\n  }\r\n  else\r\n  {\r\n    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;\r\n    for (i = 0U; i < (fifo - 1U); i++)\r\n    {\r\n      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);\r\n    }\r\n\r\n    /* Multiply Tx_Size by 2 to get higher performance */\r\n    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Set Rx FIFO\r\n  * @param  hpcd PCD handle\r\n  * @param  size Size of Rx fifo\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)\r\n{\r\n  hpcd->Instance->GRXFSIZ = size;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Activate LPM feature.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;\r\n\r\n  hpcd->lpm_active = 1U;\r\n  hpcd->LPM_State = LPM_L0;\r\n  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;\r\n  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Deactivate LPM feature.\r\n  * @param  hpcd PCD handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PCDEx_DeActivateLPM(PCD_HandleTypeDef *hpcd)\r\n{\r\n  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;\r\n\r\n  hpcd->lpm_active = 0U;\r\n  USBx->GINTMSK &= ~USB_OTG_GINTMSK_LPMINTM;\r\n  USBx->GLPMCFG &= ~(USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */\r\n\r\n/**\r\n  * @brief  Send LPM message to user layer callback.\r\n  * @param  hpcd PCD handle\r\n  * @param  msg LPM message\r\n  * @retval HAL status\r\n  */\r\n__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n  UNUSED(msg);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCDEx_LPM_Callback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Send BatteryCharging message to user layer callback.\r\n  * @param  hpcd PCD handle\r\n  * @param  msg LPM message\r\n  * @retval HAL status\r\n  */\r\n__weak void HAL_PCDEx_BCD_Callback(PCD_HandleTypeDef *hpcd, PCD_BCD_MsgTypeDef msg)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hpcd);\r\n  UNUSED(msg);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PCDEx_BCD_Callback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */\r\n#endif /* HAL_PCD_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32f7xx_hal_pwr.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_pwr.c\r\n  * @author  MCD Application Team\r\n  * @brief   PWR HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the Power Controller (PWR) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions \r\n  *         \r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWR PWR\r\n  * @brief PWR HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_PWR_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup PWR_Private_Constants\r\n  * @{\r\n  */\r\n\t\r\n/** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask\r\n  * @{\r\n  */     \r\n#define PVD_MODE_IT               ((uint32_t)0x00010000U)\r\n#define PVD_MODE_EVT              ((uint32_t)0x00020000U)\r\n#define PVD_RISING_EDGE           ((uint32_t)0x00000001U)\r\n#define PVD_FALLING_EDGE          ((uint32_t)0x00000002U)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWR_ENABLE_WUP_Mask PWR Enable WUP Mask\r\n  * @{\r\n  */  \r\n#define  PWR_EWUP_MASK                          ((uint32_t)0x00003F00)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup PWR_Exported_Functions PWR Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions \r\n  *  @brief    Initialization and de-initialization functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]\r\n      After reset, the backup domain (RTC registers, RTC backup data \r\n      registers and backup SRAM) is protected against possible unwanted \r\n      write accesses. \r\n      To enable access to the RTC Domain and RTC registers, proceed as follows:\r\n        (+) Enable the Power Controller (PWR) APB1 interface clock using the\r\n            __HAL_RCC_PWR_CLK_ENABLE() macro.\r\n        (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.\r\n \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Deinitializes the HAL PWR peripheral registers to their default reset values.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DeInit(void)\r\n{\r\n  __HAL_RCC_PWR_FORCE_RESET();\r\n  __HAL_RCC_PWR_RELEASE_RESET();\r\n}\r\n\r\n/**\r\n  * @brief Enables access to the backup domain (RTC registers, RTC \r\n  *         backup data registers and backup SRAM).\r\n  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the \r\n  *         Backup Domain Access should be kept enabled.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnableBkUpAccess(void)\r\n{\r\n  /* Enable access to RTC and backup registers */\r\n  SET_BIT(PWR->CR1, PWR_CR1_DBP);\r\n}\r\n\r\n/**\r\n  * @brief Disables access to the backup domain (RTC registers, RTC \r\n  *         backup data registers and backup SRAM).\r\n  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the \r\n  *         Backup Domain Access should be kept enabled.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableBkUpAccess(void)\r\n{\r\n  /* Disable access to RTC and backup registers */\r\n\tCLEAR_BIT(PWR->CR1, PWR_CR1_DBP);\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions \r\n  *  @brief Low Power modes configuration functions \r\n  *\r\n@verbatim\r\n\r\n ===============================================================================\r\n                 ##### Peripheral Control functions #####\r\n ===============================================================================\r\n     \r\n    *** PVD configuration ***\r\n    =========================\r\n    [..]\r\n      (+) The PVD is used to monitor the VDD power supply by comparing it to a \r\n          threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).\r\n      (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower \r\n          than the PVD threshold. This event is internally connected to the EXTI \r\n          line16 and can generate an interrupt if enabled. This is done through\r\n          __HAL_PWR_PVD_EXTI_ENABLE_IT() macro.\r\n      (+) The PVD is stopped in Standby mode.\r\n\r\n    *** Wake-up pin configuration ***\r\n    ================================\r\n    [..]\r\n      (+) Wake-up pin is used to wake up the system from Standby mode. This pin is \r\n          forced in input pull-down configuration and is active on rising edges.\r\n      (+) There are up to 6 Wake-up pin in the STM32F7 devices family\r\n\r\n    *** Low Power modes configuration ***\r\n    =====================================\r\n    [..]\r\n      The devices feature 3 low-power modes:\r\n      (+) Sleep mode: Cortex-M7 core stopped, peripherals kept running.\r\n      (+) Stop mode: all clocks are stopped, regulator running, regulator \r\n          in low power mode\r\n      (+) Standby mode: 1.2V domain powered off.\r\n   \r\n   *** Sleep mode ***\r\n   ==================\r\n    [..]\r\n      (+) Entry:\r\n        The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI)\r\n              functions with\r\n          (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction\r\n          (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction\r\n      \r\n      -@@- The Regulator parameter is not used for the STM32F7 family \r\n              and is kept as parameter just to maintain compatibility with the \r\n              lower power families (STM32L).\r\n      (+) Exit:\r\n        Any peripheral interrupt acknowledged by the nested vectored interrupt \r\n              controller (NVIC) can wake up the device from Sleep mode.\r\n\r\n   *** Stop mode ***\r\n   =================\r\n    [..]\r\n      In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,\r\n      and the HSE RC oscillators are disabled. Internal SRAM and register contents \r\n      are preserved.\r\n      The voltage regulator can be configured either in normal or low-power mode.\r\n      To minimize the consumption In Stop mode, FLASH can be powered off before \r\n      entering the Stop mode using the HAL_PWREx_EnableFlashPowerDown() function.\r\n      It can be switched on again by software after exiting the Stop mode using\r\n      the HAL_PWREx_DisableFlashPowerDown() function. \r\n\r\n      (+) Entry:\r\n         The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON) \r\n             function with:\r\n          (++) Main regulator ON.\r\n          (++) Low Power regulator ON.\r\n      (+) Exit:\r\n        Any EXTI Line (Internal or External) configured in Interrupt/Event mode.\r\n\r\n   *** Standby mode ***\r\n   ====================\r\n    [..]\r\n    (+)\r\n      The Standby mode allows to achieve the lowest power consumption. It is based \r\n      on the Cortex-M7 deep sleep mode, with the voltage regulator disabled. \r\n      The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and \r\n      the HSE oscillator are also switched off. SRAM and register contents are lost \r\n      except for the RTC registers, RTC backup registers, backup SRAM and Standby \r\n      circuitry.\r\n   \r\n      The voltage regulator is OFF.\r\n      \r\n      (++) Entry:\r\n        (+++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.\r\n      (++) Exit:\r\n        (+++) WKUP pin rising or falling edge, RTC alarm (Alarm A and Alarm B), RTC\r\n             wakeup, tamper event, time stamp event, external reset in NRST pin, IWDG reset.\r\n\r\n   *** Auto-wakeup (AWU) from low-power mode ***\r\n   =============================================\r\n    [..]\r\n    \r\n     (+) The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC \r\n      Wakeup event, a tamper event or a time-stamp event, without depending on \r\n      an external interrupt (Auto-wakeup mode).\r\n\r\n      (+) RTC auto-wakeup (AWU) from the Stop and Standby modes\r\n       \r\n        (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to \r\n              configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.\r\n\r\n        (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it \r\n             is necessary to configure the RTC to detect the tamper or time stamp event using the\r\n                HAL_RTCEx_SetTimeStamp_IT() or HAL_RTCEx_SetTamper_IT() functions.\r\n                  \r\n        (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to\r\n              configure the RTC to generate the RTC WakeUp event using the HAL_RTCEx_SetWakeUpTimer_IT() function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Configures the voltage threshold detected by the Power Voltage Detector(PVD).\r\n  * @param sConfigPVD pointer to an PWR_PVDTypeDef structure that contains the configuration\r\n  *        information for the PVD.\r\n  * @note Refer to the electrical characteristics of your device datasheet for\r\n  *         more details about the voltage threshold corresponding to each \r\n  *         detection level.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));\r\n  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));\r\n  \r\n  /* Set PLS[7:5] bits according to PVDLevel value */\r\n  MODIFY_REG(PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);\r\n  \r\n  /* Clear any previous config. Keep it clear if no event or IT mode is selected */\r\n  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();\r\n  __HAL_PWR_PVD_EXTI_DISABLE_IT();\r\n  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();\r\n  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); \r\n\r\n  /* Configure interrupt mode */\r\n  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_IT();\r\n  }\r\n  \r\n  /* Configure event mode */\r\n  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();\r\n  }\r\n  \r\n  /* Configure the edge */\r\n  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();\r\n  }\r\n  \r\n  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Enables the Power Voltage Detector(PVD).\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnablePVD(void)\r\n{\r\n  /* Enable the power voltage detector */\r\n\tSET_BIT(PWR->CR1, PWR_CR1_PVDE);\r\n}\r\n\r\n/**\r\n  * @brief Disables the Power Voltage Detector(PVD).\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisablePVD(void)\r\n{\r\n  /* Disable the power voltage detector */\r\n\tCLEAR_BIT(PWR->CR1, PWR_CR1_PVDE);\r\n}\r\n\r\n/**\r\n  * @brief Enable the WakeUp PINx functionality.\r\n  * @param WakeUpPinPolarity Specifies which Wake-Up pin to enable.\r\n  *         This parameter can be one of the following legacy values, which sets the default polarity: \r\n  *         detection on high level (rising edge):\r\n  *           @arg PWR_WAKEUP_PIN1, PWR_WAKEUP_PIN2, PWR_WAKEUP_PIN3, PWR_WAKEUP_PIN4, PWR_WAKEUP_PIN5, PWR_WAKEUP_PIN6 \r\n  *         or one of the following value where the user can explicitly states the enabled pin and\r\n  *         the chosen polarity  \r\n  *           @arg PWR_WAKEUP_PIN1_HIGH or PWR_WAKEUP_PIN1_LOW \r\n  *           @arg PWR_WAKEUP_PIN2_HIGH or PWR_WAKEUP_PIN2_LOW \r\n  *           @arg PWR_WAKEUP_PIN3_HIGH or PWR_WAKEUP_PIN3_LOW \r\n  *           @arg PWR_WAKEUP_PIN4_HIGH or PWR_WAKEUP_PIN4_LOW\r\n  *           @arg PWR_WAKEUP_PIN5_HIGH or PWR_WAKEUP_PIN5_LOW \r\n  *           @arg PWR_WAKEUP_PIN6_HIGH or PWR_WAKEUP_PIN6_LOW \r\n  * @note  PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.               \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinPolarity)\r\n{\r\n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity));\r\n  \r\n  /* Enable wake-up pin */\r\n  SET_BIT(PWR->CSR2, (PWR_EWUP_MASK & WakeUpPinPolarity));\r\n\t\r\n  /* Specifies the Wake-Up pin polarity for the event detection\r\n    (rising or falling edge) */\r\n  MODIFY_REG(PWR->CR2, (PWR_EWUP_MASK & WakeUpPinPolarity), (WakeUpPinPolarity >> 0x06));\r\n}\r\n\r\n/**\r\n  * @brief Disables the WakeUp PINx functionality.\r\n  * @param WakeUpPinx Specifies the Power Wake-Up pin to disable.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg PWR_WAKEUP_PIN1\r\n  *           @arg PWR_WAKEUP_PIN2\r\n  *           @arg PWR_WAKEUP_PIN3\r\n  *           @arg PWR_WAKEUP_PIN4\r\n  *           @arg PWR_WAKEUP_PIN5\r\n  *           @arg PWR_WAKEUP_PIN6 \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)\r\n{\r\n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));\r\n\r\n  CLEAR_BIT(PWR->CSR2, WakeUpPinx);\r\n}\r\n  \r\n/**\r\n  * @brief Enters Sleep mode.\r\n  *   \r\n  * @note In Sleep mode, all I/O pins keep the same state as in Run mode.\r\n  * \r\n  * @note In Sleep mode, the systick is stopped to avoid exit from this mode with\r\n  *       systick interrupt when used as time base for Timeout \r\n  *                \r\n  * @param Regulator Specifies the regulator state in SLEEP mode.\r\n  *            This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON\r\n  *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON\r\n  * @note This parameter is not used for the STM32F7 family and is kept as parameter\r\n  *       just to maintain compatibility with the lower power families.\r\n  * @param SLEEPEntry Specifies if SLEEP mode in entered with WFI or WFE instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction\r\n  *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_PWR_REGULATOR(Regulator));\r\n  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));\r\n\r\n  /* Clear SLEEPDEEP bit of Cortex System Control Register */\r\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\r\n\r\n  /* Ensure that all instructions done before entering SLEEP mode */\r\n  __DSB();\r\n  __ISB();\r\n\r\n  /* Select SLEEP mode entry -------------------------------------------------*/\r\n  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)\r\n  {   \r\n    /* Request Wait For Interrupt */\r\n    __WFI();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __SEV();\r\n    __WFE();\r\n    __WFE();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Enters Stop mode. \r\n  * @note In Stop mode, all I/O pins keep the same state as in Run mode.\r\n  * @note When exiting Stop mode by issuing an interrupt or a wakeup event, \r\n  *         the HSI RC oscillator is selected as system clock.\r\n  * @note When the voltage regulator operates in low power mode, an additional \r\n  *         startup delay is incurred when waking up from Stop mode. \r\n  *         By keeping the internal regulator ON during Stop mode, the consumption \r\n  *         is higher although the startup time is reduced.    \r\n  * @param Regulator Specifies the regulator state in Stop mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON\r\n  *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON\r\n  * @param STOPEntry Specifies if Stop mode in entered with WFI or WFE instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction\r\n  *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\r\n{\r\n  uint32_t tmpreg = 0;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_PWR_REGULATOR(Regulator));\r\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\r\n\r\n  /* Select the regulator state in Stop mode ---------------------------------*/\r\n  tmpreg = PWR->CR1;\r\n  /* Clear PDDS and LPDS bits */\r\n  tmpreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS);\r\n\r\n  /* Set LPDS, MRLVDS and LPLVDS bits according to Regulator value */\r\n  tmpreg |= Regulator;\r\n\r\n  /* Store the new value */\r\n  PWR->CR1 = tmpreg;\r\n\r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\r\n\r\n  /* Ensure that all instructions done before entering STOP mode */\r\n  __DSB();\r\n  __ISB();\r\n\r\n  /* Select Stop mode entry --------------------------------------------------*/\r\n  if(STOPEntry == PWR_STOPENTRY_WFI)\r\n  {   \r\n    /* Request Wait For Interrupt */\r\n    __WFI();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __SEV();\r\n    __WFE();\r\n    __WFE();\r\n  }\r\n  /* Reset SLEEPDEEP bit of Cortex System Control Register */\r\n  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  \r\n}\r\n\r\n/**\r\n  * @brief Enters Standby mode.\r\n  * @note In Standby mode, all I/O pins are high impedance except for:\r\n  *          - Reset pad (still available) \r\n  *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC \r\n  *            Alarm out, or RTC clock calibration out.\r\n  *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  \r\n  *          - WKUP pins if enabled.       \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnterSTANDBYMode(void)\r\n{\r\n  /* Select Standby mode */\r\n  PWR->CR1 |= PWR_CR1_PDDS;\r\n  \r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\r\n  \r\n  /* This option is used to ensure that store operations are completed */\r\n#if defined ( __CC_ARM)\r\n  __force_stores();\r\n#endif\r\n  /* Request Wait For Interrupt */\r\n  __WFI();\r\n}\r\n\r\n/**\r\n  * @brief This function handles the PWR PVD interrupt request.\r\n  * @note This API should be called under the PVD_IRQHandler().\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_PVD_IRQHandler(void)\r\n{\r\n  /* Check PWR Exti flag */\r\n  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)\r\n  {\r\n    /* PWR PVD interrupt user callback */\r\n    HAL_PWR_PVDCallback();\r\n    \r\n    /* Clear PWR Exti pending bit */\r\n    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  PWR PVD interrupt callback\r\n  * @retval None\r\n  */\r\n__weak void HAL_PWR_PVDCallback(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_PWR_PVDCallback could be implemented in the user file\r\n   */ \r\n}\r\n\r\n/**\r\n  * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. \r\n  * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor \r\n  *       re-enters SLEEP mode when an interruption handling is over.\r\n  *       Setting this bit is useful when the processor is expected to run only on\r\n  *       interruptions handling.         \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnableSleepOnExit(void)\r\n{\r\n  /* Set SLEEPONEXIT bit of Cortex System Control Register */\r\n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));\r\n}\r\n\r\n/**\r\n  * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. \r\n  * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor \r\n  *       re-enters SLEEP mode when an interruption handling is over.          \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableSleepOnExit(void)\r\n{\r\n  /* Clear SLEEPONEXIT bit of Cortex System Control Register */\r\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));\r\n}\r\n\r\n/**\r\n  * @brief Enables CORTEX M4 SEVONPEND bit. \r\n  * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes \r\n  *       WFE to wake up when an interrupt moves from inactive to pended.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnableSEVOnPend(void)\r\n{\r\n  /* Set SEVONPEND bit of Cortex System Control Register */\r\n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));\r\n}\r\n\r\n/**\r\n  * @brief Disables CORTEX M4 SEVONPEND bit. \r\n  * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes \r\n  *       WFE to wake up when an interrupt moves from inactive to pended.         \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableSEVOnPend(void)\r\n{\r\n  /* Clear SEVONPEND bit of Cortex System Control Register */\r\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n  \r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_PWR_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_pwr_ex.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_pwr_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended PWR HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of PWR extension peripheral:           \r\n  *           + Peripheral Extended features functions\r\n  *         \r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWREx PWREx\r\n  * @brief PWR HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_PWR_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup PWREx_Private_Constants\r\n  * @{\r\n  */    \r\n#define PWR_OVERDRIVE_TIMEOUT_VALUE  1000\r\n#define PWR_UDERDRIVE_TIMEOUT_VALUE  1000\r\n#define PWR_BKPREG_TIMEOUT_VALUE     1000\r\n#define PWR_VOSRDY_TIMEOUT_VALUE     1000\r\n/**\r\n  * @}\r\n  */\r\n    \r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @defgroup PWREx_Exported_Functions PWREx Exported Functions\r\n  *  @{\r\n  */\r\n\r\n/** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended features functions \r\n  *  @brief Peripheral Extended features functions \r\n  *\r\n@verbatim   \r\n\r\n ===============================================================================\r\n                 ##### Peripheral extended features functions #####\r\n ===============================================================================\r\n\r\n    *** Main and Backup Regulators configuration ***\r\n    ================================================\r\n    [..] \r\n      (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from \r\n          the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is \r\n          retained even in Standby or VBAT mode when the low power backup regulator\r\n          is enabled. It can be considered as an internal EEPROM when VBAT is \r\n          always present. You can use the HAL_PWREx_EnableBkUpReg() function to \r\n          enable the low power backup regulator. \r\n\r\n      (+) When the backup domain is supplied by VDD (analog switch connected to VDD) \r\n          the backup SRAM is powered from VDD which replaces the VBAT power supply to \r\n          save battery life.\r\n\r\n      (+) The backup SRAM is not mass erased by a tamper event. It is read \r\n          protected to prevent confidential data, such as cryptographic private \r\n          key, from being accessed. The backup SRAM can be erased only through \r\n          the Flash interface when a protection level change from level 1 to \r\n          level 0 is requested. \r\n      -@- Refer to the description of Read protection (RDP) in the Flash \r\n          programming manual.\r\n\r\n      (+) The main internal regulator can be configured to have a tradeoff between \r\n          performance and power consumption when the device does not operate at \r\n          the maximum frequency. This is done through __HAL_PWR_MAINREGULATORMODE_CONFIG() \r\n          macro which configure VOS bit in PWR_CR register\r\n          \r\n        Refer to the product datasheets for more details.\r\n\r\n    *** FLASH Power Down configuration ****\r\n    =======================================\r\n    [..] \r\n      (+) By setting the FPDS bit in the PWR_CR register by using the \r\n          HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters power \r\n          down mode when the device enters Stop mode. When the Flash memory \r\n          is in power down mode, an additional startup delay is incurred when \r\n          waking up from Stop mode.\r\n\r\n    *** Over-Drive and Under-Drive configuration ****\r\n    =================================================\r\n    [..]         \r\n       (+) In Run mode: the main regulator has 2 operating modes available:\r\n        (++) Normal mode: The CPU and core logic operate at maximum frequency at a given \r\n             voltage scaling (scale 1, scale 2 or scale 3)\r\n        (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a \r\n            higher frequency than the normal mode for a given voltage scaling (scale 1,  \r\n            scale 2 or scale 3). This mode is enabled through HAL_PWREx_EnableOverDrive() function and\r\n            disabled by HAL_PWREx_DisableOverDrive() function, to enter or exit from Over-drive mode please follow \r\n            the sequence described in Reference manual.\r\n             \r\n       (+) In Stop mode: the main regulator or low power regulator supplies a low power \r\n           voltage to the 1.2V domain, thus preserving the content of registers \r\n           and internal SRAM. 2 operating modes are available:\r\n         (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only \r\n              available when the main regulator or the low power regulator is used in Scale 3 or \r\n              low voltage mode.\r\n         (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only\r\n              available when the main regulator or the low power regulator is in low voltage mode.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Enables the Backup Regulator.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)\r\n{\r\n  uint32_t tickstart = 0;\r\n\r\n  /* Enable Backup regulator */\r\n  PWR->CSR1 |= PWR_CSR1_BRE;\r\n    \r\n  /* Workaround for the following hardware bug: */\r\n  /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */\r\n  PWR->CSR1 |= PWR_CSR1_EIWUP;\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait till Backup regulator ready flag is set */  \r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    } \r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Disables the Backup Regulator.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)\r\n{\r\n  uint32_t tickstart = 0;\r\n  \r\n  /* Disable Backup regulator */\r\n  PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);\r\n  \r\n  /* Workaround for the following hardware bug: */\r\n  /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */\r\n  PWR->CSR1 |= PWR_CSR1_EIWUP;\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait till Backup regulator ready flag is set */  \r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    } \r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Enables the Flash Power Down in Stop mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_EnableFlashPowerDown(void)\r\n{\r\n  /* Enable the Flash Power Down */\r\n  PWR->CR1 |= PWR_CR1_FPDS;\r\n}\r\n\r\n/**\r\n  * @brief Disables the Flash Power Down in Stop mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_DisableFlashPowerDown(void)\r\n{\r\n  /* Disable the Flash Power Down */\r\n  PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);\r\n}\r\n\r\n/**\r\n  * @brief Enables Main Regulator low voltage mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_EnableMainRegulatorLowVoltage(void)\r\n{\r\n  /* Enable Main regulator low voltage */\r\n  PWR->CR1 |= PWR_CR1_MRUDS;\r\n}\r\n\r\n/**\r\n  * @brief Disables Main Regulator low voltage mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_DisableMainRegulatorLowVoltage(void)\r\n{  \r\n  /* Disable Main regulator low voltage */\r\n  PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);\r\n}\r\n\r\n/**\r\n  * @brief Enables Low Power Regulator low voltage mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_EnableLowRegulatorLowVoltage(void)\r\n{\r\n  /* Enable low power regulator */\r\n  PWR->CR1 |= PWR_CR1_LPUDS;\r\n}\r\n\r\n/**\r\n  * @brief Disables Low Power Regulator low voltage mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_DisableLowRegulatorLowVoltage(void)\r\n{\r\n  /* Disable low power regulator */\r\n  PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);\r\n}\r\n\r\n/**\r\n  * @brief  Activates the Over-Drive mode.\r\n  * @note   This mode allows the CPU and the core logic to operate at a higher frequency\r\n  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   \r\n  * @note   It is recommended to enter or exit Over-drive mode when the application is not running \r\n  *         critical tasks and when the system clock source is either HSI or HSE. \r\n  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   \r\n  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)\r\n{\r\n  uint32_t tickstart = 0;\r\n\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  \r\n  /* Enable the Over-drive to extend the clock frequency to 216 MHz */\r\n  __HAL_PWR_OVERDRIVE_ENABLE();\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n  \r\n  /* Enable the Over-drive switch */\r\n  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } \r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Deactivates the Over-Drive mode.\r\n  * @note   This mode allows the CPU and the core logic to operate at a higher frequency\r\n  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).    \r\n  * @note   It is recommended to enter or exit Over-drive mode when the application is not running \r\n  *         critical tasks and when the system clock source is either HSI or HSE. \r\n  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   \r\n  *         The peripheral clocks must be enabled once the Over-drive mode is activated.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)\r\n{\r\n  uint32_t tickstart = 0;\r\n  \r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n    \r\n  /* Disable the Over-drive switch */\r\n  __HAL_PWR_OVERDRIVESWITCHING_DISABLE();\r\n  \r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n \r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } \r\n  \r\n  /* Disable the Over-drive */\r\n  __HAL_PWR_OVERDRIVE_DISABLE();\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n  \r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Enters in Under-Drive STOP mode.\r\n  * \r\n  * @note    This mode can be selected only when the Under-Drive is already active \r\n  *   \r\n  * @note    This mode is enabled only with STOP low power mode.\r\n  *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This \r\n  *          mode is only available when the main regulator or the low power regulator \r\n  *          is in low voltage mode\r\n  *        \r\n  * @note   If the Under-drive mode was enabled, it is automatically disabled after \r\n  *         exiting Stop mode. \r\n  *         When the voltage regulator operates in Under-drive mode, an additional  \r\n  *         startup delay is induced when waking up from Stop mode.\r\n  *                    \r\n  * @note   In Stop mode, all I/O pins keep the same state as in Run mode.\r\n  *   \r\n  * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, \r\n  *         the HSI RC oscillator is selected as system clock.\r\n  *           \r\n  * @note   When the voltage regulator operates in low power mode, an additional \r\n  *         startup delay is incurred when waking up from Stop mode. \r\n  *         By keeping the internal regulator ON during Stop mode, the consumption \r\n  *         is higher although the startup time is reduced.\r\n  *     \r\n  * @param  Regulator specifies the regulator state in STOP mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_UNDERDRIVE_ON:  Main Regulator in under-drive mode \r\n  *                 and Flash memory in power-down when the device is in Stop under-drive mode\r\n  *            @arg PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON:  Low Power Regulator in under-drive mode \r\n  *                and Flash memory in power-down when the device is in Stop under-drive mode\r\n  * @param  STOPEntry specifies if STOP mode in entered with WFI or WFE instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction\r\n  *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\r\n{\r\n  uint32_t tempreg = 0;\r\n  uint32_t tickstart = 0;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));\r\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\r\n  \r\n  /* Enable Power ctrl clock */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  /* Enable the Under-drive Mode ---------------------------------------------*/\r\n  /* Clear Under-drive flag */\r\n  __HAL_PWR_CLEAR_ODRUDR_FLAG();\r\n  \r\n  /* Enable the Under-drive */ \r\n  __HAL_PWR_UNDERDRIVE_ENABLE();\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait for UnderDrive mode is ready */\r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n  \r\n  /* Select the regulator state in STOP mode ---------------------------------*/\r\n  tempreg = PWR->CR1;\r\n  /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */\r\n  tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);\r\n  \r\n  /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */\r\n  tempreg |= Regulator;\r\n  \r\n  /* Store the new value */\r\n  PWR->CR1 = tempreg;\r\n  \r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\r\n  \r\n  /* Select STOP mode entry --------------------------------------------------*/\r\n  if(STOPEntry == PWR_SLEEPENTRY_WFI)\r\n  {   \r\n    /* Request Wait For Interrupt */\r\n    __WFI();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __WFE();\r\n  }\r\n  /* Reset SLEEPDEEP bit of Cortex System Control Register */\r\n  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n  return HAL_OK;  \r\n}\r\n\r\n/**\r\n  * @brief Returns Voltage Scaling Range.\r\n  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or \r\n  *            PWR_REGULATOR_VOLTAGE_SCALE3)PWR_REGULATOR_VOLTAGE_SCALE1\r\n  */  \r\nuint32_t HAL_PWREx_GetVoltageRange(void)\r\n{\r\n  return  (PWR->CR1 & PWR_CR1_VOS);\r\n}\r\n\r\n/**\r\n  * @brief Configures the main internal regulator output voltage.\r\n  * @param  VoltageScaling specifies the regulator output voltage to achieve\r\n  *         a tradeoff between performance and power consumption.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,\r\n  *                                                typical output voltage at 1.4 V,  \r\n  *                                                system frequency up to 216 MHz.\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,\r\n  *                                                typical output voltage at 1.2 V,                \r\n  *                                                system frequency up to 180 MHz.\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output range 2 mode,\r\n  *                                                typical output voltage at 1.00 V,                \r\n  *                                                system frequency up to 151 MHz.\r\n  * @note To update the system clock frequency(SYSCLK):\r\n  *        - Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig().\r\n  *        - Call the HAL_RCC_OscConfig() to configure the PLL.\r\n  *        - Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.\r\n  *        - Set the new system clock frequency using the HAL_RCC_ClockConfig().\r\n  * @note The scale can be modified only when the HSI or HSE clock source is selected \r\n  *        as system clock source, otherwise the API returns HAL_ERROR.  \r\n  * @note When the PLL is OFF, the voltage scale 3 is automatically selected and the VOS bits\r\n  *       value in the PWR_CR1 register are not taken in account.\r\n  * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.\r\n  * @note The new voltage scale is active only when the PLL is ON.  \r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)\r\n{\r\n  uint32_t tickstart = 0;\r\n\r\n  assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));\r\n\r\n  /* Enable Power ctrl clock */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n  /* Check if the PLL is used as system clock or not */\r\n  if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)\r\n  {\r\n    /* Disable the main PLL */\r\n    __HAL_RCC_PLL_DISABLE();\r\n    \r\n    /* Get Start Tick */\r\n    tickstart = HAL_GetTick();    \r\n    /* Wait till PLL is disabled */  \r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    \r\n    /* Set Range */\r\n    __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);\r\n    \r\n    /* Enable the main PLL */\r\n    __HAL_RCC_PLL_ENABLE();\r\n    \r\n    /* Get Start Tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLL is ready */  \r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      } \r\n    }\r\n    \r\n    /* Get Start Tick */\r\n    tickstart = HAL_GetTick();\r\n    while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      } \r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_PWR_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_rcc.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_rcc.c\r\n  * @author  MCD Application Team\r\n  * @brief   RCC HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Reset and Clock Control (RCC) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### RCC specific features #####\r\n  ==============================================================================\r\n    [..]\r\n      After reset the device is running from Internal High Speed oscillator\r\n      (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache\r\n      and I-Cache are disabled, and all peripherals are off except internal\r\n      SRAM, Flash and JTAG.\r\n      (+) There is no prescaler on High speed (AHB) and Low speed (APB) buses;\r\n          all peripherals mapped on these buses are running at HSI speed.\r\n      (+) The clock for all peripherals is switched off, except the SRAM and FLASH.\r\n      (+) All GPIOs are in input floating state, except the JTAG pins which\r\n          are assigned to be used for debug purpose.\r\n\r\n    [..]\r\n      Once the device started from reset, the user application has to:\r\n      (+) Configure the clock source to be used to drive the System clock\r\n          (if the application needs higher frequency/performance)\r\n      (+) Configure the System clock frequency and Flash settings\r\n      (+) Configure the AHB and APB buses prescalers\r\n      (+) Enable the clock for the peripheral(s) to be used\r\n      (+) Configure the clock source(s) for peripherals which clocks are not\r\n          derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)\r\n\r\n                      ##### RCC Limitations #####\r\n  ==============================================================================\r\n    [..]\r\n      A delay between an RCC peripheral clock enable and the effective peripheral\r\n      enabling should be taken into account in order to manage the peripheral read/write\r\n      from/to registers.\r\n      (+) This delay depends on the peripheral mapping.\r\n      (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle\r\n          after the clock enable bit is set on the hardware register\r\n      (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle\r\n          after the clock enable bit is set on the hardware register\r\n\r\n    [..]\r\n      Implemented Workaround:\r\n      (+) For AHB & APB peripherals, a dummy read to the peripheral register has been\r\n          inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCC RCC\r\n  * @brief RCC HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_RCC_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/** @defgroup RCC_Private_Macros RCC Private Macros\r\n  * @{\r\n  */\r\n\r\n#define MCO1_CLK_ENABLE()   __HAL_RCC_GPIOA_CLK_ENABLE()\r\n#define MCO1_GPIO_PORT        GPIOA\r\n#define MCO1_PIN              GPIO_PIN_8\r\n\r\n#define MCO2_CLK_ENABLE()   __HAL_RCC_GPIOC_CLK_ENABLE()\r\n#define MCO2_GPIO_PORT         GPIOC\r\n#define MCO2_PIN               GPIO_PIN_9\r\n\r\n/**\r\n  * @}\r\n  */\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @defgroup RCC_Private_Variables RCC Private Variables\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup RCC_Exported_Functions RCC Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions\r\n  *  @brief    Initialization and Configuration functions\r\n  *\r\n  @verbatim\r\n  ===============================================================================\r\n##### Initialization and de-initialization functions #####\r\n  ===============================================================================\r\n    [..]\r\n      This section provides functions allowing to configure the internal/external oscillators\r\n      (HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB, APB1\r\n      and APB2).\r\n\r\n    [..] Internal/external clock and PLL configuration\r\n      (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through\r\n          the PLL as System clock source.\r\n\r\n      (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC\r\n          clock source.\r\n\r\n      (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or\r\n          through the PLL as System clock source. Can be used also as RTC clock source.\r\n\r\n      (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.\r\n\r\n      (#) PLL (clocked by HSI or HSE), featuring two different output clocks:\r\n        (++) The first output is used to generate the high speed system clock (up to 216 MHz)\r\n        (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),\r\n             the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).\r\n\r\n      (#) CSS (Clock security system), once enable using the function HAL_RCC_EnableCSS()\r\n          and if a HSE clock failure occurs(HSE used directly or through PLL as System\r\n          clock source), the System clock is automatically switched to HSI and an interrupt\r\n          is generated if enabled. The interrupt is linked to the Cortex-M7 NMI\r\n          (Non-Maskable Interrupt) exception vector.\r\n\r\n      (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL\r\n          clock (through a configurable prescaler) on PA8 pin.\r\n\r\n      (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S\r\n          clock (through a configurable prescaler) on PC9 pin.\r\n\r\n    [..] System, AHB and APB buses clocks configuration\r\n      (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,\r\n          HSE and PLL.\r\n          The AHB clock (HCLK) is derived from System clock through configurable\r\n          prescaler and used to clock the CPU, memory and peripherals mapped\r\n          on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived\r\n          from AHB clock through configurable prescalers and used to clock\r\n          the peripherals mapped on these buses. You can use\r\n          \"HAL_RCC_GetSysClockFreq()\" function to retrieve the frequencies of these clocks.\r\n\r\n      -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:\r\n          (+@) I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or\r\n              from an external clock mapped on the I2S_CKIN pin.\r\n              You have to use __HAL_RCC_PLLI2S_CONFIG() macro to configure this clock.\r\n          (+@)  SAI: the SAI clock can be derived either from a specific PLL (PLLI2S) or (PLLSAI) or\r\n              from an external clock mapped on the I2S_CKIN pin.\r\n               You have to use __HAL_RCC_PLLI2S_CONFIG() macro to configure this clock.\r\n          (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock\r\n              divided by 2 to 31. You have to use __HAL_RCC_RTC_CONFIG() and __HAL_RCC_RTC_ENABLE()\r\n              macros to configure this clock.\r\n          (+@) USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz\r\n              to work correctly, while the SDIO require a frequency equal or lower than\r\n              to 48. This clock is derived of the main PLL through PLLQ divider.\r\n          (+@) IWDG clock which is always the LSI clock.\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Resets the RCC clock configuration to the default reset state.\r\n  * @note   The default reset state of the clock configuration is given below:\r\n  *            - HSI ON and used as system clock source\r\n  *            - HSE, PLL, PLLI2S and PLLSAI OFF\r\n  *            - AHB, APB1 and APB2 prescaler set to 1.\r\n  *            - CSS, MCO1 and MCO2 OFF\r\n  *            - All interrupts disabled\r\n  * @note   This function doesn't modify the configuration of the\r\n  *            - Peripheral clocks\r\n  *            - LSI, LSE and RTC clocks\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_RCC_DeInit(void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Set HSION bit to the reset value */\r\n  SET_BIT(RCC->CR, RCC_CR_HSION);\r\n\r\n  /* Wait till HSI is ready */\r\n  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Set HSITRIM[4:0] bits to the reset value */\r\n  SET_BIT(RCC->CR, RCC_CR_HSITRIM_4);\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset CFGR register */\r\n  CLEAR_REG(RCC->CFGR);\r\n\r\n  /* Wait till clock switch is ready */\r\n  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Clear HSEON, HSEBYP and CSSON bits */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON);\r\n\r\n  /* Wait till HSE is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Clear PLLON bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);\r\n\r\n  /* Wait till PLL is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset PLLI2SON bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLLI2SON);\r\n\r\n  /* Wait till PLLI2S is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset PLLSAI bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAION);\r\n\r\n  /* Wait till PLLSAI is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value */\r\n  RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 | 0x20000000U;\r\n\r\n  /* Reset PLLI2SCFGR register to default value */\r\n  RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;\r\n\r\n  /* Reset PLLSAICFGR register to default value */\r\n  RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2 | 0x20000000U;\r\n\r\n  /* Disable all interrupts */\r\n  CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE | RCC_CIR_PLLI2SRDYIE | RCC_CIR_PLLSAIRDYIE);\r\n\r\n  /* Clear all interrupt flags */\r\n  SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_PLLI2SRDYC | RCC_CIR_PLLSAIRDYC | RCC_CIR_CSSC);\r\n\r\n  /* Clear LSION bit */\r\n  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);\r\n\r\n  /* Reset all CSR flags */\r\n  SET_BIT(RCC->CSR, RCC_CSR_RMVF);\r\n\r\n  /* Update the SystemCoreClock global variable */\r\n  SystemCoreClock = HSI_VALUE;\r\n\r\n  /* Adapt Systick interrupt period */\r\n  if (HAL_InitTick(uwTickPrio) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    return HAL_OK;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the RCC Oscillators according to the specified parameters in the\r\n  *         RCC_OscInitTypeDef.\r\n  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that\r\n  *         contains the configuration information for the RCC Oscillators.\r\n  * @note   The PLL is not disabled when used as system clock.\r\n  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not\r\n  *         supported by this function. User should request a transition to LSE Off\r\n  *         first and then LSE On or LSE Bypass.\r\n  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not\r\n  *         supported by this function. User should request a transition to HSE Off\r\n  *         first and then HSE On or HSE Bypass.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t pll_config;\r\n  FlagStatus pwrclkchanged = RESET;\r\n\r\n  /* Check Null pointer */\r\n  if (RCC_OscInitStruct == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));\r\n\r\n  /*------------------------------- HSE Configuration ------------------------*/\r\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));\r\n    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */\r\n    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)\r\n        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))\r\n    {\r\n      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Set the new HSE configuration ---------------------------------------*/\r\n      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);\r\n\r\n      /* Check the HSE State */\r\n      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSE is ready */\r\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSE is bypassed or disabled */\r\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*----------------------------- HSI Configuration --------------------------*/\r\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));\r\n    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));\r\n\r\n    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */\r\n    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)\r\n        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))\r\n    {\r\n      /* When HSI is used as system clock it will not disabled */\r\n      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      /* Otherwise, just the calibration is allowed */\r\n      else\r\n      {\r\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\r\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Check the HSI State */\r\n      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)\r\n      {\r\n        /* Enable the Internal High Speed oscillator (HSI). */\r\n        __HAL_RCC_HSI_ENABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSI is ready */\r\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\r\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\r\n      }\r\n      else\r\n      {\r\n        /* Disable the Internal High Speed oscillator (HSI). */\r\n        __HAL_RCC_HSI_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSI is ready */\r\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*------------------------------ LSI Configuration -------------------------*/\r\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));\r\n\r\n    /* Check the LSI State */\r\n    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)\r\n    {\r\n      /* Enable the Internal Low Speed oscillator (LSI). */\r\n      __HAL_RCC_LSI_ENABLE();\r\n\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSI is ready */\r\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)\r\n      {\r\n        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Disable the Internal Low Speed oscillator (LSI). */\r\n      __HAL_RCC_LSI_DISABLE();\r\n\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSI is ready */\r\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)\r\n      {\r\n        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*------------------------------ LSE Configuration -------------------------*/\r\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));\r\n\r\n    /* Update LSE configuration in Backup Domain control register    */\r\n    /* Requires to enable write access to Backup Domain of necessary */\r\n    if (__HAL_RCC_PWR_IS_CLK_DISABLED())\r\n    {\r\n      /* Enable Power Clock*/\r\n      __HAL_RCC_PWR_CLK_ENABLE();\r\n      pwrclkchanged = SET;\r\n    }\r\n\r\n    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))\r\n    {\r\n      /* Enable write access to Backup domain */\r\n      PWR->CR1 |= PWR_CR1_DBP;\r\n\r\n      /* Wait for Backup domain Write protection disable */\r\n      tickstart = HAL_GetTick();\r\n\r\n      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))\r\n      {\r\n        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Set the new LSE configuration -----------------------------------------*/\r\n    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);\r\n    /* Check the LSE State */\r\n    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)\r\n    {\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSE is ready */\r\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n      {\r\n        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSE is ready */\r\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)\r\n      {\r\n        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Restore clock configuration if changed */\r\n    if (pwrclkchanged == SET)\r\n    {\r\n      __HAL_RCC_PWR_CLK_DISABLE();\r\n    }\r\n  }\r\n  /*-------------------------------- PLL Configuration -----------------------*/\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));\r\n  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)\r\n  {\r\n    /* Check if the PLL is used as system clock or not */\r\n    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)\r\n    {\r\n      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)\r\n      {\r\n        /* Check the parameters */\r\n        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));\r\n        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));\r\n        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));\r\n        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));\r\n        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));\r\n#if defined (RCC_PLLCFGR_PLLR)\r\n        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));\r\n#endif\r\n\r\n        /* Disable the main PLL. */\r\n        __HAL_RCC_PLL_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Configure the main PLL clock source, multiplication and division factors. */\r\n#if defined (RCC_PLLCFGR_PLLR)\r\n        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,\r\n                             RCC_OscInitStruct->PLL.PLLM,\r\n                             RCC_OscInitStruct->PLL.PLLN,\r\n                             RCC_OscInitStruct->PLL.PLLP,\r\n                             RCC_OscInitStruct->PLL.PLLQ,\r\n                             RCC_OscInitStruct->PLL.PLLR);\r\n#else\r\n        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,\r\n                             RCC_OscInitStruct->PLL.PLLM,\r\n                             RCC_OscInitStruct->PLL.PLLN,\r\n                             RCC_OscInitStruct->PLL.PLLP,\r\n                             RCC_OscInitStruct->PLL.PLLQ);\r\n#endif\r\n\r\n        /* Enable the main PLL. */\r\n        __HAL_RCC_PLL_ENABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Disable the main PLL. */\r\n        __HAL_RCC_PLL_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Do not return HAL_ERROR if request repeats the current configuration */\r\n      pll_config = RCC->PLLCFGR;\r\n#if defined (RCC_PLLCFGR_PLLR)\r\n      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))\r\n#else\r\n      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||\r\n          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))\r\n#endif\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified\r\n  *         parameters in the RCC_ClkInitStruct.\r\n  * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that\r\n  *         contains the configuration information for the RCC peripheral.\r\n  * @param  FLatency FLASH Latency, this parameter depend on device selected\r\n  *\r\n  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency\r\n  *         and updated by HAL_RCC_GetHCLKFreq() function called within this function\r\n  *\r\n  * @note   The HSI is used (enabled by hardware) as system clock source after\r\n  *         startup from Reset, wake-up from STOP and STANDBY mode, or in case\r\n  *         of failure of the HSE used directly or indirectly as system clock\r\n  *         (if the Clock Security System CSS is enabled).\r\n  *\r\n  * @note   A switch from one clock source to another occurs only if the target\r\n  *         clock source is ready (clock stable after startup delay or PLL locked).\r\n  *         If a clock source which is not yet ready is selected, the switch will\r\n  *         occur when the clock source will be ready.\r\n  *         You can use HAL_RCC_GetClockConfig() function to know which clock is\r\n  *         currently used as system clock source.\r\n  * @note   Depending on the device voltage range, the software has to set correctly\r\n  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency\r\n  *         (for more details refer to section above \"Initialization/de-initialization functions\")\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)\r\n{\r\n  uint32_t tickstart = 0;\r\n\r\n  /* Check Null pointer */\r\n  if (RCC_ClkInitStruct == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));\r\n  assert_param(IS_FLASH_LATENCY(FLatency));\r\n\r\n  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)\r\n     must be correctly programmed according to the frequency of the CPU clock\r\n     (HCLK) and the supply voltage of the device. */\r\n\r\n  /* Increasing the CPU frequency */\r\n  if (FLatency > __HAL_FLASH_GET_LATENCY())\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    __HAL_FLASH_SET_LATENCY(FLatency);\r\n\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n    memory by reading the FLASH_ACR register */\r\n    if (__HAL_FLASH_GET_LATENCY() != FLatency)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  /*-------------------------- HCLK Configuration --------------------------*/\r\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)\r\n  {\r\n    /* Set the highest APBx dividers in order to ensure that we do not go through\r\n       a non-spec phase whatever we decrease or increase HCLK. */\r\n    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\r\n    {\r\n      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);\r\n    }\r\n\r\n    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\r\n    {\r\n      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));\r\n    }\r\n\r\n    /* Set the new HCLK clock divider */\r\n    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\r\n    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\r\n  }\r\n\r\n  /*------------------------- SYSCLK Configuration ---------------------------*/\r\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)\r\n  {\r\n    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));\r\n\r\n    /* HSE is selected as System Clock Source */\r\n    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)\r\n    {\r\n      /* Check the HSE ready flag */\r\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    /* PLL is selected as System Clock Source */\r\n    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)\r\n    {\r\n      /* Check the PLL ready flag */\r\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    /* HSI is selected as System Clock Source */\r\n    else\r\n    {\r\n      /* Check the HSI ready flag */\r\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))\r\n    {\r\n      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if (FLatency < __HAL_FLASH_GET_LATENCY())\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    __HAL_FLASH_SET_LATENCY(FLatency);\r\n\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n    memory by reading the FLASH_ACR register */\r\n    if (__HAL_FLASH_GET_LATENCY() != FLatency)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  /*-------------------------- PCLK1 Configuration ---------------------------*/\r\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\r\n  {\r\n    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));\r\n    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);\r\n  }\r\n\r\n  /*-------------------------- PCLK2 Configuration ---------------------------*/\r\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\r\n  {\r\n    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));\r\n    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));\r\n  }\r\n\r\n  /* Update the SystemCoreClock global variable */\r\n  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];\r\n\r\n  /* Configure the source of time base considering new system clocks settings*/\r\n  HAL_InitTick(uwTickPrio);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions\r\n  *  @brief   RCC clocks control functions\r\n  *\r\n  @verbatim\r\n  ===============================================================================\r\n                  ##### Peripheral Control functions #####\r\n  ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the RCC Clocks\r\n    frequencies.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Selects the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).\r\n  * @note   PA8/PC9 should be configured in alternate function mode.\r\n  * @param  RCC_MCOx specifies the output direction for the clock source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCO1: Clock source to output on MCO1 pin(PA8).\r\n  *            @arg RCC_MCO2: Clock source to output on MCO2 pin(PC9).\r\n  * @param  RCC_MCOSource specifies the clock source to output.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source\r\n  *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source\r\n  * @param  RCC_MCODiv specifies the MCOx prescaler.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCODIV_1: no division applied to MCOx clock\r\n  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock\r\n  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock\r\n  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock\r\n  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)\r\n{\r\n  GPIO_InitTypeDef GPIO_InitStruct;\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_MCO(RCC_MCOx));\r\n  assert_param(IS_RCC_MCODIV(RCC_MCODiv));\r\n  /* RCC_MCO1 */\r\n  if (RCC_MCOx == RCC_MCO1)\r\n  {\r\n    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));\r\n\r\n    /* MCO1 Clock Enable */\r\n    MCO1_CLK_ENABLE();\r\n\r\n    /* Configure the MCO1 pin in alternate function mode */\r\n    GPIO_InitStruct.Pin = MCO1_PIN;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\r\n    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);\r\n\r\n    /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */\r\n    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));\r\n  }\r\n  else\r\n  {\r\n    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));\r\n\r\n    /* MCO2 Clock Enable */\r\n    MCO2_CLK_ENABLE();\r\n\r\n    /* Configure the MCO2 pin in alternate function mode */\r\n    GPIO_InitStruct.Pin = MCO2_PIN;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\r\n    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);\r\n\r\n    /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */\r\n    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Enables the Clock Security System.\r\n  * @note   If a failure is detected on the HSE oscillator clock, this oscillator\r\n  *         is automatically disabled and an interrupt is generated to inform the\r\n  *         software about the failure (Clock Security System Interrupt, CSSI),\r\n  *         allowing the MCU to perform rescue operations. The CSSI is linked to\r\n  *         the Cortex-M7 NMI (Non-Maskable Interrupt) exception vector.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_EnableCSS(void)\r\n{\r\n  SET_BIT(RCC->CR, RCC_CR_CSSON);\r\n}\r\n\r\n/**\r\n  * @brief  Disables the Clock Security System.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_DisableCSS(void)\r\n{\r\n  CLEAR_BIT(RCC->CR, RCC_CR_CSSON);\r\n}\r\n\r\n/**\r\n  * @brief  Returns the SYSCLK frequency\r\n  *\r\n  * @note   The system frequency computed by this function is not the real\r\n  *         frequency in the chip. It is calculated based on the predefined\r\n  *         constant and the selected clock source:\r\n  * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)\r\n  * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)\r\n  * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**)\r\n  *           or HSI_VALUE(*) multiplied/divided by the PLL factors.\r\n  * @note     (*) HSI_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value\r\n  *               16 MHz) but the real value may vary depending on the variations\r\n  *               in voltage and temperature.\r\n  * @note     (**) HSE_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value\r\n  *                25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *                frequency of the crystal used. Otherwise, this function may\r\n  *                have wrong result.\r\n  *\r\n  * @note   The result of this function could be not correct when using fractional\r\n  *         value for HSE crystal.\r\n  *\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baudrate for the communication peripherals or configure other parameters.\r\n  *\r\n  * @note   Each time SYSCLK changes, this function must be called to update the\r\n  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  *\r\n  *\r\n  * @retval SYSCLK frequency\r\n  */\r\nuint32_t HAL_RCC_GetSysClockFreq(void)\r\n{\r\n  uint32_t pllm = 0, pllvco = 0, pllp = 0;\r\n  uint32_t sysclockfreq = 0;\r\n\r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n  switch (RCC->CFGR & RCC_CFGR_SWS)\r\n  {\r\n    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */\r\n    {\r\n      sysclockfreq = HSI_VALUE;\r\n      break;\r\n    }\r\n    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */\r\n    {\r\n      sysclockfreq = HSE_VALUE;\r\n      break;\r\n    }\r\n    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */\r\n    {\r\n      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n      SYSCLK = PLL_VCO / PLLP */\r\n      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;\r\n      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)\r\n      {\r\n        /* HSE used as PLL clock source */\r\n        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);\r\n      }\r\n      else\r\n      {\r\n        /* HSI used as PLL clock source */\r\n        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);\r\n      }\r\n      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);\r\n\r\n      sysclockfreq = pllvco / pllp;\r\n      break;\r\n    }\r\n    default:\r\n    {\r\n      sysclockfreq = HSI_VALUE;\r\n      break;\r\n    }\r\n  }\r\n  return sysclockfreq;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the HCLK frequency\r\n  * @note   Each time HCLK changes, this function must be called to update the\r\n  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.\r\n  * @retval HCLK frequency\r\n  */\r\nuint32_t HAL_RCC_GetHCLKFreq(void)\r\n{\r\n  return SystemCoreClock;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the PCLK1 frequency\r\n  * @note   Each time PCLK1 changes, this function must be called to update the\r\n  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @retval PCLK1 frequency\r\n  */\r\nuint32_t HAL_RCC_GetPCLK1Freq(void)\r\n{\r\n  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);\r\n}\r\n\r\n/**\r\n  * @brief  Returns the PCLK2 frequency\r\n  * @note   Each time PCLK2 changes, this function must be called to update the\r\n  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @retval PCLK2 frequency\r\n  */\r\nuint32_t HAL_RCC_GetPCLK2Freq(void)\r\n{\r\n  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_OscInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that\r\n  * will be configured.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\r\n{\r\n  /* Set all possible values for the Oscillator type parameter ---------------*/\r\n  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;\r\n\r\n  /* Get the HSE configuration -----------------------------------------------*/\r\n  if ((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\r\n  }\r\n  else if ((RCC->CR & RCC_CR_HSEON) == RCC_CR_HSEON)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\r\n  }\r\n\r\n  /* Get the HSI configuration -----------------------------------------------*/\r\n  if ((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)\r\n  {\r\n    RCC_OscInitStruct->HSIState = RCC_HSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;\r\n  }\r\n\r\n  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR & RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);\r\n\r\n  /* Get the LSE configuration -----------------------------------------------*/\r\n  if ((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\r\n  }\r\n  else if ((RCC->BDCR & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\r\n  }\r\n\r\n  /* Get the LSI configuration -----------------------------------------------*/\r\n  if ((RCC->CSR & RCC_CSR_LSION) == RCC_CSR_LSION)\r\n  {\r\n    RCC_OscInitStruct->LSIState = RCC_LSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;\r\n  }\r\n\r\n  /* Get the PLL configuration -----------------------------------------------*/\r\n  if ((RCC->CR & RCC_CR_PLLON) == RCC_CR_PLLON)\r\n  {\r\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;\r\n  }\r\n  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);\r\n  RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);\r\n  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);\r\n  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1) >> RCC_PLLCFGR_PLLP_Pos);\r\n  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos);\r\n#if defined (RCC_PLLCFGR_PLLR)\r\n  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR));\r\n#endif\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_ClkInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that\r\n  * will be configured.\r\n  * @param  pFLatency Pointer on the Flash Latency.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)\r\n{\r\n  /* Set all possible values for the Clock type parameter --------------------*/\r\n  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\r\n\r\n  /* Get the SYSCLK configuration --------------------------------------------*/\r\n  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);\r\n\r\n  /* Get the HCLK configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);\r\n\r\n  /* Get the APB1 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);\r\n\r\n  /* Get the APB2 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);\r\n\r\n  /* Get the Flash Wait State (Latency) configuration ------------------------*/\r\n  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);\r\n}\r\n\r\n/**\r\n  * @brief This function handles the RCC CSS interrupt request.\r\n  * @note This API should be called under the NMI_Handler().\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_NMI_IRQHandler(void)\r\n{\r\n  /* Check RCC CSSF flag  */\r\n  if (__HAL_RCC_GET_IT(RCC_IT_CSS))\r\n  {\r\n    /* RCC Clock Security System interrupt user callback */\r\n    HAL_RCC_CSSCallback();\r\n\r\n    /* Clear RCC CSS pending bit */\r\n    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  RCC Clock Security System interrupt callback\r\n  * @retval None\r\n  */\r\n__weak void HAL_RCC_CSSCallback(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_RCC_CSSCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_RCC_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_rcc_ex.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_rcc_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extension RCC HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities RCC extension peripheral:\r\n  *           + Extended Peripheral Control functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCCEx RCCEx\r\n  * @brief RCCEx HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_RCC_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @defgroup RCCEx_Private_Defines RCCEx Private Defines\r\n  * @{\r\n  */\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/** @defgroup RCCEx_Private_Macros RCCEx Private Macros\r\n * @{\r\n */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup RCCEx_Private_Macros RCCEx Private Macros\r\n * @{\r\n */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions\r\n *  @brief  Extended Peripheral Control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                ##### Extended Peripheral Control functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the RCC Clocks\r\n    frequencies.\r\n    [..]\r\n    (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to\r\n        select the RTC clock source; in this case the Backup domain will be reset in\r\n        order to modify the RTC Clock source, as consequence RTC registers (including\r\n        the backup registers) and RCC_BDCR register will be set to their reset values.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n#if defined (STM32F745xx) || defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F765xx) || \\\r\n    defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || \\\r\n    defined (STM32F750xx)\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified\r\n  *         parameters in the RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals\r\n  *         clocks(I2S, SAI, LTDC, RTC, TIM, UARTs, USARTs, LTPIM, SDMMC...).\r\n  *\r\n  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select\r\n  *         the RTC clock source; in this case the Backup domain will be reset in\r\n  *         order to modify the RTC Clock source, as consequence RTC registers (including\r\n  *         the backup registers) are set to their reset values.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tickstart = 0;\r\n  uint32_t tmpreg0 = 0;\r\n  uint32_t tmpreg1 = 0;\r\n  uint32_t plli2sused = 0;\r\n  uint32_t pllsaiused = 0;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));\r\n\r\n  /*----------------------------------- I2S configuration ----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));\r\n\r\n    /* Configure I2S Clock source */\r\n    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);\r\n\r\n    /* Enable the PLLI2S when it's used as clock source for I2S */\r\n    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1;\r\n    }\r\n  }\r\n\r\n  /*------------------------------------ SAI1 configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));\r\n\r\n    /* Configure SAI1 Clock source */\r\n    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1;\r\n    }\r\n    /* Enable the PLLSAI when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)\r\n    {\r\n      pllsaiused = 1;\r\n    }\r\n  }\r\n\r\n  /*------------------------------------ SAI2 configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));\r\n\r\n    /* Configure SAI2 Clock source */\r\n    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);\r\n\r\n    /* Enable the PLLI2S when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1;\r\n    }\r\n    /* Enable the PLLSAI when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)\r\n    {\r\n      pllsaiused = 1;\r\n    }\r\n  }\r\n\r\n  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)\r\n  {\r\n      plli2sused = 1;\r\n  }\r\n\r\n  /*------------------------------------ RTC configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))\r\n  {\r\n    /* Check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable Power Clock*/\r\n    __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR1 |= PWR_CR1_DBP;\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait for Backup domain Write protection disable */\r\n    while((PWR->CR1 & PWR_CR1_DBP) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Reset the Backup domain only if the RTC Clock source selection is modified */\r\n    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);\r\n\r\n    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))\r\n    {\r\n      /* Store the content of BDCR register before the reset of Backup Domain */\r\n      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n\r\n      /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n      __HAL_RCC_BACKUPRESET_FORCE();\r\n      __HAL_RCC_BACKUPRESET_RELEASE();\r\n\r\n      /* Restore the Content of BDCR register */\r\n      RCC->BDCR = tmpreg0;\r\n\r\n      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */\r\n      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n  }\r\n\r\n  /*------------------------------------ TIM configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));\r\n\r\n    /* Configure Timer Prescaler */\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n\r\n  /*-------------------------------------- I2C1 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));\r\n\r\n    /* Configure the I2C1 clock source */\r\n    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- I2C2 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));\r\n\r\n    /* Configure the I2C2 clock source */\r\n    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- I2C3 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));\r\n\r\n    /* Configure the I2C3 clock source */\r\n    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- I2C4 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));\r\n\r\n    /* Configure the I2C4 clock source */\r\n    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- USART1 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));\r\n\r\n    /* Configure the USART1 clock source */\r\n    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- USART2 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));\r\n\r\n    /* Configure the USART2 clock source */\r\n    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- USART3 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));\r\n\r\n    /* Configure the USART3 clock source */\r\n    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- UART4 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));\r\n\r\n    /* Configure the UART4 clock source */\r\n    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- UART5 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));\r\n\r\n    /* Configure the UART5 clock source */\r\n    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- USART6 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));\r\n\r\n    /* Configure the USART6 clock source */\r\n    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- UART7 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));\r\n\r\n    /* Configure the UART7 clock source */\r\n    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- UART8 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));\r\n\r\n    /* Configure the UART8 clock source */\r\n    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);\r\n  }\r\n\r\n  /*--------------------------------------- CEC Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));\r\n\r\n    /* Configure the CEC clock source */\r\n    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- CK48 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));\r\n\r\n    /* Configure the CLK48 source */\r\n    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);\r\n\r\n    /* Enable the PLLSAI when it's used as clock source for CK48 */\r\n    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)\r\n    {\r\n      pllsaiused = 1;\r\n    }\r\n  }\r\n\r\n  /*-------------------------------------- LTDC Configuration -----------------------------------*/\r\n#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)\r\n  {\r\n    pllsaiused = 1;\r\n  }\r\n#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */\r\n\r\n  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));\r\n\r\n    /* Configure the LTPIM1 clock source */\r\n    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);\r\n   }\r\n\r\n  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));\r\n\r\n    /* Configure the SDMMC1 clock source */\r\n    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);\r\n  }\r\n\r\n#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)\r\n  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));\r\n\r\n    /* Configure the SDMMC2 clock source */\r\n    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);\r\n  }\r\n\r\n  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));\r\n\r\n    /* Configure the DFSDM1 interface clock source */\r\n    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);\r\n  }\r\n\r\n  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));\r\n\r\n    /* Configure the DFSDM interface clock source */\r\n    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);\r\n  }\r\n#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */\r\n\r\n  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/\r\n  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */\r\n  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))\r\n  {\r\n    /* Disable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_DISABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLLI2S is disabled */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* check for common PLLI2S Parameters */\r\n    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));\r\n\r\n    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n\r\n      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */\r\n      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);\r\n      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */\r\n      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))\r\n    {\r\n      /* Check for PLLI2S Parameters */\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n      /* Check for PLLI2S/DIVQ parameters */\r\n      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));\r\n\r\n      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */\r\n      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);\r\n      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */\r\n      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);\r\n    }\r\n\r\n    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));\r\n\r\n     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */\r\n      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */\r\n      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);\r\n    }\r\n\r\n    /*----------------- In Case of PLLI2S is just selected  -----------------*/\r\n    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)\r\n    {\r\n      /* Check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */\r\n      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /* Enable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_ENABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLLI2S is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/\r\n  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */\r\n  if(pllsaiused == 1)\r\n  {\r\n    /* Disable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_DISABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLLSAI is disabled */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Check the PLLSAI division factors */\r\n    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));\r\n\r\n    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\\\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))\r\n    {\r\n      /* check for PLLSAIQ Parameter */\r\n      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));\r\n      /* check for PLLSAI/DIVQ Parameter */\r\n      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));\r\n\r\n      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */\r\n      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);\r\n      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */\r\n      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);\r\n    }\r\n\r\n    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/\r\n    /* In Case of PLLI2S is selected as source clock for CK48 */\r\n    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));\r\n      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */\r\n      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);\r\n\r\n      /* Configure the PLLSAI division factors */\r\n      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */\r\n      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);\r\n    }\r\n\r\n#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)\r\n    /*---------------------------- LTDC configuration -------------------------------*/\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))\r\n    {\r\n      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));\r\n      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));\r\n\r\n      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */\r\n      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);\r\n\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);\r\n\r\n      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */\r\n      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);\r\n    }\r\n#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */\r\n\r\n    /* Enable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_ENABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLLSAI is ready */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Get the RCC_PeriphCLKInitTypeDef according to the internal\r\n  *         RCC configuration registers.\r\n  * @param  PeriphClkInit pointer to the configured RCC_PeriphCLKInitTypeDef structure\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tempreg = 0;\r\n\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\\\r\n                                        RCC_PERIPHCLK_SAI1     | RCC_PERIPHCLK_SAI2     |\\\r\n                                        RCC_PERIPHCLK_TIM      | RCC_PERIPHCLK_RTC      |\\\r\n                                        RCC_PERIPHCLK_CEC      | RCC_PERIPHCLK_I2C4     |\\\r\n                                        RCC_PERIPHCLK_I2C1     | RCC_PERIPHCLK_I2C2     |\\\r\n                                        RCC_PERIPHCLK_I2C3     | RCC_PERIPHCLK_USART1   |\\\r\n                                        RCC_PERIPHCLK_USART2   | RCC_PERIPHCLK_USART3   |\\\r\n                                        RCC_PERIPHCLK_UART4    | RCC_PERIPHCLK_UART5    |\\\r\n                                        RCC_PERIPHCLK_USART6   | RCC_PERIPHCLK_UART7    |\\\r\n                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\\\r\n                                        RCC_PERIPHCLK_CLK48    | RCC_PERIPHCLK_SDMMC2   |\\\r\n                                        RCC_PERIPHCLK_DFSDM1   | RCC_PERIPHCLK_DFSDM1_AUDIO;\r\n#else\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\\\r\n                                        RCC_PERIPHCLK_SAI1     | RCC_PERIPHCLK_SAI2     |\\\r\n                                        RCC_PERIPHCLK_TIM      | RCC_PERIPHCLK_RTC      |\\\r\n                                        RCC_PERIPHCLK_CEC      | RCC_PERIPHCLK_I2C4     |\\\r\n                                        RCC_PERIPHCLK_I2C1     | RCC_PERIPHCLK_I2C2     |\\\r\n                                        RCC_PERIPHCLK_I2C3     | RCC_PERIPHCLK_USART1   |\\\r\n                                        RCC_PERIPHCLK_USART2   | RCC_PERIPHCLK_USART3   |\\\r\n                                        RCC_PERIPHCLK_UART4    | RCC_PERIPHCLK_UART5    |\\\r\n                                        RCC_PERIPHCLK_USART6   | RCC_PERIPHCLK_UART7    |\\\r\n                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\\\r\n                                        RCC_PERIPHCLK_CLK48;\r\n#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */\r\n\r\n  /* Get the PLLI2S Clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SP = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n\r\n  /* Get the PLLSAI Clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIP = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);\r\n\r\n  /* Get the PLLSAI/PLLI2S division factors -------------------------------------------*/\r\n  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) >> RCC_DCKCFGR1_PLLI2SDIVQ_Pos);\r\n  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> RCC_DCKCFGR1_PLLSAIDIVQ_Pos);\r\n  PeriphClkInit->PLLSAIDivR = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVR) >> RCC_DCKCFGR1_PLLSAIDIVR_Pos);\r\n\r\n  /* Get the SAI1 clock configuration ----------------------------------------------*/\r\n  PeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();\r\n\r\n  /* Get the SAI2 clock configuration ----------------------------------------------*/\r\n  PeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();\r\n\r\n  /* Get the I2S clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2sClockSelection = __HAL_RCC_GET_I2SCLKSOURCE();\r\n\r\n  /* Get the I2C1 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();\r\n\r\n  /* Get the I2C2 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2c2ClockSelection = __HAL_RCC_GET_I2C2_SOURCE();\r\n\r\n  /* Get the I2C3 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2c3ClockSelection = __HAL_RCC_GET_I2C3_SOURCE();\r\n\r\n  /* Get the I2C4 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2c4ClockSelection = __HAL_RCC_GET_I2C4_SOURCE();\r\n\r\n  /* Get the USART1 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();\r\n\r\n  /* Get the USART2 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();\r\n\r\n  /* Get the USART3 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();\r\n\r\n  /* Get the UART4 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Uart4ClockSelection = __HAL_RCC_GET_UART4_SOURCE();\r\n\r\n  /* Get the UART5 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Uart5ClockSelection = __HAL_RCC_GET_UART5_SOURCE();\r\n\r\n  /* Get the USART6 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Usart6ClockSelection = __HAL_RCC_GET_USART6_SOURCE();\r\n\r\n  /* Get the UART7 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Uart7ClockSelection = __HAL_RCC_GET_UART7_SOURCE();\r\n\r\n  /* Get the UART8 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Uart8ClockSelection = __HAL_RCC_GET_UART8_SOURCE();\r\n\r\n  /* Get the LPTIM1 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();\r\n\r\n  /* Get the CEC clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();\r\n\r\n  /* Get the CK48 clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();\r\n\r\n  /* Get the SDMMC1 clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->Sdmmc1ClockSelection = __HAL_RCC_GET_SDMMC1_SOURCE();\r\n\r\n#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)\r\n  /* Get the SDMMC2 clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->Sdmmc2ClockSelection = __HAL_RCC_GET_SDMMC2_SOURCE();\r\n\r\n  /* Get the DFSDM clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->Dfsdm1ClockSelection = __HAL_RCC_GET_DFSDM1_SOURCE();\r\n\r\n  /* Get the DFSDM AUDIO clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->Dfsdm1AudioClockSelection = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();\r\n#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */\r\n\r\n  /* Get the RTC Clock configuration -----------------------------------------------*/\r\n  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);\r\n  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));\r\n\r\n  /* Get the TIM Prescaler configuration --------------------------------------------*/\r\n  if ((RCC->DCKCFGR1 & RCC_DCKCFGR1_TIMPRE) == RESET)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n}\r\n#endif /* STM32F745xx || STM32F746xx || STM32F756xx || STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */\r\n\r\n#if defined (STM32F722xx) || defined (STM32F723xx) || defined (STM32F732xx) || defined (STM32F733xx) || defined (STM32F730xx)\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified\r\n  *         parameters in the RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals\r\n  *         clocks(I2S, SAI, RTC, TIM, UARTs, USARTs, LTPIM, SDMMC...).\r\n  *\r\n  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select\r\n  *         the RTC clock source; in this case the Backup domain will be reset in\r\n  *         order to modify the RTC Clock source, as consequence RTC registers (including\r\n  *         the backup registers) are set to their reset values.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tickstart = 0;\r\n  uint32_t tmpreg0 = 0;\r\n  uint32_t plli2sused = 0;\r\n  uint32_t pllsaiused = 0;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));\r\n\r\n  /*----------------------------------- I2S configuration ----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));\r\n\r\n    /* Configure I2S Clock source */\r\n    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);\r\n\r\n    /* Enable the PLLI2S when it's used as clock source for I2S */\r\n    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1;\r\n    }\r\n  }\r\n\r\n  /*------------------------------------ SAI1 configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));\r\n\r\n    /* Configure SAI1 Clock source */\r\n    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1;\r\n    }\r\n    /* Enable the PLLSAI when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)\r\n    {\r\n      pllsaiused = 1;\r\n    }\r\n  }\r\n\r\n  /*------------------------------------ SAI2 configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));\r\n\r\n    /* Configure SAI2 Clock source */\r\n    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);\r\n\r\n    /* Enable the PLLI2S when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1;\r\n    }\r\n    /* Enable the PLLSAI when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)\r\n    {\r\n      pllsaiused = 1;\r\n    }\r\n  }\r\n\r\n  /*------------------------------------ RTC configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))\r\n  {\r\n    /* Check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable Power Clock*/\r\n    __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR1 |= PWR_CR1_DBP;\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait for Backup domain Write protection disable */\r\n    while((PWR->CR1 & PWR_CR1_DBP) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Reset the Backup domain only if the RTC Clock source selection is modified */\r\n    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);\r\n\r\n    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))\r\n    {\r\n      /* Store the content of BDCR register before the reset of Backup Domain */\r\n      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n\r\n      /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n      __HAL_RCC_BACKUPRESET_FORCE();\r\n      __HAL_RCC_BACKUPRESET_RELEASE();\r\n\r\n      /* Restore the Content of BDCR register */\r\n      RCC->BDCR = tmpreg0;\r\n\r\n      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */\r\n      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n  }\r\n\r\n  /*------------------------------------ TIM configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));\r\n\r\n    /* Configure Timer Prescaler */\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n\r\n  /*-------------------------------------- I2C1 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));\r\n\r\n    /* Configure the I2C1 clock source */\r\n    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- I2C2 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));\r\n\r\n    /* Configure the I2C2 clock source */\r\n    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- I2C3 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));\r\n\r\n    /* Configure the I2C3 clock source */\r\n    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- USART1 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));\r\n\r\n    /* Configure the USART1 clock source */\r\n    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- USART2 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));\r\n\r\n    /* Configure the USART2 clock source */\r\n    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- USART3 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));\r\n\r\n    /* Configure the USART3 clock source */\r\n    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- UART4 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));\r\n\r\n    /* Configure the UART4 clock source */\r\n    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- UART5 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));\r\n\r\n    /* Configure the UART5 clock source */\r\n    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- USART6 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));\r\n\r\n    /* Configure the USART6 clock source */\r\n    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- UART7 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));\r\n\r\n    /* Configure the UART7 clock source */\r\n    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- UART8 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));\r\n\r\n    /* Configure the UART8 clock source */\r\n    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- CK48 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));\r\n\r\n    /* Configure the CLK48 source */\r\n    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);\r\n\r\n    /* Enable the PLLSAI when it's used as clock source for CK48 */\r\n    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)\r\n    {\r\n      pllsaiused = 1;\r\n    }\r\n  }\r\n\r\n  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));\r\n\r\n    /* Configure the LTPIM1 clock source */\r\n    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);\r\n   }\r\n\r\n  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));\r\n\r\n    /* Configure the SDMMC1 clock source */\r\n    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);\r\n  }\r\n\r\n  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));\r\n\r\n    /* Configure the SDMMC2 clock source */\r\n    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);\r\n  }\r\n\r\n  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/\r\n  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2 or I2S */\r\n  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))\r\n  {\r\n    /* Disable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_DISABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLLI2S is disabled */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* check for common PLLI2S Parameters */\r\n    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));\r\n\r\n    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n\r\n      /* Read PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */\r\n      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */\r\n      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))\r\n    {\r\n      /* Check for PLLI2S Parameters */\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n      /* Check for PLLI2S/DIVQ parameters */\r\n      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));\r\n\r\n      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */\r\n      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg0);\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */\r\n      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);\r\n    }\r\n\r\n    /*----------------- In Case of PLLI2S is just selected  -----------------*/\r\n    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)\r\n    {\r\n      /* Check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /* Enable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_ENABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLLI2S is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/\r\n  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */\r\n  if(pllsaiused == 1)\r\n  {\r\n    /* Disable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_DISABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLLSAI is disabled */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Check the PLLSAI division factors */\r\n    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));\r\n\r\n    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\\\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))\r\n    {\r\n      /* check for PLLSAIQ Parameter */\r\n      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));\r\n      /* check for PLLSAI/DIVQ Parameter */\r\n      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));\r\n\r\n      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */\r\n      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ);\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */\r\n      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);\r\n    }\r\n\r\n    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/\r\n    /* In Case of PLLI2S is selected as source clock for CK48 */\r\n    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));\r\n      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */\r\n      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n\r\n      /* Configure the PLLSAI division factors */\r\n      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */\r\n      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0);\r\n    }\r\n\r\n    /* Enable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_ENABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLLSAI is ready */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Get the RCC_PeriphCLKInitTypeDef according to the internal\r\n  *         RCC configuration registers.\r\n  * @param  PeriphClkInit pointer to the configured RCC_PeriphCLKInitTypeDef structure\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tempreg = 0;\r\n\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\\\r\n                                        RCC_PERIPHCLK_SAI1     | RCC_PERIPHCLK_SAI2     |\\\r\n                                        RCC_PERIPHCLK_TIM      | RCC_PERIPHCLK_RTC      |\\\r\n                                        RCC_PERIPHCLK_I2C1     | RCC_PERIPHCLK_I2C2     |\\\r\n                                        RCC_PERIPHCLK_I2C3     | RCC_PERIPHCLK_USART1   |\\\r\n                                        RCC_PERIPHCLK_USART2   | RCC_PERIPHCLK_USART3   |\\\r\n                                        RCC_PERIPHCLK_UART4    | RCC_PERIPHCLK_UART5    |\\\r\n                                        RCC_PERIPHCLK_USART6   | RCC_PERIPHCLK_UART7    |\\\r\n                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\\\r\n                                        RCC_PERIPHCLK_CLK48    | RCC_PERIPHCLK_SDMMC2;\r\n\r\n  /* Get the PLLI2S Clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n\r\n  /* Get the PLLSAI Clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIP = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n\r\n  /* Get the PLLSAI/PLLI2S division factors -------------------------------------------*/\r\n  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) >> RCC_DCKCFGR1_PLLI2SDIVQ_Pos);\r\n  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> RCC_DCKCFGR1_PLLSAIDIVQ_Pos);\r\n\r\n  /* Get the SAI1 clock configuration ----------------------------------------------*/\r\n  PeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();\r\n\r\n  /* Get the SAI2 clock configuration ----------------------------------------------*/\r\n  PeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();\r\n\r\n  /* Get the I2S clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2sClockSelection = __HAL_RCC_GET_I2SCLKSOURCE();\r\n\r\n  /* Get the I2C1 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();\r\n\r\n  /* Get the I2C2 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2c2ClockSelection = __HAL_RCC_GET_I2C2_SOURCE();\r\n\r\n  /* Get the I2C3 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->I2c3ClockSelection = __HAL_RCC_GET_I2C3_SOURCE();\r\n\r\n  /* Get the USART1 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();\r\n\r\n  /* Get the USART2 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();\r\n\r\n  /* Get the USART3 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();\r\n\r\n  /* Get the UART4 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Uart4ClockSelection = __HAL_RCC_GET_UART4_SOURCE();\r\n\r\n  /* Get the UART5 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Uart5ClockSelection = __HAL_RCC_GET_UART5_SOURCE();\r\n\r\n  /* Get the USART6 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Usart6ClockSelection = __HAL_RCC_GET_USART6_SOURCE();\r\n\r\n  /* Get the UART7 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Uart7ClockSelection = __HAL_RCC_GET_UART7_SOURCE();\r\n\r\n  /* Get the UART8 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Uart8ClockSelection = __HAL_RCC_GET_UART8_SOURCE();\r\n\r\n  /* Get the LPTIM1 clock configuration ------------------------------------------*/\r\n  PeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();\r\n\r\n  /* Get the CK48 clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();\r\n\r\n  /* Get the SDMMC1 clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->Sdmmc1ClockSelection = __HAL_RCC_GET_SDMMC1_SOURCE();\r\n\r\n  /* Get the SDMMC2 clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->Sdmmc2ClockSelection = __HAL_RCC_GET_SDMMC2_SOURCE();\r\n\r\n  /* Get the RTC Clock configuration -----------------------------------------------*/\r\n  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);\r\n  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));\r\n\r\n  /* Get the TIM Prescaler configuration --------------------------------------------*/\r\n  if ((RCC->DCKCFGR1 & RCC_DCKCFGR1_TIMPRE) == RESET)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n}\r\n#endif /* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F730xx */\r\n\r\n/**\r\n  * @brief  Return the peripheral clock frequency for a given peripheral(SAI..)\r\n  * @note   Return 0 if peripheral clock identifier not managed by this API\r\n  * @param  PeriphClk Peripheral clock identifier\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_PERIPHCLK_SAI1: SAI1 peripheral clock\r\n  *            @arg RCC_PERIPHCLK_SAI2: SAI2 peripheral clock\r\n  * @retval Frequency in KHz\r\n  */\r\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\r\n{\r\n  uint32_t tmpreg = 0;\r\n  /* This variable is used to store the SAI clock frequency (value in Hz) */\r\n  uint32_t frequency = 0;\r\n  /* This variable is used to store the VCO Input (value in Hz) */\r\n  uint32_t vcoinput = 0;\r\n  /* This variable is used to store the SAI clock source */\r\n  uint32_t saiclocksource = 0;\r\n\r\n  if (PeriphClk == RCC_PERIPHCLK_SAI1)\r\n  {\r\n    saiclocksource = RCC->DCKCFGR1;\r\n    saiclocksource &= RCC_DCKCFGR1_SAI1SEL;\r\n    switch (saiclocksource)\r\n    {\r\n    case 0: /* PLLSAI is the clock source for SAI1 */\r\n      {\r\n        /* Configure the PLLSAI division factor */\r\n        /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n        {\r\n          /* In Case the PLL Source is HSI (Internal Clock) */\r\n          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n        }\r\n        else\r\n        {\r\n          /* In Case the PLL Source is HSE (External Clock) */\r\n          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));\r\n        }\r\n        /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n        /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */\r\n        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;\r\n        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);\r\n\r\n        /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */\r\n        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);\r\n        frequency = frequency/(tmpreg);\r\n        break;\r\n      }\r\n    case RCC_DCKCFGR1_SAI1SEL_0: /* PLLI2S is the clock source for SAI1 */\r\n      {\r\n        /* Configure the PLLI2S division factor */\r\n        /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */\r\n        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n        {\r\n          /* In Case the PLL Source is HSI (Internal Clock) */\r\n          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n        }\r\n        else\r\n        {\r\n          /* In Case the PLL Source is HSE (External Clock) */\r\n          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));\r\n        }\r\n\r\n        /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n        /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;\r\n        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);\r\n\r\n        /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */\r\n        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);\r\n        frequency = frequency/(tmpreg);\r\n        break;\r\n      }\r\n    case RCC_DCKCFGR1_SAI1SEL_1: /* External clock is the clock source for SAI1 */\r\n      {\r\n        frequency = EXTERNAL_CLOCK_VALUE;\r\n        break;\r\n      }\r\n#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)\r\n    case RCC_DCKCFGR1_SAI1SEL: /* HSI or HSE is the clock source for SAI*/\r\n      {\r\n        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n        {\r\n          /* In Case the main PLL Source is HSI */\r\n          frequency = HSI_VALUE;\r\n        }\r\n        else\r\n        {\r\n          /* In Case the main PLL Source is HSE */\r\n          frequency = HSE_VALUE;\r\n        }\r\n        break;\r\n      }\r\n#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */\r\n    default :\r\n      {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (PeriphClk == RCC_PERIPHCLK_SAI2)\r\n  {\r\n    saiclocksource = RCC->DCKCFGR1;\r\n    saiclocksource &= RCC_DCKCFGR1_SAI2SEL;\r\n    switch (saiclocksource)\r\n    {\r\n    case 0: /* PLLSAI is the clock source for SAI*/\r\n      {\r\n        /* Configure the PLLSAI division factor */\r\n        /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n        {\r\n          /* In Case the PLL Source is HSI (Internal Clock) */\r\n          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n        }\r\n        else\r\n        {\r\n          /* In Case the PLL Source is HSE (External Clock) */\r\n          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));\r\n        }\r\n        /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n        /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */\r\n        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;\r\n        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);\r\n\r\n        /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */\r\n        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);\r\n        frequency = frequency/(tmpreg);\r\n        break;\r\n      }\r\n    case RCC_DCKCFGR1_SAI2SEL_0: /* PLLI2S is the clock source for SAI2 */\r\n      {\r\n        /* Configure the PLLI2S division factor */\r\n        /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */\r\n        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n        {\r\n          /* In Case the PLL Source is HSI (Internal Clock) */\r\n          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n        }\r\n        else\r\n        {\r\n          /* In Case the PLL Source is HSE (External Clock) */\r\n          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));\r\n        }\r\n\r\n        /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n        /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;\r\n        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);\r\n\r\n        /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */\r\n        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);\r\n        frequency = frequency/(tmpreg);\r\n        break;\r\n      }\r\n    case RCC_DCKCFGR1_SAI2SEL_1: /* External clock is the clock source for SAI2 */\r\n      {\r\n        frequency = EXTERNAL_CLOCK_VALUE;\r\n        break;\r\n      }\r\n#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)\r\n    case RCC_DCKCFGR1_SAI2SEL: /* HSI or HSE is the clock source for SAI2 */\r\n      {\r\n        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n        {\r\n          /* In Case the main PLL Source is HSI */\r\n          frequency = HSI_VALUE;\r\n        }\r\n        else\r\n        {\r\n          /* In Case the main PLL Source is HSE */\r\n          frequency = HSE_VALUE;\r\n        }\r\n        break;\r\n      }\r\n#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */\r\n    default :\r\n      {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return frequency;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup RCCEx_Exported_Functions_Group2 Extended Clock management functions\r\n *  @brief  Extended Clock management functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                ##### Extended clock management functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the\r\n    activation or deactivation of PLLI2S, PLLSAI.\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Enable PLLI2S.\r\n  * @param  PLLI2SInit  pointer to an RCC_PLLI2SInitTypeDef structure that\r\n  *         contains the configuration information for the PLLI2S\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check for parameters */\r\n  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SInit->PLLI2SN));\r\n  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SInit->PLLI2SR));\r\n  assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SInit->PLLI2SQ));\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SP)\r\n  assert_param(IS_RCC_PLLI2SP_VALUE(PLLI2SInit->PLLI2SP));\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SP */\r\n\r\n  /* Disable the PLLI2S */\r\n  __HAL_RCC_PLLI2S_DISABLE();\r\n\r\n  /* Wait till PLLI2S is disabled */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Configure the PLLI2S division factors */\r\n#if defined (STM32F722xx) || defined (STM32F723xx) || defined (STM32F732xx) || defined (STM32F733xx) || defined (STM32F730xx)\r\n  /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * PLLI2SN */\r\n  /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */\r\n  /* I2SRCLK = PLLI2S_VCO / PLLI2SR */\r\n  __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);\r\n#else\r\n  /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * PLLI2SN */\r\n  /* I2SPCLK = PLLI2S_VCO / PLLI2SP */\r\n  /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */\r\n  /* I2SRCLK = PLLI2S_VCO / PLLI2SR */\r\n  __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SP, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);\r\n#endif /* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F730xx */\r\n\r\n  /* Enable the PLLI2S */\r\n  __HAL_RCC_PLLI2S_ENABLE();\r\n\r\n  /* Wait till PLLI2S is ready */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) == RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Disable PLLI2S.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_DisablePLLI2S(void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Disable the PLLI2S */\r\n  __HAL_RCC_PLLI2S_DISABLE();\r\n\r\n  /* Wait till PLLI2S is disabled */\r\n  tickstart = HAL_GetTick();\r\n  while(READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Enable PLLSAI.\r\n  * @param  PLLSAIInit  pointer to an RCC_PLLSAIInitTypeDef structure that\r\n  *         contains the configuration information for the PLLSAI\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI(RCC_PLLSAIInitTypeDef  *PLLSAIInit)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check for parameters */\r\n  assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIInit->PLLSAIN));\r\n  assert_param(IS_RCC_PLLSAIQ_VALUE(PLLSAIInit->PLLSAIQ));\r\n  assert_param(IS_RCC_PLLSAIP_VALUE(PLLSAIInit->PLLSAIP));\r\n#if defined(RCC_PLLSAICFGR_PLLSAIR)\r\n  assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIInit->PLLSAIR));\r\n#endif /* RCC_PLLSAICFGR_PLLSAIR */\r\n\r\n  /* Disable the PLLSAI */\r\n  __HAL_RCC_PLLSAI_DISABLE();\r\n\r\n  /* Wait till PLLSAI is disabled */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Configure the PLLSAI division factors */\r\n#if defined (STM32F722xx) || defined (STM32F723xx) || defined (STM32F732xx) || defined (STM32F733xx) || defined (STM32F730xx)\r\n  /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * PLLSAIN */\r\n  /* SAIPCLK = PLLSAI_VCO / PLLSAIP */\r\n  /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */\r\n  __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIN, PLLSAIInit->PLLSAIP, PLLSAIInit->PLLSAIQ);\r\n#else\r\n  /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * PLLSAIN */\r\n  /* SAIPCLK = PLLSAI_VCO / PLLSAIP */\r\n  /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */\r\n  /* SAIRCLK = PLLSAI_VCO / PLLSAIR */\r\n  __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIN, PLLSAIInit->PLLSAIP, \\\r\n                          PLLSAIInit->PLLSAIQ, PLLSAIInit->PLLSAIR);\r\n#endif /* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F730xx */\r\n\r\n  /* Enable the PLLSAI */\r\n  __HAL_RCC_PLLSAI_ENABLE();\r\n\r\n  /* Wait till PLLSAI is ready */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Disable PLLSAI.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI(void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Disable the PLLSAI */\r\n  __HAL_RCC_PLLSAI_DISABLE();\r\n\r\n  /* Wait till PLLSAI is disabled */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_RCC_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32f7xx_hal_tim.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_tim.c\r\n  * @author  MCD Application Team\r\n  * @brief   TIM HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Timer (TIM) peripheral:\r\n  *           + TIM Time Base Initialization\r\n  *           + TIM Time Base Start\r\n  *           + TIM Time Base Start Interruption\r\n  *           + TIM Time Base Start DMA\r\n  *           + TIM Output Compare/PWM Initialization\r\n  *           + TIM Output Compare/PWM Channel Configuration\r\n  *           + TIM Output Compare/PWM  Start\r\n  *           + TIM Output Compare/PWM  Start Interruption\r\n  *           + TIM Output Compare/PWM Start DMA\r\n  *           + TIM Input Capture Initialization\r\n  *           + TIM Input Capture Channel Configuration\r\n  *           + TIM Input Capture Start\r\n  *           + TIM Input Capture Start Interruption\r\n  *           + TIM Input Capture Start DMA\r\n  *           + TIM One Pulse Initialization\r\n  *           + TIM One Pulse Channel Configuration\r\n  *           + TIM One Pulse Start\r\n  *           + TIM Encoder Interface Initialization\r\n  *           + TIM Encoder Interface Start\r\n  *           + TIM Encoder Interface Start Interruption\r\n  *           + TIM Encoder Interface Start DMA\r\n  *           + Commutation Event configuration with Interruption and DMA\r\n  *           + TIM OCRef clear configuration\r\n  *           + TIM External Clock configuration\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### TIMER Generic features #####\r\n  ==============================================================================\r\n  [..] The Timer features include:\r\n       (#) 16-bit up, down, up/down auto-reload counter.\r\n       (#) 16-bit programmable prescaler allowing dividing (also on the fly) the\r\n           counter clock frequency either by any factor between 1 and 65536.\r\n       (#) Up to 4 independent channels for:\r\n           (++) Input Capture\r\n           (++) Output Compare\r\n           (++) PWM generation (Edge and Center-aligned Mode)\r\n           (++) One-pulse mode output\r\n       (#) Synchronization circuit to control the timer with external signals and to interconnect\r\n            several timers together.\r\n       (#) Supports incremental encoder for positioning purposes\r\n\r\n            ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n     (#) Initialize the TIM low level resources by implementing the following functions\r\n         depending on the selected feature:\r\n           (++) Time Base : HAL_TIM_Base_MspInit()\r\n           (++) Input Capture : HAL_TIM_IC_MspInit()\r\n           (++) Output Compare : HAL_TIM_OC_MspInit()\r\n           (++) PWM generation : HAL_TIM_PWM_MspInit()\r\n           (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()\r\n           (++) Encoder mode output : HAL_TIM_Encoder_MspInit()\r\n\r\n     (#) Initialize the TIM low level resources :\r\n        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();\r\n        (##) TIM pins configuration\r\n            (+++) Enable the clock for the TIM GPIOs using the following function:\r\n             __HAL_RCC_GPIOx_CLK_ENABLE();\r\n            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();\r\n\r\n     (#) The external Clock can be configured, if needed (the default clock is the\r\n         internal clock from the APBx), using the following function:\r\n         HAL_TIM_ConfigClockSource, the clock configuration should be done before\r\n         any start function.\r\n\r\n     (#) Configure the TIM in the desired functioning mode using one of the\r\n       Initialization function of this driver:\r\n       (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base\r\n       (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an\r\n            Output Compare signal.\r\n       (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a\r\n            PWM signal.\r\n       (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an\r\n            external signal.\r\n       (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer\r\n            in One Pulse Mode.\r\n       (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.\r\n\r\n     (#) Activate the TIM peripheral using one of the start functions depending from the feature used:\r\n           (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()\r\n           (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()\r\n           (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()\r\n           (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()\r\n           (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()\r\n           (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().\r\n\r\n     (#) The DMA Burst is managed with the two following functions:\r\n         HAL_TIM_DMABurst_WriteStart()\r\n         HAL_TIM_DMABurst_ReadStart()\r\n\r\n    *** Callback registration ***\r\n  =============================================\r\n\r\n  [..]\r\n  The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1\r\n  allows the user to configure dynamically the driver callbacks.\r\n\r\n  [..]\r\n  Use Function HAL_TIM_RegisterCallback() to register a callback.\r\n  HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,\r\n  the Callback ID and a pointer to the user callback function.\r\n\r\n  [..]\r\n  Use function HAL_TIM_UnRegisterCallback() to reset a callback to the default\r\n  weak function.\r\n  HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,\r\n  and the Callback ID.\r\n\r\n  [..]\r\n  These functions allow to register/unregister following callbacks:\r\n    (+) Base_MspInitCallback              : TIM Base Msp Init Callback.\r\n    (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.\r\n    (+) IC_MspInitCallback                : TIM IC Msp Init Callback.\r\n    (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.\r\n    (+) OC_MspInitCallback                : TIM OC Msp Init Callback.\r\n    (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.\r\n    (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.\r\n    (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.\r\n    (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.\r\n    (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.\r\n    (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.\r\n    (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.\r\n    (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.\r\n    (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.\r\n    (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.\r\n    (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.\r\n    (+) TriggerCallback                   : TIM Trigger Callback.\r\n    (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.\r\n    (+) IC_CaptureCallback                : TIM Input Capture Callback.\r\n    (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.\r\n    (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.\r\n    (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.\r\n    (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.\r\n    (+) ErrorCallback                     : TIM Error Callback.\r\n    (+) CommutationCallback               : TIM Commutation Callback.\r\n    (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.\r\n    (+) BreakCallback                     : TIM Break Callback.\r\n    (+) Break2Callback                    : TIM Break2 Callback.\r\n\r\n  [..]\r\nBy default, after the Init and when the state is HAL_TIM_STATE_RESET\r\nall interrupt callbacks are set to the corresponding weak functions:\r\n  examples HAL_TIM_TriggerCallback(), HAL_TIM_ErrorCallback().\r\n\r\n  [..]\r\n  Exception done for MspInit and MspDeInit functions that are reset to the legacy weak\r\n  functionalities in the Init / DeInit only when these callbacks are null\r\n  (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit\r\n    keep and use the user MspInit / MspDeInit callbacks(registered beforehand)\r\n\r\n  [..]\r\n    Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.\r\n    Exception done MspInit / MspDeInit that can be registered / unregistered\r\n    in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,\r\n    thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.\r\n  In that case first register the MspInit/MspDeInit user callbacks\r\n      using HAL_TIM_RegisterCallback() before calling DeInit or Init function.\r\n\r\n  [..]\r\n      When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or\r\n      not defined, the callback registration feature is not available and all callbacks\r\n      are set to the corresponding weak functions.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIM TIM\r\n  * @brief TIM HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_TIM_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup TIM_Private_Functions\r\n  * @{\r\n  */\r\nstatic void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);\r\nstatic void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);\r\nstatic void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);\r\nstatic void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);\r\nstatic HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,\r\n                                                  TIM_SlaveConfigTypeDef *sSlaveConfig);\r\n/**\r\n  * @}\r\n  */\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup TIM_Exported_Functions TIM Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions\r\n  *  @brief    Time Base functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Time Base functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM base.\r\n    (+) De-initialize the TIM base.\r\n    (+) Start the Time Base.\r\n    (+) Stop the Time Base.\r\n    (+) Start the Time Base and enable interrupt.\r\n    (+) Stop the Time Base and disable interrupt.\r\n    (+) Start the Time Base and enable DMA transfer.\r\n    (+) Stop the Time Base and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Time base Unit according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initialize the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->Base_MspInitCallback == NULL)\r\n    {\r\n      htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->Base_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    HAL_TIM_Base_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Set the Time Base configuration */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Base peripheral\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->Base_MspDeInitCallback == NULL)\r\n  {\r\n    htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->Base_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_Base_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Base MSP.\r\n  * @param  htim TIM Base handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Base_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Base MSP.\r\n  * @param  htim TIM Base handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Base_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM state */\r\n  if (htim->State != HAL_TIM_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation in interrupt mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM state */\r\n  if (htim->State != HAL_TIM_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Enable the TIM Update interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation in interrupt mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the TIM Update interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation in DMA mode.\r\n  * @param  htim TIM Base handle\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM state */\r\n  if (htim->State == HAL_TIM_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->State = HAL_TIM_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the DMA Period elapsed callbacks */\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n  /* Enable the DMA stream */\r\n  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR,\r\n                       Length) != HAL_OK)\r\n  {\r\n    /* Return error status */\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the TIM Update DMA request */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation in DMA mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the TIM Update DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);\r\n\r\n  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions\r\n  *  @brief    TIM Output Compare functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                  ##### TIM Output Compare functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM Output Compare.\r\n    (+) De-initialize the TIM Output Compare.\r\n    (+) Start the TIM Output Compare.\r\n    (+) Stop the TIM Output Compare.\r\n    (+) Start the TIM Output Compare and enable interrupt.\r\n    (+) Stop the TIM Output Compare and disable interrupt.\r\n    (+) Start the TIM Output Compare and enable DMA transfer.\r\n    (+) Stop the TIM Output Compare and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Output Compare according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->OC_MspInitCallback == NULL)\r\n    {\r\n      htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->OC_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_OC_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the Output Compare */\r\n  TIM_Base_SetConfig(htim->Instance,  &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->OC_MspDeInitCallback == NULL)\r\n  {\r\n    htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->OC_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_OC_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Output Compare MSP.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Output Compare MSP.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Output compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Output compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in interrupt mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in interrupt mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in DMA mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in DMA mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions\r\n  *  @brief    TIM PWM functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                          ##### TIM PWM functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM PWM.\r\n    (+) De-initialize the TIM PWM.\r\n    (+) Start the TIM PWM.\r\n    (+) Stop the TIM PWM.\r\n    (+) Start the TIM PWM and enable interrupt.\r\n    (+) Stop the TIM PWM and disable interrupt.\r\n    (+) Start the TIM PWM and enable DMA transfer.\r\n    (+) Stop the TIM PWM and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM PWM Time Base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()\r\n  * @param  htim TIM PWM handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->PWM_MspInitCallback == NULL)\r\n    {\r\n      htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->PWM_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_PWM_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the PWM */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM PWM handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->PWM_MspDeInitCallback == NULL)\r\n  {\r\n    htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->PWM_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_PWM_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM PWM MSP.\r\n  * @param  htim TIM PWM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM PWM MSP.\r\n  * @param  htim TIM PWM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Capture compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation in interrupt mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation in interrupt mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM PWM signal generation in DMA mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Capture/Compare 3 request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM PWM signal generation in DMA mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions\r\n  *  @brief    TIM Input Capture functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### TIM Input Capture functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides functions allowing to:\r\n   (+) Initialize and configure the TIM Input Capture.\r\n   (+) De-initialize the TIM Input Capture.\r\n   (+) Start the TIM Input Capture.\r\n   (+) Stop the TIM Input Capture.\r\n   (+) Start the TIM Input Capture and enable interrupt.\r\n   (+) Stop the TIM Input Capture and disable interrupt.\r\n   (+) Start the TIM Input Capture and enable DMA transfer.\r\n   (+) Stop the TIM Input Capture and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Input Capture Time base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->IC_MspInitCallback == NULL)\r\n    {\r\n      htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->IC_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_IC_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the input capture */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->IC_MspDeInitCallback == NULL)\r\n  {\r\n    htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->IC_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_IC_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Input Capture MSP.\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Input Capture MSP.\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement in interrupt mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Input Capture channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement in interrupt mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Input Capture channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement in DMA mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The destination Buffer address.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel state */\r\n  if ((channel_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n      || (complementary_channel_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if ((channel_state == HAL_TIM_CHANNEL_STATE_READY)\r\n           && (complementary_channel_state == HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement in DMA mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3  DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4  DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions\r\n  *  @brief    TIM One Pulse functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### TIM One Pulse functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM One Pulse.\r\n    (+) De-initialize the TIM One Pulse.\r\n    (+) Start the TIM One Pulse.\r\n    (+) Stop the TIM One Pulse.\r\n    (+) Start the TIM One Pulse and enable interrupt.\r\n    (+) Stop the TIM One Pulse and disable interrupt.\r\n    (+) Start the TIM One Pulse and enable DMA transfer.\r\n    (+) Stop the TIM One Pulse and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM One Pulse Time Base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()\r\n  * @note   When the timer instance is initialized in One Pulse mode, timer\r\n  *         channels 1 and channel 2 are reserved and cannot be used for other\r\n  *         purpose.\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OnePulseMode Select the One pulse mode.\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.\r\n  *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_OPM_MODE(OnePulseMode));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->OnePulse_MspInitCallback == NULL)\r\n    {\r\n      htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->OnePulse_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_OnePulse_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Configure the Time base in the One Pulse Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Reset the OPM Bit */\r\n  htim->Instance->CR1 &= ~TIM_CR1_OPM;\r\n\r\n  /* Configure the OPM Mode */\r\n  htim->Instance->CR1 |= OnePulseMode;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM One Pulse\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->OnePulse_MspDeInitCallback == NULL)\r\n  {\r\n    htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->OnePulse_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_OnePulse_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM One Pulse MSP.\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OnePulse_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM One Pulse MSP.\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare and the Input Capture channels\r\n    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n    whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together\r\n\r\n    No need to enable the counter, it's enabled automatically by hardware\r\n    (the counter starts in response to a stimulus and generate a pulse */\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Disable the Capture compare and the Input Capture channels\r\n  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation in interrupt mode.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare and the Input Capture channels\r\n    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n    whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together\r\n\r\n    No need to enable the counter, it's enabled automatically by hardware\r\n    (the counter starts in response to a stimulus and generate a pulse */\r\n\r\n  /* Enable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation in interrupt mode.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Disable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Disable the Capture compare and the Input Capture channels\r\n  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions\r\n  *  @brief    TIM Encoder functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                          ##### TIM Encoder functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM Encoder.\r\n    (+) De-initialize the TIM Encoder.\r\n    (+) Start the TIM Encoder.\r\n    (+) Stop the TIM Encoder.\r\n    (+) Start the TIM Encoder and enable interrupt.\r\n    (+) Stop the TIM Encoder and disable interrupt.\r\n    (+) Start the TIM Encoder and enable DMA transfer.\r\n    (+) Stop the TIM Encoder and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()\r\n  * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together\r\n  *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource\r\n  *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa\r\n  * @note   When the timer instance is initialized in Encoder mode, timer\r\n  *         channels 1 and channel 2 are reserved and cannot be used for other\r\n  *         purpose.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  sConfig TIM Encoder Interface configuration structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)\r\n{\r\n  uint32_t tmpsmcr;\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n  assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));\r\n  assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));\r\n  assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->Encoder_MspInitCallback == NULL)\r\n    {\r\n      htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->Encoder_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_Encoder_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Reset the SMS and ECE bits */\r\n  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);\r\n\r\n  /* Configure the Time base in the Encoder Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmr1 = htim->Instance->CCMR1;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = htim->Instance->CCER;\r\n\r\n  /* Set the encoder Mode */\r\n  tmpsmcr |= sConfig->EncoderMode;\r\n\r\n  /* Select the Capture Compare 1 and the Capture Compare 2 as input */\r\n  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);\r\n  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));\r\n\r\n  /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */\r\n  tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);\r\n  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);\r\n  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);\r\n  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);\r\n\r\n  /* Set the TI1 and the TI2 Polarities */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);\r\n  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);\r\n  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);\r\n\r\n  /* Write to TIMx SMCR */\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  htim->Instance->CCMR1 = tmpccmr1;\r\n\r\n  /* Write to TIMx CCER */\r\n  htim->Instance->CCER = tmpccer;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Encoder interface\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->Encoder_MspDeInitCallback == NULL)\r\n  {\r\n    htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->Encoder_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_Encoder_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Encoder Interface MSP.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Encoder_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Encoder Interface MSP.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Encoder_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n\r\n  /* Enable the encoder interface channels */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n  }\r\n  /* Enable the Peripheral */\r\n  __HAL_TIM_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface in interrupt mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n\r\n  /* Enable the encoder interface channels */\r\n  /* Enable the capture compare Interrupts 1 and/or 2 */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Enable the Peripheral */\r\n  __HAL_TIM_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface in interrupt mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 1 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 2 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n  }\r\n  else\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 1 and 2 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface in DMA mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @param  pData1 The destination Buffer address for IC1.\r\n  * @param  pData2 The destination Buffer address for IC2.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,\r\n                                            uint32_t *pData2, uint16_t Length)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((pData1 == NULL) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_2_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((pData2 == NULL) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (channel_2_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Input Capture DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n\r\n    default:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface in DMA mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 1 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 2 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n  }\r\n  else\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 1 and 2 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n/** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management\r\n  *  @brief    TIM IRQ handler management\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### IRQ handler management #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides Timer IRQ handler function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  This function handles TIM interrupts requests.\r\n  * @param  htim TIM  handle\r\n  * @retval None\r\n  */\r\nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Capture compare 1 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)\r\n    {\r\n      {\r\n        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);\r\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n        /* Input capture event */\r\n        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)\r\n        {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n          htim->IC_CaptureCallback(htim);\r\n#else\r\n          HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n        }\r\n        /* Output compare event */\r\n        else\r\n        {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n          htim->OC_DelayElapsedCallback(htim);\r\n          htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n          HAL_TIM_OC_DelayElapsedCallback(htim);\r\n          HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n        }\r\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n      }\r\n    }\r\n  }\r\n  /* Capture compare 2 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* Capture compare 3 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* Capture compare 4 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* TIM Update event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->PeriodElapsedCallback(htim);\r\n#else\r\n      HAL_TIM_PeriodElapsedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM Break input event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->BreakCallback(htim);\r\n#else\r\n      HAL_TIMEx_BreakCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM Break2 input event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->Break2Callback(htim);\r\n#else\r\n      HAL_TIMEx_Break2Callback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM Trigger detection event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->TriggerCallback(htim);\r\n#else\r\n      HAL_TIM_TriggerCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM commutation event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->CommutationCallback(htim);\r\n#else\r\n      HAL_TIMEx_CommutCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions\r\n  *  @brief    TIM Peripheral Control functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                   ##### Peripheral Control functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides functions allowing to:\r\n      (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.\r\n      (+) Configure External Clock source.\r\n      (+) Configure Complementary channels, break features and dead time.\r\n      (+) Configure Master and the Slave synchronization.\r\n      (+) Configure the DMA Burst Mode.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the TIM Output Compare Channels according to the specified\r\n  *         parameters in the TIM_OC_InitTypeDef.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  sConfig TIM Output Compare configuration structure\r\n  * @param  Channel TIM Channels to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,\r\n                                           TIM_OC_InitTypeDef *sConfig,\r\n                                           uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n  assert_param(IS_TIM_OC_MODE(sConfig->OCMode));\r\n  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 1 in Output Compare */\r\n      TIM_OC1_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 2 in Output Compare */\r\n      TIM_OC2_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 3 in Output Compare */\r\n      TIM_OC3_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 4 in Output Compare */\r\n      TIM_OC4_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_5:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 5 in Output Compare */\r\n      TIM_OC5_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_6:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 6 in Output Compare */\r\n      TIM_OC6_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Input Capture Channels according to the specified\r\n  *         parameters in the TIM_IC_InitTypeDef.\r\n  * @param  htim TIM IC handle\r\n  * @param  sConfig TIM Input Capture configuration structure\r\n  * @param  Channel TIM Channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    /* TI1 Configuration */\r\n    TIM_TI1_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC1PSC Bits */\r\n    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n\r\n    /* Set the IC1PSC value */\r\n    htim->Instance->CCMR1 |= sConfig->ICPrescaler;\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    /* TI2 Configuration */\r\n    assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI2_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC2PSC Bits */\r\n    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;\r\n\r\n    /* Set the IC2PSC value */\r\n    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_3)\r\n  {\r\n    /* TI3 Configuration */\r\n    assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI3_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC3PSC Bits */\r\n    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;\r\n\r\n    /* Set the IC3PSC value */\r\n    htim->Instance->CCMR2 |= sConfig->ICPrescaler;\r\n  }\r\n  else if (Channel == TIM_CHANNEL_4)\r\n  {\r\n    /* TI4 Configuration */\r\n    assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI4_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC4PSC Bits */\r\n    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;\r\n\r\n    /* Set the IC4PSC value */\r\n    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);\r\n  }\r\n  else\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM PWM  channels according to the specified\r\n  *         parameters in the TIM_OC_InitTypeDef.\r\n  * @param  htim TIM PWM handle\r\n  * @param  sConfig TIM PWM configuration structure\r\n  * @param  Channel TIM Channels to be configured\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,\r\n                                            TIM_OC_InitTypeDef *sConfig,\r\n                                            uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));\r\n  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));\r\n  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 1 in PWM mode */\r\n      TIM_OC1_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel1 */\r\n      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;\r\n      htim->Instance->CCMR1 |= sConfig->OCFastMode;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 2 in PWM mode */\r\n      TIM_OC2_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel2 */\r\n      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;\r\n      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 3 in PWM mode */\r\n      TIM_OC3_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel3 */\r\n      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;\r\n      htim->Instance->CCMR2 |= sConfig->OCFastMode;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 4 in PWM mode */\r\n      TIM_OC4_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel4 */\r\n      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;\r\n      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_5:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 5 in PWM mode */\r\n      TIM_OC5_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel5*/\r\n      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;\r\n      htim->Instance->CCMR3 |= sConfig->OCFastMode;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_6:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 6 in PWM mode */\r\n      TIM_OC6_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel6 */\r\n      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;\r\n      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM One Pulse Channels according to the specified\r\n  *         parameters in the TIM_OnePulse_InitTypeDef.\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  sConfig TIM One Pulse configuration structure\r\n  * @param  OutputChannel TIM output channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @param  InputChannel TIM input Channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @note  To output a waveform with a minimum delay user can enable the fast\r\n  *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx\r\n  *        output is forced in response to the edge detection on TIx input,\r\n  *        without taking in account the comparison.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,\r\n                                                 uint32_t OutputChannel,  uint32_t InputChannel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  TIM_OC_InitTypeDef temp1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));\r\n  assert_param(IS_TIM_OPM_CHANNELS(InputChannel));\r\n\r\n  if (OutputChannel != InputChannel)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(htim);\r\n\r\n    htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n    /* Extract the Output compare configuration from sConfig structure */\r\n    temp1.OCMode = sConfig->OCMode;\r\n    temp1.Pulse = sConfig->Pulse;\r\n    temp1.OCPolarity = sConfig->OCPolarity;\r\n    temp1.OCNPolarity = sConfig->OCNPolarity;\r\n    temp1.OCIdleState = sConfig->OCIdleState;\r\n    temp1.OCNIdleState = sConfig->OCNIdleState;\r\n\r\n    switch (OutputChannel)\r\n    {\r\n      case TIM_CHANNEL_1:\r\n      {\r\n        assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n        TIM_OC1_SetConfig(htim->Instance, &temp1);\r\n        break;\r\n      }\r\n\r\n      case TIM_CHANNEL_2:\r\n      {\r\n        assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n        TIM_OC2_SetConfig(htim->Instance, &temp1);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n\r\n    if (status == HAL_OK)\r\n    {\r\n      switch (InputChannel)\r\n      {\r\n        case TIM_CHANNEL_1:\r\n        {\r\n          assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n          TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,\r\n                            sConfig->ICSelection, sConfig->ICFilter);\r\n\r\n          /* Reset the IC1PSC Bits */\r\n          htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n\r\n          /* Select the Trigger source */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n          htim->Instance->SMCR |= TIM_TS_TI1FP1;\r\n\r\n          /* Select the Slave Mode */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n          htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;\r\n          break;\r\n        }\r\n\r\n        case TIM_CHANNEL_2:\r\n        {\r\n          assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n          TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,\r\n                            sConfig->ICSelection, sConfig->ICFilter);\r\n\r\n          /* Reset the IC2PSC Bits */\r\n          htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;\r\n\r\n          /* Select the Trigger source */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n          htim->Instance->SMCR |= TIM_TS_TI2FP2;\r\n\r\n          /* Select the Slave Mode */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n          htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;\r\n          break;\r\n        }\r\n\r\n        default:\r\n          status = HAL_ERROR;\r\n          break;\r\n      }\r\n    }\r\n\r\n    htim->State = HAL_TIM_STATE_READY;\r\n\r\n    __HAL_UNLOCK(htim);\r\n\r\n    return status;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  *            @arg TIM_DMABASE_OR\r\n  *            @arg TIM_DMABASE_CCMR3\r\n  *            @arg TIM_DMABASE_CCR5\r\n  *            @arg TIM_DMABASE_CCR6\r\n  *            @arg TIM_DMABASE_AF1  (*)\r\n  *            @arg TIM_DMABASE_AF2  (*)\r\n  *         (*) value not defined in all devices\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                              uint32_t BurstRequestSrc, uint32_t *BurstBuffer, uint32_t  BurstLength)\r\n{\r\n  HAL_StatusTypeDef status;\r\n\r\n  status = HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,\r\n                                            ((BurstLength) >> 8U) + 1U);\r\n\r\n\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer multiple Data from the memory to the TIM peripheral\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA will start the Data write\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  *            @arg TIM_DMABASE_OR\r\n  *            @arg TIM_DMABASE_CCMR3\r\n  *            @arg TIM_DMABASE_CCR5\r\n  *            @arg TIM_DMABASE_CCR6\r\n  *            @arg TIM_DMABASE_AF1  (*)\r\n  *            @arg TIM_DMABASE_AF2  (*)\r\n  *         (*) value not defined in all devices\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @param  DataLength Data length. This parameter can be one value\r\n  *         between 1 and 0xFFFF.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                                   uint32_t BurstRequestSrc, uint32_t *BurstBuffer,\r\n                                                   uint32_t  BurstLength,  uint32_t  DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n  assert_param(IS_TIM_DMA_LENGTH(BurstLength));\r\n  assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));\r\n\r\n  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)\r\n  {\r\n    if ((BurstBuffer == NULL) && (BurstLength > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      /* Set the DMA Period elapsed callbacks */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      /* Set the DMA commutation callbacks */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      /* Set the DMA trigger callbacks */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Configure the DMA Burst Mode */\r\n    htim->Instance->DCR = (BurstBaseAddress | BurstLength);\r\n    /* Enable the TIM DMA Request */\r\n    __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM DMA Burst mode\r\n  * @param  htim TIM handle\r\n  * @param  BurstRequestSrc TIM DMA Request sources to disable\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n\r\n  /* Abort the DMA transfer (at least disable the DMA stream) */\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the TIM Update DMA request */\r\n    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);\r\n\r\n    /* Change the DMA burst operation state */\r\n    htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  *            @arg TIM_DMABASE_OR\r\n  *            @arg TIM_DMABASE_CCMR3\r\n  *            @arg TIM_DMABASE_CCR5\r\n  *            @arg TIM_DMABASE_CCR6\r\n  *            @arg TIM_DMABASE_AF1  (*)\r\n  *            @arg TIM_DMABASE_AF2  (*)\r\n  *         (*) value not defined in all devices\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                             uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)\r\n{\r\n  HAL_StatusTypeDef status;\r\n\r\n  status = HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,\r\n                                           ((BurstLength) >> 8U) + 1U);\r\n\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  *            @arg TIM_DMABASE_OR\r\n  *            @arg TIM_DMABASE_CCMR3\r\n  *            @arg TIM_DMABASE_CCR5\r\n  *            @arg TIM_DMABASE_CCR6\r\n  *            @arg TIM_DMABASE_AF1  (*)\r\n  *            @arg TIM_DMABASE_AF2  (*)\r\n  *         (*) value not defined in all devices\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @param  DataLength Data length. This parameter can be one value\r\n  *         between 1 and 0xFFFF.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                                  uint32_t BurstRequestSrc, uint32_t  *BurstBuffer,\r\n                                                  uint32_t  BurstLength, uint32_t  DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n  assert_param(IS_TIM_DMA_LENGTH(BurstLength));\r\n  assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));\r\n\r\n  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)\r\n  {\r\n    if ((BurstBuffer == NULL) && (BurstLength > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      /* Set the DMA Period elapsed callbacks */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      /* Set the DMA commutation callbacks */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      /* Set the DMA trigger callbacks */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Configure the DMA Burst Mode */\r\n    htim->Instance->DCR = (BurstBaseAddress | BurstLength);\r\n\r\n    /* Enable the TIM DMA Request */\r\n    __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stop the DMA burst reading\r\n  * @param  htim TIM handle\r\n  * @param  BurstRequestSrc TIM DMA Request sources to disable.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n\r\n  /* Abort the DMA transfer (at least disable the DMA stream) */\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the TIM Update DMA request */\r\n    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);\r\n\r\n    /* Change the DMA burst operation state */\r\n    htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Generate a software event\r\n  * @param  htim TIM handle\r\n  * @param  EventSource specifies the event source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source\r\n  *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source\r\n  *            @arg TIM_EVENTSOURCE_COM: Timer COM event source\r\n  *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source\r\n  *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source\r\n  *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source\r\n  * @note   Basic timers can only generate an update event.\r\n  * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.\r\n  * @note   TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are relevant\r\n  *         only for timer instances supporting break input(s).\r\n  * @retval HAL status\r\n  */\r\n\r\nHAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_EVENT_SOURCE(EventSource));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Change the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Set the event sources */\r\n  htim->Instance->EGR = EventSource;\r\n\r\n  /* Change the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the OCRef clear feature\r\n  * @param  htim TIM handle\r\n  * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that\r\n  *         contains the OCREF clear feature and parameters for the TIM peripheral.\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,\r\n                                           TIM_ClearInputConfigTypeDef *sClearInputConfig,\r\n                                           uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  switch (sClearInputConfig->ClearInputSource)\r\n  {\r\n    case TIM_CLEARINPUTSOURCE_NONE:\r\n    {\r\n      /* Clear the OCREF clear selection bit and the the ETR Bits */\r\n      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));\r\n      break;\r\n    }\r\n\r\n    case TIM_CLEARINPUTSOURCE_ETR:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));\r\n      assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));\r\n      assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));\r\n\r\n      /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */\r\n      if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)\r\n      {\r\n        htim->State = HAL_TIM_STATE_READY;\r\n        __HAL_UNLOCK(htim);\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClearInputConfig->ClearInputPrescaler,\r\n                        sClearInputConfig->ClearInputPolarity,\r\n                        sClearInputConfig->ClearInputFilter);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    switch (Channel)\r\n    {\r\n      case TIM_CHANNEL_1:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 1 */\r\n          SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 1 */\r\n          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_2:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 2 */\r\n          SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 2 */\r\n          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_3:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 3 */\r\n          SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 3 */\r\n          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_4:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 4 */\r\n          SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 4 */\r\n          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_5:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 5 */\r\n          SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 5 */\r\n          CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_6:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 6 */\r\n          SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 6 */\r\n          CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief   Configures the clock source to be used\r\n  * @param  htim TIM handle\r\n  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that\r\n  *         contains the clock source information for the TIM peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));\r\n\r\n  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);\r\n  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  switch (sClockSourceConfig->ClockSource)\r\n  {\r\n    case TIM_CLOCKSOURCE_INTERNAL:\r\n    {\r\n      assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ETRMODE1:\r\n    {\r\n      /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));\r\n\r\n      /* Check ETR input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      /* Configure the ETR Clock source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClockSourceConfig->ClockPrescaler,\r\n                        sClockSourceConfig->ClockPolarity,\r\n                        sClockSourceConfig->ClockFilter);\r\n\r\n      /* Select the External clock mode1 and the ETRF trigger */\r\n      tmpsmcr = htim->Instance->SMCR;\r\n      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);\r\n      /* Write to TIMx SMCR */\r\n      htim->Instance->SMCR = tmpsmcr;\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ETRMODE2:\r\n    {\r\n      /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));\r\n\r\n      /* Check ETR input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      /* Configure the ETR Clock source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClockSourceConfig->ClockPrescaler,\r\n                        sClockSourceConfig->ClockPolarity,\r\n                        sClockSourceConfig->ClockFilter);\r\n      /* Enable the External clock mode2 */\r\n      htim->Instance->SMCR |= TIM_SMCR_ECE;\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI1:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 */\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI1 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI2:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI2 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI2_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI1ED:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 */\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI1 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ITR0:\r\n    case TIM_CLOCKSOURCE_ITR1:\r\n    case TIM_CLOCKSOURCE_ITR2:\r\n    case TIM_CLOCKSOURCE_ITR3:\r\n    {\r\n      /* Check whether or not the timer instance supports internal trigger input */\r\n      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));\r\n\r\n      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Selects the signal connected to the TI1 input: direct from CH1_input\r\n  *         or a XOR combination between CH1_input, CH2_input & CH3_input\r\n  * @param  htim TIM handle.\r\n  * @param  TI1_Selection Indicate whether or not channel 1 is connected to the\r\n  *         output of a XOR gate.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input\r\n  *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3\r\n  *            pins are connected to the TI1 input (XOR combination)\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)\r\n{\r\n  uint32_t tmpcr2;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_TI1SELECTION(TI1_Selection));\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = htim->Instance->CR2;\r\n\r\n  /* Reset the TI1 selection */\r\n  tmpcr2 &= ~TIM_CR2_TI1S;\r\n\r\n  /* Set the TI1 selection */\r\n  tmpcr2 |= TI1_Selection;\r\n\r\n  /* Write to TIMxCR2 */\r\n  htim->Instance->CR2 = tmpcr2;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in Slave mode\r\n  * @param  htim TIM handle.\r\n  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that\r\n  *         contains the selected trigger (internal trigger input, filtered\r\n  *         timer input or external trigger input) and the Slave mode\r\n  *         (Disable, Reset, Gated, Trigger, External clock mode 1).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));\r\n  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n    __HAL_UNLOCK(htim);\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Disable Trigger Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);\r\n\r\n  /* Disable Trigger DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in Slave mode in interrupt mode\r\n  * @param  htim TIM handle.\r\n  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that\r\n  *         contains the selected trigger (internal trigger input, filtered\r\n  *         timer input or external trigger input) and the Slave mode\r\n  *         (Disable, Reset, Gated, Trigger, External clock mode 1).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,\r\n                                                TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));\r\n  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n    __HAL_UNLOCK(htim);\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable Trigger Interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);\r\n\r\n  /* Disable Trigger DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Read the captured value from Capture Compare unit\r\n  * @param  htim TIM handle.\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval Captured value\r\n  */\r\nuint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpreg = 0U;\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 1 value */\r\n      tmpreg =  htim->Instance->CCR1;\r\n\r\n      break;\r\n    }\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 2 value */\r\n      tmpreg =   htim->Instance->CCR2;\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 3 value */\r\n      tmpreg =   htim->Instance->CCR3;\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 4 value */\r\n      tmpreg =   htim->Instance->CCR4;\r\n\r\n      break;\r\n    }\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return tmpreg;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions\r\n  *  @brief    TIM Callbacks functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### TIM Callbacks functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides TIM callback functions:\r\n   (+) TIM Period elapsed callback\r\n   (+) TIM Output Compare callback\r\n   (+) TIM Input capture callback\r\n   (+) TIM Trigger callback\r\n   (+) TIM Error callback\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Period elapsed callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Period elapsed half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Output Compare callback in non-blocking mode\r\n  * @param  htim TIM OC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Input Capture callback in non-blocking mode\r\n  * @param  htim TIM IC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_CaptureCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Input Capture half complete callback in non-blocking mode\r\n  * @param  htim TIM IC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  PWM Pulse finished callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  PWM Pulse finished half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Trigger detection callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_TriggerCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Trigger detection half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Timer error callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_ErrorCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Register a User TIM callback to be used instead of the weak predefined callback\r\n  * @param htim tim handle\r\n  * @param CallbackID ID of the callback to be registered\r\n  *        This parameter can be one of the following values:\r\n  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID\r\n  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID\r\n  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID\r\n  *          @param pCallback pointer to the callback function\r\n  *          @retval status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,\r\n                                           pTIM_CallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  /* Process locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        htim->Base_MspInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        htim->Base_MspDeInitCallback               = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        htim->IC_MspInitCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        htim->IC_MspDeInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        htim->OC_MspInitCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        htim->OC_MspDeInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        htim->PWM_MspInitCallback                  = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        htim->PWM_MspDeInitCallback                = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        htim->OnePulse_MspInitCallback             = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        htim->OnePulse_MspDeInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        htim->Encoder_MspInitCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        htim->Encoder_MspDeInitCallback            = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        htim->HallSensor_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        htim->HallSensor_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_CB_ID :\r\n        htim->PeriodElapsedCallback                = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :\r\n        htim->PeriodElapsedHalfCpltCallback        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_CB_ID :\r\n        htim->TriggerCallback                      = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_HALF_CB_ID :\r\n        htim->TriggerHalfCpltCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_CB_ID :\r\n        htim->IC_CaptureCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_HALF_CB_ID :\r\n        htim->IC_CaptureHalfCpltCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :\r\n        htim->OC_DelayElapsedCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :\r\n        htim->PWM_PulseFinishedCallback            = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :\r\n        htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ERROR_CB_ID :\r\n        htim->ErrorCallback                        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_CB_ID :\r\n        htim->CommutationCallback                  = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_HALF_CB_ID :\r\n        htim->CommutationHalfCpltCallback          = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK_CB_ID :\r\n        htim->BreakCallback                        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK2_CB_ID :\r\n        htim->Break2Callback                       = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        htim->Base_MspInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        htim->Base_MspDeInitCallback       = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        htim->IC_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        htim->IC_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        htim->OC_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        htim->OC_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        htim->PWM_MspInitCallback          = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        htim->PWM_MspDeInitCallback        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        htim->OnePulse_MspInitCallback     = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        htim->OnePulse_MspDeInitCallback   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        htim->Encoder_MspInitCallback      = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        htim->Encoder_MspDeInitCallback    = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        htim->HallSensor_MspInitCallback   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        htim->HallSensor_MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister a TIM callback\r\n  *         TIM callback is redirected to the weak predefined callback\r\n  * @param htim tim handle\r\n  * @param CallbackID ID of the callback to be unregistered\r\n  *        This parameter can be one of the following values:\r\n  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID\r\n  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID\r\n  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID\r\n  *          @retval status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        /* Legacy weak Base MspInit Callback */\r\n        htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Base Msp DeInit Callback */\r\n        htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        /* Legacy weak IC Msp Init Callback */\r\n        htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak IC Msp DeInit Callback */\r\n        htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        /* Legacy weak OC Msp Init Callback */\r\n        htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak OC Msp DeInit Callback */\r\n        htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        /* Legacy weak PWM Msp Init Callback */\r\n        htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        /* Legacy weak PWM Msp DeInit Callback */\r\n        htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp Init Callback */\r\n        htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp DeInit Callback */\r\n        htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp Init Callback */\r\n        htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp DeInit Callback */\r\n        htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp Init Callback */\r\n        htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp DeInit Callback */\r\n        htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_CB_ID :\r\n        /* Legacy weak Period Elapsed Callback */\r\n        htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :\r\n        /* Legacy weak Period Elapsed half complete Callback */\r\n        htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_CB_ID :\r\n        /* Legacy weak Trigger Callback */\r\n        htim->TriggerCallback                   = HAL_TIM_TriggerCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_HALF_CB_ID :\r\n        /* Legacy weak Trigger half complete Callback */\r\n        htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_CB_ID :\r\n        /* Legacy weak IC Capture Callback */\r\n        htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_HALF_CB_ID :\r\n        /* Legacy weak IC Capture half complete Callback */\r\n        htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :\r\n        /* Legacy weak OC Delay Elapsed Callback */\r\n        htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :\r\n        /* Legacy weak PWM Pulse Finished Callback */\r\n        htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :\r\n        /* Legacy weak PWM Pulse Finished half complete Callback */\r\n        htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ERROR_CB_ID :\r\n        /* Legacy weak Error Callback */\r\n        htim->ErrorCallback                     = HAL_TIM_ErrorCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_CB_ID :\r\n        /* Legacy weak Commutation Callback */\r\n        htim->CommutationCallback               = HAL_TIMEx_CommutCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_HALF_CB_ID :\r\n        /* Legacy weak Commutation half complete Callback */\r\n        htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK_CB_ID :\r\n        /* Legacy weak Break Callback */\r\n        htim->BreakCallback                     = HAL_TIMEx_BreakCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK2_CB_ID :\r\n        /* Legacy weak Break2 Callback */\r\n        htim->Break2Callback                    = HAL_TIMEx_Break2Callback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        /* Legacy weak Base MspInit Callback */\r\n        htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Base Msp DeInit Callback */\r\n        htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        /* Legacy weak IC Msp Init Callback */\r\n        htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak IC Msp DeInit Callback */\r\n        htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        /* Legacy weak OC Msp Init Callback */\r\n        htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak OC Msp DeInit Callback */\r\n        htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        /* Legacy weak PWM Msp Init Callback */\r\n        htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        /* Legacy weak PWM Msp DeInit Callback */\r\n        htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp Init Callback */\r\n        htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp DeInit Callback */\r\n        htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp Init Callback */\r\n        htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp DeInit Callback */\r\n        htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp Init Callback */\r\n        htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp DeInit Callback */\r\n        htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions\r\n  *  @brief   TIM Peripheral State functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### Peripheral State functions #####\r\n  ==============================================================================\r\n    [..]\r\n    This subsection permits to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the TIM Base handle state.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM OC handle state.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM PWM handle state.\r\n  * @param  htim TIM handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Input Capture handle state.\r\n  * @param  htim TIM IC handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM One Pulse Mode handle state.\r\n  * @param  htim TIM OPM handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Encoder Mode handle state.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Encoder Mode handle state.\r\n  * @param  htim TIM handle\r\n  * @retval Active channel\r\n  */\r\nHAL_TIM_ActiveChannel HAL_TIM_GetActiveChannel(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->Channel;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of the TIM channel.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6\r\n  * @retval TIM Channel state\r\n  */\r\nHAL_TIM_ChannelStateTypeDef HAL_TIM_GetChannelState(TIM_HandleTypeDef *htim,  uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_state;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n\r\n  return channel_state;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of a DMA burst operation.\r\n  * @param  htim TIM handle\r\n  * @retval DMA burst state\r\n  */\r\nHAL_TIM_DMABurstStateTypeDef HAL_TIM_DMABurstState(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n\r\n  return htim->DMABurstState;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Private_Functions TIM Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  TIM DMA error callback\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMAError(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->ErrorCallback(htim);\r\n#else\r\n  HAL_TIM_ErrorCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Capture complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->IC_CaptureCallback(htim);\r\n#else\r\n  HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Capture half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->IC_CaptureHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_IC_CaptureHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Period Elapse complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (htim->hdma[TIM_DMA_ID_UPDATE]->Init.Mode == DMA_NORMAL)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PeriodElapsedCallback(htim);\r\n#else\r\n  HAL_TIM_PeriodElapsedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Period Elapse half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PeriodElapsedHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_PeriodElapsedHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Trigger callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (htim->hdma[TIM_DMA_ID_TRIGGER]->Init.Mode == DMA_NORMAL)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->TriggerCallback(htim);\r\n#else\r\n  HAL_TIM_TriggerCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Trigger half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->TriggerHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_TriggerHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  Time Base configuration\r\n  * @param  TIMx TIM peripheral\r\n  * @param  Structure TIM Base configuration structure\r\n  * @retval None\r\n  */\r\nvoid TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)\r\n{\r\n  uint32_t tmpcr1;\r\n  tmpcr1 = TIMx->CR1;\r\n\r\n  /* Set TIM Time Base Unit parameters ---------------------------------------*/\r\n  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))\r\n  {\r\n    /* Select the Counter Mode */\r\n    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);\r\n    tmpcr1 |= Structure->CounterMode;\r\n  }\r\n\r\n  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))\r\n  {\r\n    /* Set the clock division */\r\n    tmpcr1 &= ~TIM_CR1_CKD;\r\n    tmpcr1 |= (uint32_t)Structure->ClockDivision;\r\n  }\r\n\r\n  /* Set the auto-reload preload */\r\n  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);\r\n\r\n  TIMx->CR1 = tmpcr1;\r\n\r\n  /* Set the Autoreload value */\r\n  TIMx->ARR = (uint32_t)Structure->Period ;\r\n\r\n  /* Set the Prescaler value */\r\n  TIMx->PSC = Structure->Prescaler;\r\n\r\n  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))\r\n  {\r\n    /* Set the Repetition Counter value */\r\n    TIMx->RCR = Structure->RepetitionCounter;\r\n  }\r\n\r\n  /* Generate an update event to reload the Prescaler\r\n     and the repetition counter (only for advanced timer) value immediately */\r\n  TIMx->EGR = TIM_EGR_UG;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 1 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR1;\r\n\r\n  /* Reset the Output Compare Mode Bits */\r\n  tmpccmrx &= ~TIM_CCMR1_OC1M;\r\n  tmpccmrx &= ~TIM_CCMR1_CC1S;\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= OC_Config->OCMode;\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC1P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= OC_Config->OCPolarity;\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC1NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= OC_Config->OCNPolarity;\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC1NE;\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS1;\r\n    tmpcr2 &= ~TIM_CR2_OIS1N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= OC_Config->OCIdleState;\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= OC_Config->OCNIdleState;\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  TIMx->CCMR1 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR1 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 2 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nvoid TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR1;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR1_OC2M;\r\n  tmpccmrx &= ~TIM_CCMR1_CC2S;\r\n\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= (OC_Config->OCMode << 8U);\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC2P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 4U);\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))\r\n  {\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC2NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= (OC_Config->OCNPolarity << 4U);\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC2NE;\r\n\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS2;\r\n    tmpcr2 &= ~TIM_CR2_OIS2N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 2U);\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= (OC_Config->OCNIdleState << 2U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  TIMx->CCMR1 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR2 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 3 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 3: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC3E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR2 register value */\r\n  tmpccmrx = TIMx->CCMR2;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR2_OC3M;\r\n  tmpccmrx &= ~TIM_CCMR2_CC3S;\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= OC_Config->OCMode;\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC3P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 8U);\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))\r\n  {\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC3NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= (OC_Config->OCNPolarity << 8U);\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC3NE;\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS3;\r\n    tmpcr2 &= ~TIM_CR2_OIS3N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 4U);\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= (OC_Config->OCNIdleState << 4U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR2 */\r\n  TIMx->CCMR2 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR3 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 4 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 4: Reset the CC4E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC4E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR2 register value */\r\n  tmpccmrx = TIMx->CCMR2;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR2_OC4M;\r\n  tmpccmrx &= ~TIM_CCMR2_CC4S;\r\n\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= (OC_Config->OCMode << 8U);\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC4P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 12U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS4;\r\n\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 6U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR2 */\r\n  TIMx->CCMR2 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR4 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 5 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,\r\n                              TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the output: Reset the CCxE Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC5E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR3;\r\n\r\n  /* Reset the Output Compare Mode Bits */\r\n  tmpccmrx &= ~(TIM_CCMR3_OC5M);\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= OC_Config->OCMode;\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC5P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 16U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Reset the Output Compare IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS5;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 8U);\r\n  }\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR3 */\r\n  TIMx->CCMR3 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR5 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 6 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,\r\n                              TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the output: Reset the CCxE Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC6E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR3;\r\n\r\n  /* Reset the Output Compare Mode Bits */\r\n  tmpccmrx &= ~(TIM_CCMR3_OC6M);\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= (OC_Config->OCMode << 8U);\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= (uint32_t)~TIM_CCER_CC6P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 20U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Reset the Output Compare IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS6;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 10U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR3 */\r\n  TIMx->CCMR3 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR6 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Slave Timer configuration function\r\n  * @param  htim TIM handle\r\n  * @param  sSlaveConfig Slave timer configuration\r\n  * @retval None\r\n  */\r\nstatic HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,\r\n                                                  TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* Reset the Trigger Selection Bits */\r\n  tmpsmcr &= ~TIM_SMCR_TS;\r\n  /* Set the Input Trigger source */\r\n  tmpsmcr |= sSlaveConfig->InputTrigger;\r\n\r\n  /* Reset the slave mode Bits */\r\n  tmpsmcr &= ~TIM_SMCR_SMS;\r\n  /* Set the slave mode */\r\n  tmpsmcr |= sSlaveConfig->SlaveMode;\r\n\r\n  /* Write to TIMx SMCR */\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  /* Configure the trigger prescaler, filter, and polarity */\r\n  switch (sSlaveConfig->InputTrigger)\r\n  {\r\n    case TIM_TS_ETRF:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n      /* Configure the ETR Trigger source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sSlaveConfig->TriggerPrescaler,\r\n                        sSlaveConfig->TriggerPolarity,\r\n                        sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI1F_ED:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      if (sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Disable the Channel 1: Reset the CC1E Bit */\r\n      tmpccer = htim->Instance->CCER;\r\n      htim->Instance->CCER &= ~TIM_CCER_CC1E;\r\n      tmpccmr1 = htim->Instance->CCMR1;\r\n\r\n      /* Set the filter */\r\n      tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);\r\n\r\n      /* Write to TIMx CCMR1 and CCER registers */\r\n      htim->Instance->CCMR1 = tmpccmr1;\r\n      htim->Instance->CCER = tmpccer;\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI1FP1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      /* Configure TI1 Filter and Polarity */\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sSlaveConfig->TriggerPolarity,\r\n                               sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI2FP2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      /* Configure TI2 Filter and Polarity */\r\n      TIM_TI2_ConfigInputStage(htim->Instance,\r\n                               sSlaveConfig->TriggerPolarity,\r\n                               sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_ITR0:\r\n    case TIM_TS_ITR1:\r\n    case TIM_TS_ITR2:\r\n    case TIM_TS_ITR3:\r\n    {\r\n      /* Check the parameter */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI1 as Input.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1\r\n  *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nvoid TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                       uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)\r\n  {\r\n    tmpccmr1 &= ~TIM_CCMR1_CC1S;\r\n    tmpccmr1 |= TIM_ICSelection;\r\n  }\r\n  else\r\n  {\r\n    tmpccmr1 |= TIM_CCMR1_CC1S_0;\r\n  }\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);\r\n\r\n  /* Select the Polarity and set the CC1E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);\r\n  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Polarity and Filter for TI1.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  tmpccer = TIMx->CCER;\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n  tmpccmr1 |= (TIM_ICFilter << 4U);\r\n\r\n  /* Select the Polarity and set the CC1E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);\r\n  tmpccer |= TIM_ICPolarity;\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI2 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nstatic void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr1 &= ~TIM_CCMR1_CC2S;\r\n  tmpccmr1 |= (TIM_ICSelection << 8U);\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC2F;\r\n  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);\r\n\r\n  /* Select the Polarity and set the CC2E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);\r\n  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1 ;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Polarity and Filter for TI2.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC2F;\r\n  tmpccmr1 |= (TIM_ICFilter << 12U);\r\n\r\n  /* Select the Polarity and set the CC2E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);\r\n  tmpccer |= (TIM_ICPolarity << 4U);\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1 ;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI3 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nstatic void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr2;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 3: Reset the CC3E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC3E;\r\n  tmpccmr2 = TIMx->CCMR2;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr2 &= ~TIM_CCMR2_CC3S;\r\n  tmpccmr2 |= TIM_ICSelection;\r\n\r\n  /* Set the filter */\r\n  tmpccmr2 &= ~TIM_CCMR2_IC3F;\r\n  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);\r\n\r\n  /* Select the Polarity and set the CC3E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);\r\n  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));\r\n\r\n  /* Write to TIMx CCMR2 and CCER registers */\r\n  TIMx->CCMR2 = tmpccmr2;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI4 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr2;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 4: Reset the CC4E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC4E;\r\n  tmpccmr2 = TIMx->CCMR2;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr2 &= ~TIM_CCMR2_CC4S;\r\n  tmpccmr2 |= (TIM_ICSelection << 8U);\r\n\r\n  /* Set the filter */\r\n  tmpccmr2 &= ~TIM_CCMR2_IC4F;\r\n  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);\r\n\r\n  /* Select the Polarity and set the CC4E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);\r\n  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));\r\n\r\n  /* Write to TIMx CCMR2 and CCER registers */\r\n  TIMx->CCMR2 = tmpccmr2;\r\n  TIMx->CCER = tmpccer ;\r\n}\r\n\r\n/**\r\n  * @brief  Selects the Input Trigger source\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  InputTriggerSource The Input Trigger source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal Trigger 0\r\n  *            @arg TIM_TS_ITR1: Internal Trigger 1\r\n  *            @arg TIM_TS_ITR2: Internal Trigger 2\r\n  *            @arg TIM_TS_ITR3: Internal Trigger 3\r\n  *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector\r\n  *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1\r\n  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2\r\n  *            @arg TIM_TS_ETRF: External Trigger input\r\n  * @retval None\r\n  */\r\nstatic void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = TIMx->SMCR;\r\n  /* Reset the TS Bits */\r\n  tmpsmcr &= ~TIM_SMCR_TS;\r\n  /* Set the Input Trigger source and the slave mode*/\r\n  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);\r\n  /* Write to TIMx SMCR */\r\n  TIMx->SMCR = tmpsmcr;\r\n}\r\n/**\r\n  * @brief  Configures the TIMx External Trigger (ETR).\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.\r\n  *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.\r\n  *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.\r\n  *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.\r\n  * @param  TIM_ExtTRGPolarity The external Trigger Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.\r\n  *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.\r\n  * @param  ExtTRGFilter External Trigger Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F\r\n  * @retval None\r\n  */\r\nvoid TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,\r\n                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  tmpsmcr = TIMx->SMCR;\r\n\r\n  /* Reset the ETR Bits */\r\n  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);\r\n\r\n  /* Set the Prescaler, the Filter value and the Polarity */\r\n  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));\r\n\r\n  /* Write to TIMx SMCR */\r\n  TIMx->SMCR = tmpsmcr;\r\n}\r\n\r\n/**\r\n  * @brief  Enables or disables the TIM Capture Compare Channel x.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @param  ChannelState specifies the TIM Channel CCxE bit new state.\r\n  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.\r\n  * @retval None\r\n  */\r\nvoid TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)\r\n{\r\n  uint32_t tmp;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC1_INSTANCE(TIMx));\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n\r\n  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */\r\n\r\n  /* Reset the CCxE Bit */\r\n  TIMx->CCER &= ~tmp;\r\n\r\n  /* Set or reset the CCxE Bit */\r\n  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */\r\n}\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Reset interrupt callbacks to the legacy weak callbacks.\r\n  * @param  htim pointer to a TIM_HandleTypeDef structure that contains\r\n  *                the configuration information for TIM module.\r\n  * @retval None\r\n  */\r\nvoid TIM_ResetCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Reset the TIM callback to the legacy weak callbacks */\r\n  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;\r\n  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;\r\n  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;\r\n  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;\r\n  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;\r\n  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;\r\n  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;\r\n  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;\r\n  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback;\r\n  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;\r\n  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;\r\n  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;\r\n  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;\r\n  htim->Break2Callback                    = HAL_TIMEx_Break2Callback;\r\n}\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_TIM_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32f7xx_hal_tim_ex.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_tim_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   TIM HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Timer Extended peripheral:\r\n  *           + Time Hall Sensor Interface Initialization\r\n  *           + Time Hall Sensor Interface Start\r\n  *           + Time Complementary signal break and dead time configuration\r\n  *           + Time Master and Slave synchronization configuration\r\n  *           + Time Output Compare/PWM Channel Configuration (for channels 5 and 6)\r\n  *           + Timer remapping capabilities configuration\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### TIMER Extended features #####\r\n  ==============================================================================\r\n  [..]\r\n    The Timer Extended features include:\r\n    (#) Complementary outputs with programmable dead-time for :\r\n        (++) Output Compare\r\n        (++) PWM generation (Edge and Center-aligned Mode)\r\n        (++) One-pulse mode output\r\n    (#) Synchronization circuit to control the timer with external signals and to\r\n        interconnect several timers together.\r\n    (#) Break input to put the timer output signals in reset state or in a known state.\r\n    (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for\r\n        positioning purposes\r\n\r\n            ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n     (#) Initialize the TIM low level resources by implementing the following functions\r\n         depending on the selected feature:\r\n           (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()\r\n\r\n     (#) Initialize the TIM low level resources :\r\n        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();\r\n        (##) TIM pins configuration\r\n            (+++) Enable the clock for the TIM GPIOs using the following function:\r\n              __HAL_RCC_GPIOx_CLK_ENABLE();\r\n            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();\r\n\r\n     (#) The external Clock can be configured, if needed (the default clock is the\r\n         internal clock from the APBx), using the following function:\r\n         HAL_TIM_ConfigClockSource, the clock configuration should be done before\r\n         any start function.\r\n\r\n     (#) Configure the TIM in the desired functioning mode using one of the\r\n         initialization function of this driver:\r\n          (++) HAL_TIMEx_HallSensor_Init() and HAL_TIMEx_ConfigCommutEvent(): to use the\r\n               Timer Hall Sensor Interface and the commutation event with the corresponding\r\n               Interrupt and DMA request if needed (Note that One Timer is used to interface\r\n               with the Hall sensor Interface and another Timer should be used to use\r\n               the commutation event).\r\n\r\n     (#) Activate the TIM peripheral using one of the start functions:\r\n           (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(),\r\n                HAL_TIMEx_OCN_Start_IT()\r\n           (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(),\r\n                HAL_TIMEx_PWMN_Start_IT()\r\n           (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()\r\n           (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(),\r\n                HAL_TIMEx_HallSensor_Start_IT().\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIMEx TIMEx\r\n  * @brief TIM Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_TIM_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\nstatic void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState);\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup TIMEx_Exported_Functions TIM Extended Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions\r\n  * @brief    Timer Hall Sensor functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                      ##### Timer Hall Sensor functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure TIM HAL Sensor.\r\n    (+) De-initialize TIM HAL Sensor.\r\n    (+) Start the Hall Sensor Interface.\r\n    (+) Stop the Hall Sensor Interface.\r\n    (+) Start the Hall Sensor Interface and enable interrupts.\r\n    (+) Stop the Hall Sensor Interface and disable interrupts.\r\n    (+) Start the Hall Sensor Interface and enable DMA transfers.\r\n    (+) Stop the Hall Sensor Interface and disable DMA transfers.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Hall Sensor Interface and initialize the associated handle.\r\n  * @note   When the timer instance is initialized in Hall Sensor Interface mode,\r\n  *         timer channels 1 and channel 2 are reserved and cannot be used for\r\n  *         other purpose.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @param  sConfig TIM Hall Sensor configuration structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig)\r\n{\r\n  TIM_OC_InitTypeDef OC_Config;\r\n\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n  assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy week callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->HallSensor_MspInitCallback == NULL)\r\n    {\r\n      htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->HallSensor_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIMEx_HallSensor_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Configure the Time base in the Encoder Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */\r\n  TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);\r\n\r\n  /* Reset the IC1PSC Bits */\r\n  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n  /* Set the IC1PSC value */\r\n  htim->Instance->CCMR1 |= sConfig->IC1Prescaler;\r\n\r\n  /* Enable the Hall sensor interface (XOR function of the three inputs) */\r\n  htim->Instance->CR2 |= TIM_CR2_TI1S;\r\n\r\n  /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */\r\n  htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n  htim->Instance->SMCR |= TIM_TS_TI1F_ED;\r\n\r\n  /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */\r\n  htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n  htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;\r\n\r\n  /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/\r\n  OC_Config.OCFastMode = TIM_OCFAST_DISABLE;\r\n  OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;\r\n  OC_Config.OCMode = TIM_OCMODE_PWM2;\r\n  OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\r\n  OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\r\n  OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;\r\n  OC_Config.Pulse = sConfig->Commutation_Delay;\r\n\r\n  TIM_OC2_SetConfig(htim->Instance, &OC_Config);\r\n\r\n  /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2\r\n    register to 101 */\r\n  htim->Instance->CR2 &= ~TIM_CR2_MMS;\r\n  htim->Instance->CR2 |= TIM_TRGO_OC2REF;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Hall Sensor interface\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->HallSensor_MspDeInitCallback == NULL)\r\n  {\r\n    htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->HallSensor_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIMEx_HallSensor_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Hall Sensor MSP.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Hall Sensor MSP.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall sensor Interface.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1, 2 and 3\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the capture compare Interrupts 1 event */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the capture compare Interrupts event */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface in DMA mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @param  pData The destination Buffer address.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel state */\r\n  if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n      || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n           && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Set the DMA Input Capture 1 Callbacks */\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n  /* Enable the DMA stream for Capture 1*/\r\n  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)\r\n  {\r\n    /* Return error status */\r\n    return HAL_ERROR;\r\n  }\r\n  /* Enable the capture compare 1 Interrupt */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall Sensor Interface in DMA mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n\r\n  /* Disable the capture compare Interrupts 1 event */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions\r\n  *  @brief   Timer Complementary Output Compare functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Timer Complementary Output Compare functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary Output Compare/PWM.\r\n    (+) Stop the Complementary Output Compare/PWM.\r\n    (+) Start the Complementary Output Compare/PWM and enable interrupts.\r\n    (+) Stop the Complementary Output Compare/PWM and disable interrupts.\r\n    (+) Start the Complementary Output Compare/PWM and enable DMA transfers.\r\n    (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation on the complementary\r\n  *         output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare channel N */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation on the complementary\r\n  *         output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Capture compare channel N */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in interrupt mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM OC handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the TIM Break interrupt */\r\n    __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);\r\n\r\n    /* Enable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in interrupt mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the TIM Break interrupt (only if no more channel is active) */\r\n    tmpccer = htim->Instance->CCER;\r\n    if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)\r\n    {\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);\r\n    }\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in DMA mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in DMA mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions\r\n  * @brief    Timer Complementary PWM functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                 ##### Timer Complementary PWM functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary PWM.\r\n    (+) Stop the Complementary PWM.\r\n    (+) Start the Complementary PWM and enable interrupts.\r\n    (+) Stop the Complementary PWM and disable interrupts.\r\n    (+) Start the Complementary PWM and enable DMA transfers.\r\n    (+) Stop the Complementary PWM and disable DMA transfers.\r\n    (+) Start the Complementary Input Capture measurement.\r\n    (+) Stop the Complementary Input Capture.\r\n    (+) Start the Complementary Input Capture and enable interrupts.\r\n    (+) Stop the Complementary Input Capture and disable interrupts.\r\n    (+) Start the Complementary Input Capture and enable DMA transfers.\r\n    (+) Stop the Complementary Input Capture and disable DMA transfers.\r\n    (+) Start the Complementary One Pulse generation.\r\n    (+) Stop the Complementary One Pulse.\r\n    (+) Start the Complementary One Pulse and enable interrupts.\r\n    (+) Stop the Complementary One Pulse and disable interrupts.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation on the complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the complementary PWM output  */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation on the complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the complementary PWM output  */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation in interrupt mode on the\r\n  *         complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the TIM Break interrupt */\r\n    __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);\r\n\r\n    /* Enable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation in interrupt mode on the\r\n  *         complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the TIM Break interrupt (only if no more channel is active) */\r\n    tmpccer = htim->Instance->CCER;\r\n    if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)\r\n    {\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);\r\n    }\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM PWM signal generation in DMA mode on the\r\n  *         complementary output\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary\r\n  *         output\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the complementary PWM output */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions\r\n  * @brief    Timer Complementary One Pulse functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                ##### Timer Complementary One Pulse functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary One Pulse generation.\r\n    (+) Stop the Complementary One Pulse.\r\n    (+) Start the Complementary One Pulse and enable interrupts.\r\n    (+) Stop the Complementary One Pulse and disable interrupts.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation on the complementary\r\n  *         output.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to enable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation on the complementary\r\n  *         output.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to disable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Disable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM  channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the\r\n  *         complementary channel.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to enable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Enable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the\r\n  *         complementary channel.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to disable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Disable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Disable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM  channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions\r\n  * @brief    Peripheral Control functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                    ##### Peripheral Control functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n      (+) Configure the commutation event in case of use of the Hall sensor interface.\r\n      (+) Configure Output channels for OC and PWM mode.\r\n\r\n      (+) Configure Complementary channels, break features and dead time.\r\n      (+) Configure Master synchronization.\r\n      (+) Configure timer remapping capabilities.\r\n      (+) Enable or disable channel grouping.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                              uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Disable Commutation Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);\r\n\r\n  /* Disable Commutation DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence with interrupt.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                                 uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Disable Commutation DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  /* Enable the Commutation Interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence with DMA.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @note  The user should configure the DMA in his own software, in This function only the COMDE bit is set\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                                  uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Enable the Commutation DMA Request */\r\n  /* Set the DMA Commutation Callback */\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;\r\n\r\n  /* Disable Commutation Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);\r\n\r\n  /* Enable the Commutation DMA Request */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in master mode.\r\n  * @param  htim TIM handle.\r\n  * @param  sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that\r\n  *         contains the selected trigger output (TRGO) and the Master/Slave\r\n  *         mode.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,\r\n                                                        TIM_MasterConfigTypeDef *sMasterConfig)\r\n{\r\n  uint32_t tmpcr2;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));\r\n  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));\r\n\r\n  /* Check input state */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Change the handler state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = htim->Instance->CR2;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */\r\n  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));\r\n\r\n    /* Clear the MMS2 bits */\r\n    tmpcr2 &= ~TIM_CR2_MMS2;\r\n    /* Select the TRGO2 source*/\r\n    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;\r\n  }\r\n\r\n  /* Reset the MMS Bits */\r\n  tmpcr2 &= ~TIM_CR2_MMS;\r\n  /* Select the TRGO source */\r\n  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;\r\n\r\n  /* Update TIMx CR2 */\r\n  htim->Instance->CR2 = tmpcr2;\r\n\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    /* Reset the MSM Bit */\r\n    tmpsmcr &= ~TIM_SMCR_MSM;\r\n    /* Set master mode */\r\n    tmpsmcr |= sMasterConfig->MasterSlaveMode;\r\n\r\n    /* Update TIMx SMCR */\r\n    htim->Instance->SMCR = tmpsmcr;\r\n  }\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State\r\n  *         and the AOE(automatic output enable).\r\n  * @param  htim TIM handle\r\n  * @param  sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that\r\n  *         contains the BDTR Register configuration  information for the TIM peripheral.\r\n  * @note   Interrupts can be generated when an active level is detected on the\r\n  *         break input, the break 2 input or the system break input. Break\r\n  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,\r\n                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)\r\n{\r\n  /* Keep this variable initialized to 0 as it is used to configure BDTR register */\r\n  uint32_t tmpbdtr = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));\r\n  assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));\r\n  assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));\r\n  assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));\r\n  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));\r\n  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));\r\n  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));\r\n  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));\r\n\r\n  /* Check input state */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,\r\n     the OSSI State, the dead time value and the Automatic Output Enable Bit */\r\n\r\n  /* Set the BDTR bits */\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));\r\n\r\n  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));\r\n    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));\r\n    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));\r\n\r\n    /* Set the BREAK2 input related BDTR bits */\r\n    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));\r\n    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);\r\n    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);\r\n  }\r\n\r\n  /* Set TIMx_BDTR */\r\n  htim->Instance->BDTR = tmpbdtr;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n#if defined(TIM_BREAK_INPUT_SUPPORT)\r\n\r\n/**\r\n  * @brief  Configures the break input source.\r\n  * @param  htim TIM handle.\r\n  * @param  BreakInput Break input to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_BREAKINPUT_BRK: Timer break input\r\n  *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input\r\n  * @param  sBreakInputConfig Break input source configuration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,\r\n                                             uint32_t BreakInput,\r\n                                             TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)\r\n\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmporx;\r\n  uint32_t bkin_enable_mask;\r\n  uint32_t bkin_polarity_mask;\r\n  uint32_t bkin_enable_bitpos;\r\n  uint32_t bkin_polarity_bitpos;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_BREAKINPUT(BreakInput));\r\n  assert_param(IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source));\r\n  assert_param(IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable));\r\n#if defined(DFSDM1_Channel0)\r\n  if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)\r\n  {\r\n    assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));\r\n  }\r\n#else\r\n  assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));\r\n#endif /* DFSDM1_Channel0 */\r\n\r\n  /* Check input state */\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (sBreakInputConfig->Source)\r\n  {\r\n    case TIM_BREAKINPUTSOURCE_BKIN:\r\n    {\r\n      bkin_enable_mask = TIM1_AF1_BKINE;\r\n      bkin_enable_bitpos = TIM1_AF1_BKINE_Pos;\r\n      bkin_polarity_mask = TIM1_AF1_BKINP;\r\n      bkin_polarity_bitpos = TIM1_AF1_BKINP_Pos;\r\n      break;\r\n    }\r\n#if defined(DFSDM1_Channel0)\r\n    case TIM_BREAKINPUTSOURCE_DFSDM1:\r\n    {\r\n      bkin_enable_mask = TIM1_AF1_BKDF1BKE;\r\n      bkin_enable_bitpos = TIM1_AF1_BKDF1BKE_Pos;\r\n      bkin_polarity_mask = 0U;\r\n      bkin_polarity_bitpos = 0U;\r\n      break;\r\n    }\r\n#endif /* DFSDM1_Channel0 */\r\n\r\n    default:\r\n    {\r\n      bkin_enable_mask = 0U;\r\n      bkin_polarity_mask = 0U;\r\n      bkin_enable_bitpos = 0U;\r\n      bkin_polarity_bitpos = 0U;\r\n      break;\r\n    }\r\n  }\r\n\r\n  switch (BreakInput)\r\n  {\r\n    case TIM_BREAKINPUT_BRK:\r\n    {\r\n      /* Get the TIMx_AF1 register value */\r\n      tmporx = htim->Instance->AF1;\r\n\r\n      /* Enable the break input */\r\n      tmporx &= ~bkin_enable_mask;\r\n      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;\r\n\r\n      /* Set the break input polarity */\r\n#if defined(DFSDM1_Channel0)\r\n      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)\r\n#endif /* DFSDM1_Channel0 */\r\n      {\r\n        tmporx &= ~bkin_polarity_mask;\r\n        tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;\r\n      }\r\n\r\n      /* Set TIMx_AF1 */\r\n      htim->Instance->AF1 = tmporx;\r\n      break;\r\n    }\r\n    case TIM_BREAKINPUT_BRK2:\r\n    {\r\n      /* Get the TIMx_AF2 register value */\r\n      tmporx = htim->Instance->AF2;\r\n\r\n      /* Enable the break input */\r\n      tmporx &= ~bkin_enable_mask;\r\n      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;\r\n\r\n      /* Set the break input polarity */\r\n#if defined(DFSDM1_Channel0)\r\n      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)\r\n#endif /* DFSDM1_Channel0 */\r\n      {\r\n        tmporx &= ~bkin_polarity_mask;\r\n        tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;\r\n      }\r\n\r\n      /* Set TIMx_AF2 */\r\n      htim->Instance->AF2 = tmporx;\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n#endif /*TIM_BREAK_INPUT_SUPPORT */\r\n\r\n/**\r\n  * @brief  Configures the TIMx Remapping input capabilities.\r\n  * @param  htim TIM handle.\r\n  * @param  Remap specifies the TIM remapping source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)\r\n  *            @arg TIM_TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trigger output.\r\n  *            @arg TIM_TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF.\r\n  *            @arg TIM_TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF.\r\n  *            @arg TIM_TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)\r\n  *            @arg TIM_TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.\r\n  *            @arg TIM_TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.\r\n  *            @arg TIM_TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.\r\n  *            @arg TIM_TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default)\r\n  *            @arg TIM_TIM11_SPDIF:    SPDIF Frame synchronous\r\n  *            @arg TIM_TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock\r\n  *                                     (HSE divided by a programmable prescaler)\r\n  *            @arg TIM_TIM11_MCO1:     TIM11 CH1 input is connected to MCO1\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)\r\n{\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_REMAP(Remap));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Set the Timer remapping configuration */\r\n  htim->Instance->OR = Remap;\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Group channel 5 and channel 1, 2 or 3\r\n  * @param  htim TIM handle.\r\n  * @param  Channels specifies the reference signal(s) the OC5REF is combined with.\r\n  *         This parameter can be any combination of the following values:\r\n  *         TIM_GROUPCH5_NONE: No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC\r\n  *         TIM_GROUPCH5_OC1REFC: OC1REFC is the logical AND of OC1REFC and OC5REF\r\n  *         TIM_GROUPCH5_OC2REFC: OC2REFC is the logical AND of OC2REFC and OC5REF\r\n  *         TIM_GROUPCH5_OC3REFC: OC3REFC is the logical AND of OC3REFC and OC5REF\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t Channels)\r\n{\r\n  /* Check parameters */\r\n  assert_param(IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_GROUPCH5(Channels));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Clear GC5Cx bit fields */\r\n  htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1);\r\n\r\n  /* Set GC5Cx bit fields */\r\n  htim->Instance->CCR5 |= Channels;\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions\r\n  * @brief    Extended Callbacks functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                    ##### Extended Callbacks functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides Extended TIM callback functions:\r\n    (+) Timer Commutation callback\r\n    (+) Timer Break callback\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Hall commutation changed callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_CommutCallback could be implemented in the user file\r\n   */\r\n}\r\n/**\r\n  * @brief  Hall commutation changed half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Break detection callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_BreakCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Break2 detection callback in non blocking mode\r\n  * @param  htim: TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_Break2Callback could be implemented in the user file\r\n   */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions\r\n  * @brief    Extended Peripheral State functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                ##### Extended Peripheral State functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This subsection permits to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the TIM Hall Sensor interface handle state.\r\n  * @param  htim TIM Hall Sensor handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of the TIM complementary channel.\r\n  * @param  htim TIM handle\r\n  * @param  ChannelN TIM Complementary channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  * @retval TIM Complementary channel state\r\n  */\r\nHAL_TIM_ChannelStateTypeDef HAL_TIMEx_GetChannelNState(TIM_HandleTypeDef *htim,  uint32_t ChannelN)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_state;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, ChannelN));\r\n\r\n  channel_state = TIM_CHANNEL_N_STATE_GET(htim, ChannelN);\r\n\r\n  return channel_state;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @defgroup TIMEx_Private_Functions TIM Extended Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  TIM DMA Commutation callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->CommutationCallback(htim);\r\n#else\r\n  HAL_TIMEx_CommutCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Commutation half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->CommutationHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIMEx_CommutHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse complete callback (complementary channel).\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA error callback (complementary channel)\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->ErrorCallback(htim);\r\n#else\r\n  HAL_TIM_ErrorCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  Enables or disables the TIM Capture Compare Channel xN.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.\r\n  *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.\r\n  * @retval None\r\n  */\r\nstatic void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)\r\n{\r\n  uint32_t tmp;\r\n\r\n  tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */\r\n\r\n  /* Reset the CCxNE Bit */\r\n  TIMx->CCER &=  ~tmp;\r\n\r\n  /* Set or reset the CCxNE Bit */\r\n  TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_TIM_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32f7xx_hal_timebase_tim.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Core\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_hal_timebase_TIM.c\r\n  * @brief   HAL time base based on the hardware TIM.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2025 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n#include \"stm32f7xx_hal_tim.h\"\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\nTIM_HandleTypeDef        htim5;\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/**\r\n  * @brief  This function configures the TIM5 as a time base source.\r\n  *         The time source is configured  to have 1ms time base with a dedicated\r\n  *         Tick interrupt priority.\r\n  * @note   This function is called  automatically at the beginning of program after\r\n  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().\r\n  * @param  TickPriority: Tick interrupt priority.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\r\n{\r\n  RCC_ClkInitTypeDef    clkconfig;\r\n  uint32_t              uwTimclock = 0;\r\n  uint32_t              uwPrescalerValue = 0;\r\n  uint32_t              pFLatency;\r\n  /*Configure the TIM5 IRQ priority */\r\n  HAL_NVIC_SetPriority(TIM5_IRQn, TickPriority ,0);\r\n\r\n  /* Enable the TIM5 global Interrupt */\r\n  HAL_NVIC_EnableIRQ(TIM5_IRQn);\r\n\r\n  /* Enable TIM5 clock */\r\n  __HAL_RCC_TIM5_CLK_ENABLE();\r\n\r\n  /* Get clock configuration */\r\n  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);\r\n\r\n  /* Compute TIM5 clock */\r\n  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();\r\n  /* Compute the prescaler value to have TIM5 counter clock equal to 1MHz */\r\n  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);\r\n\r\n  /* Initialize TIM5 */\r\n  htim5.Instance = TIM5;\r\n\r\n  /* Initialize TIMx peripheral as follow:\r\n  + Period = [(TIM5CLK/1000) - 1]. to have a (1/1000) s time base.\r\n  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.\r\n  + ClockDivision = 0\r\n  + Counter direction = Up\r\n  */\r\n  htim5.Init.Period = (1000000U / 1000U) - 1U;\r\n  htim5.Init.Prescaler = uwPrescalerValue;\r\n  htim5.Init.ClockDivision = 0;\r\n  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;\r\n\r\n  if(HAL_TIM_Base_Init(&htim5) == HAL_OK)\r\n  {\r\n    /* Start the TIM time Base generation in interrupt mode */\r\n    return HAL_TIM_Base_Start_IT(&htim5);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_ERROR;\r\n}\r\n\r\n/**\r\n  * @brief  Suspend Tick increment.\r\n  * @note   Disable the tick increment by disabling TIM5 update interrupt.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid HAL_SuspendTick(void)\r\n{\r\n  /* Disable TIM5 update Interrupt */\r\n  __HAL_TIM_DISABLE_IT(&htim5, TIM_IT_UPDATE);\r\n}\r\n\r\n/**\r\n  * @brief  Resume Tick increment.\r\n  * @note   Enable the tick increment by Enabling TIM5 update interrupt.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid HAL_ResumeTick(void)\r\n{\r\n  /* Enable TIM5 Update interrupt */\r\n  __HAL_TIM_ENABLE_IT(&htim5, TIM_IT_UPDATE);\r\n}\r\n\r\n"},{"name":"stm32f7xx_it.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Core\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_it.c\r\n  * @brief   Interrupt Service Routines.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2025 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n#include \"stm32f7xx_it.h\"\r\n/* Private includes ----------------------------------------------------------*/\r\n/* USER CODE BEGIN Includes */\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN TD */\r\n\r\n/* USER CODE END TD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN PD */\r\n\r\n/* USER CODE END PD */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN PM */\r\n\r\n/* USER CODE END PM */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* Private user code ---------------------------------------------------------*/\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n\r\n/* External variables --------------------------------------------------------*/\r\nextern TIM_HandleTypeDef htim5;\r\n\r\n/* USER CODE BEGIN EV */\r\n\r\n/* USER CODE END EV */\r\n\r\n/******************************************************************************/\r\n/*           Cortex-M7 Processor Interruption and Exception Handlers          */\r\n/******************************************************************************/\r\n/**\r\n  * @brief This function handles Non maskable interrupt.\r\n  */\r\n__attribute__((weak)) void NMI_Handler (void)\r\n{\r\n  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */\r\n\r\n  /* USER CODE END NonMaskableInt_IRQn 0 */\r\n  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */\r\n  while (1)\r\n  {\r\n  }\r\n  /* USER CODE END NonMaskableInt_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Hard fault interrupt.\r\n  */\r\n__attribute__((weak)) void HardFault_Handler (void)\r\n{\r\n  /* USER CODE BEGIN HardFault_IRQn 0 */\r\n\r\n  /* USER CODE END HardFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_HardFault_IRQn 0 */\r\n    /* USER CODE END W1_HardFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Memory management fault.\r\n  */\r\n__attribute__((weak)) void MemManage_Handler (void)\r\n{\r\n  /* USER CODE BEGIN MemoryManagement_IRQn 0 */\r\n\r\n  /* USER CODE END MemoryManagement_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */\r\n    /* USER CODE END W1_MemoryManagement_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Pre-fetch fault, memory access fault.\r\n  */\r\n__attribute__((weak)) void BusFault_Handler (void)\r\n{\r\n  /* USER CODE BEGIN BusFault_IRQn 0 */\r\n\r\n  /* USER CODE END BusFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_BusFault_IRQn 0 */\r\n    /* USER CODE END W1_BusFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Undefined instruction or illegal state.\r\n  */\r\n__attribute__((weak)) void UsageFault_Handler (void)\r\n{\r\n  /* USER CODE BEGIN UsageFault_IRQn 0 */\r\n\r\n  /* USER CODE END UsageFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */\r\n    /* USER CODE END W1_UsageFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles System service call via SWI instruction.\r\n  */\r\n__attribute__((weak)) void SVC_Handler (void)\r\n{\r\n  /* USER CODE BEGIN SVCall_IRQn 0 */\r\n\r\n  /* USER CODE END SVCall_IRQn 0 */\r\n  /* USER CODE BEGIN SVCall_IRQn 1 */\r\n\r\n  /* USER CODE END SVCall_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Debug monitor.\r\n  */\r\n__attribute__((weak)) void DebugMon_Handler (void)\r\n{\r\n  /* USER CODE BEGIN DebugMonitor_IRQn 0 */\r\n\r\n  /* USER CODE END DebugMonitor_IRQn 0 */\r\n  /* USER CODE BEGIN DebugMonitor_IRQn 1 */\r\n\r\n  /* USER CODE END DebugMonitor_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Pendable request for system service.\r\n  */\r\n__attribute__((weak)) void PendSV_Handler (void)\r\n{\r\n  /* USER CODE BEGIN PendSV_IRQn 0 */\r\n\r\n  /* USER CODE END PendSV_IRQn 0 */\r\n  /* USER CODE BEGIN PendSV_IRQn 1 */\r\n\r\n  /* USER CODE END PendSV_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles System tick timer.\r\n  */\r\n__attribute__((weak)) void SysTick_Handler (void)\r\n{\r\n  /* USER CODE BEGIN SysTick_IRQn 0 */\r\n\r\n  /* USER CODE END SysTick_IRQn 0 */\r\n\r\n  /* USER CODE BEGIN SysTick_IRQn 1 */\r\n\r\n  /* USER CODE END SysTick_IRQn 1 */\r\n}\r\n\r\n/******************************************************************************/\r\n/* STM32F7xx Peripheral Interrupt Handlers                                    */\r\n/* Add here the Interrupt Handlers for the used peripherals.                  */\r\n/* For the available peripheral interrupt handler names,                      */\r\n/* please refer to the startup file (startup_stm32f7xx.s).                    */\r\n/******************************************************************************/\r\n\r\n/**\r\n  * @brief This function handles DMA1 stream1 global interrupt.\r\n  */\r\n__attribute__((weak)) void DMA1_Stream1_IRQHandler (void)\r\n{\r\n  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */\r\n\r\n  /* USER CODE END DMA1_Stream1_IRQn 0 */\r\n\r\n  /* USER CODE BEGIN DMA1_Stream1_IRQn 1 */\r\n\r\n  /* USER CODE END DMA1_Stream1_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles TIM5 global interrupt.\r\n  */\r\n__attribute__((weak)) void TIM5_IRQHandler (void)\r\n{\r\n  /* USER CODE BEGIN TIM5_IRQn 0 */\r\n\r\n  /* USER CODE END TIM5_IRQn 0 */\r\n  HAL_TIM_IRQHandler(&htim5);\r\n  /* USER CODE BEGIN TIM5_IRQn 1 */\r\n\r\n  /* USER CODE END TIM5_IRQn 1 */\r\n}\r\n\r\n/* USER CODE BEGIN 1 */\r\n\r\n/* USER CODE END 1 */\r\n\r\n"},{"name":"stm32f7xx_ll_dma.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_ll_dma.c\r\n  * @author  MCD Application Team\r\n  * @brief   DMA LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_ll_dma.h\"\r\n#include \"stm32f7xx_ll_bus.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (DMA1) || defined (DMA2)\r\n\r\n/** @defgroup DMA_LL DMA\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup DMA_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_DMA_DIRECTION(__VALUE__)          (((__VALUE__) == LL_DMA_DIRECTION_PERIPH_TO_MEMORY) || \\\r\n                                                 ((__VALUE__) == LL_DMA_DIRECTION_MEMORY_TO_PERIPH) || \\\r\n                                                 ((__VALUE__) == LL_DMA_DIRECTION_MEMORY_TO_MEMORY))\r\n\r\n#define IS_LL_DMA_MODE(__VALUE__)               (((__VALUE__) == LL_DMA_MODE_NORMAL)    || \\\r\n                                                 ((__VALUE__) == LL_DMA_MODE_CIRCULAR)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_MODE_PFCTRL))\r\n\r\n#define IS_LL_DMA_PERIPHINCMODE(__VALUE__)      (((__VALUE__) == LL_DMA_PERIPH_INCREMENT) || \\\r\n                                                 ((__VALUE__) == LL_DMA_PERIPH_NOINCREMENT))\r\n\r\n#define IS_LL_DMA_MEMORYINCMODE(__VALUE__)      (((__VALUE__) == LL_DMA_MEMORY_INCREMENT) || \\\r\n                                                 ((__VALUE__) == LL_DMA_MEMORY_NOINCREMENT))\r\n\r\n#define IS_LL_DMA_PERIPHDATASIZE(__VALUE__)     (((__VALUE__) == LL_DMA_PDATAALIGN_BYTE)      || \\\r\n                                                 ((__VALUE__) == LL_DMA_PDATAALIGN_HALFWORD)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_PDATAALIGN_WORD))\r\n\r\n#define IS_LL_DMA_MEMORYDATASIZE(__VALUE__)     (((__VALUE__) == LL_DMA_MDATAALIGN_BYTE)      || \\\r\n                                                 ((__VALUE__) == LL_DMA_MDATAALIGN_HALFWORD)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_MDATAALIGN_WORD))\r\n\r\n#define IS_LL_DMA_NBDATA(__VALUE__)             ((__VALUE__)  <= 0x0000FFFFU)\r\n\r\n#if  defined(DMA_CHANNEL_SELECTION_8_15)\r\n#define IS_LL_DMA_CHANNEL(__VALUE__)            (((__VALUE__) == LL_DMA_CHANNEL_0)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_1)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_2)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_3)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_4)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_5)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_6)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_7)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_8)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_9)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_10)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_11)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_12)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_13)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_14)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_15))\r\n\r\n#else\r\n#define IS_LL_DMA_CHANNEL(__VALUE__)            (((__VALUE__) == LL_DMA_CHANNEL_0)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_1)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_2)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_3)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_4)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_5)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_6)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_7))\r\n\r\n#endif /* DMA_CHANNEL_SELECTION_8_15 */\r\n\r\n#define IS_LL_DMA_PRIORITY(__VALUE__)           (((__VALUE__) == LL_DMA_PRIORITY_LOW)    || \\\r\n                                                 ((__VALUE__) == LL_DMA_PRIORITY_MEDIUM) || \\\r\n                                                 ((__VALUE__) == LL_DMA_PRIORITY_HIGH)   || \\\r\n                                                 ((__VALUE__) == LL_DMA_PRIORITY_VERYHIGH))\r\n\r\n#define IS_LL_DMA_ALL_STREAM_INSTANCE(INSTANCE, STREAM)   ((((INSTANCE) == DMA1) && \\\r\n                                                           (((STREAM) == LL_DMA_STREAM_0) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_1) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_2) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_3) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_4) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_5) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_6) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_7) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_ALL))) ||\\\r\n                                                            (((INSTANCE) == DMA2) && \\\r\n                                                          (((STREAM) == LL_DMA_STREAM_0) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_1) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_2) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_3) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_4) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_5) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_6) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_7) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_ALL))))\r\n\r\n#define IS_LL_DMA_FIFO_MODE_STATE(STATE) (((STATE) == LL_DMA_FIFOMODE_DISABLE ) || \\\r\n                                          ((STATE) == LL_DMA_FIFOMODE_ENABLE))\r\n\r\n#define IS_LL_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == LL_DMA_FIFOTHRESHOLD_1_4) || \\\r\n                                             ((THRESHOLD) == LL_DMA_FIFOTHRESHOLD_1_2)  || \\\r\n                                             ((THRESHOLD) == LL_DMA_FIFOTHRESHOLD_3_4)  || \\\r\n                                             ((THRESHOLD) == LL_DMA_FIFOTHRESHOLD_FULL))\r\n\r\n#define IS_LL_DMA_MEMORY_BURST(BURST) (((BURST) == LL_DMA_MBURST_SINGLE) || \\\r\n                                       ((BURST) == LL_DMA_MBURST_INC4)   || \\\r\n                                       ((BURST) == LL_DMA_MBURST_INC8)   || \\\r\n                                       ((BURST) == LL_DMA_MBURST_INC16))\r\n\r\n#define IS_LL_DMA_PERIPHERAL_BURST(BURST) (((BURST) == LL_DMA_PBURST_SINGLE) || \\\r\n                                           ((BURST) == LL_DMA_PBURST_INC4)   || \\\r\n                                           ((BURST) == LL_DMA_PBURST_INC8)   || \\\r\n                                           ((BURST) == LL_DMA_PBURST_INC16))\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup DMA_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup DMA_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize the DMA registers to their default reset values.\r\n  * @param  DMAx DMAx Instance\r\n  * @param  Stream This parameter can be one of the following values:\r\n  *         @arg @ref LL_DMA_STREAM_0\r\n  *         @arg @ref LL_DMA_STREAM_1\r\n  *         @arg @ref LL_DMA_STREAM_2\r\n  *         @arg @ref LL_DMA_STREAM_3\r\n  *         @arg @ref LL_DMA_STREAM_4\r\n  *         @arg @ref LL_DMA_STREAM_5\r\n  *         @arg @ref LL_DMA_STREAM_6\r\n  *         @arg @ref LL_DMA_STREAM_7\r\n  *         @arg @ref LL_DMA_STREAM_ALL\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: DMA registers are de-initialized\r\n  *          - ERROR: DMA registers are not de-initialized\r\n  */\r\nuint32_t LL_DMA_DeInit(DMA_TypeDef *DMAx, uint32_t Stream)\r\n{\r\n  DMA_Stream_TypeDef *tmp = (DMA_Stream_TypeDef *)DMA1_Stream0;\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check the DMA Instance DMAx and Stream parameters*/\r\n  assert_param(IS_LL_DMA_ALL_STREAM_INSTANCE(DMAx, Stream));\r\n\r\n  if (Stream == LL_DMA_STREAM_ALL)\r\n  {\r\n    if (DMAx == DMA1)\r\n    {\r\n      /* Force reset of DMA clock */\r\n      LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_DMA1);\r\n\r\n      /* Release reset of DMA clock */\r\n      LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_DMA1);\r\n    }\r\n    else if (DMAx == DMA2)\r\n    {\r\n      /* Force reset of DMA clock */\r\n      LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_DMA2);\r\n\r\n      /* Release reset of DMA clock */\r\n      LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_DMA2);\r\n    }\r\n    else\r\n    {\r\n      status = ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Disable the selected Stream */\r\n    LL_DMA_DisableStream(DMAx,Stream);\r\n\r\n    /* Get the DMA Stream Instance */\r\n    tmp = (DMA_Stream_TypeDef *)(__LL_DMA_GET_STREAM_INSTANCE(DMAx, Stream));\r\n\r\n    /* Reset DMAx_Streamy configuration register */\r\n    LL_DMA_WriteReg(tmp, CR, 0U);\r\n\r\n    /* Reset DMAx_Streamy remaining bytes register */\r\n    LL_DMA_WriteReg(tmp, NDTR, 0U);\r\n\r\n    /* Reset DMAx_Streamy peripheral address register */\r\n    LL_DMA_WriteReg(tmp, PAR, 0U);\r\n\r\n    /* Reset DMAx_Streamy memory address register */\r\n    LL_DMA_WriteReg(tmp, M0AR, 0U);\r\n\r\n    /* Reset DMAx_Streamy memory address register */\r\n    LL_DMA_WriteReg(tmp, M1AR, 0U);\r\n\r\n    /* Reset DMAx_Streamy FIFO control register */\r\n    LL_DMA_WriteReg(tmp, FCR, 0x00000021U);\r\n\r\n    /* Reset Channel register field for DMAx Stream*/\r\n    LL_DMA_SetChannelSelection(DMAx, Stream, LL_DMA_CHANNEL_0);\r\n\r\n    if(Stream == LL_DMA_STREAM_0)\r\n    {\r\n       /* Reset the Stream0 pending flags */\r\n       DMAx->LIFCR = 0x0000003FU;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_1)\r\n    {\r\n       /* Reset the Stream1 pending flags */\r\n       DMAx->LIFCR = 0x00000F40U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_2)\r\n    {\r\n       /* Reset the Stream2 pending flags */\r\n       DMAx->LIFCR = 0x003F0000U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_3)\r\n    {\r\n       /* Reset the Stream3 pending flags */\r\n       DMAx->LIFCR = 0x0F400000U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_4)\r\n    {\r\n       /* Reset the Stream4 pending flags */\r\n       DMAx->HIFCR = 0x0000003FU;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_5)\r\n    {\r\n       /* Reset the Stream5 pending flags */\r\n       DMAx->HIFCR = 0x00000F40U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_6)\r\n    {\r\n       /* Reset the Stream6 pending flags */\r\n       DMAx->HIFCR = 0x003F0000U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_7)\r\n    {\r\n       /* Reset the Stream7 pending flags */\r\n       DMAx->HIFCR = 0x0F400000U;\r\n    }\r\n    else\r\n    {\r\n      status = ERROR;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize the DMA registers according to the specified parameters in DMA_InitStruct.\r\n  * @note   To convert DMAx_Streamy Instance to DMAx Instance and Streamy, use helper macros :\r\n  *         @arg @ref __LL_DMA_GET_INSTANCE\r\n  *         @arg @ref __LL_DMA_GET_STREAM\r\n  * @param  DMAx DMAx Instance\r\n  * @param  Stream This parameter can be one of the following values:\r\n  *         @arg @ref LL_DMA_STREAM_0\r\n  *         @arg @ref LL_DMA_STREAM_1\r\n  *         @arg @ref LL_DMA_STREAM_2\r\n  *         @arg @ref LL_DMA_STREAM_3\r\n  *         @arg @ref LL_DMA_STREAM_4\r\n  *         @arg @ref LL_DMA_STREAM_5\r\n  *         @arg @ref LL_DMA_STREAM_6\r\n  *         @arg @ref LL_DMA_STREAM_7\r\n  * @param  DMA_InitStruct pointer to a @ref LL_DMA_InitTypeDef structure.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: DMA registers are initialized\r\n  *          - ERROR: Not applicable\r\n  */\r\nuint32_t LL_DMA_Init(DMA_TypeDef *DMAx, uint32_t Stream, LL_DMA_InitTypeDef *DMA_InitStruct)\r\n{\r\n  /* Check the DMA Instance DMAx and Stream parameters*/\r\n  assert_param(IS_LL_DMA_ALL_STREAM_INSTANCE(DMAx, Stream));\r\n\r\n  /* Check the DMA parameters from DMA_InitStruct */\r\n  assert_param(IS_LL_DMA_DIRECTION(DMA_InitStruct->Direction));\r\n  assert_param(IS_LL_DMA_MODE(DMA_InitStruct->Mode));\r\n  assert_param(IS_LL_DMA_PERIPHINCMODE(DMA_InitStruct->PeriphOrM2MSrcIncMode));\r\n  assert_param(IS_LL_DMA_MEMORYINCMODE(DMA_InitStruct->MemoryOrM2MDstIncMode));\r\n  assert_param(IS_LL_DMA_PERIPHDATASIZE(DMA_InitStruct->PeriphOrM2MSrcDataSize));\r\n  assert_param(IS_LL_DMA_MEMORYDATASIZE(DMA_InitStruct->MemoryOrM2MDstDataSize));\r\n  assert_param(IS_LL_DMA_NBDATA(DMA_InitStruct->NbData));\r\n  assert_param(IS_LL_DMA_CHANNEL(DMA_InitStruct->Channel));\r\n  assert_param(IS_LL_DMA_PRIORITY(DMA_InitStruct->Priority));\r\n  assert_param(IS_LL_DMA_FIFO_MODE_STATE(DMA_InitStruct->FIFOMode));\r\n  /* Check the memory burst, peripheral burst and FIFO threshold parameters only\r\n     when FIFO mode is enabled */\r\n  if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)\r\n  {\r\n    assert_param(IS_LL_DMA_FIFO_THRESHOLD(DMA_InitStruct->FIFOThreshold));\r\n    assert_param(IS_LL_DMA_MEMORY_BURST(DMA_InitStruct->MemBurst));\r\n    assert_param(IS_LL_DMA_PERIPHERAL_BURST(DMA_InitStruct->PeriphBurst));\r\n  }\r\n\r\n  /*---------------------------- DMAx SxCR Configuration ------------------------\r\n   * Configure DMAx_Streamy: data transfer direction, data transfer mode,\r\n   *                          peripheral and memory increment mode,\r\n   *                          data size alignment and  priority level with parameters :\r\n   * - Direction:      DMA_SxCR_DIR[1:0] bits\r\n   * - Mode:           DMA_SxCR_CIRC bit\r\n   * - PeriphOrM2MSrcIncMode:  DMA_SxCR_PINC bit\r\n   * - MemoryOrM2MDstIncMode:  DMA_SxCR_MINC bit\r\n   * - PeriphOrM2MSrcDataSize: DMA_SxCR_PSIZE[1:0] bits\r\n   * - MemoryOrM2MDstDataSize: DMA_SxCR_MSIZE[1:0] bits\r\n   * - Priority:               DMA_SxCR_PL[1:0] bits\r\n   */\r\n  LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \\\r\n                        DMA_InitStruct->Mode                    | \\\r\n                        DMA_InitStruct->PeriphOrM2MSrcIncMode   | \\\r\n                        DMA_InitStruct->MemoryOrM2MDstIncMode   | \\\r\n                        DMA_InitStruct->PeriphOrM2MSrcDataSize  | \\\r\n                        DMA_InitStruct->MemoryOrM2MDstDataSize  | \\\r\n                        DMA_InitStruct->Priority\r\n                        );\r\n\r\n  if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)\r\n  {\r\n    /*---------------------------- DMAx SxFCR Configuration ------------------------\r\n     * Configure DMAx_Streamy:  fifo mode and fifo threshold with parameters :\r\n     * - FIFOMode:                DMA_SxFCR_DMDIS bit\r\n     * - FIFOThreshold:           DMA_SxFCR_FTH[1:0] bits\r\n     */\r\n    LL_DMA_ConfigFifo(DMAx, Stream, DMA_InitStruct->FIFOMode, DMA_InitStruct->FIFOThreshold);   \r\n\r\n    /*---------------------------- DMAx SxCR Configuration --------------------------\r\n     * Configure DMAx_Streamy:  memory burst transfer with parameters :\r\n     * - MemBurst:                DMA_SxCR_MBURST[1:0] bits\r\n     */\r\n    LL_DMA_SetMemoryBurstxfer(DMAx,Stream,DMA_InitStruct->MemBurst); \r\n\r\n    /*---------------------------- DMAx SxCR Configuration --------------------------\r\n     * Configure DMAx_Streamy:  peripheral burst transfer with parameters :\r\n     * - PeriphBurst:             DMA_SxCR_PBURST[1:0] bits\r\n     */\r\n    LL_DMA_SetPeriphBurstxfer(DMAx,Stream,DMA_InitStruct->PeriphBurst);\r\n  }\r\n\r\n  /*-------------------------- DMAx SxM0AR Configuration --------------------------\r\n   * Configure the memory or destination base address with parameter :\r\n   * - MemoryOrM2MDstAddress:     DMA_SxM0AR_M0A[31:0] bits\r\n   */\r\n  LL_DMA_SetMemoryAddress(DMAx, Stream, DMA_InitStruct->MemoryOrM2MDstAddress);\r\n\r\n  /*-------------------------- DMAx SxPAR Configuration ---------------------------\r\n   * Configure the peripheral or source base address with parameter :\r\n   * - PeriphOrM2MSrcAddress:     DMA_SxPAR_PA[31:0] bits\r\n   */\r\n  LL_DMA_SetPeriphAddress(DMAx, Stream, DMA_InitStruct->PeriphOrM2MSrcAddress);\r\n\r\n  /*--------------------------- DMAx SxNDTR Configuration -------------------------\r\n   * Configure the peripheral base address with parameter :\r\n   * - NbData:                    DMA_SxNDT[15:0] bits\r\n   */\r\n  LL_DMA_SetDataLength(DMAx, Stream, DMA_InitStruct->NbData);\r\n\r\n  /*--------------------------- DMA SxCR_CHSEL Configuration ----------------------\r\n   * Configure the peripheral base address with parameter :\r\n   * - PeriphRequest:             DMA_SxCR_CHSEL[3:0] bits\r\n   */\r\n  LL_DMA_SetChannelSelection(DMAx, Stream, DMA_InitStruct->Channel);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_DMA_InitTypeDef field to default value.\r\n  * @param  DMA_InitStruct Pointer to a @ref LL_DMA_InitTypeDef structure.\r\n  * @retval None\r\n  */\r\nvoid LL_DMA_StructInit(LL_DMA_InitTypeDef *DMA_InitStruct)\r\n{\r\n  /* Set DMA_InitStruct fields to default values */\r\n  DMA_InitStruct->PeriphOrM2MSrcAddress  = 0x00000000U;\r\n  DMA_InitStruct->MemoryOrM2MDstAddress  = 0x00000000U;\r\n  DMA_InitStruct->Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;\r\n  DMA_InitStruct->Mode                   = LL_DMA_MODE_NORMAL;\r\n  DMA_InitStruct->PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;\r\n  DMA_InitStruct->MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_NOINCREMENT;\r\n  DMA_InitStruct->PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;\r\n  DMA_InitStruct->MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;\r\n  DMA_InitStruct->NbData                 = 0x00000000U;\r\n  DMA_InitStruct->Channel                = LL_DMA_CHANNEL_0;\r\n  DMA_InitStruct->Priority               = LL_DMA_PRIORITY_LOW;\r\n  DMA_InitStruct->FIFOMode               = LL_DMA_FIFOMODE_DISABLE;\r\n  DMA_InitStruct->FIFOThreshold          = LL_DMA_FIFOTHRESHOLD_1_4;\r\n  DMA_InitStruct->MemBurst               = LL_DMA_MBURST_SINGLE;\r\n  DMA_InitStruct->PeriphBurst            = LL_DMA_PBURST_SINGLE;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* DMA1 || DMA2 */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n"},{"name":"stm32f7xx_ll_exti.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_ll_exti.c\r\n  * @author  MCD Application Team\r\n  * @brief   EXTI LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_ll_exti.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (EXTI)\r\n\r\n/** @defgroup EXTI_LL EXTI\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup EXTI_LL_Private_Macros\r\n  * @{\r\n  */\r\n\r\n#define IS_LL_EXTI_LINE_0_31(__VALUE__)              (((__VALUE__) & ~LL_EXTI_LINE_ALL_0_31) == 0x00000000U)\r\n\r\n#define IS_LL_EXTI_MODE(__VALUE__)                   (((__VALUE__) == LL_EXTI_MODE_IT)            \\\r\n                                                   || ((__VALUE__) == LL_EXTI_MODE_EVENT)         \\\r\n                                                   || ((__VALUE__) == LL_EXTI_MODE_IT_EVENT))\r\n\r\n\r\n#define IS_LL_EXTI_TRIGGER(__VALUE__)                (((__VALUE__) == LL_EXTI_TRIGGER_NONE)       \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_RISING)     \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_FALLING)    \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_RISING_FALLING))\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup EXTI_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize the EXTI registers to their default reset values.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: EXTI registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nuint32_t LL_EXTI_DeInit(void)\r\n{\r\n  /* Interrupt mask register set to default reset values */\r\n  LL_EXTI_WriteReg(IMR,   0x00000000U);\r\n  /* Event mask register set to default reset values */\r\n  LL_EXTI_WriteReg(EMR,   0x00000000U);\r\n  /* Rising Trigger selection register set to default reset values */\r\n  LL_EXTI_WriteReg(RTSR,  0x00000000U);\r\n  /* Falling Trigger selection register set to default reset values */\r\n  LL_EXTI_WriteReg(FTSR,  0x00000000U);\r\n  /* Software interrupt event register set to default reset values */\r\n  LL_EXTI_WriteReg(SWIER, 0x00000000U);\r\n  /* Pending register set to default reset values */\r\n  LL_EXTI_WriteReg(PR,    0x01FFFFFFU);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize the EXTI registers according to the specified parameters in EXTI_InitStruct.\r\n  * @param  EXTI_InitStruct pointer to a @ref LL_EXTI_InitTypeDef structure.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: EXTI registers are initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nuint32_t LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_EXTI_LINE_0_31(EXTI_InitStruct->Line_0_31));\r\n  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->LineCommand));\r\n  assert_param(IS_LL_EXTI_MODE(EXTI_InitStruct->Mode));\r\n\r\n  /* ENABLE LineCommand */\r\n  if (EXTI_InitStruct->LineCommand != DISABLE)\r\n  {\r\n    assert_param(IS_LL_EXTI_TRIGGER(EXTI_InitStruct->Trigger));\r\n\r\n    /* Configure EXTI Lines in range from 0 to 31 */\r\n    if (EXTI_InitStruct->Line_0_31 != LL_EXTI_LINE_NONE)\r\n    {\r\n      switch (EXTI_InitStruct->Mode)\r\n      {\r\n        case LL_EXTI_MODE_IT:\r\n          /* First Disable Event on provided Lines */\r\n          LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n          /* Then Enable IT on provided Lines */\r\n          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n          break;\r\n        case LL_EXTI_MODE_EVENT:\r\n          /* First Disable IT on provided Lines */\r\n          LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n          /* Then Enable Event on provided Lines */\r\n          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n          break;\r\n        case LL_EXTI_MODE_IT_EVENT:\r\n          /* Directly Enable IT & Event on provided Lines */\r\n          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n          break;\r\n        default:\r\n          status = ERROR;\r\n          break;\r\n      }\r\n      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)\r\n      {\r\n        switch (EXTI_InitStruct->Trigger)\r\n        {\r\n          case LL_EXTI_TRIGGER_RISING:\r\n            /* First Disable Falling Trigger on provided Lines */\r\n            LL_EXTI_DisableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            /* Then Enable Rising Trigger on provided Lines */\r\n            LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          case LL_EXTI_TRIGGER_FALLING:\r\n            /* First Disable Rising Trigger on provided Lines */\r\n            LL_EXTI_DisableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            /* Then Enable Falling Trigger on provided Lines */\r\n            LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          case LL_EXTI_TRIGGER_RISING_FALLING:\r\n            LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          default:\r\n            status = ERROR;\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /* DISABLE LineCommand */\r\n  else\r\n  {\r\n    /* De-configure EXTI Lines in range from 0 to 31 */\r\n    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_EXTI_InitTypeDef field to default value.\r\n  * @param  EXTI_InitStruct Pointer to a @ref LL_EXTI_InitTypeDef structure.\r\n  * @retval None\r\n  */\r\nvoid LL_EXTI_StructInit(LL_EXTI_InitTypeDef *EXTI_InitStruct)\r\n{\r\n  EXTI_InitStruct->Line_0_31      = LL_EXTI_LINE_NONE;\r\n  EXTI_InitStruct->LineCommand    = DISABLE;\r\n  EXTI_InitStruct->Mode           = LL_EXTI_MODE_IT;\r\n  EXTI_InitStruct->Trigger        = LL_EXTI_TRIGGER_FALLING;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined (EXTI) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n"},{"name":"stm32f7xx_ll_gpio.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_ll_gpio.c\r\n  * @author  MCD Application Team\r\n  * @brief   GPIO LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_ll_gpio.h\"\r\n#include \"stm32f7xx_ll_bus.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI) || defined (GPIOJ) || defined (GPIOK)\r\n\r\n/** @addtogroup GPIO_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup GPIO_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_GPIO_PIN(__VALUE__)          (((0x00000000U) < (__VALUE__)) && ((__VALUE__) <= (LL_GPIO_PIN_ALL)))\r\n\r\n#define IS_LL_GPIO_MODE(__VALUE__)         (((__VALUE__) == LL_GPIO_MODE_INPUT)     ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_OUTPUT)    ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_ALTERNATE) ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_ANALOG))\r\n\r\n#define IS_LL_GPIO_OUTPUT_TYPE(__VALUE__)  (((__VALUE__) == LL_GPIO_OUTPUT_PUSHPULL)  ||\\\r\n                                            ((__VALUE__) == LL_GPIO_OUTPUT_OPENDRAIN))\r\n\r\n#define IS_LL_GPIO_SPEED(__VALUE__)        (((__VALUE__) == LL_GPIO_SPEED_FREQ_LOW)       ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_MEDIUM)    ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_HIGH)      ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_VERY_HIGH))\r\n\r\n#define IS_LL_GPIO_PULL(__VALUE__)         (((__VALUE__) == LL_GPIO_PULL_NO)   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_PULL_UP)   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_PULL_DOWN))\r\n\r\n#define IS_LL_GPIO_ALTERNATE(__VALUE__)    (((__VALUE__) == LL_GPIO_AF_0  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_1  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_2  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_3  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_4  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_5  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_6  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_7  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_8  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_9  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_10 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_11 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_12 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_13 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_14 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_15 ))\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup GPIO_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup GPIO_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize GPIO registers (Registers restored to their default values).\r\n  * @param  GPIOx GPIO Port\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: GPIO registers are de-initialized\r\n  *          - ERROR:   Wrong GPIO Port\r\n  */\r\nErrorStatus LL_GPIO_DeInit(GPIO_TypeDef *GPIOx)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n\r\n  /* Force and Release reset on clock of GPIOx Port */\r\n  if (GPIOx == GPIOA)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n  }\r\n  else if (GPIOx == GPIOB)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOB);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOB);\r\n  }\r\n  else if (GPIOx == GPIOC)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOC);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOC);\r\n  }\r\n#if defined(GPIOD)\r\n  else if (GPIOx == GPIOD)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOD);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOD);\r\n  }\r\n#endif /* GPIOD */\r\n#if defined(GPIOE)\r\n  else if (GPIOx == GPIOE)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOE);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOE);\r\n  }\r\n#endif /* GPIOE */\r\n#if defined(GPIOF)\r\n  else if (GPIOx == GPIOF)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOF);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOF);\r\n  }\r\n#endif /* GPIOF */\r\n#if defined(GPIOG)\r\n  else if (GPIOx == GPIOG)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOG);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOG);\r\n  }\r\n#endif /* GPIOG */\r\n#if defined(GPIOH)\r\n  else if (GPIOx == GPIOH)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOH);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOH);\r\n  }\r\n#endif /* GPIOH */\r\n#if defined(GPIOI)\r\n  else if (GPIOx == GPIOI)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOI);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOI);\r\n  }\r\n#endif /* GPIOI */\r\n#if defined(GPIOJ)\r\n  else if (GPIOx == GPIOJ)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOJ);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOJ);\r\n  }\r\n#endif /* GPIOJ */\r\n#if defined(GPIOK)\r\n  else if (GPIOx == GPIOK)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOK);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOK);\r\n  }\r\n#endif /* GPIOK */\r\n  else\r\n  {\r\n    status = ERROR;\r\n  }\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief  Initialize GPIO registers according to the specified parameters in GPIO_InitStruct.\r\n  * @param  GPIOx GPIO Port\r\n  * @param  GPIO_InitStruct pointer to a @ref LL_GPIO_InitTypeDef structure\r\n  *         that contains the configuration information for the specified GPIO peripheral.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content\r\n  *          - ERROR:   Not applicable\r\n  */\r\nErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)\r\n{\r\n  uint32_t pinpos     = 0x00000000U;\r\n  uint32_t currentpin = 0x00000000U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n  assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));\r\n  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));\r\n  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));\r\n\r\n  /* ------------------------- Configure the port pins ---------------- */\r\n  /* Initialize  pinpos on first pin set */\r\n  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);\r\n\r\n  /* Configure the port pins */\r\n  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)\r\n  {\r\n    /* Get current io position */\r\n    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);\r\n\r\n    if (currentpin)\r\n    {\r\n      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))\r\n      {\r\n        /* Check Speed mode parameters */\r\n        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));\r\n\r\n        /* Speed mode configuration */\r\n        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);\r\n\r\n        /* Check Output mode parameters */\r\n        assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));\r\n\r\n        /* Output mode configuration*/\r\n        LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);\r\n      }\r\n\r\n      /* Pull-up Pull down resistor configuration*/\r\n      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);\r\n\r\n      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)\r\n      {\r\n        /* Check Alternate parameter */\r\n        assert_param(IS_LL_GPIO_ALTERNATE(GPIO_InitStruct->Alternate));\r\n\r\n        /* Speed mode configuration */\r\n        if (POSITION_VAL(currentpin) < 0x00000008U)\r\n        {\r\n          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);\r\n        }\r\n        else\r\n        {\r\n          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);\r\n        }\r\n      }\r\n      /* Pin Mode configuration */\r\n      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);\r\n    }\r\n    pinpos++;\r\n  }\r\n  return (SUCCESS);\r\n}\r\n\r\n/**\r\n  * @brief Set each @ref LL_GPIO_InitTypeDef field to default value.\r\n  * @param GPIO_InitStruct pointer to a @ref LL_GPIO_InitTypeDef structure\r\n  *                          whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\n\r\nvoid LL_GPIO_StructInit(LL_GPIO_InitTypeDef *GPIO_InitStruct)\r\n{\r\n  /* Reset GPIO init structure parameters values */\r\n  GPIO_InitStruct->Pin        = LL_GPIO_PIN_ALL;\r\n  GPIO_InitStruct->Mode       = LL_GPIO_MODE_ANALOG;\r\n  GPIO_InitStruct->Speed      = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct->OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct->Pull       = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct->Alternate  = LL_GPIO_AF_0;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI) || defined (GPIOJ) || defined (GPIOK) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n"},{"name":"stm32f7xx_ll_rcc.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_ll_rcc.c\r\n  * @author  MCD Application Team\r\n  * @brief   RCC LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_ll_rcc.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n  #include \"stm32_assert.h\"\r\n#else\r\n  #define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined(RCC)\r\n\r\n/** @addtogroup RCC_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup RCC_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_USART2_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_USART3_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_USART6_CLKSOURCE))\r\n\r\n#define IS_LL_RCC_UART_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_UART4_CLKSOURCE) \\\r\n                                             || ((__VALUE__) == LL_RCC_UART5_CLKSOURCE) \\\r\n                                             || ((__VALUE__) == LL_RCC_UART7_CLKSOURCE) \\\r\n                                             || ((__VALUE__) == LL_RCC_UART8_CLKSOURCE))\r\n\r\n#if defined(I2C4)\r\n#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_I2C2_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_I2C4_CLKSOURCE))\r\n#else\r\n#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_I2C2_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE))\r\n#endif /* I2C4 */\r\n\r\n#define IS_LL_RCC_LPTIM_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_LPTIM1_CLKSOURCE))\r\n\r\n#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SAI1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI2_CLKSOURCE))\r\n\r\n#if defined(SDMMC2)\r\n#define IS_LL_RCC_SDMMC_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_SDMMC1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SDMMC2_CLKSOURCE))\r\n#else\r\n#define IS_LL_RCC_SDMMC_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_SDMMC1_CLKSOURCE))\r\n#endif /* SDMMC2 */\r\n\r\n#define IS_LL_RCC_RNG_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_RNG_CLKSOURCE))\r\n\r\n#define IS_LL_RCC_USB_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_USB_CLKSOURCE))\r\n\r\n#if defined(DFSDM1_Channel0)\r\n#define IS_LL_RCC_DFSDM_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DFSDM1_CLKSOURCE))\r\n\r\n#define IS_LL_RCC_DFSDM_AUDIO_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DFSDM1_AUDIO_CLKSOURCE))\r\n#endif /* DFSDM1_Channel0 */\r\n\r\n#define IS_LL_RCC_I2S_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2S1_CLKSOURCE))\r\n\r\n#if defined(CEC)\r\n#define IS_LL_RCC_CEC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_CEC_CLKSOURCE))\r\n#endif /* CEC */\r\n\r\n#if defined(DSI)\r\n#define IS_LL_RCC_DSI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DSI_CLKSOURCE))\r\n#endif /* DSI */\r\n\r\n#if defined(LTDC)\r\n#define IS_LL_RCC_LTDC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_LTDC_CLKSOURCE))\r\n#endif /* LTDC */\r\n\r\n#if defined(SPDIFRX)\r\n#define IS_LL_RCC_SPDIFRX_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SPDIFRX1_CLKSOURCE))\r\n#endif /* SPDIFRX */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup RCC_LL_Private_Functions RCC Private functions\r\n  * @{\r\n  */\r\nuint32_t RCC_GetSystemClockFreq(void);\r\nuint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency);\r\nuint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency);\r\nuint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency);\r\nuint32_t RCC_PLL_GetFreqDomain_SYS(void);\r\nuint32_t RCC_PLL_GetFreqDomain_SAI(void);\r\nuint32_t RCC_PLL_GetFreqDomain_48M(void);\r\n#if defined(DSI)\r\nuint32_t RCC_PLL_GetFreqDomain_DSI(void);\r\n#endif /* DSI */\r\nuint32_t RCC_PLLSAI_GetFreqDomain_SAI(void);\r\nuint32_t RCC_PLLSAI_GetFreqDomain_48M(void);\r\n#if defined(LTDC)\r\nuint32_t RCC_PLLSAI_GetFreqDomain_LTDC(void);\r\n#endif /* LTDC */\r\nuint32_t RCC_PLLI2S_GetFreqDomain_I2S(void);\r\nuint32_t RCC_PLLI2S_GetFreqDomain_SAI(void);\r\n#if defined(SPDIFRX)\r\nuint32_t RCC_PLLI2S_GetFreqDomain_SPDIFRX(void);\r\n#endif /* SPDIFRX */\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup RCC_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup RCC_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Reset the RCC clock configuration to the default reset state.\r\n  * @note   The default reset state of the clock configuration is given below:\r\n  *         - HSI ON and used as system clock source\r\n  *         - HSE, PLL, PLLI2S, PLLSAI OFF\r\n  *         - AHB, APB1 and APB2 prescaler set to 1.\r\n  *         - CSS, MCO OFF\r\n  *         - All interrupts disabled\r\n  * @note   This function doesn't modify the configuration of the\r\n  *         - Peripheral clocks\r\n  *         - LSI, LSE and RTC clocks\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: RCC registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_RCC_DeInit(void)\r\n{\r\n  __IO uint32_t vl_mask;\r\n\r\n  /* Set HSION bit */\r\n  LL_RCC_HSI_Enable();\r\n\r\n  /* Wait for HSI READY bit */\r\n  while(LL_RCC_HSI_IsReady() != 1U)\r\n  {}\r\n\r\n  /* Reset CFGR register */\r\n  LL_RCC_WriteReg(CFGR, 0x00000000U);\r\n\r\n  /* Read CR register */\r\n  vl_mask = LL_RCC_ReadReg(CR);\r\n  \r\n  /* Reset HSEON, HSEBYP, PLLON, CSSON, PLLI2SON and PLLSAION bits */\r\n  CLEAR_BIT(vl_mask, (RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_PLLON | RCC_CR_CSSON | RCC_CR_PLLSAION | RCC_CR_PLLI2SON));\r\n\r\n  /* Write new value in CR register */\r\n  LL_RCC_WriteReg(CR, vl_mask);\r\n\r\n  /* Set HSITRIM bits to the reset value*/\r\n  LL_RCC_HSI_SetCalibTrimming(0x10U);\r\n\r\n  /* Wait for PLL READY bit to be reset */\r\n  while(LL_RCC_PLL_IsReady() != 0U)\r\n  {}\r\n\r\n  /* Wait for PLLI2S READY bit to be reset */\r\n  while(LL_RCC_PLLI2S_IsReady() != 0U)\r\n  {}\r\n\r\n  /* Wait for PLLSAI READY bit to be reset */\r\n  while(LL_RCC_PLLSAI_IsReady() != 0U)\r\n  {}\r\n\r\n  /* Reset PLLCFGR register */\r\n  LL_RCC_WriteReg(PLLCFGR, 0x24003010U);\r\n\r\n  /* Reset PLLI2SCFGR register */\r\n  LL_RCC_WriteReg(PLLI2SCFGR, 0x24003000U);\r\n\r\n  /* Reset PLLSAICFGR register */\r\n  LL_RCC_WriteReg(PLLSAICFGR, 0x24003000U);\r\n\r\n  /* Disable all interrupts */\r\n  CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE | RCC_CIR_PLLI2SRDYIE | RCC_CIR_PLLSAIRDYIE);\r\n\r\n  /* Clear all interrupt flags */\r\n  SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_PLLI2SRDYC | RCC_CIR_PLLSAIRDYC | RCC_CIR_CSSC);\r\n\r\n  /* Clear LSION bit */\r\n  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);\r\n\r\n  /* Reset all CSR flags */\r\n  SET_BIT(RCC->CSR, RCC_CSR_RMVF);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup RCC_LL_EF_Get_Freq\r\n  * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1 and APB2 buses clocks\r\n  *         and different peripheral clocks available on the device.\r\n  * @note   If SYSCLK source is HSI, function returns values based on HSI_VALUE(**)\r\n  * @note   If SYSCLK source is HSE, function returns values based on HSE_VALUE(***)\r\n  * @note   If SYSCLK source is PLL, function returns values based on HSE_VALUE(***)\r\n  *         or HSI_VALUE(**) multiplied/divided by the PLL factors.\r\n  * @note   (**) HSI_VALUE is a constant defined in this file (default value\r\n  *              16 MHz) but the real value may vary depending on the variations\r\n  *              in voltage and temperature.\r\n  * @note   (***) HSE_VALUE is a constant defined in this file (default value\r\n  *               25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *               frequency of the crystal used. Otherwise, this function may\r\n  *               have wrong result.\r\n  * @note   The result of this function could be incorrect when using fractional\r\n  *         value for HSE crystal.\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baud-rate for the communication peripherals or configure other parameters.\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1 and APB2 buses clocks\r\n  * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function\r\n  *         must be called to update structure fields. Otherwise, any\r\n  *         configuration based on this function will be incorrect.\r\n  * @param  RCC_Clocks pointer to a @ref LL_RCC_ClocksTypeDef structure which will hold the clocks frequencies\r\n  * @retval None\r\n  */\r\nvoid LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)\r\n{\r\n  /* Get SYSCLK frequency */\r\n  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();\r\n\r\n  /* HCLK clock frequency */\r\n  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);\r\n\r\n  /* PCLK1 clock frequency */\r\n  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);\r\n\r\n  /* PCLK2 clock frequency */\r\n  RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);\r\n}\r\n\r\n/**\r\n  * @brief  Return USARTx clock frequency\r\n  * @param  USARTxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_USART1_CLKSOURCE\r\n  *         @arg @ref LL_RCC_USART2_CLKSOURCE\r\n  *         @arg @ref LL_RCC_USART3_CLKSOURCE\r\n  *         @arg @ref LL_RCC_USART6_CLKSOURCE\r\n  * @retval USART clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready\r\n  */\r\nuint32_t LL_RCC_GetUSARTClockFreq(uint32_t USARTxSource)\r\n{\r\n  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_USART_CLKSOURCE(USARTxSource));\r\n\r\n  if (USARTxSource == LL_RCC_USART1_CLKSOURCE)\r\n  {\r\n    /* USART1CLK clock frequency */\r\n    switch (LL_RCC_GetUSARTClockSource(USARTxSource))\r\n    {\r\n      case LL_RCC_USART1_CLKSOURCE_SYSCLK: /* USART1 Clock is System Clock */\r\n        usart_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_USART1_CLKSOURCE_HSI:    /* USART1 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          usart_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_USART1_CLKSOURCE_LSE:    /* USART1 Clock is LSE Osc. */\r\n        if (LL_RCC_LSE_IsReady())\r\n        {\r\n          usart_frequency = LSE_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_USART1_CLKSOURCE_PCLK2:  /* USART1 Clock is PCLK2 */\r\n      default:\r\n        usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n  else if (USARTxSource == LL_RCC_USART2_CLKSOURCE)\r\n  {\r\n    /* USART2CLK clock frequency */\r\n    switch (LL_RCC_GetUSARTClockSource(USARTxSource))\r\n    {\r\n      case LL_RCC_USART2_CLKSOURCE_SYSCLK: /* USART2 Clock is System Clock */\r\n        usart_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_USART2_CLKSOURCE_HSI:    /* USART2 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          usart_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_USART2_CLKSOURCE_LSE:    /* USART2 Clock is LSE Osc. */\r\n        if (LL_RCC_LSE_IsReady())\r\n        {\r\n          usart_frequency = LSE_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_USART2_CLKSOURCE_PCLK1:  /* USART2 Clock is PCLK1 */\r\n      default:\r\n        usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n  else if (USARTxSource == LL_RCC_USART6_CLKSOURCE)\r\n  {\r\n    /* USART6CLK clock frequency */\r\n    switch (LL_RCC_GetUSARTClockSource(USARTxSource))\r\n    {\r\n      case LL_RCC_USART6_CLKSOURCE_SYSCLK: /* USART6 Clock is System Clock */\r\n        usart_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_USART6_CLKSOURCE_HSI:    /* USART6 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          usart_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_USART6_CLKSOURCE_LSE:    /* USART6 Clock is LSE Osc. */\r\n        if (LL_RCC_LSE_IsReady())\r\n        {\r\n          usart_frequency = LSE_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_USART6_CLKSOURCE_PCLK2:  /* USART6 Clock is PCLK2 */\r\n      default:\r\n        usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (USARTxSource == LL_RCC_USART3_CLKSOURCE)\r\n    {\r\n      /* USART3CLK clock frequency */\r\n      switch (LL_RCC_GetUSARTClockSource(USARTxSource))\r\n      {\r\n        case LL_RCC_USART3_CLKSOURCE_SYSCLK: /* USART3 Clock is System Clock */\r\n          usart_frequency = RCC_GetSystemClockFreq();\r\n          break;\r\n\r\n        case LL_RCC_USART3_CLKSOURCE_HSI:    /* USART3 Clock is HSI Osc. */\r\n          if (LL_RCC_HSI_IsReady())\r\n          {\r\n            usart_frequency = HSI_VALUE;\r\n          }\r\n          break;\r\n\r\n        case LL_RCC_USART3_CLKSOURCE_LSE:    /* USART3 Clock is LSE Osc. */\r\n          if (LL_RCC_LSE_IsReady())\r\n          {\r\n            usart_frequency = LSE_VALUE;\r\n          }\r\n          break;\r\n\r\n        case LL_RCC_USART3_CLKSOURCE_PCLK1:  /* USART3 Clock is PCLK1 */\r\n        default:\r\n          usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  return usart_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return UARTx clock frequency\r\n  * @param  UARTxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_UART4_CLKSOURCE\r\n  *         @arg @ref LL_RCC_UART5_CLKSOURCE\r\n  *         @arg @ref LL_RCC_UART7_CLKSOURCE\r\n  *         @arg @ref LL_RCC_UART8_CLKSOURCE\r\n  * @retval UART clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready\r\n  */\r\nuint32_t LL_RCC_GetUARTClockFreq(uint32_t UARTxSource)\r\n{\r\n  uint32_t uart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_UART_CLKSOURCE(UARTxSource));\r\n\r\n  if (UARTxSource == LL_RCC_UART4_CLKSOURCE)\r\n  {\r\n    /* UART4CLK clock frequency */\r\n    switch (LL_RCC_GetUARTClockSource(UARTxSource))\r\n    {\r\n      case LL_RCC_UART4_CLKSOURCE_SYSCLK: /* UART4 Clock is System Clock */\r\n        uart_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_UART4_CLKSOURCE_HSI:    /* UART4 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          uart_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_UART4_CLKSOURCE_LSE:    /* UART4 Clock is LSE Osc. */\r\n        if (LL_RCC_LSE_IsReady())\r\n        {\r\n          uart_frequency = LSE_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_UART4_CLKSOURCE_PCLK1:  /* UART4 Clock is PCLK1 */\r\n      default:\r\n        uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n  else if (UARTxSource == LL_RCC_UART5_CLKSOURCE)\r\n  {\r\n    /* UART5CLK clock frequency */\r\n    switch (LL_RCC_GetUARTClockSource(UARTxSource))\r\n    {\r\n      case LL_RCC_UART5_CLKSOURCE_SYSCLK: /* UART5 Clock is System Clock */\r\n        uart_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_UART5_CLKSOURCE_HSI:    /* UART5 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          uart_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_UART5_CLKSOURCE_LSE:    /* UART5 Clock is LSE Osc. */\r\n        if (LL_RCC_LSE_IsReady())\r\n        {\r\n          uart_frequency = LSE_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_UART5_CLKSOURCE_PCLK1:  /* UART5 Clock is PCLK1 */\r\n      default:\r\n        uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n  else if (UARTxSource == LL_RCC_UART7_CLKSOURCE)\r\n  {\r\n    /* UART7CLK clock frequency */\r\n    switch (LL_RCC_GetUARTClockSource(UARTxSource))\r\n    {\r\n      case LL_RCC_UART7_CLKSOURCE_SYSCLK: /* UART7 Clock is System Clock */\r\n        uart_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_UART7_CLKSOURCE_HSI:    /* UART7 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          uart_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_UART7_CLKSOURCE_LSE:    /* UART7 Clock is LSE Osc. */\r\n        if (LL_RCC_LSE_IsReady())\r\n        {\r\n          uart_frequency = LSE_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_UART7_CLKSOURCE_PCLK1:  /* UART7 Clock is PCLK1 */\r\n      default:\r\n        uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (UARTxSource == LL_RCC_UART8_CLKSOURCE)\r\n    {\r\n      /* UART8CLK clock frequency */\r\n      switch (LL_RCC_GetUARTClockSource(UARTxSource))\r\n      {\r\n        case LL_RCC_UART8_CLKSOURCE_SYSCLK: /* UART8 Clock is System Clock */\r\n          uart_frequency = RCC_GetSystemClockFreq();\r\n          break;\r\n\r\n        case LL_RCC_UART8_CLKSOURCE_HSI:    /* UART8 Clock is HSI Osc. */\r\n          if (LL_RCC_HSI_IsReady())\r\n          {\r\n            uart_frequency = HSI_VALUE;\r\n          }\r\n          break;\r\n\r\n        case LL_RCC_UART8_CLKSOURCE_LSE:    /* UART8 Clock is LSE Osc. */\r\n          if (LL_RCC_LSE_IsReady())\r\n          {\r\n            uart_frequency = LSE_VALUE;\r\n          }\r\n          break;\r\n\r\n        case LL_RCC_UART8_CLKSOURCE_PCLK1:  /* UART8 Clock is PCLK1 */\r\n        default:\r\n          uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  return uart_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return I2Cx clock frequency\r\n  * @param  I2CxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_I2C1_CLKSOURCE\r\n  *         @arg @ref LL_RCC_I2C2_CLKSOURCE\r\n  *         @arg @ref LL_RCC_I2C3_CLKSOURCE\r\n  *         @arg @ref LL_RCC_I2C4_CLKSOURCE (*)\r\n  *\r\n  *         (*) value not defined in all devices.\r\n  * @retval I2C clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that HSI oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetI2CClockFreq(uint32_t I2CxSource)\r\n{\r\n  uint32_t i2c_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_I2C_CLKSOURCE(I2CxSource));\r\n\r\n  if (I2CxSource == LL_RCC_I2C1_CLKSOURCE)\r\n  {\r\n    /* I2C1 CLK clock frequency */\r\n    switch (LL_RCC_GetI2CClockSource(I2CxSource))\r\n    {\r\n      case LL_RCC_I2C1_CLKSOURCE_SYSCLK: /* I2C1 Clock is System Clock */\r\n        i2c_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_I2C1_CLKSOURCE_HSI:    /* I2C1 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          i2c_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_I2C1_CLKSOURCE_PCLK1:  /* I2C1 Clock is PCLK1 */\r\n      default:\r\n        i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n  else if (I2CxSource == LL_RCC_I2C2_CLKSOURCE)\r\n  {\r\n    /* I2C2 CLK clock frequency */\r\n    switch (LL_RCC_GetI2CClockSource(I2CxSource))\r\n    {\r\n      case LL_RCC_I2C2_CLKSOURCE_SYSCLK: /* I2C2 Clock is System Clock */\r\n        i2c_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_I2C2_CLKSOURCE_HSI:    /* I2C2 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          i2c_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_I2C2_CLKSOURCE_PCLK1:  /* I2C2 Clock is PCLK1 */\r\n      default:\r\n        i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n  else if (I2CxSource == LL_RCC_I2C3_CLKSOURCE)\r\n  {\r\n    /* I2C3 CLK clock frequency */\r\n    switch (LL_RCC_GetI2CClockSource(I2CxSource))\r\n    {\r\n      case LL_RCC_I2C3_CLKSOURCE_SYSCLK: /* I2C3 Clock is System Clock */\r\n        i2c_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_I2C3_CLKSOURCE_HSI:    /* I2C3 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          i2c_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_I2C3_CLKSOURCE_PCLK1:  /* I2C3 Clock is PCLK1 */\r\n      default:\r\n        i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n#if defined(I2C4)\r\n  else\r\n  {\r\n    if (I2CxSource == LL_RCC_I2C4_CLKSOURCE)\r\n    {\r\n      /* I2C4 CLK clock frequency */\r\n      switch (LL_RCC_GetI2CClockSource(I2CxSource))\r\n      {\r\n        case LL_RCC_I2C4_CLKSOURCE_SYSCLK: /* I2C4 Clock is System Clock */\r\n          i2c_frequency = RCC_GetSystemClockFreq();\r\n          break;\r\n\r\n        case LL_RCC_I2C4_CLKSOURCE_HSI:    /* I2C4 Clock is HSI Osc. */\r\n          if (LL_RCC_HSI_IsReady())\r\n          {\r\n            i2c_frequency = HSI_VALUE;\r\n          }\r\n          break;\r\n\r\n        case LL_RCC_I2C4_CLKSOURCE_PCLK1:  /* I2C4 Clock is PCLK1 */\r\n        default:\r\n          i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n          break;\r\n      }\r\n    }\r\n  }\r\n#endif /* I2C4 */\r\n\r\n  return i2c_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return I2Sx clock frequency\r\n  * @param  I2SxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_I2S1_CLKSOURCE\r\n  * @retval I2S clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that PLLI2S oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetI2SClockFreq(uint32_t I2SxSource)\r\n{\r\n  uint32_t i2s_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_I2S_CLKSOURCE(I2SxSource));\r\n\r\n  if (I2SxSource == LL_RCC_I2S1_CLKSOURCE)\r\n  {\r\n    /* I2S1 CLK clock frequency */\r\n    switch (LL_RCC_GetI2SClockSource(I2SxSource))\r\n    {\r\n      case LL_RCC_I2S1_CLKSOURCE_PLLI2S:       /* I2S1 Clock is PLLI2S */\r\n        if (LL_RCC_PLLI2S_IsReady())\r\n        {\r\n          i2s_frequency = RCC_PLLI2S_GetFreqDomain_I2S();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_I2S1_CLKSOURCE_PIN:          /* I2S1 Clock is External clock */\r\n      default:\r\n        i2s_frequency = EXTERNAL_CLOCK_VALUE;\r\n        break;\r\n    }\r\n  }\r\n\r\n  return i2s_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return LPTIMx clock frequency\r\n  * @param  LPTIMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE\r\n  * @retval LPTIM clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI, LSI or LSE) is not ready\r\n  */\r\nuint32_t LL_RCC_GetLPTIMClockFreq(uint32_t LPTIMxSource)\r\n{\r\n  uint32_t lptim_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_LPTIM_CLKSOURCE(LPTIMxSource));\r\n\r\n  if (LPTIMxSource == LL_RCC_LPTIM1_CLKSOURCE)\r\n  {\r\n    /* LPTIM1CLK clock frequency */\r\n    switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))\r\n    {\r\n      case LL_RCC_LPTIM1_CLKSOURCE_LSI:    /* LPTIM1 Clock is LSI Osc. */\r\n        if (LL_RCC_LSI_IsReady())\r\n        {\r\n          lptim_frequency = LSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_LPTIM1_CLKSOURCE_HSI:    /* LPTIM1 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          lptim_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_LPTIM1_CLKSOURCE_LSE:    /* LPTIM1 Clock is LSE Osc. */\r\n        if (LL_RCC_LSE_IsReady())\r\n        {\r\n          lptim_frequency = LSE_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_LPTIM1_CLKSOURCE_PCLK1:  /* LPTIM1 Clock is PCLK1 */\r\n      default:\r\n        lptim_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n\r\n  return lptim_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return SAIx clock frequency\r\n  * @param  SAIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SAI1_CLKSOURCE\r\n  *         @arg @ref LL_RCC_SAI2_CLKSOURCE\r\n  * @retval SAI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that PLL is not ready\r\n  */\r\nuint32_t LL_RCC_GetSAIClockFreq(uint32_t SAIxSource)\r\n{\r\n  uint32_t sai_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_SAI_CLKSOURCE(SAIxSource));\r\n\r\n  if (SAIxSource == LL_RCC_SAI1_CLKSOURCE)\r\n  {\r\n    /* SAI1CLK clock frequency */\r\n    switch (LL_RCC_GetSAIClockSource(SAIxSource))\r\n    {\r\n      case LL_RCC_SAI1_CLKSOURCE_PLLSAI:    /* PLLSAI clock used as SAI1 clock source */\r\n        if (LL_RCC_PLLSAI_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLLSAI_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SAI1_CLKSOURCE_PLLI2S:    /* PLLI2S clock used as SAI1 clock source */\r\n        if (LL_RCC_PLLI2S_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLLI2S_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n#if defined(RCC_SAI1SEL_PLLSRC_SUPPORT)\r\n      case LL_RCC_SAI1_CLKSOURCE_PLLSRC:\r\n        switch (LL_RCC_PLL_GetMainSource())\r\n        {\r\n           case LL_RCC_PLLSOURCE_HSE:       /* HSE clock used as SAI1 clock source */\r\n             if (LL_RCC_HSE_IsReady())\r\n             {\r\n               sai_frequency = HSE_VALUE;\r\n             }\r\n             break;\r\n\r\n           case LL_RCC_PLLSOURCE_HSI:       /* HSI clock used as SAI1 clock source */\r\n           default:\r\n             if (LL_RCC_HSI_IsReady())\r\n             {\r\n               sai_frequency = HSI_VALUE;\r\n             }\r\n             break;\r\n        }\r\n        break;\r\n#endif /* RCC_SAI1SEL_PLLSRC_SUPPORT */\r\n      case LL_RCC_SAI1_CLKSOURCE_PIN:        /* External input clock used as SAI1 clock source */\r\n        sai_frequency = EXTERNAL_SAI1_CLOCK_VALUE;\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (SAIxSource == LL_RCC_SAI2_CLKSOURCE)\r\n    {\r\n      /* SAI2CLK clock frequency */\r\n      switch (LL_RCC_GetSAIClockSource(SAIxSource))\r\n      {\r\n      case LL_RCC_SAI2_CLKSOURCE_PLLSAI:    /* PLLSAI clock used as SAI2 clock source */\r\n        if (LL_RCC_PLLSAI_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLLSAI_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SAI2_CLKSOURCE_PLLI2S:    /* PLLI2S clock used as SAI2 clock source */\r\n        if (LL_RCC_PLLI2S_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLLI2S_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n#if defined(RCC_SAI2SEL_PLLSRC_SUPPORT)\r\n      case LL_RCC_SAI2_CLKSOURCE_PLLSRC:\r\n        switch (LL_RCC_PLL_GetMainSource())\r\n        {\r\n           case LL_RCC_PLLSOURCE_HSE:       /* HSE clock used as SAI2 clock source */\r\n             if (LL_RCC_HSE_IsReady())\r\n             {\r\n               sai_frequency = HSE_VALUE;\r\n             }\r\n             break;\r\n\r\n           case LL_RCC_PLLSOURCE_HSI:       /* HSI clock used as SAI2 clock source */\r\n           default:\r\n             if (LL_RCC_HSI_IsReady())\r\n             {\r\n               sai_frequency = HSI_VALUE;\r\n             }\r\n             break;\r\n        }\r\n        break;\r\n#endif /* RCC_SAI2SEL_PLLSRC_SUPPORT */\r\n        case LL_RCC_SAI2_CLKSOURCE_PIN:      /* External input clock used as SAI2 clock source */\r\n          sai_frequency = EXTERNAL_SAI2_CLOCK_VALUE;\r\n          break;\r\n\r\n      default:\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return sai_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return SDMMCx clock frequency\r\n  * @param  SDMMCxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE\r\n  *         @arg @ref LL_RCC_SDMMC2_CLKSOURCE (*)\r\n  *\r\n  *         (*) value not defined in all devices.\r\n  * @retval SDMMC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator PLL is not ready\r\n  */\r\nuint32_t LL_RCC_GetSDMMCClockFreq(uint32_t SDMMCxSource)\r\n{\r\n  uint32_t sdmmc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_SDMMC_CLKSOURCE(SDMMCxSource));\r\n\r\n  if (SDMMCxSource == LL_RCC_SDMMC1_CLKSOURCE)\r\n  {\r\n    /* SDMMC1CLK clock frequency */\r\n    switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))\r\n    {\r\n      case LL_RCC_SDMMC1_CLKSOURCE_PLL48CLK:        /* PLL48 clock used as SDMMC1 clock source */\r\n        switch (LL_RCC_GetCK48MClockSource(LL_RCC_CK48M_CLKSOURCE))\r\n        {\r\n          case LL_RCC_CK48M_CLKSOURCE_PLL:         /* PLL clock used as 48Mhz domain clock */\r\n            if (LL_RCC_PLL_IsReady())\r\n            {\r\n              sdmmc_frequency = RCC_PLL_GetFreqDomain_48M();\r\n            }\r\n          break;\r\n\r\n          case LL_RCC_CK48M_CLKSOURCE_PLLSAI:      /* PLLSAI clock used as 48Mhz domain clock */\r\n          default:\r\n            if (LL_RCC_PLLSAI_IsReady())\r\n            {\r\n              sdmmc_frequency = RCC_PLLSAI_GetFreqDomain_48M();\r\n            }\r\n            break;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SDMMC1_CLKSOURCE_SYSCLK:        /* PLL clock used as SDMMC1 clock source */\r\n      default:\r\n      sdmmc_frequency = RCC_GetSystemClockFreq();\r\n      break;\r\n    }\r\n  }\r\n#if defined(SDMMC2)\r\n  else\r\n  {\r\n     /* SDMMC2CLK clock frequency */\r\n     switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))\r\n     {\r\n       case LL_RCC_SDMMC2_CLKSOURCE_PLL48CLK:        /* PLL48 clock used as SDMMC2 clock source */\r\n         switch (LL_RCC_GetCK48MClockSource(LL_RCC_CK48M_CLKSOURCE))\r\n         {\r\n           case LL_RCC_CK48M_CLKSOURCE_PLL:         /* PLL clock used as 48Mhz domain clock */\r\n             if (LL_RCC_PLL_IsReady())\r\n             {\r\n               sdmmc_frequency = RCC_PLL_GetFreqDomain_48M();\r\n             }\r\n           break;\r\n\r\n           case LL_RCC_CK48M_CLKSOURCE_PLLSAI:      /* PLLSAI clock used as 48Mhz domain clock */\r\n           default:\r\n             if (LL_RCC_PLLSAI_IsReady())\r\n             {\r\n               sdmmc_frequency = RCC_PLLSAI_GetFreqDomain_48M();\r\n             }\r\n             break;\r\n         }\r\n         break;\r\n\r\n       case LL_RCC_SDMMC2_CLKSOURCE_SYSCLK:        /* PLL clock used as SDMMC2 clock source */\r\n       default:\r\n       sdmmc_frequency = RCC_GetSystemClockFreq();\r\n       break;\r\n     }\r\n  }\r\n#endif /* SDMMC2 */\r\n\r\n  return sdmmc_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return RNGx clock frequency\r\n  * @param  RNGxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_RNG_CLKSOURCE\r\n  * @retval RNG clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetRNGClockFreq(uint32_t RNGxSource)\r\n{\r\n  uint32_t rng_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_RNG_CLKSOURCE(RNGxSource));\r\n\r\n  /* RNGCLK clock frequency */\r\n  switch (LL_RCC_GetRNGClockSource(RNGxSource))\r\n  {\r\n    case LL_RCC_RNG_CLKSOURCE_PLL:           /* PLL clock used as RNG clock source */\r\n      if (LL_RCC_PLL_IsReady())\r\n      {\r\n        rng_frequency = RCC_PLL_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_RNG_CLKSOURCE_PLLSAI:       /* PLLSAI clock used as RNG clock source */\r\n    default:\r\n      if (LL_RCC_PLLSAI_IsReady())\r\n      {\r\n        rng_frequency = RCC_PLLSAI_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n  }\r\n\r\n  return rng_frequency;\r\n}\r\n\r\n#if defined(CEC)\r\n/**\r\n  * @brief  Return CEC clock frequency\r\n  * @param  CECxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_CEC_CLKSOURCE\r\n  * @retval CEC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready\r\n  */\r\nuint32_t LL_RCC_GetCECClockFreq(uint32_t CECxSource)\r\n{\r\n  uint32_t cec_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_CEC_CLKSOURCE(CECxSource));\r\n\r\n  /* CECCLK clock frequency */\r\n  switch (LL_RCC_GetCECClockSource(CECxSource))\r\n  {\r\n    case LL_RCC_CEC_CLKSOURCE_LSE:           /* CEC Clock is LSE Osc. */\r\n      if (LL_RCC_LSE_IsReady())\r\n      {\r\n        cec_frequency = LSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_CEC_CLKSOURCE_HSI_DIV488:    /* CEC Clock is HSI Osc. */\r\n    default:\r\n      if (LL_RCC_HSI_IsReady())\r\n      {\r\n        cec_frequency = HSI_VALUE/488U;\r\n      }\r\n      break;\r\n  }\r\n\r\n  return cec_frequency;\r\n}\r\n#endif /* CEC */\r\n\r\n/**\r\n  * @brief  Return USBx clock frequency\r\n  * @param  USBxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_USB_CLKSOURCE\r\n  * @retval USB clock frequency (in Hz)\r\n  */\r\nuint32_t LL_RCC_GetUSBClockFreq(uint32_t USBxSource)\r\n{\r\n  uint32_t usb_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_USB_CLKSOURCE(USBxSource));\r\n\r\n  /* USBCLK clock frequency */\r\n  switch (LL_RCC_GetUSBClockSource(USBxSource))\r\n  {\r\n    case LL_RCC_USB_CLKSOURCE_PLL:           /* PLL clock used as USB clock source */\r\n      if (LL_RCC_PLL_IsReady())\r\n      {\r\n        usb_frequency = RCC_PLL_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_USB_CLKSOURCE_PLLSAI:       /* PLLSAI clock used as USB clock source */\r\n    default:\r\n      if (LL_RCC_PLLSAI_IsReady())\r\n      {\r\n        usb_frequency = RCC_PLLSAI_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n  }\r\n\r\n  return usb_frequency;\r\n}\r\n\r\n#if defined(DFSDM1_Channel0)\r\n/**\r\n  * @brief  Return DFSDMx clock frequency\r\n  * @param  DFSDMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE\r\n  * @retval DFSDM clock frequency (in Hz)\r\n  */\r\nuint32_t LL_RCC_GetDFSDMClockFreq(uint32_t DFSDMxSource)\r\n{\r\n  uint32_t dfsdm_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_DFSDM_CLKSOURCE(DFSDMxSource));\r\n\r\n  /* DFSDM1CLK clock frequency */\r\n  switch (LL_RCC_GetDFSDMClockSource(DFSDMxSource))\r\n  {\r\n    case LL_RCC_DFSDM1_CLKSOURCE_SYSCLK:     /* DFSDM1 Clock is SYSCLK */\r\n      dfsdm_frequency = RCC_GetSystemClockFreq();\r\n      break;\r\n\r\n    case LL_RCC_DFSDM1_CLKSOURCE_PCLK2:      /* DFSDM1 Clock is PCLK2 */\r\n    default:\r\n      dfsdm_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n      break;\r\n  }\r\n\r\n  return dfsdm_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return DFSDMx Audio clock frequency\r\n  * @param  DFSDMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE\r\n  * @retval DFSDM clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetDFSDMAudioClockFreq(uint32_t DFSDMxSource)\r\n{\r\n  uint32_t dfsdm_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_DFSDM_AUDIO_CLKSOURCE(DFSDMxSource));\r\n\r\n  /* DFSDM1CLK clock frequency */\r\n  switch (LL_RCC_GetDFSDMAudioClockSource(DFSDMxSource))\r\n  {\r\n    case LL_RCC_DFSDM1_AUDIO_CLKSOURCE_SAI1:     /* SAI1 clock used as DFSDM1 audio clock */\r\n      dfsdm_frequency = LL_RCC_GetSAIClockFreq(LL_RCC_SAI1_CLKSOURCE);\r\n      break;\r\n\r\n    case LL_RCC_DFSDM1_AUDIO_CLKSOURCE_SAI2:     /* SAI2 clock used as DFSDM1 audio clock */\r\n    default:\r\n      dfsdm_frequency = LL_RCC_GetSAIClockFreq(LL_RCC_SAI2_CLKSOURCE);\r\n      break;\r\n  }\r\n\r\n  return dfsdm_frequency;\r\n}\r\n#endif /* DFSDM1_Channel0 */\r\n\r\n#if defined(DSI)\r\n/**\r\n  * @brief  Return DSI clock frequency\r\n  * @param  DSIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DSI_CLKSOURCE\r\n  * @retval DSI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that external clock is used\r\n  */\r\nuint32_t LL_RCC_GetDSIClockFreq(uint32_t DSIxSource)\r\n{\r\n  uint32_t dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_DSI_CLKSOURCE(DSIxSource));\r\n\r\n  /* DSICLK clock frequency */\r\n  switch (LL_RCC_GetDSIClockSource(DSIxSource))\r\n  {\r\n    case LL_RCC_DSI_CLKSOURCE_PLL:     /* DSI Clock is PLL Osc. */\r\n      if (LL_RCC_PLL_IsReady())\r\n      {\r\n        dsi_frequency = RCC_PLL_GetFreqDomain_DSI();\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_DSI_CLKSOURCE_PHY:    /* DSI Clock is DSI physical clock. */\r\n    default:\r\n      dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NA;\r\n      break;\r\n  }\r\n\r\n  return dsi_frequency;\r\n}\r\n#endif /* DSI */\r\n\r\n#if defined(LTDC)\r\n/**\r\n  * @brief  Return LTDC clock frequency\r\n  * @param  LTDCxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_LTDC_CLKSOURCE\r\n  * @retval LTDC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator PLLSAI is not ready\r\n  */\r\nuint32_t LL_RCC_GetLTDCClockFreq(uint32_t LTDCxSource)\r\n{\r\n  uint32_t ltdc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_LTDC_CLKSOURCE(LTDCxSource));\r\n\r\n  if (LL_RCC_PLLSAI_IsReady())\r\n  {\r\n     ltdc_frequency = RCC_PLLSAI_GetFreqDomain_LTDC();\r\n  }\r\n\r\n  return ltdc_frequency;\r\n}\r\n#endif /* LTDC */\r\n\r\n#if defined(SPDIFRX)\r\n/**\r\n  * @brief  Return SPDIFRX clock frequency\r\n  * @param  SPDIFRXxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SPDIFRX1_CLKSOURCE\r\n  * @retval SPDIFRX clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetSPDIFRXClockFreq(uint32_t SPDIFRXxSource)\r\n{\r\n  uint32_t spdifrx_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_SPDIFRX_CLKSOURCE(SPDIFRXxSource));\r\n\r\n  if (LL_RCC_PLLI2S_IsReady())\r\n  {\r\n     spdifrx_frequency = RCC_PLLI2S_GetFreqDomain_SPDIFRX();\r\n  }\r\n\r\n  return spdifrx_frequency;\r\n}\r\n#endif /* SPDIFRX */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup RCC_LL_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return SYSTEM clock frequency\r\n  * @retval SYSTEM clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_GetSystemClockFreq(void)\r\n{\r\n  uint32_t frequency = 0U;\r\n\r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n  switch (LL_RCC_GetSysClkSource())\r\n  {\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */\r\n      frequency = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */\r\n      frequency = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */\r\n      frequency = RCC_PLL_GetFreqDomain_SYS();\r\n      break;\r\n\r\n    default:\r\n      frequency = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n  return frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return HCLK clock frequency\r\n  * @param  SYSCLK_Frequency SYSCLK clock frequency\r\n  * @retval HCLK clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)\r\n{\r\n  /* HCLK clock frequency */\r\n  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PCLK1 clock frequency\r\n  * @param  HCLK_Frequency HCLK clock frequency\r\n  * @retval PCLK1 clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)\r\n{\r\n  /* PCLK1 clock frequency */\r\n  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PCLK2 clock frequency\r\n  * @param  HCLK_Frequency HCLK clock frequency\r\n  * @retval PCLK2 clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)\r\n{\r\n  /* PCLK2 clock frequency */\r\n  return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PLL clock frequency used for system domain\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_SYS(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n     SYSCLK = PLL_VCO / PLLP\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetP());\r\n}\r\n\r\n/**\r\n  * @brief  Return PLL clock frequency used for 48 MHz domain\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_48M(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM ) * PLLN\r\n     48M Domain clock = PLL_VCO / PLLQ\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLCLK_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetQ());\r\n}\r\n\r\n#if defined(DSI)\r\n/**\r\n  * @brief  Return PLL clock frequency used for DSI clock\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_DSI(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n     DSICLK = PLL_VCO / PLLR\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLCLK_DSI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());\r\n}\r\n#endif /* DSI */\r\n\r\n/**\r\n  * @brief  Return PLLSAI clock frequency used for SAI1 and SAI2 domains\r\n  * @retval PLLSAI clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLSAI_GetFreqDomain_SAI(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLSAI_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLSAIN\r\n     SAI1 and SAI2 domains clock  = (PLLSAI_VCO / PLLSAIQ) / PLLSAIDIVQ\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLSAI_SAI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLLSAI_GetN(), LL_RCC_PLLSAI_GetQ(), LL_RCC_PLLSAI_GetDIVQ());\r\n}\r\n\r\n/**\r\n  * @brief  Return PLLSAI clock frequency used for 48Mhz domain\r\n  * @retval PLLSAI clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLSAI_GetFreqDomain_48M(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLSAI_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLSAIN\r\n     48M Domain clock  = PLLSAI_VCO / PLLSAIP\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLSAI_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLLSAI_GetN(), LL_RCC_PLLSAI_GetP());\r\n}\r\n\r\n#if defined(LTDC)\r\n/**\r\n  * @brief  Return PLLSAI clock frequency used for LTDC domain\r\n  * @retval PLLSAI clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLSAI_GetFreqDomain_LTDC(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLSAI_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLSAIN\r\n     LTDC Domain clock  = (PLLSAI_VCO / PLLSAIR) / PLLSAIDIVR\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLSAI_LTDC_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLLSAI_GetN(), LL_RCC_PLLSAI_GetR(), LL_RCC_PLLSAI_GetDIVR());\r\n}\r\n#endif /* LTDC */\r\n\r\n/**\r\n  * @brief  Return PLLI2S clock frequency used for SAI1 and SAI2 domains\r\n  * @retval PLLI2S clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLI2S_GetFreqDomain_SAI(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLI2SN\r\n     SAI1 and SAI2 domains clock  = (PLLI2S_VCO / PLLI2SQ) / PLLI2SDIVQ\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLI2S clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLI2S clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLI2S_SAI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetQ(), LL_RCC_PLLI2S_GetDIVQ());\r\n}\r\n\r\n#if defined(SPDIFRX)\r\n/**\r\n  * @brief  Return PLLI2S clock frequency used for SPDIFRX domain\r\n  * @retval PLLI2S clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLI2S_GetFreqDomain_SPDIFRX(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLI2SN\r\n     SPDIFRX Domain clock  = PLLI2S_VCO / PLLI2SP\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLI2S clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLI2S clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n  return __LL_RCC_CALC_PLLI2S_SPDIFRX_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetP());\r\n}\r\n#endif /* SPDIFRX */\r\n\r\n/**\r\n  * @brief  Return PLLI2S clock frequency used for I2S domain\r\n  * @retval PLLI2S clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLI2S_GetFreqDomain_I2S(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLI2SN\r\n     I2S Domain clock  = PLLI2S_VCO / PLLI2SR\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLI2S clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLI2S clock source */\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLI2S_I2S_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetR());\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined(RCC) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n"},{"name":"stm32f7xx_ll_usart.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_ll_usart.c\r\n  * @author  MCD Application Team\r\n  * @brief   USART LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_ll_usart.h\"\r\n#include \"stm32f7xx_ll_rcc.h\"\r\n#include \"stm32f7xx_ll_bus.h\"\r\n#ifdef USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif /* USE_FULL_ASSERT */\r\n\r\n/** @addtogroup STM32F7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (USART1) || defined (USART2) || defined (USART3) || defined (USART6) || defined (UART4) || defined (UART5) || defined (UART7) || defined (UART8)\r\n\r\n/** @addtogroup USART_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup USART_LL_Private_Macros\r\n  * @{\r\n  */\r\n\r\n/* __BAUDRATE__ The maximum Baud Rate is derived from the maximum clock available\r\n *              divided by the smallest oversampling used on the USART (i.e. 8)    */\r\n#define IS_LL_USART_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) <= 27000000U)\r\n\r\n/* __VALUE__ In case of oversampling by 16 and 8, BRR content must be greater than or equal to 16d. */\r\n#define IS_LL_USART_BRR_MIN(__VALUE__) ((__VALUE__) >= 16U)\r\n\r\n#define IS_LL_USART_DIRECTION(__VALUE__) (((__VALUE__) == LL_USART_DIRECTION_NONE) \\\r\n                                          || ((__VALUE__) == LL_USART_DIRECTION_RX) \\\r\n                                          || ((__VALUE__) == LL_USART_DIRECTION_TX) \\\r\n                                          || ((__VALUE__) == LL_USART_DIRECTION_TX_RX))\r\n\r\n#define IS_LL_USART_PARITY(__VALUE__) (((__VALUE__) == LL_USART_PARITY_NONE) \\\r\n                                       || ((__VALUE__) == LL_USART_PARITY_EVEN) \\\r\n                                       || ((__VALUE__) == LL_USART_PARITY_ODD))\r\n\r\n#define IS_LL_USART_DATAWIDTH(__VALUE__) (((__VALUE__) == LL_USART_DATAWIDTH_7B) \\\r\n                                          || ((__VALUE__) == LL_USART_DATAWIDTH_8B) \\\r\n                                          || ((__VALUE__) == LL_USART_DATAWIDTH_9B))\r\n\r\n#define IS_LL_USART_OVERSAMPLING(__VALUE__) (((__VALUE__) == LL_USART_OVERSAMPLING_16) \\\r\n                                             || ((__VALUE__) == LL_USART_OVERSAMPLING_8))\r\n\r\n#define IS_LL_USART_LASTBITCLKOUTPUT(__VALUE__) (((__VALUE__) == LL_USART_LASTCLKPULSE_NO_OUTPUT) \\\r\n                                                 || ((__VALUE__) == LL_USART_LASTCLKPULSE_OUTPUT))\r\n\r\n#define IS_LL_USART_CLOCKPHASE(__VALUE__) (((__VALUE__) == LL_USART_PHASE_1EDGE) \\\r\n                                           || ((__VALUE__) == LL_USART_PHASE_2EDGE))\r\n\r\n#define IS_LL_USART_CLOCKPOLARITY(__VALUE__) (((__VALUE__) == LL_USART_POLARITY_LOW) \\\r\n                                              || ((__VALUE__) == LL_USART_POLARITY_HIGH))\r\n\r\n#define IS_LL_USART_CLOCKOUTPUT(__VALUE__) (((__VALUE__) == LL_USART_CLOCK_DISABLE) \\\r\n                                            || ((__VALUE__) == LL_USART_CLOCK_ENABLE))\r\n\r\n#define IS_LL_USART_STOPBITS(__VALUE__) (((__VALUE__) == LL_USART_STOPBITS_0_5) \\\r\n                                         || ((__VALUE__) == LL_USART_STOPBITS_1) \\\r\n                                         || ((__VALUE__) == LL_USART_STOPBITS_1_5) \\\r\n                                         || ((__VALUE__) == LL_USART_STOPBITS_2))\r\n\r\n#define IS_LL_USART_HWCONTROL(__VALUE__) (((__VALUE__) == LL_USART_HWCONTROL_NONE) \\\r\n                                          || ((__VALUE__) == LL_USART_HWCONTROL_RTS) \\\r\n                                          || ((__VALUE__) == LL_USART_HWCONTROL_CTS) \\\r\n                                          || ((__VALUE__) == LL_USART_HWCONTROL_RTS_CTS))\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup USART_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup USART_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize USART registers (Registers restored to their default values).\r\n  * @param  USARTx USART Instance\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: USART registers are de-initialized\r\n  *          - ERROR: USART registers are not de-initialized\r\n  */\r\nErrorStatus LL_USART_DeInit(USART_TypeDef *USARTx)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_UART_INSTANCE(USARTx));\r\n\r\n  if (USARTx == USART1)\r\n  {\r\n    /* Force reset of USART clock */\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_USART1);\r\n\r\n    /* Release reset of USART clock */\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_USART1);\r\n  }\r\n  else if (USARTx == USART2)\r\n  {\r\n    /* Force reset of USART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_USART2);\r\n\r\n    /* Release reset of USART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART2);\r\n  }\r\n  else if (USARTx == USART3)\r\n  {\r\n    /* Force reset of USART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_USART3);\r\n\r\n    /* Release reset of USART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART3);\r\n  }\r\n  else if (USARTx == UART4)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART4);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART4);\r\n  }\r\n  else if (USARTx == UART5)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART5);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART5);\r\n  }\r\n  else if (USARTx == USART6)\r\n  {\r\n    /* Force reset of USART clock */\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_USART6);\r\n\r\n    /* Release reset of USART clock */\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_USART6);\r\n  }\r\n  else if (USARTx == UART7)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART7);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART7);\r\n  }\r\n  else if (USARTx == UART8)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART8);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART8);\r\n  }\r\n  else\r\n  {\r\n    status = ERROR;\r\n  }\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief  Initialize USART registers according to the specified\r\n  *         parameters in USART_InitStruct.\r\n  * @note   As some bits in USART configuration registers can only be written when\r\n  *         the USART is disabled (USART_CR1_UE bit =0), USART Peripheral should be in disabled state prior calling\r\n  *         this function. Otherwise, ERROR result will be returned.\r\n  * @note   Baud rate value stored in USART_InitStruct BaudRate field, should be valid (different from 0).\r\n  * @param  USARTx USART Instance\r\n  * @param  USART_InitStruct pointer to a LL_USART_InitTypeDef structure\r\n  *         that contains the configuration information for the specified USART peripheral.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content\r\n  *          - ERROR: Problem occurred during USART Registers initialization\r\n  */\r\nErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)\r\n{\r\n  ErrorStatus status = ERROR;\r\n  uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_UART_INSTANCE(USARTx));\r\n  assert_param(IS_LL_USART_BAUDRATE(USART_InitStruct->BaudRate));\r\n  assert_param(IS_LL_USART_DATAWIDTH(USART_InitStruct->DataWidth));\r\n  assert_param(IS_LL_USART_STOPBITS(USART_InitStruct->StopBits));\r\n  assert_param(IS_LL_USART_PARITY(USART_InitStruct->Parity));\r\n  assert_param(IS_LL_USART_DIRECTION(USART_InitStruct->TransferDirection));\r\n  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));\r\n  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));\r\n\r\n  /* USART needs to be in disabled state, in order to be able to configure some bits in\r\n     CRx registers */\r\n  if (LL_USART_IsEnabled(USARTx) == 0U)\r\n  {\r\n    /*---------------------------- USART CR1 Configuration ---------------------\r\n     * Configure USARTx CR1 (USART Word Length, Parity, Mode and Oversampling bits) with parameters:\r\n     * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value\r\n     * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value\r\n     * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value\r\n     * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.\r\n     */\r\n    MODIFY_REG(USARTx->CR1,\r\n               (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |\r\n                USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),\r\n               (USART_InitStruct->DataWidth | USART_InitStruct->Parity |\r\n                USART_InitStruct->TransferDirection | USART_InitStruct->OverSampling));\r\n\r\n    /*---------------------------- USART CR2 Configuration ---------------------\r\n     * Configure USARTx CR2 (Stop bits) with parameters:\r\n     * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.\r\n     * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().\r\n     */\r\n    LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);\r\n\r\n    /*---------------------------- USART CR3 Configuration ---------------------\r\n     * Configure USARTx CR3 (Hardware Flow Control) with parameters:\r\n     * - HardwareFlowControl: USART_CR3_RTSE, USART_CR3_CTSE bits according to\r\n     *   USART_InitStruct->HardwareFlowControl value.\r\n     */\r\n    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);\r\n\r\n    /*---------------------------- USART BRR Configuration ---------------------\r\n     * Retrieve Clock frequency used for USART Peripheral\r\n     */\r\n    if (USARTx == USART1)\r\n    {\r\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART1_CLKSOURCE);\r\n    }\r\n    else if (USARTx == USART2)\r\n    {\r\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART2_CLKSOURCE);\r\n    }\r\n    else if (USARTx == USART3)\r\n    {\r\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART3_CLKSOURCE);\r\n    }\r\n    else if (USARTx == UART4)\r\n    {\r\n      periphclk = LL_RCC_GetUARTClockFreq(LL_RCC_UART4_CLKSOURCE);\r\n    }\r\n    else if (USARTx == UART5)\r\n    {\r\n      periphclk = LL_RCC_GetUARTClockFreq(LL_RCC_UART5_CLKSOURCE);\r\n    }\r\n    else if (USARTx == USART6)\r\n    {\r\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART6_CLKSOURCE);\r\n    }\r\n    else if (USARTx == UART7)\r\n    {\r\n      periphclk = LL_RCC_GetUARTClockFreq(LL_RCC_UART7_CLKSOURCE);\r\n    }\r\n    else if (USARTx == UART8)\r\n    {\r\n      periphclk = LL_RCC_GetUARTClockFreq(LL_RCC_UART8_CLKSOURCE);\r\n    }\r\n    else\r\n    {\r\n      /* Nothing to do, as error code is already assigned to ERROR value */\r\n    }\r\n\r\n    /* Configure the USART Baud Rate :\r\n       - valid baud rate value (different from 0) is required\r\n       - Peripheral clock as returned by RCC service, should be valid (different from 0).\r\n    */\r\n    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)\r\n        && (USART_InitStruct->BaudRate != 0U))\r\n    {\r\n      status = SUCCESS;\r\n      LL_USART_SetBaudRate(USARTx,\r\n                           periphclk,\r\n                           USART_InitStruct->OverSampling,\r\n                           USART_InitStruct->BaudRate);\r\n\r\n      /* Check BRR is greater than or equal to 16d */\r\n      assert_param(IS_LL_USART_BRR_MIN(USARTx->BRR));\r\n    }\r\n  }\r\n  /* Endif (=> USART not in Disabled state => return ERROR) */\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief Set each @ref LL_USART_InitTypeDef field to default value.\r\n  * @param USART_InitStruct pointer to a @ref LL_USART_InitTypeDef structure\r\n  *                         whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\n\r\nvoid LL_USART_StructInit(LL_USART_InitTypeDef *USART_InitStruct)\r\n{\r\n  /* Set USART_InitStruct fields to default values */\r\n  USART_InitStruct->BaudRate            = 9600U;\r\n  USART_InitStruct->DataWidth           = LL_USART_DATAWIDTH_8B;\r\n  USART_InitStruct->StopBits            = LL_USART_STOPBITS_1;\r\n  USART_InitStruct->Parity              = LL_USART_PARITY_NONE ;\r\n  USART_InitStruct->TransferDirection   = LL_USART_DIRECTION_TX_RX;\r\n  USART_InitStruct->HardwareFlowControl = LL_USART_HWCONTROL_NONE;\r\n  USART_InitStruct->OverSampling        = LL_USART_OVERSAMPLING_16;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize USART Clock related settings according to the\r\n  *         specified parameters in the USART_ClockInitStruct.\r\n  * @note   As some bits in USART configuration registers can only be written when\r\n  *         the USART is disabled (USART_CR1_UE bit =0), USART Peripheral should be in disabled state prior calling\r\n  *         this function. Otherwise, ERROR result will be returned.\r\n  * @param  USARTx USART Instance\r\n  * @param  USART_ClockInitStruct pointer to a @ref LL_USART_ClockInitTypeDef structure\r\n  *         that contains the Clock configuration information for the specified USART peripheral.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: USART registers related to Clock settings are initialized according\r\n  *                     to USART_ClockInitStruct content\r\n  *          - ERROR: Problem occurred during USART Registers initialization\r\n  */\r\nErrorStatus LL_USART_ClockInit(USART_TypeDef *USARTx, LL_USART_ClockInitTypeDef *USART_ClockInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check USART Instance and Clock signal output parameters */\r\n  assert_param(IS_UART_INSTANCE(USARTx));\r\n  assert_param(IS_LL_USART_CLOCKOUTPUT(USART_ClockInitStruct->ClockOutput));\r\n\r\n  /* USART needs to be in disabled state, in order to be able to configure some bits in\r\n     CRx registers */\r\n  if (LL_USART_IsEnabled(USARTx) == 0U)\r\n  {\r\n    /* If USART Clock signal is disabled */\r\n    if (USART_ClockInitStruct->ClockOutput == LL_USART_CLOCK_DISABLE)\r\n    {\r\n      /* Deactivate Clock signal delivery :\r\n       * - Disable Clock Output:        USART_CR2_CLKEN cleared\r\n       */\r\n      LL_USART_DisableSCLKOutput(USARTx);\r\n    }\r\n    else\r\n    {\r\n      /* Ensure USART instance is USART capable */\r\n      assert_param(IS_USART_INSTANCE(USARTx));\r\n\r\n      /* Check clock related parameters */\r\n      assert_param(IS_LL_USART_CLOCKPOLARITY(USART_ClockInitStruct->ClockPolarity));\r\n      assert_param(IS_LL_USART_CLOCKPHASE(USART_ClockInitStruct->ClockPhase));\r\n      assert_param(IS_LL_USART_LASTBITCLKOUTPUT(USART_ClockInitStruct->LastBitClockPulse));\r\n\r\n      /*---------------------------- USART CR2 Configuration -----------------------\r\n       * Configure USARTx CR2 (Clock signal related bits) with parameters:\r\n       * - Enable Clock Output:         USART_CR2_CLKEN set\r\n       * - Clock Polarity:              USART_CR2_CPOL bit according to USART_ClockInitStruct->ClockPolarity value\r\n       * - Clock Phase:                 USART_CR2_CPHA bit according to USART_ClockInitStruct->ClockPhase value\r\n       * - Last Bit Clock Pulse Output: USART_CR2_LBCL bit according to USART_ClockInitStruct->LastBitClockPulse value.\r\n       */\r\n      MODIFY_REG(USARTx->CR2,\r\n                 USART_CR2_CLKEN | USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL,\r\n                 USART_CR2_CLKEN | USART_ClockInitStruct->ClockPolarity |\r\n                 USART_ClockInitStruct->ClockPhase | USART_ClockInitStruct->LastBitClockPulse);\r\n    }\r\n  }\r\n  /* Else (USART not in Disabled state => return ERROR */\r\n  else\r\n  {\r\n    status = ERROR;\r\n  }\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief Set each field of a @ref LL_USART_ClockInitTypeDef type structure to default value.\r\n  * @param USART_ClockInitStruct pointer to a @ref LL_USART_ClockInitTypeDef structure\r\n  *                              whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\nvoid LL_USART_ClockStructInit(LL_USART_ClockInitTypeDef *USART_ClockInitStruct)\r\n{\r\n  /* Set LL_USART_ClockInitStruct fields with default values */\r\n  USART_ClockInitStruct->ClockOutput       = LL_USART_CLOCK_DISABLE;\r\n  USART_ClockInitStruct->ClockPolarity     = LL_USART_POLARITY_LOW;            /* Not relevant when ClockOutput =\r\n                                                                                  LL_USART_CLOCK_DISABLE */\r\n  USART_ClockInitStruct->ClockPhase        = LL_USART_PHASE_1EDGE;             /* Not relevant when ClockOutput =\r\n                                                                                  LL_USART_CLOCK_DISABLE */\r\n  USART_ClockInitStruct->LastBitClockPulse = LL_USART_LASTCLKPULSE_NO_OUTPUT;  /* Not relevant when ClockOutput =\r\n                                                                                  LL_USART_CLOCK_DISABLE */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USART1 || USART2 || USART3 || USART6 || UART4 || UART5 || UART7 || UART8 */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n\r\n"},{"name":"stm32f7xx_ll_usb.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_ll_usb.c\r\n  * @author  MCD Application Team\r\n  * @brief   USB Low Layer HAL module driver.\r\n  *\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the USB Peripheral Controller:\r\n  *           + Initialization/de-initialization functions\r\n  *           + I/O operation functions\r\n  *           + Peripheral Control functions\r\n  *           + Peripheral State functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n      (#) Fill parameters of Init structure in USB_OTG_CfgTypeDef structure.\r\n\r\n      (#) Call USB_CoreInit() API to initialize the USB Core peripheral.\r\n\r\n      (#) The upper HAL HCD/PCD driver will call the right routines for its internal processes.\r\n\r\n  @endverbatim\r\n\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_hal.h\"\r\n\r\n/** @addtogroup STM32F7xx_LL_USB_DRIVER\r\n  * @{\r\n  */\r\n\r\n#if defined (HAL_PCD_MODULE_ENABLED) || defined (HAL_HCD_MODULE_ENABLED)\r\n#if defined (USB_OTG_FS) || defined (USB_OTG_HS)\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n#if defined (USB_OTG_FS) || defined (USB_OTG_HS)\r\nstatic HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx);\r\n#ifdef USBPHYC\r\nstatic HAL_StatusTypeDef USB_HS_PHYCInit(USB_OTG_GlobalTypeDef *USBx);\r\n#endif /* USBPHYC */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup USB_LL_Exported_Functions USB Low Layer Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup USB_LL_Exported_Functions_Group1 Initialization/de-initialization functions\r\n  *  @brief    Initialization and Configuration functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Initialization/de-initialization functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the USB Core\r\n  * @param  USBx USB Instance\r\n  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains\r\n  *         the configuration information for the specified USBx peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)\r\n{\r\n  HAL_StatusTypeDef ret;\r\n\r\n  if (cfg.phy_itface == USB_OTG_ULPI_PHY)\r\n  {\r\n    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);\r\n\r\n    /* Init The ULPI Interface */\r\n    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);\r\n\r\n#if defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F730xx) || defined(STM32F732xx) || defined(STM32F733xx)\r\n    /* Select ULPI Interface */\r\n    USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPI_UTMI_SEL;\r\n#endif /* defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F730xx) || defined(STM32F732xx) || defined(STM32F733xx) */\r\n\r\n    /* Select vbus source */\r\n    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);\r\n    if (cfg.use_external_vbus == 1U)\r\n    {\r\n      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;\r\n    }\r\n\r\n    /* Reset after a PHY select */\r\n    ret = USB_CoreReset(USBx);\r\n  }\r\n#if defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F730xx) || defined(STM32F732xx) || defined(STM32F733xx)\r\n  else if (cfg.phy_itface == USB_OTG_HS_EMBEDDED_PHY)\r\n  {\r\n    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);\r\n\r\n    /* Init The UTMI Interface */\r\n    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);\r\n\r\n    /* Select vbus source */\r\n    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);\r\n\r\n    /* Select UTMI Interface */\r\n    USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_ULPI_UTMI_SEL;\r\n#ifdef USBPHYC\r\n    /* Enable USB HS PHY */\r\n    USBx->GCCFG |= USB_OTG_GCCFG_PHYHSEN;\r\n\r\n    /* Enables control of a High Speed USB PHY */\r\n    if (USB_HS_PHYCInit(USBx) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n#endif /* USBPHYC */\r\n\r\n    if (cfg.use_external_vbus == 1U)\r\n    {\r\n      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;\r\n    }\r\n\r\n    /* Reset after a PHY select */\r\n    ret = USB_CoreReset(USBx);\r\n  }\r\n#endif /* defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F730xx) || defined(STM32F732xx) || defined(STM32F733xx) */\r\n  else /* FS interface (embedded Phy) */\r\n  {\r\n    /* Select FS Embedded PHY */\r\n    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;\r\n\r\n    /* Reset after a PHY select */\r\n    ret = USB_CoreReset(USBx);\r\n\r\n    /* Activate the USB Transceiver */\r\n    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;\r\n  }\r\n\r\n  if (cfg.dma_enable == 1U)\r\n  {\r\n    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;\r\n    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Set the USB turnaround time\r\n  * @param  USBx USB Instance\r\n  * @param  hclk: AHB clock frequency\r\n  * @retval USB turnaround time In PHY Clocks number\r\n  */\r\nHAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,\r\n                                        uint32_t hclk, uint8_t speed)\r\n{\r\n  uint32_t UsbTrd;\r\n\r\n  /* The USBTRD is configured according to the tables below, depending on AHB frequency\r\n  used by application. In the low AHB frequency range it is used to stretch enough the USB response\r\n  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access\r\n  latency to the Data FIFO */\r\n  if (speed == USBD_FS_SPEED)\r\n  {\r\n    if ((hclk >= 14200000U) && (hclk < 15000000U))\r\n    {\r\n      /* hclk Clock Range between 14.2-15 MHz */\r\n      UsbTrd = 0xFU;\r\n    }\r\n    else if ((hclk >= 15000000U) && (hclk < 16000000U))\r\n    {\r\n      /* hclk Clock Range between 15-16 MHz */\r\n      UsbTrd = 0xEU;\r\n    }\r\n    else if ((hclk >= 16000000U) && (hclk < 17200000U))\r\n    {\r\n      /* hclk Clock Range between 16-17.2 MHz */\r\n      UsbTrd = 0xDU;\r\n    }\r\n    else if ((hclk >= 17200000U) && (hclk < 18500000U))\r\n    {\r\n      /* hclk Clock Range between 17.2-18.5 MHz */\r\n      UsbTrd = 0xCU;\r\n    }\r\n    else if ((hclk >= 18500000U) && (hclk < 20000000U))\r\n    {\r\n      /* hclk Clock Range between 18.5-20 MHz */\r\n      UsbTrd = 0xBU;\r\n    }\r\n    else if ((hclk >= 20000000U) && (hclk < 21800000U))\r\n    {\r\n      /* hclk Clock Range between 20-21.8 MHz */\r\n      UsbTrd = 0xAU;\r\n    }\r\n    else if ((hclk >= 21800000U) && (hclk < 24000000U))\r\n    {\r\n      /* hclk Clock Range between 21.8-24 MHz */\r\n      UsbTrd = 0x9U;\r\n    }\r\n    else if ((hclk >= 24000000U) && (hclk < 27700000U))\r\n    {\r\n      /* hclk Clock Range between 24-27.7 MHz */\r\n      UsbTrd = 0x8U;\r\n    }\r\n    else if ((hclk >= 27700000U) && (hclk < 32000000U))\r\n    {\r\n      /* hclk Clock Range between 27.7-32 MHz */\r\n      UsbTrd = 0x7U;\r\n    }\r\n    else /* if(hclk >= 32000000) */\r\n    {\r\n      /* hclk Clock Range between 32-200 MHz */\r\n      UsbTrd = 0x6U;\r\n    }\r\n  }\r\n  else if (speed == USBD_HS_SPEED)\r\n  {\r\n    UsbTrd = USBD_HS_TRDT_VALUE;\r\n  }\r\n  else\r\n  {\r\n    UsbTrd = USBD_DEFAULT_TRDT_VALUE;\r\n  }\r\n\r\n  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;\r\n  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_EnableGlobalInt\r\n  *         Enables the controller's Global Int in the AHB Config reg\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_DisableGlobalInt\r\n  *         Disable the controller's Global Int in the AHB Config reg\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_SetCurrentMode Set functional mode\r\n  * @param  USBx  Selected device\r\n  * @param  mode  current core mode\r\n  *          This parameter can be one of these values:\r\n  *            @arg USB_DEVICE_MODE Peripheral mode\r\n  *            @arg USB_HOST_MODE Host mode\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)\r\n{\r\n  uint32_t ms = 0U;\r\n\r\n  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);\r\n\r\n  if (mode == USB_HOST_MODE)\r\n  {\r\n    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;\r\n\r\n    do\r\n    {\r\n      HAL_Delay(1U);\r\n      ms++;\r\n    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));\r\n  }\r\n  else if (mode == USB_DEVICE_MODE)\r\n  {\r\n    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;\r\n\r\n    do\r\n    {\r\n      HAL_Delay(1U);\r\n      ms++;\r\n    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (ms == 50U)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_DevInit Initializes the USB_OTG controller registers\r\n  *         for device mode\r\n  * @param  USBx  Selected device\r\n  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains\r\n  *         the configuration information for the specified USBx peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)\r\n{\r\n  HAL_StatusTypeDef ret = HAL_OK;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t i;\r\n\r\n  for (i = 0U; i < 15U; i++)\r\n  {\r\n    USBx->DIEPTXF[i] = 0U;\r\n  }\r\n\r\n  /* VBUS Sensing setup */\r\n  if (cfg.vbus_sensing_enable == 0U)\r\n  {\r\n    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;\r\n\r\n    /* Deactivate VBUS Sensing B */\r\n    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;\r\n\r\n    /* B-peripheral session valid override enable */\r\n    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;\r\n    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;\r\n  }\r\n  else\r\n  {\r\n    /* Enable HW VBUS sensing */\r\n    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;\r\n  }\r\n\r\n  /* Restart the Phy Clock */\r\n  USBx_PCGCCTL = 0U;\r\n\r\n  /* Device mode configuration */\r\n  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;\r\n\r\n  if (cfg.phy_itface == USB_OTG_ULPI_PHY)\r\n  {\r\n    if (cfg.speed == USBD_HS_SPEED)\r\n    {\r\n      /* Set Core speed to High speed mode */\r\n      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);\r\n    }\r\n    else\r\n    {\r\n      /* Set Core speed to Full speed mode */\r\n      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);\r\n    }\r\n  }\r\n#if defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F730xx) || defined(STM32F732xx) || defined(STM32F733xx)\r\n  else if (cfg.phy_itface == USB_OTG_HS_EMBEDDED_PHY)\r\n  {\r\n    if (cfg.speed == USBD_HS_SPEED)\r\n    {\r\n      /* Set Core speed to High speed mode */\r\n      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);\r\n    }\r\n    else\r\n    {\r\n      /* Set Core speed to Full speed mode */\r\n      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);\r\n    }\r\n  }\r\n#endif /* defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F730xx) || defined(STM32F732xx) || defined(STM32F733xx) */\r\n  else\r\n  {\r\n    /* Set Core speed to Full speed mode */\r\n    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);\r\n  }\r\n\r\n  /* Flush the FIFOs */\r\n  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */\r\n  {\r\n    ret = HAL_ERROR;\r\n  }\r\n\r\n  if (USB_FlushRxFifo(USBx) != HAL_OK)\r\n  {\r\n    ret = HAL_ERROR;\r\n  }\r\n\r\n  /* Clear all pending Device Interrupts */\r\n  USBx_DEVICE->DIEPMSK = 0U;\r\n  USBx_DEVICE->DOEPMSK = 0U;\r\n  USBx_DEVICE->DAINTMSK = 0U;\r\n\r\n  for (i = 0U; i < cfg.dev_endpoints; i++)\r\n  {\r\n    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)\r\n    {\r\n      if (i == 0U)\r\n      {\r\n        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;\r\n      }\r\n      else\r\n      {\r\n        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      USBx_INEP(i)->DIEPCTL = 0U;\r\n    }\r\n\r\n    USBx_INEP(i)->DIEPTSIZ = 0U;\r\n    USBx_INEP(i)->DIEPINT  = 0xFB7FU;\r\n  }\r\n\r\n  for (i = 0U; i < cfg.dev_endpoints; i++)\r\n  {\r\n    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)\r\n    {\r\n      if (i == 0U)\r\n      {\r\n        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;\r\n      }\r\n      else\r\n      {\r\n        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      USBx_OUTEP(i)->DOEPCTL = 0U;\r\n    }\r\n\r\n    USBx_OUTEP(i)->DOEPTSIZ = 0U;\r\n    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;\r\n  }\r\n\r\n  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);\r\n\r\n  /* Disable all interrupts. */\r\n  USBx->GINTMSK = 0U;\r\n\r\n  /* Clear any pending interrupts */\r\n  USBx->GINTSTS = 0xBFFFFFFFU;\r\n\r\n  /* Enable the common interrupts */\r\n  if (cfg.dma_enable == 0U)\r\n  {\r\n    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;\r\n  }\r\n\r\n  /* Enable interrupts matching to the Device mode ONLY */\r\n  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\r\n                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\r\n                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |\r\n                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;\r\n\r\n  if (cfg.Sof_enable != 0U)\r\n  {\r\n    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;\r\n  }\r\n\r\n  if (cfg.vbus_sensing_enable == 1U)\r\n  {\r\n    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n  * @brief  USB_FlushTxFifo Flush a Tx FIFO\r\n  * @param  USBx  Selected device\r\n  * @param  num  FIFO number\r\n  *         This parameter can be a value from 1 to 15\r\n            15 means Flush all Tx FIFOs\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)\r\n{\r\n  __IO uint32_t count = 0U;\r\n\r\n  /* Wait for AHB master IDLE state. */\r\n  do\r\n  {\r\n    if (++count > 200000U)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);\r\n\r\n  /* Flush TX Fifo */\r\n  count = 0U;\r\n  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));\r\n\r\n  do\r\n  {\r\n    if (++count > 200000U)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_FlushRxFifo  Flush Rx FIFO\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  __IO uint32_t count = 0U;\r\n\r\n  /* Wait for AHB master IDLE state. */\r\n  do\r\n  {\r\n    if (++count > 200000U)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);\r\n\r\n  /* Flush RX Fifo */\r\n  count = 0U;\r\n  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;\r\n\r\n  do\r\n  {\r\n    if (++count > 200000U)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_SetDevSpeed  Initializes the DevSpd field of DCFG register\r\n  *         depending the PHY type and the enumeration speed of the device.\r\n  * @param  USBx  Selected device\r\n  * @param  speed  device speed\r\n  *          This parameter can be one of these values:\r\n  *            @arg USB_OTG_SPEED_HIGH: High speed mode\r\n  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode\r\n  *            @arg USB_OTG_SPEED_FULL: Full speed mode\r\n  * @retval  Hal status\r\n  */\r\nHAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx, uint8_t speed)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  USBx_DEVICE->DCFG |= speed;\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_GetDevSpeed  Return the Dev Speed\r\n  * @param  USBx  Selected device\r\n  * @retval speed  device speed\r\n  *          This parameter can be one of these values:\r\n  *            @arg USBD_HS_SPEED: High speed mode\r\n  *            @arg USBD_FS_SPEED: Full speed mode\r\n  */\r\nuint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint8_t speed;\r\n  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;\r\n\r\n  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)\r\n  {\r\n    speed = USBD_HS_SPEED;\r\n  }\r\n  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||\r\n           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))\r\n  {\r\n    speed = USBD_FS_SPEED;\r\n  }\r\n  else\r\n  {\r\n    speed = 0xFU;\r\n  }\r\n\r\n  return speed;\r\n}\r\n\r\n/**\r\n  * @brief  Activate and configure an endpoint\r\n  * @param  USBx  Selected device\r\n  * @param  ep pointer to endpoint structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t epnum = (uint32_t)ep->num;\r\n\r\n  if (ep->is_in == 1U)\r\n  {\r\n    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));\r\n\r\n    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)\r\n    {\r\n      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |\r\n                                   ((uint32_t)ep->type << 18) | (epnum << 22) |\r\n                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |\r\n                                   USB_OTG_DIEPCTL_USBAEP;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);\r\n\r\n    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)\r\n    {\r\n      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |\r\n                                    ((uint32_t)ep->type << 18) |\r\n                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |\r\n                                    USB_OTG_DOEPCTL_USBAEP;\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Activate and configure a dedicated endpoint\r\n  * @param  USBx  Selected device\r\n  * @param  ep pointer to endpoint structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t epnum = (uint32_t)ep->num;\r\n\r\n  /* Read DEPCTLn register */\r\n  if (ep->is_in == 1U)\r\n  {\r\n    if (((USBx_INEP(epnum)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)\r\n    {\r\n      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |\r\n                                   ((uint32_t)ep->type << 18) | (epnum << 22) |\r\n                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |\r\n                                   USB_OTG_DIEPCTL_USBAEP;\r\n    }\r\n\r\n    USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));\r\n  }\r\n  else\r\n  {\r\n    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)\r\n    {\r\n      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |\r\n                                    ((uint32_t)ep->type << 18) | (epnum << 22) |\r\n                                    USB_OTG_DOEPCTL_USBAEP;\r\n    }\r\n\r\n    USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  De-activate and de-initialize an endpoint\r\n  * @param  USBx  Selected device\r\n  * @param  ep pointer to endpoint structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t epnum = (uint32_t)ep->num;\r\n\r\n  /* Read DEPCTLn register */\r\n  if (ep->is_in == 1U)\r\n  {\r\n    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)\r\n    {\r\n      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;\r\n      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;\r\n    }\r\n\r\n    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));\r\n    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));\r\n    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |\r\n                                   USB_OTG_DIEPCTL_MPSIZ |\r\n                                   USB_OTG_DIEPCTL_TXFNUM |\r\n                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |\r\n                                   USB_OTG_DIEPCTL_EPTYP);\r\n  }\r\n  else\r\n  {\r\n    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)\r\n    {\r\n      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;\r\n      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;\r\n    }\r\n\r\n    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));\r\n    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));\r\n    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |\r\n                                    USB_OTG_DOEPCTL_MPSIZ |\r\n                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |\r\n                                    USB_OTG_DOEPCTL_EPTYP);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  De-activate and de-initialize a dedicated endpoint\r\n  * @param  USBx  Selected device\r\n  * @param  ep pointer to endpoint structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t epnum = (uint32_t)ep->num;\r\n\r\n  /* Read DEPCTLn register */\r\n  if (ep->is_in == 1U)\r\n  {\r\n    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)\r\n    {\r\n      USBx_INEP(epnum)->DIEPCTL  |= USB_OTG_DIEPCTL_SNAK;\r\n      USBx_INEP(epnum)->DIEPCTL  |= USB_OTG_DIEPCTL_EPDIS;\r\n    }\r\n\r\n    USBx_INEP(epnum)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;\r\n    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));\r\n  }\r\n  else\r\n  {\r\n    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)\r\n    {\r\n      USBx_OUTEP(epnum)->DOEPCTL  |= USB_OTG_DOEPCTL_SNAK;\r\n      USBx_OUTEP(epnum)->DOEPCTL  |= USB_OTG_DOEPCTL_EPDIS;\r\n    }\r\n\r\n    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;\r\n    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_EPStartXfer : setup and starts a transfer over an EP\r\n  * @param  USBx  Selected device\r\n  * @param  ep pointer to endpoint structure\r\n  * @param  dma USB dma enabled or disabled\r\n  *          This parameter can be one of these values:\r\n  *           0 : DMA feature not used\r\n  *           1 : DMA feature used\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t epnum = (uint32_t)ep->num;\r\n  uint16_t pktcnt;\r\n\r\n  /* IN endpoint */\r\n  if (ep->is_in == 1U)\r\n  {\r\n    /* Zero Length Packet? */\r\n    if (ep->xfer_len == 0U)\r\n    {\r\n      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);\r\n      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));\r\n      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);\r\n    }\r\n    else\r\n    {\r\n      /* Program the transfer size and packet count\r\n      * as follows: xfersize = N * maxpacket +\r\n      * short_packet pktcnt = N + (short_packet\r\n      * exist ? 1 : 0)\r\n      */\r\n      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);\r\n      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);\r\n      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &\r\n                                     (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));\r\n\r\n      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);\r\n\r\n      if (ep->type == EP_TYPE_ISOC)\r\n      {\r\n        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);\r\n        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));\r\n      }\r\n    }\r\n\r\n    if (dma == 1U)\r\n    {\r\n      if ((uint32_t)ep->dma_addr != 0U)\r\n      {\r\n        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);\r\n      }\r\n\r\n      if (ep->type == EP_TYPE_ISOC)\r\n      {\r\n        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)\r\n        {\r\n          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;\r\n        }\r\n        else\r\n        {\r\n          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;\r\n        }\r\n      }\r\n\r\n      /* EP enable, IN data in FIFO */\r\n      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);\r\n    }\r\n    else\r\n    {\r\n      /* EP enable, IN data in FIFO */\r\n      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);\r\n\r\n      if (ep->type != EP_TYPE_ISOC)\r\n      {\r\n        /* Enable the Tx FIFO Empty Interrupt for this EP */\r\n        if (ep->xfer_len > 0U)\r\n        {\r\n          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)\r\n        {\r\n          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;\r\n        }\r\n        else\r\n        {\r\n          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;\r\n        }\r\n\r\n        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);\r\n      }\r\n    }\r\n  }\r\n  else /* OUT endpoint */\r\n  {\r\n    /* Program the transfer size and packet count as follows:\r\n    * pktcnt = N\r\n    * xfersize = N * maxpacket\r\n    */\r\n    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);\r\n    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);\r\n\r\n    if (ep->xfer_len == 0U)\r\n    {\r\n      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);\r\n      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));\r\n    }\r\n    else\r\n    {\r\n      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);\r\n      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);\r\n      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);\r\n    }\r\n\r\n    if (dma == 1U)\r\n    {\r\n      if ((uint32_t)ep->xfer_buff != 0U)\r\n      {\r\n        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);\r\n      }\r\n    }\r\n\r\n    if (ep->type == EP_TYPE_ISOC)\r\n    {\r\n      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)\r\n      {\r\n        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;\r\n      }\r\n      else\r\n      {\r\n        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;\r\n      }\r\n    }\r\n    /* EP enable */\r\n    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_EP0StartXfer : setup and starts a transfer over the EP  0\r\n  * @param  USBx  Selected device\r\n  * @param  ep pointer to endpoint structure\r\n  * @param  dma USB dma enabled or disabled\r\n  *          This parameter can be one of these values:\r\n  *           0 : DMA feature not used\r\n  *           1 : DMA feature used\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t epnum = (uint32_t)ep->num;\r\n\r\n  /* IN endpoint */\r\n  if (ep->is_in == 1U)\r\n  {\r\n    /* Zero Length Packet? */\r\n    if (ep->xfer_len == 0U)\r\n    {\r\n      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);\r\n      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));\r\n      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);\r\n    }\r\n    else\r\n    {\r\n      /* Program the transfer size and packet count\r\n      * as follows: xfersize = N * maxpacket +\r\n      * short_packet pktcnt = N + (short_packet\r\n      * exist ? 1 : 0)\r\n      */\r\n      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);\r\n      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);\r\n\r\n      if (ep->xfer_len > ep->maxpacket)\r\n      {\r\n        ep->xfer_len = ep->maxpacket;\r\n      }\r\n      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));\r\n      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);\r\n    }\r\n\r\n    if (dma == 1U)\r\n    {\r\n      if ((uint32_t)ep->dma_addr != 0U)\r\n      {\r\n        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);\r\n      }\r\n\r\n      /* EP enable, IN data in FIFO */\r\n      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);\r\n    }\r\n    else\r\n    {\r\n      /* EP enable, IN data in FIFO */\r\n      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);\r\n\r\n      /* Enable the Tx FIFO Empty Interrupt for this EP */\r\n      if (ep->xfer_len > 0U)\r\n      {\r\n        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);\r\n      }\r\n    }\r\n  }\r\n  else /* OUT endpoint */\r\n  {\r\n    /* Program the transfer size and packet count as follows:\r\n    * pktcnt = N\r\n    * xfersize = N * maxpacket\r\n    */\r\n    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);\r\n    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);\r\n\r\n    if (ep->xfer_len > 0U)\r\n    {\r\n      ep->xfer_len = ep->maxpacket;\r\n    }\r\n\r\n    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));\r\n    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));\r\n\r\n    if (dma == 1U)\r\n    {\r\n      if ((uint32_t)ep->xfer_buff != 0U)\r\n      {\r\n        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);\r\n      }\r\n    }\r\n\r\n    /* EP enable */\r\n    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_WritePacket : Writes a packet into the Tx FIFO associated\r\n  *         with the EP/channel\r\n  * @param  USBx  Selected device\r\n  * @param  src   pointer to source buffer\r\n  * @param  ch_ep_num  endpoint or host channel number\r\n  * @param  len  Number of bytes to write\r\n  * @param  dma USB dma enabled or disabled\r\n  *          This parameter can be one of these values:\r\n  *           0 : DMA feature not used\r\n  *           1 : DMA feature used\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src,\r\n                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint8_t *pSrc = src;\r\n  uint32_t count32b;\r\n  uint32_t i;\r\n\r\n  if (dma == 0U)\r\n  {\r\n    count32b = ((uint32_t)len + 3U) / 4U;\r\n    for (i = 0U; i < count32b; i++)\r\n    {\r\n      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);\r\n      pSrc++;\r\n      pSrc++;\r\n      pSrc++;\r\n      pSrc++;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_ReadPacket : read a packet from the RX FIFO\r\n  * @param  USBx  Selected device\r\n  * @param  dest  source pointer\r\n  * @param  len  Number of bytes to read\r\n  * @retval pointer to destination buffer\r\n  */\r\nvoid *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint8_t *pDest = dest;\r\n  uint32_t pData;\r\n  uint32_t i;\r\n  uint32_t count32b = (uint32_t)len >> 2U;\r\n  uint16_t remaining_bytes = len % 4U;\r\n\r\n  for (i = 0U; i < count32b; i++)\r\n  {\r\n    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));\r\n    pDest++;\r\n    pDest++;\r\n    pDest++;\r\n    pDest++;\r\n  }\r\n\r\n  /* When Number of data is not word aligned, read the remaining byte */\r\n  if (remaining_bytes != 0U)\r\n  {\r\n    i = 0U;\r\n    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));\r\n\r\n    do\r\n    {\r\n      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));\r\n      i++;\r\n      pDest++;\r\n      remaining_bytes--;\r\n    } while (remaining_bytes != 0U);\r\n  }\r\n\r\n  return ((void *)pDest);\r\n}\r\n\r\n/**\r\n  * @brief  USB_EPSetStall : set a stall condition over an EP\r\n  * @param  USBx  Selected device\r\n  * @param  ep pointer to endpoint structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t epnum = (uint32_t)ep->num;\r\n\r\n  if (ep->is_in == 1U)\r\n  {\r\n    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))\r\n    {\r\n      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);\r\n    }\r\n    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;\r\n  }\r\n  else\r\n  {\r\n    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))\r\n    {\r\n      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);\r\n    }\r\n    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_EPClearStall : Clear a stall condition over an EP\r\n  * @param  USBx  Selected device\r\n  * @param  ep pointer to endpoint structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t epnum = (uint32_t)ep->num;\r\n\r\n  if (ep->is_in == 1U)\r\n  {\r\n    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;\r\n    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))\r\n    {\r\n      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */\r\n    }\r\n  }\r\n  else\r\n  {\r\n    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;\r\n    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))\r\n    {\r\n      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_StopDevice : Stop the usb device mode\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  HAL_StatusTypeDef ret;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t i;\r\n\r\n  /* Clear Pending interrupt */\r\n  for (i = 0U; i < 15U; i++)\r\n  {\r\n    USBx_INEP(i)->DIEPINT = 0xFB7FU;\r\n    USBx_OUTEP(i)->DOEPINT = 0xFB7FU;\r\n  }\r\n\r\n  /* Clear interrupt masks */\r\n  USBx_DEVICE->DIEPMSK  = 0U;\r\n  USBx_DEVICE->DOEPMSK  = 0U;\r\n  USBx_DEVICE->DAINTMSK = 0U;\r\n\r\n  /* Flush the FIFO */\r\n  ret = USB_FlushRxFifo(USBx);\r\n  if (ret != HAL_OK)\r\n  {\r\n    return ret;\r\n  }\r\n\r\n  ret = USB_FlushTxFifo(USBx,  0x10U);\r\n  if (ret != HAL_OK)\r\n  {\r\n    return ret;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n  * @brief  USB_SetDevAddress : Stop the usb device mode\r\n  * @param  USBx  Selected device\r\n  * @param  address  new device address to be assigned\r\n  *          This parameter can be a value from 0 to 255\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef  USB_SetDevAddress(USB_OTG_GlobalTypeDef *USBx, uint8_t address)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);\r\n  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef  USB_DevConnect(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  /* In case phy is stopped, ensure to ungate and restore the phy CLK */\r\n  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);\r\n\r\n  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef  USB_DevDisconnect(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  /* In case phy is stopped, ensure to ungate and restore the phy CLK */\r\n  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);\r\n\r\n  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_ReadInterrupts: return the global USB interrupt status\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nuint32_t  USB_ReadInterrupts(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t tmpreg;\r\n\r\n  tmpreg = USBx->GINTSTS;\r\n  tmpreg &= USBx->GINTMSK;\r\n\r\n  return tmpreg;\r\n}\r\n\r\n/**\r\n  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nuint32_t USB_ReadDevAllOutEpInterrupt(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t tmpreg;\r\n\r\n  tmpreg  = USBx_DEVICE->DAINT;\r\n  tmpreg &= USBx_DEVICE->DAINTMSK;\r\n\r\n  return ((tmpreg & 0xffff0000U) >> 16);\r\n}\r\n\r\n/**\r\n  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nuint32_t USB_ReadDevAllInEpInterrupt(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t tmpreg;\r\n\r\n  tmpreg  = USBx_DEVICE->DAINT;\r\n  tmpreg &= USBx_DEVICE->DAINTMSK;\r\n\r\n  return ((tmpreg & 0xFFFFU));\r\n}\r\n\r\n/**\r\n  * @brief  Returns Device OUT EP Interrupt register\r\n  * @param  USBx  Selected device\r\n  * @param  epnum  endpoint number\r\n  *          This parameter can be a value from 0 to 15\r\n  * @retval Device OUT EP Interrupt register\r\n  */\r\nuint32_t USB_ReadDevOutEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t tmpreg;\r\n\r\n  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;\r\n  tmpreg &= USBx_DEVICE->DOEPMSK;\r\n\r\n  return tmpreg;\r\n}\r\n\r\n/**\r\n  * @brief  Returns Device IN EP Interrupt register\r\n  * @param  USBx  Selected device\r\n  * @param  epnum  endpoint number\r\n  *          This parameter can be a value from 0 to 15\r\n  * @retval Device IN EP Interrupt register\r\n  */\r\nuint32_t USB_ReadDevInEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t tmpreg;\r\n  uint32_t msk;\r\n  uint32_t emp;\r\n\r\n  msk = USBx_DEVICE->DIEPMSK;\r\n  emp = USBx_DEVICE->DIEPEMPMSK;\r\n  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;\r\n  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;\r\n\r\n  return tmpreg;\r\n}\r\n\r\n/**\r\n  * @brief  USB_ClearInterrupts: clear a USB interrupt\r\n  * @param  USBx  Selected device\r\n  * @param  interrupt  flag\r\n  * @retval None\r\n  */\r\nvoid  USB_ClearInterrupts(USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)\r\n{\r\n  USBx->GINTSTS |= interrupt;\r\n}\r\n\r\n/**\r\n  * @brief  Returns USB core mode\r\n  * @param  USBx  Selected device\r\n  * @retval return core mode : Host or Device\r\n  *          This parameter can be one of these values:\r\n  *           0 : Host\r\n  *           1 : Device\r\n  */\r\nuint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  return ((USBx->GINTSTS) & 0x1U);\r\n}\r\n\r\n/**\r\n  * @brief  Activate EP0 for Setup transactions\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef  USB_ActivateSetup(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  /* Set the MPS of the IN EP0 to 64 bytes */\r\n  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;\r\n\r\n  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Prepare the EP0 to start the first control setup\r\n  * @param  USBx  Selected device\r\n  * @param  dma USB dma enabled or disabled\r\n  *          This parameter can be one of these values:\r\n  *           0 : DMA feature not used\r\n  *           1 : DMA feature used\r\n  * @param  psetup  pointer to setup packet\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);\r\n\r\n  if (gSNPSiD > USB_OTG_CORE_ID_300A)\r\n  {\r\n    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)\r\n    {\r\n      return HAL_OK;\r\n    }\r\n  }\r\n\r\n  USBx_OUTEP(0U)->DOEPTSIZ = 0U;\r\n  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));\r\n  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);\r\n  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;\r\n\r\n  if (dma == 1U)\r\n  {\r\n    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;\r\n    /* EP enable */\r\n    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Reset the USB Core (needed after USB clock settings change)\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  __IO uint32_t count = 0U;\r\n\r\n  /* Wait for AHB master IDLE state. */\r\n  do\r\n  {\r\n    if (++count > 200000U)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);\r\n\r\n  /* Core Soft Reset */\r\n  count = 0U;\r\n  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;\r\n\r\n  do\r\n  {\r\n    if (++count > 200000U)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n#ifdef USBPHYC\r\n/**\r\n  * @brief  Enables control of a High Speed USB PHY\r\n  *         Init the low level hardware : GPIO, CLOCK, NVIC...\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef USB_HS_PHYCInit(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  UNUSED(USBx);\r\n  __IO uint32_t count = 0U;\r\n\r\n  /* Enable LDO */\r\n  USB_HS_PHYC->USB_HS_PHYC_LDO |= USB_HS_PHYC_LDO_ENABLE;\r\n\r\n  /* wait for LDO Ready */\r\n  while ((USB_HS_PHYC->USB_HS_PHYC_LDO & USB_HS_PHYC_LDO_STATUS) == 0U)\r\n  {\r\n    if (++count > 200000U)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Controls PHY frequency operation selection */\r\n  if (HSE_VALUE == 12000000U) /* HSE = 12MHz */\r\n  {\r\n    USB_HS_PHYC->USB_HS_PHYC_PLL = (0x0U << 1);\r\n  }\r\n  else if (HSE_VALUE == 12500000U) /* HSE = 12.5MHz */\r\n  {\r\n    USB_HS_PHYC->USB_HS_PHYC_PLL = (0x2U << 1);\r\n  }\r\n  else if (HSE_VALUE == 16000000U) /* HSE = 16MHz */\r\n  {\r\n    USB_HS_PHYC->USB_HS_PHYC_PLL = (0x3U << 1);\r\n  }\r\n  else if (HSE_VALUE == 24000000U) /* HSE = 24MHz */\r\n  {\r\n    USB_HS_PHYC->USB_HS_PHYC_PLL = (0x4U << 1);\r\n  }\r\n  else if (HSE_VALUE == 25000000U) /* HSE = 25MHz */\r\n  {\r\n    USB_HS_PHYC->USB_HS_PHYC_PLL = (0x5U << 1);\r\n  }\r\n  else if (HSE_VALUE == 32000000U) /* HSE = 32MHz */\r\n  {\r\n    USB_HS_PHYC->USB_HS_PHYC_PLL = (0x7U << 1);\r\n  }\r\n  else\r\n  {\r\n    /* ... */\r\n  }\r\n\r\n  /* Control the tuning interface of the High Speed PHY */\r\n  USB_HS_PHYC->USB_HS_PHYC_TUNE |= USB_HS_PHYC_TUNE_VALUE;\r\n\r\n  /* Enable PLL internal PHY */\r\n  USB_HS_PHYC->USB_HS_PHYC_PLL |= USB_HS_PHYC_PLL_PLLEN;\r\n\r\n\r\n  /* 2ms Delay required to get internal phy clock stable */\r\n  HAL_Delay(2U);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n#endif /* USBPHYC */\r\n/**\r\n  * @brief  USB_HostInit : Initializes the USB OTG controller registers\r\n  *         for Host mode\r\n  * @param  USBx  Selected device\r\n  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains\r\n  *         the configuration information for the specified USBx peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)\r\n{\r\n  HAL_StatusTypeDef ret = HAL_OK;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t i;\r\n\r\n  /* Restart the Phy Clock */\r\n  USBx_PCGCCTL = 0U;\r\n\r\n  /* Disable VBUS sensing */\r\n  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);\r\n\r\n  if ((USBx->CID & (0x1U << 8)) != 0U)\r\n  {\r\n    if (cfg.speed == USBH_FSLS_SPEED)\r\n    {\r\n      /* Force Device Enumeration to FS/LS mode only */\r\n      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;\r\n    }\r\n    else\r\n    {\r\n      /* Set default Max speed support */\r\n      USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Set default Max speed support */\r\n    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);\r\n  }\r\n\r\n  /* Make sure the FIFOs are flushed. */\r\n  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */\r\n  {\r\n    ret = HAL_ERROR;\r\n  }\r\n\r\n  if (USB_FlushRxFifo(USBx) != HAL_OK)\r\n  {\r\n    ret = HAL_ERROR;\r\n  }\r\n\r\n  /* Clear all pending HC Interrupts */\r\n  for (i = 0U; i < cfg.Host_channels; i++)\r\n  {\r\n    USBx_HC(i)->HCINT = 0xFFFFFFFFU;\r\n    USBx_HC(i)->HCINTMSK = 0U;\r\n  }\r\n\r\n  /* Disable all interrupts. */\r\n  USBx->GINTMSK = 0U;\r\n\r\n  /* Clear any pending interrupts */\r\n  USBx->GINTSTS = 0xFFFFFFFFU;\r\n\r\n  if ((USBx->CID & (0x1U << 8)) != 0U)\r\n  {\r\n    /* set Rx FIFO size */\r\n    USBx->GRXFSIZ  = 0x200U;\r\n    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);\r\n    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);\r\n  }\r\n  else\r\n  {\r\n    /* set Rx FIFO size */\r\n    USBx->GRXFSIZ  = 0x80U;\r\n    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);\r\n    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);\r\n  }\r\n\r\n  /* Enable the common interrupts */\r\n  if (cfg.dma_enable == 0U)\r\n  {\r\n    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;\r\n  }\r\n\r\n  /* Enable interrupts matching to the Host mode ONLY */\r\n  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \\\r\n                    USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \\\r\n                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n  * @brief  USB_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the\r\n  *         HCFG register on the PHY type and set the right frame interval\r\n  * @param  USBx  Selected device\r\n  * @param  freq  clock frequency\r\n  *          This parameter can be one of these values:\r\n  *           HCFG_48_MHZ : Full Speed 48 MHz Clock\r\n  *           HCFG_6_MHZ : Low Speed 6 MHz Clock\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx, uint8_t freq)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);\r\n  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;\r\n\r\n  if (freq == HCFG_48_MHZ)\r\n  {\r\n    USBx_HOST->HFIR = 48000U;\r\n  }\r\n  else if (freq == HCFG_6_MHZ)\r\n  {\r\n    USBx_HOST->HFIR = 6000U;\r\n  }\r\n  else\r\n  {\r\n    /* ... */\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_OTG_ResetPort : Reset Host Port\r\n  * @param  USBx  Selected device\r\n  * @retval HAL status\r\n  * @note (1)The application must wait at least 10 ms\r\n  *   before clearing the reset bit.\r\n  */\r\nHAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  __IO uint32_t hprt0 = 0U;\r\n\r\n  hprt0 = USBx_HPRT0;\r\n\r\n  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\r\n             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);\r\n\r\n  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);\r\n  HAL_Delay(100U);                                 /* See Note #1 */\r\n  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);\r\n  HAL_Delay(10U);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_DriveVbus : activate or de-activate vbus\r\n  * @param  state  VBUS state\r\n  *          This parameter can be one of these values:\r\n  *           0 : Deactivate VBUS\r\n  *           1 : Activate VBUS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  __IO uint32_t hprt0 = 0U;\r\n\r\n  hprt0 = USBx_HPRT0;\r\n\r\n  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\r\n             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);\r\n\r\n  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))\r\n  {\r\n    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);\r\n  }\r\n  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))\r\n  {\r\n    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Return Host Core speed\r\n  * @param  USBx  Selected device\r\n  * @retval speed : Host speed\r\n  *          This parameter can be one of these values:\r\n  *            @arg HCD_SPEED_HIGH: High speed mode\r\n  *            @arg HCD_SPEED_FULL: Full speed mode\r\n  *            @arg HCD_SPEED_LOW: Low speed mode\r\n  */\r\nuint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  __IO uint32_t hprt0 = 0U;\r\n\r\n  hprt0 = USBx_HPRT0;\r\n  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);\r\n}\r\n\r\n/**\r\n  * @brief  Return Host Current Frame number\r\n  * @param  USBx  Selected device\r\n  * @retval current frame number\r\n  */\r\nuint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);\r\n}\r\n\r\n/**\r\n  * @brief  Initialize a host channel\r\n  * @param  USBx  Selected device\r\n  * @param  ch_num  Channel number\r\n  *         This parameter can be a value from 1 to 15\r\n  * @param  epnum  Endpoint number\r\n  *          This parameter can be a value from 1 to 15\r\n  * @param  dev_address  Current device address\r\n  *          This parameter can be a value from 0 to 255\r\n  * @param  speed  Current device speed\r\n  *          This parameter can be one of these values:\r\n  *            @arg USB_OTG_SPEED_HIGH: High speed mode\r\n  *            @arg USB_OTG_SPEED_FULL: Full speed mode\r\n  *            @arg USB_OTG_SPEED_LOW: Low speed mode\r\n  * @param  ep_type  Endpoint Type\r\n  *          This parameter can be one of these values:\r\n  *            @arg EP_TYPE_CTRL: Control type\r\n  *            @arg EP_TYPE_ISOC: Isochronous type\r\n  *            @arg EP_TYPE_BULK: Bulk type\r\n  *            @arg EP_TYPE_INTR: Interrupt type\r\n  * @param  mps  Max Packet Size\r\n  *          This parameter can be a value from 0 to 32K\r\n  * @retval HAL state\r\n  */\r\nHAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,\r\n                              uint8_t epnum, uint8_t dev_address, uint8_t speed,\r\n                              uint8_t ep_type, uint16_t mps)\r\n{\r\n  HAL_StatusTypeDef ret = HAL_OK;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t HCcharEpDir;\r\n  uint32_t HCcharLowSpeed;\r\n  uint32_t HostCoreSpeed;\r\n\r\n  /* Clear old interrupt conditions for this host channel. */\r\n  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;\r\n\r\n  /* Enable channel interrupts required for this transfer. */\r\n  switch (ep_type)\r\n  {\r\n    case EP_TYPE_CTRL:\r\n    case EP_TYPE_BULK:\r\n      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\r\n                                            USB_OTG_HCINTMSK_STALLM |\r\n                                            USB_OTG_HCINTMSK_TXERRM |\r\n                                            USB_OTG_HCINTMSK_DTERRM |\r\n                                            USB_OTG_HCINTMSK_AHBERR |\r\n                                            USB_OTG_HCINTMSK_NAKM;\r\n\r\n      if ((epnum & 0x80U) == 0x80U)\r\n      {\r\n        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;\r\n      }\r\n      else\r\n      {\r\n        if ((USBx->CID & (0x1U << 8)) != 0U)\r\n        {\r\n          USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |\r\n                                                 USB_OTG_HCINTMSK_ACKM;\r\n        }\r\n      }\r\n      break;\r\n\r\n    case EP_TYPE_INTR:\r\n      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\r\n                                            USB_OTG_HCINTMSK_STALLM |\r\n                                            USB_OTG_HCINTMSK_TXERRM |\r\n                                            USB_OTG_HCINTMSK_DTERRM |\r\n                                            USB_OTG_HCINTMSK_NAKM   |\r\n                                            USB_OTG_HCINTMSK_AHBERR |\r\n                                            USB_OTG_HCINTMSK_FRMORM;\r\n\r\n      if ((epnum & 0x80U) == 0x80U)\r\n      {\r\n        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;\r\n      }\r\n\r\n      break;\r\n\r\n    case EP_TYPE_ISOC:\r\n      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\r\n                                            USB_OTG_HCINTMSK_ACKM   |\r\n                                            USB_OTG_HCINTMSK_AHBERR |\r\n                                            USB_OTG_HCINTMSK_FRMORM;\r\n\r\n      if ((epnum & 0x80U) == 0x80U)\r\n      {\r\n        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);\r\n      }\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  /* Enable host channel Halt interrupt */\r\n  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;\r\n\r\n  /* Enable the top level host channel interrupt. */\r\n  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);\r\n\r\n  /* Make sure host channel interrupts are enabled. */\r\n  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;\r\n\r\n  /* Program the HCCHAR register */\r\n  if ((epnum & 0x80U) == 0x80U)\r\n  {\r\n    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;\r\n  }\r\n  else\r\n  {\r\n    HCcharEpDir = 0U;\r\n  }\r\n\r\n  HostCoreSpeed = USB_GetHostSpeed(USBx);\r\n\r\n  /* LS device plugged to HUB */\r\n  if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))\r\n  {\r\n    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;\r\n  }\r\n  else\r\n  {\r\n    HCcharLowSpeed = 0U;\r\n  }\r\n\r\n  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |\r\n                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |\r\n                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |\r\n                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;\r\n\r\n  if (ep_type == EP_TYPE_INTR)\r\n  {\r\n    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n  * @brief  Start a transfer over a host channel\r\n  * @param  USBx  Selected device\r\n  * @param  hc  pointer to host channel structure\r\n  * @param  dma USB dma enabled or disabled\r\n  *          This parameter can be one of these values:\r\n  *           0 : DMA feature not used\r\n  *           1 : DMA feature used\r\n  * @retval HAL state\r\n  */\r\nHAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t ch_num = (uint32_t)hc->ch_num;\r\n  __IO uint32_t tmpreg;\r\n  uint8_t  is_oddframe;\r\n  uint16_t len_words;\r\n  uint16_t num_packets;\r\n  uint16_t max_hc_pkt_count = 256U;\r\n\r\n  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))\r\n  {\r\n    /* in DMA mode host Core automatically issues ping  in case of NYET/NAK */\r\n    if ((dma == 1U) && ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)))\r\n    {\r\n      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |\r\n                                               USB_OTG_HCINTMSK_ACKM |\r\n                                               USB_OTG_HCINTMSK_NAKM);\r\n    }\r\n\r\n    if ((dma == 0U) && (hc->do_ping == 1U))\r\n    {\r\n      (void)USB_DoPing(USBx, hc->ch_num);\r\n      return HAL_OK;\r\n    }\r\n\r\n  }\r\n\r\n  /* Compute the expected number of packets associated to the transfer */\r\n  if (hc->xfer_len > 0U)\r\n  {\r\n    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);\r\n\r\n    if (num_packets > max_hc_pkt_count)\r\n    {\r\n      num_packets = max_hc_pkt_count;\r\n      hc->XferSize = (uint32_t)num_packets * hc->max_packet;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    num_packets = 1U;\r\n  }\r\n\r\n  /*\r\n   * For IN channel HCTSIZ.XferSize is expected to be an integer multiple of\r\n   * max_packet size.\r\n   */\r\n  if (hc->ep_is_in != 0U)\r\n  {\r\n    hc->XferSize = (uint32_t)num_packets * hc->max_packet;\r\n  }\r\n  else\r\n  {\r\n    hc->XferSize = hc->xfer_len;\r\n  }\r\n\r\n  /* Initialize the HCTSIZn register */\r\n  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |\r\n                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\r\n                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);\r\n\r\n  if (dma != 0U)\r\n  {\r\n    /* xfer_buff MUST be 32-bits aligned */\r\n    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;\r\n  }\r\n\r\n  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;\r\n  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;\r\n  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;\r\n\r\n  /* Set host channel enable */\r\n  tmpreg = USBx_HC(ch_num)->HCCHAR;\r\n  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;\r\n\r\n  /* make sure to set the correct ep direction */\r\n  if (hc->ep_is_in != 0U)\r\n  {\r\n    tmpreg |= USB_OTG_HCCHAR_EPDIR;\r\n  }\r\n  else\r\n  {\r\n    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;\r\n  }\r\n  tmpreg |= USB_OTG_HCCHAR_CHENA;\r\n  USBx_HC(ch_num)->HCCHAR = tmpreg;\r\n\r\n  if (dma != 0U) /* dma mode */\r\n  {\r\n    return HAL_OK;\r\n  }\r\n\r\n  if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))\r\n  {\r\n    switch (hc->ep_type)\r\n    {\r\n      /* Non periodic transfer */\r\n      case EP_TYPE_CTRL:\r\n      case EP_TYPE_BULK:\r\n\r\n        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);\r\n\r\n        /* check if there is enough space in FIFO space */\r\n        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))\r\n        {\r\n          /* need to process data in nptxfempty interrupt */\r\n          USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;\r\n        }\r\n        break;\r\n\r\n      /* Periodic transfer */\r\n      case EP_TYPE_INTR:\r\n      case EP_TYPE_ISOC:\r\n        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);\r\n        /* check if there is enough space in FIFO space */\r\n        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */\r\n        {\r\n          /* need to process data in ptxfempty interrupt */\r\n          USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n\r\n    /* Write packet into the Tx FIFO. */\r\n    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Read all host channel interrupts status\r\n  * @param  USBx  Selected device\r\n  * @retval HAL state\r\n  */\r\nuint32_t USB_HC_ReadInterrupt(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  return ((USBx_HOST->HAINT) & 0xFFFFU);\r\n}\r\n\r\n/**\r\n  * @brief  Halt a host channel\r\n  * @param  USBx  Selected device\r\n  * @param  hc_num  Host Channel number\r\n  *         This parameter can be a value from 1 to 15\r\n  * @retval HAL state\r\n  */\r\nHAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx, uint8_t hc_num)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t hcnum = (uint32_t)hc_num;\r\n  __IO uint32_t count = 0U;\r\n  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;\r\n  uint32_t ChannelEna = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) >> 31;\r\n\r\n  if (((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) &&\r\n      (ChannelEna == 0U))\r\n  {\r\n    return HAL_OK;\r\n  }\r\n\r\n  /* Check for space in the request queue to issue the halt. */\r\n  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))\r\n  {\r\n    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;\r\n\r\n    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)\r\n    {\r\n      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)\r\n      {\r\n        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;\r\n        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;\r\n        do\r\n        {\r\n          if (++count > 1000U)\r\n          {\r\n            break;\r\n          }\r\n        } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);\r\n      }\r\n      else\r\n      {\r\n        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;\r\n\r\n    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)\r\n    {\r\n      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;\r\n      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;\r\n      do\r\n      {\r\n        if (++count > 1000U)\r\n        {\r\n          break;\r\n        }\r\n      } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);\r\n    }\r\n    else\r\n    {\r\n      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initiate Do Ping protocol\r\n  * @param  USBx  Selected device\r\n  * @param  hc_num  Host Channel number\r\n  *         This parameter can be a value from 1 to 15\r\n  * @retval HAL state\r\n  */\r\nHAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  uint32_t chnum = (uint32_t)ch_num;\r\n  uint32_t num_packets = 1U;\r\n  uint32_t tmpreg;\r\n\r\n  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\r\n                           USB_OTG_HCTSIZ_DOPING;\r\n\r\n  /* Set host channel enable */\r\n  tmpreg = USBx_HC(chnum)->HCCHAR;\r\n  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;\r\n  tmpreg |= USB_OTG_HCCHAR_CHENA;\r\n  USBx_HC(chnum)->HCCHAR = tmpreg;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stop Host Core\r\n  * @param  USBx  Selected device\r\n  * @retval HAL state\r\n  */\r\nHAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  HAL_StatusTypeDef ret = HAL_OK;\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n  __IO uint32_t count = 0U;\r\n  uint32_t value;\r\n  uint32_t i;\r\n\r\n  (void)USB_DisableGlobalInt(USBx);\r\n\r\n  /* Flush USB FIFO */\r\n  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */\r\n  {\r\n    ret = HAL_ERROR;\r\n  }\r\n\r\n  if (USB_FlushRxFifo(USBx) != HAL_OK)\r\n  {\r\n    ret = HAL_ERROR;\r\n  }\r\n\r\n  /* Flush out any leftover queued requests. */\r\n  for (i = 0U; i <= 15U; i++)\r\n  {\r\n    value = USBx_HC(i)->HCCHAR;\r\n    value |=  USB_OTG_HCCHAR_CHDIS;\r\n    value &= ~USB_OTG_HCCHAR_CHENA;\r\n    value &= ~USB_OTG_HCCHAR_EPDIR;\r\n    USBx_HC(i)->HCCHAR = value;\r\n  }\r\n\r\n  /* Halt all channels to put them into a known state. */\r\n  for (i = 0U; i <= 15U; i++)\r\n  {\r\n    value = USBx_HC(i)->HCCHAR;\r\n    value |= USB_OTG_HCCHAR_CHDIS;\r\n    value |= USB_OTG_HCCHAR_CHENA;\r\n    value &= ~USB_OTG_HCCHAR_EPDIR;\r\n    USBx_HC(i)->HCCHAR = value;\r\n\r\n    do\r\n    {\r\n      if (++count > 1000U)\r\n      {\r\n        break;\r\n      }\r\n    } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);\r\n  }\r\n\r\n  /* Clear any pending Host interrupts */\r\n  USBx_HOST->HAINT = 0xFFFFFFFFU;\r\n  USBx->GINTSTS = 0xFFFFFFFFU;\r\n\r\n  (void)USB_EnableGlobalInt(USBx);\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n  * @brief  USB_ActivateRemoteWakeup active remote wakeup signalling\r\n  * @param  USBx Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_ActivateRemoteWakeup(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)\r\n  {\r\n    /* active Remote wakeup signalling */\r\n    USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  USB_DeActivateRemoteWakeup de-active remote wakeup signalling\r\n  * @param  USBx Selected device\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef USB_DeActivateRemoteWakeup(USB_OTG_GlobalTypeDef *USBx)\r\n{\r\n  uint32_t USBx_BASE = (uint32_t)USBx;\r\n\r\n  /* active Remote wakeup signalling */\r\n  USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);\r\n\r\n  return HAL_OK;\r\n}\r\n#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */\r\n#endif /* defined (HAL_PCD_MODULE_ENABLED) || defined (HAL_HCD_MODULE_ENABLED) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32f7xx_ll_utils.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Drivers\\STM32F7xx_HAL_Driver\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f7xx_ll_utils.c\r\n  * @author  MCD Application Team\r\n  * @brief   UTILS LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f7xx_ll_utils.h\"\r\n#include \"stm32f7xx_ll_rcc.h\"\r\n#include \"stm32f7xx_ll_system.h\"\r\n#include \"stm32f7xx_ll_pwr.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif /* USE_FULL_ASSERT */\r\n\r\n/** @addtogroup STM32F7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup UTILS_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Private_Constants\r\n  * @{\r\n  */\r\n#define UTILS_MAX_FREQUENCY_SCALE1  216000000U /*!< Maximum frequency for system clock at power scale1, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE2  180000000U       /*!< Maximum frequency for system clock at power scale2, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE3  144000000U       /*!< Maximum frequency for system clock at power scale3, in Hz */\r\n\r\n/* Defines used for PLL range */\r\n#define UTILS_PLLVCO_INPUT_MIN         950000U       /*!< Frequency min for PLLVCO input, in Hz   */\r\n#define UTILS_PLLVCO_INPUT_MAX        2100000U       /*!< Frequency max for PLLVCO input, in Hz   */\r\n#define UTILS_PLLVCO_OUTPUT_MIN     100000000U       /*!< Frequency min for PLLVCO output, in Hz  */\r\n#define UTILS_PLLVCO_OUTPUT_MAX     432000000U       /*!< Frequency max for PLLVCO output, in Hz  */\r\n\r\n/* Defines used for HSE range */\r\n#define UTILS_HSE_FREQUENCY_MIN      4000000U        /*!< Frequency min for HSE frequency, in Hz   */\r\n#define UTILS_HSE_FREQUENCY_MAX     26000000U        /*!< Frequency max for HSE frequency, in Hz   */\r\n\r\n/* Defines used for FLASH latency according to HCLK Frequency */\r\n#define UTILS_SCALE1_LATENCY1_FREQ   30000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY2_FREQ   60000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY3_FREQ   90000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY4_FREQ  120000000U      /*!< HCLK frequency to set FLASH latency 4 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY5_FREQ  150000000U      /*!< HCLK frequency to set FLASH latency 5 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY6_FREQ  180000000U      /*!< HCLK frequency to set FLASH latency 6 in power scale 1  with over-drive mode */\r\n#define UTILS_SCALE1_LATENCY7_FREQ  210000000U      /*!< HCLK frequency to set FLASH latency 7 in power scale 1  with over-drive mode */\r\n#define UTILS_SCALE2_LATENCY1_FREQ   30000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY2_FREQ   60000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY3_FREQ   90000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY4_FREQ  120000000U      /*!< HCLK frequency to set FLASH latency 4 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY5_FREQ  150000000U      /*!< HCLK frequency to set FLASH latency 5 in power scale 2  */\r\n#define UTILS_SCALE3_LATENCY1_FREQ   30000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY2_FREQ   60000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY3_FREQ   90000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY4_FREQ  120000000U      /*!< HCLK frequency to set FLASH latency 4 in power scale 3  */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_UTILS_SYSCLK_DIV(__VALUE__) (((__VALUE__) == LL_RCC_SYSCLK_DIV_1)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_2)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_4)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_8)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_16)  \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_64)  \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_128) \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_256) \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_512))\r\n\r\n#define IS_LL_UTILS_APB1_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB1_DIV_1) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_2) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_4) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_8) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_16))\r\n\r\n#define IS_LL_UTILS_APB2_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB2_DIV_1) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_2) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_4) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_8) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_16))\r\n\r\n#define IS_LL_UTILS_PLLM_VALUE(__VALUE__) (((__VALUE__) == LL_RCC_PLLM_DIV_2)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_3)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_4)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_5)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_6)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_7)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_8)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_9)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_10) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_11) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_12) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_13) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_14) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_15) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_16) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_17) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_18) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_19) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_20) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_21) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_22) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_23) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_24) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_25) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_26) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_27) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_28) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_29) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_30) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_31) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_32) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_33) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_34) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_35) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_36) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_37) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_38) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_39) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_40) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_41) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_42) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_43) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_44) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_45) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_46) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_47) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_48) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_49) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_50) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_51) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_52) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_53) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_54) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_55) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_56) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_57) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_58) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_59) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_60) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_61) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_62) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_63))\r\n\r\n#define IS_LL_UTILS_PLLN_VALUE(__VALUE__) ((50 <= (__VALUE__)) && ((__VALUE__) <= 432))\r\n\r\n#define IS_LL_UTILS_PLLP_VALUE(__VALUE__) (((__VALUE__) == LL_RCC_PLLP_DIV_2) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLP_DIV_4) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLP_DIV_6) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLP_DIV_8))\r\n\r\n#define IS_LL_UTILS_PLLVCO_INPUT(__VALUE__)  ((UTILS_PLLVCO_INPUT_MIN <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_INPUT_MAX))\r\n\r\n#define IS_LL_UTILS_PLLVCO_OUTPUT(__VALUE__) ((UTILS_PLLVCO_OUTPUT_MIN <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_OUTPUT_MAX))\r\n\r\n#define IS_LL_UTILS_PLL_FREQUENCY(__VALUE__) ((LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE1) : \\\r\n                                              (LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE2) : \\\r\n                                              ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE3))\r\n\r\n#define IS_LL_UTILS_HSE_BYPASS(__STATE__) (((__STATE__) == LL_UTILS_HSEBYPASS_ON) \\\r\n                                        || ((__STATE__) == LL_UTILS_HSEBYPASS_OFF))\r\n\r\n#define IS_LL_UTILS_HSE_FREQUENCY(__FREQUENCY__) (((__FREQUENCY__) >= UTILS_HSE_FREQUENCY_MIN) && ((__FREQUENCY__) <= UTILS_HSE_FREQUENCY_MAX))\r\n/**\r\n  * @}\r\n  */\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup UTILS_LL_Private_Functions UTILS Private functions\r\n  * @{\r\n  */\r\nstatic uint32_t    UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency,\r\n                                               LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct);\r\nstatic ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);\r\nstatic ErrorStatus UTILS_PLL_IsBusy(void);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup UTILS_LL_EF_DELAY\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function configures the Cortex-M SysTick source to have 1ms time base.\r\n  * @note   When a RTOS is used, it is recommended to avoid changing the Systick\r\n  *         configuration by calling this function, for a delay use rather osDelay RTOS service.\r\n  * @param  HCLKFrequency HCLK frequency in Hz\r\n  * @note   HCLK frequency can be calculated thanks to RCC helper macro or function @ref LL_RCC_GetSystemClocksFreq\r\n  * @retval None\r\n  */\r\nvoid LL_Init1msTick(uint32_t HCLKFrequency)\r\n{\r\n  /* Use frequency provided in argument */\r\n  LL_InitTick(HCLKFrequency, 1000U);\r\n}\r\n\r\n/**\r\n  * @brief  This function provides accurate delay (in milliseconds) based\r\n  *         on SysTick counter flag\r\n  * @note   When a RTOS is used, it is recommended to avoid using blocking delay\r\n  *         and use rather osDelay service.\r\n  * @note   To respect 1ms timebase, user should call @ref LL_Init1msTick function which\r\n  *         will configure Systick to 1ms\r\n  * @param  Delay specifies the delay time length, in milliseconds.\r\n  * @retval None\r\n  */\r\nvoid LL_mDelay(uint32_t Delay)\r\n{\r\n  __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */\r\n  /* Add this code to indicate that local variable is not used */\r\n  ((void)tmp);\r\n\r\n  /* Add a period to guaranty minimum wait */\r\n  if(Delay < LL_MAX_DELAY)\r\n  {\r\n    Delay++;\r\n  }\r\n\r\n  while (Delay)\r\n  {\r\n    if((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)\r\n    {\r\n      Delay--;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup UTILS_EF_SYSTEM\r\n  *  @brief    System Configuration functions\r\n  *\r\n  @verbatim\r\n ===============================================================================\r\n           ##### System Configuration functions #####\r\n ===============================================================================\r\n    [..]\r\n         System, AHB and APB buses clocks configuration\r\n\r\n         (+) The maximum frequency of the SYSCLK, HCLK, PCLK1 and PCLK2 is 216000000 Hz.\r\n  @endverbatim\r\n  @internal\r\n             Depending on the device voltage range, the maximum frequency should be\r\n             adapted accordingly:\r\n             (++) +------------------------------------------------------------------------------------------------+\r\n             (++) |  Wait states   |                           HCLK clock frequency (MHz)                          |\r\n             (++) |                |-------------------------------------------------------------------------------|\r\n             (++) |  (Latency)     |   voltage range   |   voltage range   |   voltage range   |   voltage range   |\r\n             (++) |                |    2.7V - 3.6V    |    2.4V - 2.7V    |    2.1V - 2.7V    |    1.8V - 2.1V    |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |0WS(1CPU cycle) |   0 < HCLK <= 30  |   0 < HCLK <= 24  |   0 < HCLK <= 22  |   0 < HCLK <= 20  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |1WS(2CPU cycle) |  30 < HCLK <= 60  |  24 < HCLK <= 48  |  22 < HCLK <= 44  |  20 < HCLK <= 44  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |2WS(3CPU cycle) |  60 < HCLK <= 90  |  48 < HCLK <= 72  |  44 < HCLK <= 66  |  40 < HCLK <= 60  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |3WS(4CPU cycle) |  90 < HCLK <= 120 |  72 < HCLK <= 96  |  66 < HCLK <= 88  |  60 < HCLK <= 80  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |4WS(5CPU cycle) | 120 < HCLK <= 150 |  96 < HCLK <= 120 |  88 < HCLK <= 110 |  80 < HCLK <= 100 |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |5WS(6CPU cycle) | 150 < HCLK <= 180 | 120 < HCLK <= 144 | 110 < HCLK <= 132 | 100 < HCLK <= 120 |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |6WS(7CPU cycle) | 180 < HCLK <= 210 | 144 < HCLK <= 168 | 132 < HCLK <= 154 | 120 < HCLK <= 140 |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |7WS(8CPU cycle) | 210 < HCLK <= 216 | 168 < HCLK <= 192 | 154 < HCLK <= 176 | 140 < HCLK <= 160 |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |8WS(9CPU cycle) |        --         | 192 < HCLK <= 216 | 176 < HCLK <= 198 | 160 < HCLK <= 180 |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |9WS(10CPU cycle)|        --         |         --        | 198 < HCLK <= 216 |         --        |\r\n             (++) +------------------------------------------------------------------------------------------------+\r\n\r\n  @endinternal\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function sets directly SystemCoreClock CMSIS variable.\r\n  * @note   Variable can be calculated also through SystemCoreClockUpdate function.\r\n  * @param  HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro)\r\n  * @retval None\r\n  */\r\nvoid LL_SetSystemCoreClock(uint32_t HCLKFrequency)\r\n{\r\n  /* HCLK clock frequency */\r\n  SystemCoreClock = HCLKFrequency;\r\n}\r\n\r\n/**\r\n  * @brief  Update number of Flash wait states in line with new frequency and current\r\n            voltage range.\r\n  * @note   This Function support ONLY devices with supply voltage (voltage range) between 2.7V and 3.6V\r\n  * @param  HCLK_Frequency  HCLK frequency\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Latency has been modified\r\n  *          - ERROR: Latency cannot be modified\r\n  */\r\nErrorStatus LL_SetFlashLatency(uint32_t HCLK_Frequency)\r\n{\r\n  uint32_t timeout;\r\n  uint32_t getlatency;\r\n  uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Frequency cannot be equal to 0 */\r\n  if(HCLK_Frequency == 0U)\r\n  {\r\n    status = ERROR;\r\n  }\r\n  else\r\n  {\r\n    if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)\r\n    {\r\n      if(LL_PWR_IsEnabledOverDriveMode() != 0U)\r\n        {\r\n          if(HCLK_Frequency > UTILS_SCALE1_LATENCY7_FREQ)\r\n          {\r\n            /* 210 < HCLK <= 216 => 7WS (8 CPU cycles) */\r\n            latency = LL_FLASH_LATENCY_7;\r\n          }\r\n          else /* (HCLK_Frequency > UTILS_SCALE1_LATENCY6_FREQ) */\r\n          {\r\n            /* 180 < HCLK <= 210 => 6WS (7 CPU cycles) */\r\n            latency = LL_FLASH_LATENCY_6;\r\n          }\r\n        }\r\n      if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ) && (latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        /* 150 < HCLK <= 180 => 5WS (6 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_5;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ) && (latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        /* 120 < HCLK <= 150 => 4WS (5 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ) && (latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        /* 90 < HCLK <= 120 => 3WS (4 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ) && (latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        /* 60 < HCLK <= 90 => 2WS (3 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else\r\n      {\r\n        if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ) && (latency == LL_FLASH_LATENCY_0))\r\n        {\r\n          /* 30 < HCLK <= 60 => 1WS (2 CPU cycles) */\r\n          latency = LL_FLASH_LATENCY_1;\r\n        }\r\n        /* else HCLK_Frequency < 30MHz default LL_FLASH_LATENCY_0 0WS */\r\n      }\r\n    }\r\n    else if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)\r\n    {\r\n      if(HCLK_Frequency > UTILS_SCALE2_LATENCY5_FREQ)\r\n      {\r\n        /* 150 < HCLK <= 168 OR 150 < HCLK <= 180 (when OverDrive mode is enable) => 5WS (6 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_5;\r\n      }\r\n      else if(HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)\r\n      {\r\n        /* 120 < HCLK <= 150 => 4WS (5 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n      else if(HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)\r\n      {\r\n        /* 90 < HCLK <= 120 => 3WS (4 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n      else if(HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)\r\n      {\r\n        /* 60 < HCLK <= 90 => 2WS (3 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else\r\n      {\r\n        if(HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)\r\n        {\r\n          /* 30 < HCLK <= 60 => 1WS (2 CPU cycles) */\r\n          latency = LL_FLASH_LATENCY_1;\r\n        }\r\n        /* else HCLK_Frequency < 24MHz default LL_FLASH_LATENCY_0 0WS */\r\n      }\r\n    }\r\n    else /* Scale 3 */\r\n    {\r\n      if(HCLK_Frequency > UTILS_SCALE3_LATENCY4_FREQ)\r\n      {\r\n        /* 120 < HCLK <= 144 => 4WS (5 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n      else if(HCLK_Frequency > UTILS_SCALE3_LATENCY3_FREQ)\r\n      {\r\n        /* 90 < HCLK <= 120 => 3WS (4 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n      else if(HCLK_Frequency > UTILS_SCALE3_LATENCY2_FREQ)\r\n      {\r\n        /* 60 < HCLK <= 90 => 2WS (3 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else\r\n      {\r\n        if(HCLK_Frequency > UTILS_SCALE3_LATENCY1_FREQ)\r\n        {\r\n          /* 30 < HCLK <= 60 => 1WS (2 CPU cycles) */\r\n          latency = LL_FLASH_LATENCY_1;\r\n        }\r\n        /* else HCLK_Frequency < 22MHz default LL_FLASH_LATENCY_0 0WS */\r\n      }\r\n    }\r\n\r\n    if (status != ERROR)\r\n    {\r\n      LL_FLASH_SetLatency(latency);\r\n\r\n      /* Check that the new number of wait states is taken into account to access the Flash\r\n           memory by reading the FLASH_ACR register */\r\n      timeout = 2;\r\n      do\r\n      {\r\n      /* Wait for Flash latency to be updated */\r\n      getlatency = LL_FLASH_GetLatency();\r\n      timeout--;\r\n      } while ((getlatency != latency) && (timeout > 0));\r\n\r\n      if(getlatency != latency)\r\n      {\r\n        status = ERROR;\r\n      }\r\n      else\r\n      {\r\n        status = SUCCESS;\r\n      }\r\n    }\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  This function configures system clock at maximum frequency with HSI as clock source of the PLL\r\n  * @note   The application need to ensure that PLL is disabled.\r\n  * @note   Function is based on the following formula:\r\n  *         - PLL output frequency = (((HSI frequency / PLLM) * PLLN) / PLLP)\r\n  *         - PLLM: ensure that the VCO input frequency ranges from 0.95 to 2.1 MHz (PLLVCO_input = HSI frequency / PLLM)\r\n  *         - PLLN: ensure that the VCO output frequency is between 100 and 432 MHz (PLLVCO_output = PLLVCO_input * PLLN)\r\n  *         - PLLP: ensure that max frequency at 216000000 Hz is reach (PLLVCO_output / PLLP)\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Max frequency configuration done\r\n  *          - ERROR: Max frequency configuration not done\r\n  */\r\nErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,\r\n                                         LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  uint32_t pllfreq = 0U;\r\n\r\n  /* Check if one of the PLL is enabled */\r\n  if(UTILS_PLL_IsBusy() == SUCCESS)\r\n  {\r\n    /* Calculate the new PLL output frequency */\r\n    pllfreq = UTILS_GetPLLOutputFrequency(HSI_VALUE, UTILS_PLLInitStruct);\r\n\r\n    /* Enable HSI if not enabled */\r\n    if(LL_RCC_HSI_IsReady() != 1U)\r\n    {\r\n      LL_RCC_HSI_Enable();\r\n      while (LL_RCC_HSI_IsReady() != 1U)\r\n      {\r\n        /* Wait for HSI ready */\r\n      }\r\n    }\r\n\r\n    /* Configure PLL */\r\n    LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,\r\n                                UTILS_PLLInitStruct->PLLP);\r\n\r\n    /* Enable PLL and switch system clock to PLL */\r\n    status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);\r\n  }\r\n  else\r\n  {\r\n    /* Current PLL configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  This function configures system clock with HSE as clock source of the PLL\r\n  * @note   The application need to ensure that PLL is disabled.\r\n  * @note   Function is based on the following formula:\r\n  *         - PLL output frequency = (((HSE frequency / PLLM) * PLLN) / PLLP)\r\n  *         - PLLM: ensure that the VCO input frequency ranges from 0.95 to 2.10 MHz (PLLVCO_input = HSE frequency / PLLM)\r\n  *         - PLLN: ensure that the VCO output frequency is between 100 and 432 MHz (PLLVCO_output = PLLVCO_input * PLLN)\r\n  *         - PLLP: ensure that max frequency at 216000000 Hz is reached (PLLVCO_output / PLLP)\r\n  * @param  HSEFrequency Value between Min_Data = 4000000 and Max_Data = 26000000\r\n  * @param  HSEBypass This parameter can be one of the following values:\r\n  *         @arg @ref LL_UTILS_HSEBYPASS_ON\r\n  *         @arg @ref LL_UTILS_HSEBYPASS_OFF\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Max frequency configuration done\r\n  *          - ERROR: Max frequency configuration not done\r\n  */\r\nErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,\r\n                                         LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  uint32_t pllfreq = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_UTILS_HSE_FREQUENCY(HSEFrequency));\r\n  assert_param(IS_LL_UTILS_HSE_BYPASS(HSEBypass));\r\n\r\n  /* Check if one of the PLL is enabled */\r\n  if(UTILS_PLL_IsBusy() == SUCCESS)\r\n  {\r\n    /* Calculate the new PLL output frequency */\r\n    pllfreq = UTILS_GetPLLOutputFrequency(HSEFrequency, UTILS_PLLInitStruct);\r\n\r\n    /* Enable HSE if not enabled */\r\n    if(LL_RCC_HSE_IsReady() != 1U)\r\n    {\r\n      /* Check if need to enable HSE bypass feature or not */\r\n      if(HSEBypass == LL_UTILS_HSEBYPASS_ON)\r\n      {\r\n        LL_RCC_HSE_EnableBypass();\r\n      }\r\n      else\r\n      {\r\n        LL_RCC_HSE_DisableBypass();\r\n      }\r\n\r\n      /* Enable HSE */\r\n      LL_RCC_HSE_Enable();\r\n      while (LL_RCC_HSE_IsReady() != 1U)\r\n      {\r\n        /* Wait for HSE ready */\r\n      }\r\n    }\r\n\r\n    /* Configure PLL */\r\n    LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,\r\n                                UTILS_PLLInitStruct->PLLP);\r\n\r\n    /* Enable PLL and switch system clock to PLL */\r\n    status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);\r\n  }\r\n  else\r\n  {\r\n    /* Current PLL configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup UTILS_LL_Private_Functions\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Function to check that PLL can be modified\r\n  * @param  PLL_InputFrequency  PLL input frequency (in Hz)\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @retval PLL output frequency (in Hz)\r\n  */\r\nstatic uint32_t UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct)\r\n{\r\n  uint32_t pllfreq = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_UTILS_PLLM_VALUE(UTILS_PLLInitStruct->PLLM));\r\n  assert_param(IS_LL_UTILS_PLLN_VALUE(UTILS_PLLInitStruct->PLLN));\r\n  assert_param(IS_LL_UTILS_PLLP_VALUE(UTILS_PLLInitStruct->PLLP));\r\n  \r\n  /* Check different PLL parameters according to RM                          */\r\n  /*  - PLLM: ensure that the VCO input frequency ranges from 0.95 to 2.1 MHz.   */\r\n  pllfreq = PLL_InputFrequency / (UTILS_PLLInitStruct->PLLM & (RCC_PLLCFGR_PLLM >> RCC_PLLCFGR_PLLM_Pos));\r\n  assert_param(IS_LL_UTILS_PLLVCO_INPUT(pllfreq));\r\n\r\n  /*  - PLLN: ensure that the VCO output frequency is between 100 and 432 MHz.*/\r\n  pllfreq = pllfreq * (UTILS_PLLInitStruct->PLLN & (RCC_PLLCFGR_PLLN >> RCC_PLLCFGR_PLLN_Pos));\r\n  assert_param(IS_LL_UTILS_PLLVCO_OUTPUT(pllfreq));\r\n  \r\n  /*  - PLLP: ensure that max frequency at 216000000 Hz is reached     */\r\n  pllfreq = pllfreq / (((UTILS_PLLInitStruct->PLLP >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);\r\n  assert_param(IS_LL_UTILS_PLL_FREQUENCY(pllfreq));\r\n\r\n  return pllfreq;\r\n}\r\n\r\n/**\r\n  * @brief  Function to check that PLL can be modified\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: PLL modification can be done\r\n  *          - ERROR: PLL is busy\r\n  */\r\nstatic ErrorStatus UTILS_PLL_IsBusy(void)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check if PLL is busy*/\r\n  if(LL_RCC_PLL_IsReady() != 0U)\r\n  {\r\n    /* PLL configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n\r\n  /* Check if PLLSAI is busy*/\r\n  if(LL_RCC_PLLSAI_IsReady() != 0U)\r\n  {\r\n    /* PLLSAI1 configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n  /* Check if PLLI2S is busy*/\r\n  if(LL_RCC_PLLI2S_IsReady() != 0U)\r\n  {\r\n    /* PLLI2S configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Function to enable PLL and switch system clock to PLL\r\n  * @param  SYSCLK_Frequency SYSCLK frequency\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: No problem to switch system to PLL\r\n  *          - ERROR: Problem to switch system to PLL\r\n  */\r\nstatic ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  uint32_t hclk_frequency = 0U;\r\n\r\n  assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->AHBCLKDivider));\r\n  assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));\r\n  assert_param(IS_LL_UTILS_APB2_DIV(UTILS_ClkInitStruct->APB2CLKDivider));\r\n\r\n  /* Calculate HCLK frequency */\r\n  hclk_frequency = __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider);\r\n\r\n  /* Increasing the number of wait states because of higher CPU frequency */\r\n  if(SystemCoreClock < hclk_frequency)\r\n  {\r\n    /* Set FLASH latency to highest latency */\r\n    status = LL_SetFlashLatency(hclk_frequency);\r\n  }\r\n\r\n  /* Update system clock configuration */\r\n  if(status == SUCCESS)\r\n  {\r\n    /* Enable PLL */\r\n    LL_RCC_PLL_Enable();\r\n    while (LL_RCC_PLL_IsReady() != 1U)\r\n    {\r\n      /* Wait for PLL ready */\r\n    }\r\n\r\n    /* Sysclk activation on the main PLL */\r\n    LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);\r\n    LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);\r\n    while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)\r\n    {\r\n      /* Wait for system clock switch to PLL */\r\n    }\r\n\r\n    /* Set APB1 & APB2 prescaler*/\r\n    LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);\r\n    LL_RCC_SetAPB2Prescaler(UTILS_ClkInitStruct->APB2CLKDivider);\r\n  }\r\n    \r\n  /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if(SystemCoreClock > hclk_frequency)\r\n  {\r\n    /* Set FLASH latency to lowest latency */\r\n    status = LL_SetFlashLatency(hclk_frequency);\r\n  }\r\n\r\n  /* Update SystemCoreClock variable */\r\n  if(status == SUCCESS)\r\n  {\r\n    LL_SetSystemCoreClock(hclk_frequency);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm_lpuart.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2021-2023 The MathWorks, Inc. */\n\n\n\n#if defined(MW_LPUART1_ENABLED)\n\n#include \"MW_target_hardware_resources.h\"\n\n#include \"main.h\"\n#include \"stm_lpuart.h\"\n#include \"string.h\"\n\n\n#if defined(LPUART1) && defined(MW_LPUART1_ENABLED)\nUART_Type_T mw_lpuart1;\n#if defined(MW_LPUART1_RX_DMA_ENABLED)\n    #ifdef STM32H7\n\t    #if defined(MW_DCACHE_ENABLED)\n\t\t    uint8_T LPUART1ReceiveBuffer[MW_LPUART1_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".bdma_buffer\"))) ;\n\t    #else\n\t\t    uint8_T LPUART1ReceiveBuffer[MW_LPUART1_RECEIVE_BUFFER_SIZE] __attribute__((section(\".bdma_buffer\"))) ;\n\t    #endif\n    #elif defined(MW_DCACHE_ENABLED)\n        uint8_T LPUART1ReceiveBuffer[MW_LPUART1_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n    #else\n        uint8_T LPUART1ReceiveBuffer[MW_LPUART1_RECEIVE_BUFFER_SIZE];\n    #endif\n#endif \n#if defined(MW_LPUART1_TX_DMA_ENABLED)\n    #ifdef STM32H7\n\t    #if defined(MW_DCACHE_ENABLED)\n\t\t    uint8_T LPUART1TransmitBuffer[MW_LPUART1_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".bdma_buffer\"))) ;\n\t    #else\n\t       uint8_T LPUART1TransmitBuffer[MW_LPUART1_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".bdma_buffer\"))) ;\n\t    #endif\n    #elif defined(MW_DCACHE_ENABLED)\n        uint8_T LPUART1TransmitBuffer[MW_LPUART1_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n    #else\n        uint8_T LPUART1TransmitBuffer[MW_LPUART1_TRANSMIT_BUFFER_SIZE];\n    #endif\n#endif \n#endif\n\n\n/* DMA RX Interrupt Handler */\nvoid LPUART_RXDMAInterruptHandler(UART_Type_T *h ,uint32_t  (*checkActiveFlag)(DMA_TypeDef *DMAx),  void (*clearActiveFlag)(DMA_TypeDef *DMAx))\n{\n    /* Check transfer-complete interrupt */\n    if (LL_DMA_IsEnabledIT_TC(h->rxdmaPeripheralPtr, h->rxdmastream) && (checkActiveFlag(h->rxdmaPeripheralPtr)))\n        /* Clear transfer complete interrupt flag */\n    {\n        clearActiveFlag(h->rxdmaPeripheralPtr);\n        if(h->buffer.writeRollOver == 1)\n        {\n            h->errorStatus =  h->errorStatus |  MW_SCI_RX_BUFFER_FULL;\n            h->buffer.readPos = 0;\n        }\n        h->buffer.writeRollOver = 1;\n\t\t/* Start DMA again when DMA mode is Normal */\n\t\tif ((LL_DMA_MODE_NORMAL == LL_DMA_GetMode(h->rxdmaPeripheralPtr, h->rxdmastream)) && ( (h->disableDMAIntOnError == 0) ||\n\t\t                   ((h->disableDMAIntOnError == 1) && ((h->errorStatus == MW_SCI_SUCCESS) || (h->errorStatus == MW_SCI_RX_BUFFER_FULL)))))\n\t\t{\n            #if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n            LL_DMA_DisableChannel(h->rxdmaPeripheralPtr, h->rxdmastream);\n            #else\n\t\t\tLL_DMA_DisableStream(h->rxdmaPeripheralPtr, h->rxdmastream);\n            #endif\n\t\t\t/* Set length to receive */\n\t\t\tLL_DMA_SetDataLength(h->rxdmaPeripheralPtr, h->rxdmastream, h->buffer.rxBufferSize);\n\t\t\t/* Start DMA again */\n\t\t\t#if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n            LL_DMA_EnableChannel(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n            #else\n            LL_DMA_EnableStream(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n            #endif\n\t\t}\n    }   \n}\n/* DMA RX Interrupt Handler */\n#if defined(STM32H7) && defined(MW_LPUART1_ENABLED)\nvoid LPUART_RXBDMAInterruptHandler(UART_Type_T *h ,uint32_t  (*checkActiveFlag)(BDMA_TypeDef *BDMAx),  void (*clearActiveFlag)(BDMA_TypeDef *BDMAx))\n{\n    /* Check transfer-complete interrupt */\n    if (LL_BDMA_IsEnabledIT_TC(h->rxdmaPeripheralPtr, h->rxdmastream) && (checkActiveFlag(h->rxdmaPeripheralPtr)))\n        /* Clear transfer complete interrupt flag */\n    {\n        clearActiveFlag(h->rxdmaPeripheralPtr);\n        if(h->buffer.writeRollOver == 1)\n        {\n            h->errorStatus =  h->errorStatus |  MW_SCI_RX_BUFFER_FULL;\n            h->buffer.readPos = 0;\n        }\n        h->buffer.writeRollOver = 1;\n        /* Start DMA again when DMA mode is Normal */\n        if ((LL_BDMA_MODE_NORMAL == LL_BDMA_GetMode(h->rxdmaPeripheralPtr, h->rxdmastream)) && ( (h->disableDMAIntOnError == 0) ||\n                                                                                                ((h->disableDMAIntOnError == 1) && ((h->errorStatus == MW_SCI_SUCCESS) || (h->errorStatus == MW_SCI_RX_BUFFER_FULL)))))\n        {\n            LL_BDMA_DisableChannel(h->rxdmaPeripheralPtr, h->rxdmastream);\n            /* Set length to receive */\n            LL_BDMA_SetDataLength(h->rxdmaPeripheralPtr, h->rxdmastream, h->buffer.rxBufferSize);\n            /* Start BDMA again */\n            LL_BDMA_EnableChannel(h->rxdmaPeripheralPtr, h->rxdmastream);\n        }\n    }\n}\n#endif\n\n/*DMA TX Interrupt Handler */\nvoid LPUART_TXDMAInterruptHandler(UART_Type_T *h ,uint32_t  (*checkActiveFlag)(DMA_TypeDef *DMAx),  void (*clearActiveFlag)(DMA_TypeDef *DMAx))\n{\n    /* Check transfer-complete interrupt */\n    if (LL_DMA_IsEnabledIT_TC(h->txdmaPeripheralPtr, h->txdmastream) && (checkActiveFlag(h->txdmaPeripheralPtr)))\n        /* Clear transfer complete interrupt flag */\n    {\n        clearActiveFlag(h->txdmaPeripheralPtr);\n    /* Start DMA again when DMA mode is Normal */\n\t\tif (LL_DMA_MODE_NORMAL == LL_DMA_GetMode(h->txdmaPeripheralPtr, h->txdmastream))\n\t\t{\n\t\t\t/* Data equal to h->txDMATransferLength has been transmitted so update the h->sentPos */\n\t\t\th->buffer.sentPos = h->buffer.sentPos + h->txDMATransferLength;\n\t\t\tif(h->buffer.sentPos == h->buffer.txBufferSize)\n\t\t\t{\n\t\t\t\th->buffer.sentPos = 0;\n\t\t\t}\n\t\t\th->txdmaEnabled = 0;\n\n\t\t\t/*If buffer not empty, then start the DMA with length equal to length of data in buffer */\n\t\t\tif(h->buffer.sentPos < h->buffer.writePos)\n\t\t\t{\n\t\t\t\th->txDMATransferLength = h->buffer.writePos - h->buffer.sentPos;\n                #if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n                LL_DMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n                #else\n\t\t\t\tLL_DMA_DisableStream(h->txdmaPeripheralPtr, h->txdmastream);\n                #endif\n\t\t\t\tLL_DMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n\t\t\t\tLL_DMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #if defined(MW_DCACHE_ENABLED) // Clean cache if enabled before starting DMA\n                SCB_CleanDCache_by_Addr((uint32_t *)&h->buffer.txBufferPtr[0], h->buffer.txBufferSize);\n                #endif\n                #if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n                LL_DMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #else\n                LL_DMA_EnableStream(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #endif\n\t\t\t\th->txdmaEnabled = 1;\n\t\t\t}\n\t\t\telse if(h->buffer.sentPos > h->buffer.writePos)\n\t\t\t{\n\t\t\t\th->txDMATransferLength = h->buffer.txBufferSize - h->buffer.sentPos;\n\t\t\t\t#if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n                LL_DMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n                #else\n\t\t\t\tLL_DMA_DisableStream(h->txdmaPeripheralPtr, h->txdmastream);\n                #endif\n\t\t\t\tLL_DMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n\t\t\t\tLL_DMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #if defined(MW_DCACHE_ENABLED)  // Clean cache if enabled before starting DMA\n                SCB_CleanDCache_by_Addr((uint32_t *)&h->buffer.txBufferPtr[0], h->buffer.txBufferSize);\n                #endif                \n                #if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n                LL_DMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #else\n                LL_DMA_EnableStream(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #endif\n\t\t\t\th->txdmaEnabled = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#if defined(STM32H7) && defined(MW_LPUART1_ENABLED)\nvoid LPUART_TXBDMAInterruptHandler(UART_Type_T *h ,uint32_t  (*checkActiveFlag)(BDMA_TypeDef *BDMAx),  void (*clearActiveFlag)(BDMA_TypeDef *BDMAx))\n{\n    /* Check transfer-complete interrupt */\n    if (LL_BDMA_IsEnabledIT_TC(h->txdmaPeripheralPtr, h->txdmastream) && (checkActiveFlag(h->txdmaPeripheralPtr)))\n        /* Clear transfer complete interrupt flag */\n    {\n        clearActiveFlag(h->txdmaPeripheralPtr);\n        /* Start DMA again when DMA mode is Normal */\n        if (LL_BDMA_MODE_NORMAL == LL_BDMA_GetMode(h->txdmaPeripheralPtr, h->txdmastream))\n        {\n            /* Data equal to h->txDMATransferLength has been transmitted so update the h->sentPos */\n            h->buffer.sentPos = h->buffer.sentPos + h->txDMATransferLength;\n            if(h->buffer.sentPos == h->buffer.txBufferSize)\n            {\n                h->buffer.sentPos = 0;\n            }\n            h->txdmaEnabled = 0;\n\n            /*If buffer not empty, then start the DMA with length equal to length of data in buffer */\n            if(h->buffer.sentPos < h->buffer.writePos)\n            {\n                h->txDMATransferLength = h->buffer.writePos - h->buffer.sentPos;\n                LL_BDMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n                LL_BDMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                LL_BDMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #if defined(MW_DCACHE_ENABLED)// Clean cache if enabled before starting DMA                \n                SCB_CleanDCache_by_Addr((uint32_t *)&h->buffer.txBufferPtr[0], h->buffer.txBufferSize);\n                #endif\n                LL_BDMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                h->txdmaEnabled = 1;\n            }\n            else if(h->buffer.sentPos > h->buffer.writePos)\n            {\n                h->txDMATransferLength = h->buffer.txBufferSize - h->buffer.sentPos;\n                LL_BDMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n                LL_BDMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                LL_BDMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #if defined(MW_DCACHE_ENABLED) // Clean cache if enabled before starting DMA\n                SCB_CleanDCache_by_Addr((uint32_t *)&h->buffer.txBufferPtr[0], h->buffer.txBufferSize);\n                #endif                \n                LL_BDMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                h->txdmaEnabled = 1;\n            }\n        }\n    }\n}\n#endif\n\n/* Check if RXNE flag is active */\nuint8_T LPUART_IsActiveFlagRXNE(UART_Type_T *h)\n{\n    uint8_T ret = (uint8_T)LL_LPUART_IsActiveFlag_RXNE(h->peripheralPtr) || (uint8_T)LL_LPUART_IsActiveFlag_ORE(h->peripheralPtr);\n    if(1 == ret)\n    {\n        // Store if any error occured\n        // Clear RXNE flag by reading the data\n        if((h->buffer.writeRollOver == 1) && (h->buffer.toReadPos == h->buffer.readPos) )\n        {\n            h->buffer.readPos++;\n            if(h->buffer.readPos == h->buffer.rxBufferSize)\n            {\n                h->buffer.readPos = 0;\n            }\n            h->errorStatus =  h->errorStatus |  MW_SCI_RX_BUFFER_FULL;\n        }\n        LPUART_IsActiveFlagError(h);\n        h->buffer.rxBufferPtr[h->buffer.toReadPos] = LL_LPUART_ReceiveData8((USART_TypeDef*)h->peripheralPtr) ;\n        //Update the readPos\n        if((h->buffer.toReadPos + 1) == h->buffer.rxBufferSize)\n        {\n            h->buffer.toReadPos  = 0;\n            h->buffer.writeRollOver = 1;\n        }\n        else\n        {\n            h->buffer.toReadPos++;\n        }\n    }\n    return ret;\n}\n\n/*Check if error flag is active */\nvoid LPUART_IsActiveFlagError(UART_Type_T *h)\n{\n    uint8_T ret = 0;\n   \n    if(1 == LL_LPUART_IsActiveFlag_ORE(h->peripheralPtr))\n    {\n        h->errorStatus = h->errorStatus | MW_SCI_ORE_ERROR;\n        ret = 1;\n    }\n    if(1 == LL_LPUART_IsActiveFlag_FE(h->peripheralPtr))\n    {\n        h->errorStatus = h->errorStatus | MW_SCI_FRAME_ERROR;\n        ret = 1;\n    }\n    if(1 == LL_LPUART_IsActiveFlag_NE(h->peripheralPtr))\n    {\n        h->errorStatus = h->errorStatus | MW_SCI_NOISE_ERROR;\n        ret = 1;\n    }\n    if(1 == LL_LPUART_IsActiveFlag_PE(h->peripheralPtr))\n    {\n        h->errorStatus = h->errorStatus | MW_SCI_PARITY_ERROR;\n        ret = 1;\n    }\n    \n    if(ret == 1)\n    {\n        if(h->disableDMAIntOnError == 1)\n        {\n            if((h->mode & UART_RX_INTERRUPT_MODE) == UART_RX_INTERRUPT_MODE)\n            {\n                LL_LPUART_DisableIT_RXNE(h->peripheralPtr);\n            }\n            else\n            {\n                LL_LPUART_DisableDMAReq_RX(h->peripheralPtr);\n            }\n        }\n        LL_LPUART_ClearFlag_PE(h->peripheralPtr); //Clearing this flag will clear all ORE,NE,FE and PE flags\n\n        \n        LL_LPUART_ClearFlag_ORE(h->peripheralPtr);\n        LL_LPUART_ClearFlag_FE(h->peripheralPtr);\n        LL_LPUART_ClearFlag_NE(h->peripheralPtr);\n    }\n}\n\n/* Check if TXE flag is active*/\nuint8_T LPUART_IsActiveFlagTXE(UART_Type_T *h)\n{\n    uint8_T ret = (uint8_T)LL_LPUART_IsActiveFlag_TXE(h->peripheralPtr);\n    if(1 == ret)\n    {\n        /*If buffer is not empty, transmit a byte and update sentPos */\n        if (h->buffer.sentPos != h->buffer.writePos)\n        {\n            LL_LPUART_TransmitData8((USART_TypeDef*)h->peripheralPtr,h->buffer.txBufferPtr[h->buffer.sentPos]);\n\n            if((h->buffer.sentPos + 1) == h->buffer.txBufferSize)\n            {\n                h->buffer.sentPos = 0;\n            }\n            else\n            {\n                h->buffer.sentPos++;\n            }\n        }\n        else /*Disable TXE interrupt if buffer is empty */\n        {\n            LL_LPUART_DisableIT_TXE(h->peripheralPtr);\n            h->txeEnabled = 0;\n        }\n    }\n    return ret;\n}\n\n\n#if defined(MW_LPUART1_RXNE_INTERRUPT_ENABLED ) || defined(MW_LPUART1_TXE_INTERRUPT_ENABLED ) || defined(MW_LPUART1_RX_DMA_ENABLED)\nvoid LPUART1_IRQHandler(void)\n{\n    #ifdef MW_LPUART1_RXNE_INTERRUPT_ENABLED\n    LPUART_IsActiveFlagRXNE(&mw_lpuart1);\n    #endif\n\n    #if  defined(MW_LPUART1_RX_DMA_ENABLED)\n    LPUART_IsActiveFlagError(&mw_lpuart1);\n    #endif\n\n    #ifdef MW_LPUART1_TXE_INTERRUPT_ENABLED\n    LPUART_IsActiveFlagTXE(&mw_lpuart1);\n    #endif\n}\n#endif\n\n\n#ifdef MW_LPUART1_TX_DMA_ENABLED\nGETIRQ_NAME(MW_LPUART1_TX_DMA_ENABLED)\n{\n    #ifdef STM32H7\n    LPUART_TXBDMAInterruptHandler(&mw_lpuart1, GETFCN_LL_GET_STREAM_BDMA_ACTIVEFLAG(MW_LPUART1_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_BDMA_ACTIVEFLAG(MW_LPUART1_TX_DMA_STREAM));\n    #else\n    LPUART_TXDMAInterruptHandler(&mw_lpuart1, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_LPUART1_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_LPUART1_TX_DMA_STREAM));\n    #endif\n}\n#endif\n\n#ifdef MW_LPUART1_RX_DMA_ENABLED\nGETIRQ_NAME(MW_LPUART1_RX_DMA_ENABLED)\n{\n    #ifdef STM32H7\n    LPUART_RXBDMAInterruptHandler(&mw_lpuart1, GETFCN_LL_GET_STREAM_BDMA_ACTIVEFLAG(MW_LPUART1_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_BDMA_ACTIVEFLAG(MW_LPUART1_RX_DMA_STREAM));\n    #else\n    LPUART_RXDMAInterruptHandler(&mw_lpuart1, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_LPUART1_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_LPUART1_RX_DMA_STREAM));\n    #endif\n}\n#endif\n/**************Internal Functions ****************************************************************************/\n\n/*Configure UART Receive DMA */\nvoid LPUART_ConfigureReceiveDMA(UART_Type_T *h)\n{\n    if (1 == LL_LPUART_IsEnabled(h->peripheralPtr))\n    {\n         /* Disable USART */\n        LL_LPUART_Disable(h->peripheralPtr);\n        LL_DMA_ConfigAddresses(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, \n                               LL_LPUART_DMA_GetRegAddr(h->peripheralPtr, LL_LPUART_DMA_REG_DATA_RECEIVE),\n                               (uint32_t)h->buffer.rxBufferPtr, LL_DMA_DIRECTION_PERIPH_TO_MEMORY);\n        LL_DMA_SetDataLength(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, h->buffer.rxBufferSize);\n\n        /* Enable TC interrupts */\n        LL_DMA_EnableIT_TC(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n        /* Enable DMA */\n        LL_LPUART_EnableDMAReq_RX(h->peripheralPtr);\n        ((USART_TypeDef *)h->peripheralPtr)->CR3 |= USART_CR3_DMAR;\n        /* Enable USART and DMA Stream */\n        #if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n        LL_DMA_EnableChannel(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n        #else\n        LL_DMA_EnableStream(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n        #endif\n        LL_LPUART_Enable(h->peripheralPtr);\n    }\n\n}\n\n#if defined(STM32H7) && defined(MW_LPUART1_ENABLED)\nvoid LPUART_ConfigureReceiveBDMA(UART_Type_T *h)\n{\n    if (1 == LL_LPUART_IsEnabled(h->peripheralPtr))\n    {\n        /* Disable USART */\n        LL_LPUART_Disable(h->peripheralPtr);\n        LL_BDMA_SetPeriphAddress(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, (uint32_t)(&((USART_TypeDef *)(h->peripheralPtr))->RDR));\n        LL_BDMA_SetMemoryAddress(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, (uint32_t)h->buffer.rxBufferPtr);\n        LL_BDMA_SetDataLength(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, h->buffer.rxBufferSize);\n\n        /* Enable TC interrupts */\n        LL_BDMA_EnableIT_TC(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n        /* Enable DMA */\n        LL_LPUART_EnableDMAReq_RX(h->peripheralPtr);\n        /* Enable USART and DMA Stream */\n        LL_BDMA_EnableChannel(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n        LL_LPUART_Enable(h->peripheralPtr);\n    }\n\n}\n#endif\n\n/*Configure UART Transmit DMA */\nvoid LPUART_ConfigureTransmitDMA(UART_Type_T *h)\n{\n     if (1 == LL_LPUART_IsEnabled(h->peripheralPtr))\n    {\n        /* Disable USART */\n        LL_LPUART_Disable(h->peripheralPtr);\n        LL_DMA_ConfigAddresses(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, \n        \t\t\t\t\t   (uint32_t)h->buffer.txBufferPtr,  \n                               LL_LPUART_DMA_GetRegAddr(h->peripheralPtr, LL_LPUART_DMA_REG_DATA_TRANSMIT),\n                               LL_DMA_DIRECTION_MEMORY_TO_PERIPH);\n\n        /* Enable  TC interrupts */\n        LL_DMA_EnableIT_TC(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n        /* Enable DMA */\n        LL_LPUART_EnableDMAReq_TX(h->peripheralPtr);\n        /* Enable USART and DMA */\n        LL_LPUART_Enable(h->peripheralPtr);\n    }\n}\n\n#if defined(STM32H7) && defined(MW_LPUART1_ENABLED)\nvoid LPUART_ConfigureTransmitBDMA(UART_Type_T *h)\n{\n    if (1 == LL_LPUART_IsEnabled(h->peripheralPtr))\n    {\n        /* Disable USART */\n        LL_LPUART_Disable(h->peripheralPtr);\n        LL_BDMA_SetPeriphAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(&((USART_TypeDef *)(h->peripheralPtr))->TDR));\n        LL_BDMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)h->buffer.txBufferPtr);\n\n        /* Enable  TC interrupts */\n        LL_BDMA_EnableIT_TC(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n        /* Enable DMA */\n        LL_LPUART_EnableDMAReq_TX(h->peripheralPtr);\n        /* Enable USART and DMA */\n        LL_LPUART_Enable(h->peripheralPtr);\n    }\n}\n#endif\n\nuint16_T MW_LPUART_GetReadErrorStatus(UART_Type_T *h)\n{\n   uint16_T status = MW_SCI_SUCCESS;   \n    if((h->errorStatus & MW_SCI_RX_BUFFER_FULL) == MW_SCI_RX_BUFFER_FULL) // If buffer is full, show in same step in interrupt mode\n    {\n        status = status |  MW_SCI_RX_BUFFER_FULL;\n        h->errorStatus &= ~MW_SCI_RX_BUFFER_FULL;\n    }\n\n    if(h->disableDMAIntOnError == 0) // If h->disableDMAIntOnError is 0, output the error status if this step itself\n    {\n        status = status | h->errorStatus;\n        h->errorStatus = MW_SCI_SUCCESS;\n    }\n    else if ((h->disableDMAIntOnError == 1) && (getAvailableDataInBuffer(h) == 0) && (h->errorStatus != MW_SCI_SUCCESS)) //Output error status only when last byte (erroneous) is read\n    {\n        status = status | h->errorStatus;\n        h->errorStatus = MW_SCI_SUCCESS;\n        if((h->mode & UART_RX_INTERRUPT_MODE) == UART_RX_INTERRUPT_MODE)\n        {\n            LL_LPUART_ReceiveData8((USART_TypeDef*)h->peripheralPtr);\n            LL_LPUART_ClearFlag_ORE(h->peripheralPtr);\n            LL_LPUART_EnableIT_RXNE(h->peripheralPtr);\n        }\n        else\n        {\n            LL_LPUART_ReceiveData8((USART_TypeDef*)h->peripheralPtr);\n            LL_LPUART_ClearFlag_ORE(h->peripheralPtr);\n            /* Enable DMA */\n            LL_LPUART_EnableDMAReq_RX(h->peripheralPtr);\n        }\n    }\n    return status ;\n}\n\n\n/* Initialize UART module */\nUART_Type_T * MW_LPUART_Initialize(UART_Type_T  * SCIModule)\n{\n    UART_Type_T * mw_usart;\n    switch ((uint32_t)((UART_Type_T *)SCIModule)->peripheralPtr)\n    {\n            #if defined(LPUART1) && defined(MW_LPUART1_ENABLED)\n        case ((uint32_t)LPUART1):\n            mw_usart = &mw_lpuart1;\n            #if defined(MW_LPUART1_RX_DMA_ENABLED) || defined(MW_LPUART1_RXNE_INTERRUPT_ENABLED )|| defined(MW_LPUART1_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(LPUART1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(LPUART1_IRQn);\n            #endif\n            break;\n            #endif\n        default:\n            mw_usart = NULL;\n            break;\n    }\n\tif (mw_usart != NULL)\n\t{\n\t\tmw_usart->enableRxOrTx |=  ((UART_Type_T *)SCIModule)->enableRxOrTx;\n\t\tmw_usart->mode |= ((UART_Type_T *)SCIModule)->mode;\n\t\tmw_usart->peripheralPtr = ((UART_Type_T *)SCIModule)->peripheralPtr;\n\t\tmw_usart->errorStatus = MW_SCI_SUCCESS;\n\t\tmw_usart->uartStatus =  MW_SCI_SUCCESS ;\n\t\tif (UART_ENABLE_RX == (((UART_Type_T *)SCIModule)->enableRxOrTx & UART_ENABLE_RX))\n\t\t{\n\t\t\tmw_usart->buffer.rxBufferSize = ((UART_Type_T *)SCIModule)->buffer.rxBufferSize;\n\t\t\tmw_usart->buffer.rxBufferPtr = ((UART_Type_T *)SCIModule)->buffer.rxBufferPtr;\n\t\t\tmw_usart->buffer.readPos = 0;\n\t\t\tmw_usart->buffer.toReadPos = 0;\n\t\t\tmw_usart->disableDMAIntOnError = ((UART_Type_T *)SCIModule)->disableDMAIntOnError;\n\t\t\tmw_usart->buffer.writeRollOver = 0;\n\t\t\t/* configure for DMA Rx */\n\t\t\tif ((mw_usart->mode & UART_RX_DMA_MODE) == UART_RX_DMA_MODE)\n\t\t\t{\n\t\t\t\tmw_usart->rxdmaPeripheralPtr = (DMA_TypeDef *)((UART_Type_T *)SCIModule)->rxdmaPeripheralPtr;\n\t\t\t\tmw_usart->rxdmastream = ((UART_Type_T *)SCIModule)->rxdmastream;\n\t\t\t\t#if defined(STM32H7)\n                    LPUART_ConfigureReceiveBDMA(mw_usart);\n                #else\n\t\t\t\t\tLPUART_ConfigureReceiveDMA(mw_usart);\n\t\t\t\t#endif\n\t\t\t\tLL_LPUART_EnableIT_ERROR(mw_usart->peripheralPtr);\n\t\t\t\tLL_LPUART_EnableIT_PE(mw_usart->peripheralPtr);\n\t\t\t}\n\t\t\t/*Configure interrupts for Rx with inetrrupts */\n\t\t\telse if ((mw_usart->mode & UART_RX_INTERRUPT_MODE) == UART_RX_INTERRUPT_MODE)\n\t\t\t{\n\t\t\t\tLL_LPUART_EnableIT_RXNE(mw_usart->peripheralPtr);\n\t\t\t}\n\t\t}\n\t\tif (UART_ENABLE_TX == (((UART_Type_T *)SCIModule)->enableRxOrTx & UART_ENABLE_TX))\n\t\t{\n\t\t\tmw_usart->buffer.txBufferSize = ((UART_Type_T *)SCIModule)->buffer.txBufferSize;\n\t\t\tmw_usart->buffer.txBufferPtr = ((UART_Type_T *)SCIModule)->buffer.txBufferPtr;\n\t\t\tmw_usart->buffer.writePos = 0;\n\t\t\tmw_usart->buffer.sentPos = 0;\n\t\t\tmw_usart->txeEnabled = 0;\n\t\t\tmw_usart->txdmaEnabled = 0;\n\t\t\t/* configure for DMA Tx */\n\t\t\tif ((mw_usart->mode & UART_TX_DMA_MODE) == UART_TX_DMA_MODE)\n\t\t\t{\n\t\t\t\tmw_usart->txdmaPeripheralPtr = (DMA_TypeDef *)((UART_Type_T *)SCIModule)->txdmaPeripheralPtr;\n\t\t\t\tmw_usart->txdmastream = ((UART_Type_T *)SCIModule)->txdmastream;\n\t\t\t\tmw_usart->txDMATransferLength = 0;\n\t\t\t\t#ifdef STM32H7\n\t\t\t\t\tLPUART_ConfigureTransmitBDMA(mw_usart);\n\t\t\t\t#else\n\t\t\t\t\tLPUART_ConfigureTransmitDMA(mw_usart);\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t}\n    return mw_usart;\n}\n\n/* Receive the data over UART in Polling mode*/\nMW_SCI_Status_Type MW_LPUART_ReceiveUsingPolling(UART_Type_T * h, void * RxDataPtr, uint32_T RxDataLength, uint32_T * receivedLength, uint32_T timeout)\n{\n    uint8_T *rxData = (uint8_T *)RxDataPtr;\n     *receivedLength = 0;\n    if(MW_SCI_RX_BUSY == (h->uartStatus & MW_SCI_RX_BUSY))\n    {\n        return MW_SCI_RX_BUSY;\n    }\n    else\n    {\n        h->uartStatus |= MW_SCI_RX_BUSY ;\n        uint32_T dataCounter;\n        uint16_T status =    MW_SCI_SUCCESS;\n        uint32_T initialTime = 0;\n\n        for (dataCounter = 0; dataCounter < RxDataLength; dataCounter++)\n        {\n\n            if (0 == LL_LPUART_IsActiveFlag_RXNE((USART_TypeDef*)h->peripheralPtr))\n            {\n                if (timeout > 0)\n                {\n                    initialTime = GET_CURRENT_TIME();\n                    while ((0 == LL_LPUART_IsActiveFlag_RXNE((USART_TypeDef*)h->peripheralPtr)) && (returnTimeElapsed(initialTime, 1) <= (timeout)));\n                    if (returnTimeElapsed(initialTime, 1) > (timeout) )\n                    {\n                        status = status | MW_SCI_DATA_NOT_AVAILABLE ;\n                        h->uartStatus &= ~MW_SCI_RX_BUSY ;\n                        return status;\n                    }\n                }\n                else{\n                    status = status | MW_SCI_DATA_NOT_AVAILABLE ;\n                    h->uartStatus &= ~MW_SCI_RX_BUSY ;\n                    return status;\n                }\n            }\n            if(1 == LL_LPUART_IsActiveFlag_ORE(h->peripheralPtr))\n            {\n                status = status | MW_SCI_ORE_ERROR;\n            }\n            if(1 == LL_LPUART_IsActiveFlag_FE(h->peripheralPtr))\n            {\n                status = status | MW_SCI_FRAME_ERROR;\n            }\n            if(1 == LL_LPUART_IsActiveFlag_NE(h->peripheralPtr))\n            {\n                status = status | MW_SCI_NOISE_ERROR;\n            }\n            if(1 == LL_LPUART_IsActiveFlag_PE(h->peripheralPtr))\n            {\n                status = status | MW_SCI_PARITY_ERROR;\n            }\n            rxData[dataCounter] = LL_LPUART_ReceiveData8((USART_TypeDef*)h->peripheralPtr);\n            if(status != MW_SCI_SUCCESS)\n            {\n                LL_LPUART_ClearFlag_PE(h->peripheralPtr); //Clearing this flag will clear all ORE,NE,FE and PE flags\n            }\n            (*receivedLength)++ ;\n\n        }\n        h->uartStatus &= ~MW_SCI_RX_BUSY ;\n        return status;\n    }\n}\n\n/* Receive the data over UART using DMA/Interrupt and buffer */\nMW_SCI_Status_Type MW_LPUART_ReceiveUsingBuffer(UART_Type_T * h, void * RxDataPtr, uint32_T RxDataLength, uint32_T * receivedLength)\n{\n    *receivedLength = 0;\n    if(MW_SCI_RX_BUSY == (h->uartStatus & MW_SCI_RX_BUSY))\n    {\n        return MW_SCI_RX_BUSY;\n    }\n    else\n    {\n        h->uartStatus |= MW_SCI_RX_BUSY ;\n        MW_SCI_Status_Type status = readDataFromBuffer(h,(uint8_T *)RxDataPtr, RxDataLength, receivedLength);\n        h->uartStatus &= ~MW_SCI_RX_BUSY ;\n        return status ;\n    }\n}\n\n/* Transmit the data over UART in Polling mode*/\nMW_SCI_Status_Type MW_LPUART_TransmitUsingPolling(UART_Type_T * h, void * TxDataPtr, uint32_T TxDataLength, uint32_T timeout, uint32_T *sentDataLength)\n{\n    *sentDataLength = 0;\n    uint8_T * TxData = (uint8_T *)TxDataPtr ;\n    if(MW_SCI_TX_BUSY == (h->uartStatus & MW_SCI_TX_BUSY))\n    {\n        return MW_SCI_TX_BUSY;\n    }\n    else\n    {\n        h->uartStatus |= MW_SCI_TX_BUSY ;\n        uint32_T dataCounter = 0;\n        uint32_T initialTime = 0;\n\n\n        for (dataCounter = 0; dataCounter < TxDataLength; dataCounter++)\n        {\n            if (0 == LL_LPUART_IsActiveFlag_TXE((USART_TypeDef*)h->peripheralPtr))\n            {\n                if (timeout > 0)\n                {\n                    initialTime = GET_CURRENT_TIME();\n                    while ((0 == LL_LPUART_IsActiveFlag_TXE((USART_TypeDef*)h->peripheralPtr)) && (returnTimeElapsed(initialTime, 1) <= (timeout)));\n                    if(returnTimeElapsed(initialTime, 1) > (timeout) )\n                    {\n                        *sentDataLength = dataCounter;\n                        h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                        return MW_SCI_TX_FAILED;\n                    }\n                }\n                else\n                {\n                    *sentDataLength = dataCounter;\n                    h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                    return MW_SCI_TX_FAILED;\n                }\n            }\n            LL_LPUART_TransmitData8((USART_TypeDef*)h->peripheralPtr,TxData[dataCounter]);\n        }\n\n        if (0 == LL_LPUART_IsActiveFlag_TC((USART_TypeDef*)h->peripheralPtr))\n        {\n            if (timeout > 0)\n            {\n                initialTime = GET_CURRENT_TIME();\n                while ((0 == LL_LPUART_IsActiveFlag_TC((USART_TypeDef*)h->peripheralPtr)) &&  (returnTimeElapsed(initialTime, 1) <= (timeout)))\n                    if (returnTimeElapsed(initialTime, 1) > (timeout) )\n                    {\n                        *sentDataLength = (TxDataLength - 1);\n                        h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                        return MW_SCI_TX_FAILED;\n                    }\n            }\n            else\n            {\n                *sentDataLength = (TxDataLength - 1);\n                h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                return MW_SCI_TX_FAILED;\n            }\n        }\n        *sentDataLength = TxDataLength;\n        h->uartStatus &= ~MW_SCI_TX_BUSY ;\n        return MW_SCI_SUCCESS;\n    }\n}\n\n/* Trasmit the data over UART in Interrupt mode*/\nMW_SCI_Status_Type MW_LPUART_TransmitUsingInterrupt(UART_Type_T * h, void * TxDataPtr, uint32_T TxDataLength, uint32_T timeout,uint32_T *sentDataLength)\n{\n    *sentDataLength = 0;\n    if(MW_SCI_TX_BUSY == (h->uartStatus & MW_SCI_TX_BUSY))\n    {\n        return MW_SCI_TX_BUSY;\n    }\n    else\n    {\n        if (TxDataLength > 0)\n        {\n            h->uartStatus |= MW_SCI_TX_BUSY ;\n            if(copyToTransmitBuffer(h,(uint8_T *)TxDataPtr,TxDataLength,timeout) == 1)\n            {\n                h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                return MW_SCI_TX_FAILED ;\n            }\n            if(h->txeEnabled == 0)\n            {\n                LL_LPUART_TransmitData8((USART_TypeDef*)h->peripheralPtr,h->buffer.txBufferPtr[h->buffer.sentPos]);\n                if((h->buffer.sentPos + 1) == h->buffer.txBufferSize)\n                {\n                    h->buffer.sentPos = 0;\n                }\n                else\n                {\n                    h->buffer.sentPos++;\n                }\n\n                if(h->buffer.sentPos != h->buffer.writePos)\n                {\n                    h->txeEnabled = 1;\n                    LL_LPUART_EnableIT_TXE(h->peripheralPtr);\n                }\n            }\n            *sentDataLength = TxDataLength;\n            h->uartStatus &= ~MW_SCI_TX_BUSY ;\n        }\n        return MW_SCI_SUCCESS;\n    }\n}\n\n/* Trasmit the data over UART in DMA mode*/\nMW_SCI_Status_Type MW_LPUART_TransmitUsingDMA(UART_Type_T * h, void * TxDataPtr, uint32_T TxDataLength, uint32_T timeout,uint32_T *sentDataLength)\n{\n    *sentDataLength = 0;\n    if(MW_SCI_TX_BUSY == (h->uartStatus & MW_SCI_TX_BUSY))\n    {\n        return MW_SCI_TX_BUSY;\n    }\n    else\n    {\n        if (TxDataLength > 0)\n        {\n            h->uartStatus |= MW_SCI_TX_BUSY ;\n            uint32_T intialWritePos = h->buffer.writePos ;\n            if(copyToTransmitBuffer(h,(uint8_T *)TxDataPtr,TxDataLength,timeout) == 1)\n            {\n                h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                return MW_SCI_TX_FAILED ;\n            }\n            if(h->txdmaEnabled == 0)\n            {\n                if(h->buffer.writePos < h->buffer.sentPos)\n                {\n                    h->txDMATransferLength = h->buffer.txBufferSize - intialWritePos;\n                }\n                else\n                {\n                    h->txDMATransferLength = TxDataLength ;\n                }\n                h->txdmaEnabled = 1;\n\t\t\t\t#ifdef STM32H7\n\t\t\t\t\tLL_BDMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n                    LL_BDMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                    LL_BDMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream,  h->txDMATransferLength);\n                    #if defined(MW_DCACHE_ENABLED) // Clean cache if enabled before starting DMA\n                    SCB_CleanDCache_by_Addr((uint32_t *)&h->buffer.txBufferPtr[0], h->buffer.txBufferSize);\n                    #endif\n                    LL_BDMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n\t\t\t\t#else\n\t\t\t\t\t#if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n\t\t\t\t\tLL_DMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n\t\t\t\t\t#else\n\t\t\t\t\tLL_DMA_DisableStream(h->txdmaPeripheralPtr, h->txdmastream);\n\t\t\t\t\t#endif\n\t\t\t\t\tLL_DMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n\t\t\t\t\tLL_DMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream,  h->txDMATransferLength);\n                    #if defined(STM32G4) || defined(STM32L5) || defined(STM32WB) || defined(STM32L4) || defined(STM32H5)\n\t\t\t\t\tLL_DMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n\t\t\t\t\t#else\n\t\t\t\t\tLL_DMA_EnableStream(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n            }\n            *sentDataLength = TxDataLength;\n            h->uartStatus &= ~MW_SCI_TX_BUSY ;\n        }\n        return MW_SCI_SUCCESS;\n    }\n\n}\n\n/* Release SCI module */\nvoid MW_LPUART_DeInit(UART_Type_T * h)\n{\n    /* Disable USART */\n    LL_LPUART_Disable(h->peripheralPtr);\n    /*Disable Interrupts and DMA */\n    if (UART_TX_DMA_MODE == (h->mode & UART_TX_DMA_MODE))\n    {\n\t\t#ifdef STM32H7\n\t\t\tLL_BDMA_DisableIT_TC(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n\t\t#else\n\t\t\tLL_DMA_DisableIT_TC(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n\t\t#endif\n        LL_LPUART_DisableDMAReq_TX(h->peripheralPtr);\n    }\n    else if(UART_TX_INTERRUPT_MODE == (h->mode & UART_TX_INTERRUPT_MODE))\n    {\n        LL_LPUART_DisableIT_TXE(h->peripheralPtr);\n    }\n\n    if (UART_RX_DMA_MODE == (h->mode & UART_RX_DMA_MODE))\n    {\n        LL_LPUART_DisableIT_ERROR(h->peripheralPtr);\n        LL_LPUART_DisableIT_PE(h->peripheralPtr);\n\t\t#ifdef STM32H7\n\t\t\t            LL_BDMA_DisableIT_TC(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n\n\t\t#else \n\t\t\tLL_DMA_DisableIT_TC(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n\t\t#endif\n        LL_LPUART_DisableDMAReq_RX(h->peripheralPtr);\n    }\n    else if(UART_RX_INTERRUPT_MODE == (h->mode & UART_RX_INTERRUPT_MODE))\n    {\n        LL_LPUART_DisableIT_RXNE(h->peripheralPtr);\n    }\n}\n\n#endif"},{"name":"stm_usart.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2021-2025 The MathWorks, Inc. */\n\n\n#include \"MW_target_hardware_resources.h\"\n\n#include \"main.h\"\n\n#include \"stm_uart.h\"\n\n\n#include \"string.h\"\n\n#if defined(MW_USART1_ENABLED) || defined(MW_USART2_ENABLED) || defined(MW_USART3_ENABLED) || defined(MW_UART4_ENABLED) || defined(MW_UART5_ENABLED) || defined(MW_USART6_ENABLED) || defined(MW_UART7_ENABLED) || defined(MW_UART8_ENABLED) || defined(MW_UART9_ENABLED) || defined(MW_USART10_ENABLED)\n#define MW_USART_MODULES_ENABLED 1\n#else\n#define MW_USART_MODULES_ENABLED 0\n#endif\n\n#if defined(USART1) && defined(MW_USART1_ENABLED)\nUART_Type_T mw_usart1;\n#if defined(MW_USART1_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART1ReceiveBuffer[MW_USART1_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART1ReceiveBuffer[MW_USART1_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART1ReceiveBuffer[MW_USART1_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART1ReceiveBuffer[MW_USART1_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_USART1_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART1TransmitBuffer[MW_USART1_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART1TransmitBuffer[MW_USART1_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART1TransmitBuffer[MW_USART1_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART1TransmitBuffer[MW_USART1_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(USART2) && defined(MW_USART2_ENABLED)\nUART_Type_T mw_usart2;\n#if defined(MW_USART2_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART2ReceiveBuffer[MW_USART2_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART2ReceiveBuffer[MW_USART2_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART2ReceiveBuffer[MW_USART2_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART2ReceiveBuffer[MW_USART2_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_USART2_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART2TransmitBuffer[MW_USART2_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART2TransmitBuffer[MW_USART2_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART2TransmitBuffer[MW_USART2_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART2TransmitBuffer[MW_USART2_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(USART3) && defined(MW_USART3_ENABLED)\nUART_Type_T mw_usart3;\n#if defined(MW_USART3_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART3ReceiveBuffer[MW_USART3_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART3ReceiveBuffer[MW_USART3_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART3ReceiveBuffer[MW_USART3_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART3ReceiveBuffer[MW_USART3_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_USART3_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART3TransmitBuffer[MW_USART3_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART3TransmitBuffer[MW_USART3_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART3TransmitBuffer[MW_USART3_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART3TransmitBuffer[MW_USART3_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(UART4) && defined(MW_UART4_ENABLED)\nUART_Type_T mw_usart4;\n#if defined(MW_UART4_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART4ReceiveBuffer[MW_UART4_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART4ReceiveBuffer[MW_UART4_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART4ReceiveBuffer[MW_UART4_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART4ReceiveBuffer[MW_UART4_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_UART4_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART4TransmitBuffer[MW_UART4_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART4TransmitBuffer[MW_UART4_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART4TransmitBuffer[MW_UART4_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART4TransmitBuffer[MW_UART4_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(UART5) && defined(MW_UART5_ENABLED)\nUART_Type_T mw_usart5;\n#if defined(MW_UART5_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART5ReceiveBuffer[MW_UART5_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART5ReceiveBuffer[MW_UART5_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART5ReceiveBuffer[MW_UART5_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART5ReceiveBuffer[MW_UART5_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_UART5_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART5TransmitBuffer[MW_UART5_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART5TransmitBuffer[MW_UART5_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART5TransmitBuffer[MW_UART5_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART5TransmitBuffer[MW_UART5_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(USART6) && defined(MW_USART6_ENABLED)\nUART_Type_T mw_usart6;\n#if defined(MW_USART6_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART6ReceiveBuffer[MW_USART6_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART6ReceiveBuffer[MW_USART6_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART6ReceiveBuffer[MW_USART6_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART6ReceiveBuffer[MW_USART6_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_USART6_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART6TransmitBuffer[MW_USART6_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART6TransmitBuffer[MW_USART6_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART6TransmitBuffer[MW_USART6_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART6TransmitBuffer[MW_USART6_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(UART7) && defined(MW_UART7_ENABLED)\nUART_Type_T mw_usart7;\n#if defined(MW_UART7_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART7ReceiveBuffer[MW_UART7_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART7ReceiveBuffer[MW_UART7_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART7ReceiveBuffer[MW_UART7_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART7ReceiveBuffer[MW_UART7_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_UART7_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART7TransmitBuffer[MW_UART7_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART7TransmitBuffer[MW_UART7_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART7TransmitBuffer[MW_UART7_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART7TransmitBuffer[MW_UART7_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(UART8) && defined(MW_UART8_ENABLED)\nUART_Type_T mw_usart8;\n#if defined(MW_UART8_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART8ReceiveBuffer[MW_UART8_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART8ReceiveBuffer[MW_UART8_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART8ReceiveBuffer[MW_UART8_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART8ReceiveBuffer[MW_UART8_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_UART8_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART8TransmitBuffer[MW_UART8_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART8TransmitBuffer[MW_UART8_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART8TransmitBuffer[MW_UART8_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART8TransmitBuffer[MW_UART8_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(UART9) && defined(MW_UART9_ENABLED)\nUART_Type_T mw_usart9;\n#if defined(MW_UART9_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART9ReceiveBuffer[MW_UART9_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART9ReceiveBuffer[MW_UART9_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART9ReceiveBuffer[MW_UART9_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART9ReceiveBuffer[MW_UART9_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_UART9_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T UART9TransmitBuffer[MW_UART9_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T UART9TransmitBuffer[MW_UART9_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T UART9TransmitBuffer[MW_UART9_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T UART9TransmitBuffer[MW_UART9_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n#if defined(USART10) && defined(MW_USART10_ENABLED)\nUART_Type_T mw_usart10;\n#if defined(MW_USART10_RX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART10ReceiveBuffer[MW_USART10_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART10ReceiveBuffer[MW_USART10_RECEIVE_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART10ReceiveBuffer[MW_USART10_RECEIVE_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART10ReceiveBuffer[MW_USART10_RECEIVE_BUFFER_SIZE];\n#endif\n#endif\n\n#if defined(MW_USART10_TX_DMA_ENABLED)\n#ifdef STM32H7\n#if defined(MW_DCACHE_ENABLED)\nuint8_T USART10TransmitBuffer[MW_USART10_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n#else\nuint8_T USART10TransmitBuffer[MW_USART10_TRANSMIT_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n#endif\n#elif defined(MW_DCACHE_ENABLED)\nuint8_T USART10TransmitBuffer[MW_USART10_TRANSMIT_BUFFER_SIZE] __attribute__((aligned (32)));\n#else\nuint8_T USART10TransmitBuffer[MW_USART10_TRANSMIT_BUFFER_SIZE];\n#endif\n#endif\n#endif\n\n/* Buffer functions */\n/* Check if transmit buffer is full */\nboolean_T checkIfTransmitBufferFull(UART_Type_T *h, uint32_T DataLength)\n{\n    uint32_T newWritePos = (h->buffer.writePos + DataLength);\n    return ((( h->buffer.writePos < h->buffer.sentPos) && (newWritePos >= h->buffer.sentPos)) || ((( h->buffer.writePos >= h->buffer.sentPos)) && ((newWritePos >= h->buffer.txBufferSize) && ((newWritePos - h->buffer.txBufferSize) >= h->buffer.sentPos))) );\n}\n\n\n/* Copy data to Transmit internal buffer */\nuint8_T copyToTransmitBuffer(UART_Type_T *h, uint8_T * txData, uint32_T DataLength, uint32_T timeout)\n{\n    if (checkIfTransmitBufferFull(h, DataLength))\n    {\n        if (timeout > 0)\n        {\n            uint32_T initialTime = GET_CURRENT_TIME() ;\n            while (checkIfTransmitBufferFull(h, DataLength) && (returnTimeElapsed(initialTime, 1) <= (timeout)) );\n            if (returnTimeElapsed(initialTime, 1) > (timeout) )\n            {\n                return 1;\n            }\n        }\n        else\n        {\n            return 1;\n        }\n    }\n\n    if (((h->buffer.writePos ) + DataLength) > h->buffer.txBufferSize)\n    {\n        int lengthToWriteFromBottom = (h->buffer.txBufferSize)-(h->buffer.writePos);\n        memcpy(&h->buffer.txBufferPtr[h->buffer.writePos],txData,lengthToWriteFromBottom);\n        h->buffer.writePos = (h->buffer.writePos + DataLength) - h->buffer.txBufferSize;\n        memcpy(&h->buffer.txBufferPtr[0], (txData + lengthToWriteFromBottom),h->buffer.writePos);\n    }\n    else\n    {\n        memcpy(&h->buffer.txBufferPtr[h->buffer.writePos],txData,DataLength);\n        h->buffer.writePos = (h->buffer.writePos + DataLength);\n    }\n    if(h->buffer.writePos == h->buffer.txBufferSize )\n    {\n        h->buffer.writePos = 0;\n    }\n    return 0;\n}\n\n\nuint32_T getAvailableDataInBuffer(UART_Type_T *h)\n{\n    uint32_T nbDataPos;\n    uint32_T availableData;\n    uint32_T dataToBeFilled;\n    boolean_T flag1 = h->buffer.writeRollOver;\n    if (UART_RX_INTERRUPT_MODE == (h->mode & UART_RX_INTERRUPT_MODE))\n    {\n        nbDataPos = h->buffer.toReadPos ;\n    }\n    else\n    {\n        #if defined(STM32H7) && defined(MW_LPUART1_ENABLED)\n        if( LPUART1 == h->peripheralPtr)\n        {\n            dataToBeFilled = LL_BDMA_GetDataLength(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n        }\n        else\n        {\n            #endif\n            #if defined (MW_GPDMA)\n                dataToBeFilled = LL_DMA_GetBlkDataLength(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n            #else\n            dataToBeFilled = LL_DMA_GetDataLength(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n            #endif\n            #if defined(STM32H7) && defined(MW_LPUART1_ENABLED)\n        }\n        #endif\n        nbDataPos = h->buffer.rxBufferSize - dataToBeFilled;\n    }\n    if (nbDataPos == h->buffer.rxBufferSize)\n    {\n        nbDataPos = 0;\n    }\n    /* Update read position to nbDataPos if buffer is overwritten in DMA mode i.e. read data which is not overwritten */\n    if((1 == flag1) && (UART_RX_DMA_MODE == (h->mode & UART_RX_DMA_MODE)))\n    {\n        if(nbDataPos > h->buffer.readPos)\n        {\n            h->errorStatus =  h->errorStatus |  MW_SCI_RX_BUFFER_FULL;\n            h->buffer.readPos = nbDataPos;\n        }\n    }\n    if (nbDataPos > h->buffer.readPos)\n    {\n        /* No rollover condition */\n        availableData = nbDataPos - h->buffer.readPos;\n    }\n    else if  (nbDataPos < h->buffer.readPos)\n    {\n        /* Rollover condition */\n        availableData = (h->buffer.rxBufferSize - (h->buffer.readPos)) + nbDataPos;\n    }\n    else\n    {\n        if(1 == flag1)\n        {\n            availableData = h->buffer.rxBufferSize;\n        }\n        else\n        {\n            availableData = 0;\n        }\n    }\n    return availableData;\n}\n\n/*Wait till timeout and return the number of bytes that can be read from the buffer */\nuint32_T getBytesToBeReadFromBuffer(UART_Type_T *h, uint32_T RxDataLength, uint32_T timeout)\n{\n    uint32_T availableData = 0;\n    uint32_T dataToRead;\n    if((getAvailableDataInBuffer(h) < RxDataLength) && (timeout > 0))\n    {\n        uint32_T initialTime = GET_CURRENT_TIME();\n        while ((getAvailableDataInBuffer(h) < RxDataLength) && (returnTimeElapsed(initialTime, 1) <= (timeout)));\n    }\n\n    availableData = getAvailableDataInBuffer(h);\n    (availableData < RxDataLength) ? (dataToRead = availableData) :(dataToRead = RxDataLength);\n    return dataToRead;\n}\n\n/*Read data from internal receive buffer */\nuint16_T readDataFromBuffer(UART_Type_T *h, uint8_T * RxDataPtr, uint32_T dataToRead, uint32_T * receivedLength)\n{\n    *receivedLength = 0;\n    uint16_T status = MW_SCI_SUCCESS;\n    #if defined(MW_DCACHE_ENABLED) // Invalidate cache if enabled before reading data\n    if (UART_RX_DMA_MODE == (h->mode & UART_RX_DMA_MODE))\n    {\n        SCB_InvalidateDCache_by_Addr((uint32_t *)&h->buffer.rxBufferPtr[0],   h->buffer.rxBufferSize);\n    }\n    #endif\n    /* update read position */\n    if (((h->buffer.readPos ) + dataToRead) > h->buffer.rxBufferSize)\n    {\n        int lengthToReadFromBottom = h->buffer.rxBufferSize-(h->buffer.readPos);\n        memcpy(RxDataPtr,&h->buffer.rxBufferPtr[h->buffer.readPos],lengthToReadFromBottom);\n        h->buffer.readPos = (h->buffer.readPos + dataToRead) - h->buffer.rxBufferSize;\n        memcpy((RxDataPtr + lengthToReadFromBottom),&h->buffer.rxBufferPtr[0],h->buffer.readPos);\n        h->buffer.writeRollOver = 0;\n    }\n    else\n    {\n        memcpy(RxDataPtr,&h->buffer.rxBufferPtr[h->buffer.readPos],dataToRead);\n        h->buffer.readPos+=dataToRead;\n    }\n    if(h->buffer.readPos == h->buffer.rxBufferSize )\n    {\n        h->buffer.readPos = 0;\n        h->buffer.writeRollOver = 0;\n    }\n\n    #if defined(MW_LPUART1_ENABLED)\n    if ((uint32_t)LPUART1 == (uint32_t)h->peripheralPtr)\n    {\n        extern uint16_T MW_LPUART_GetReadErrorStatus(UART_Type_T *h);\n        status = MW_LPUART_GetReadErrorStatus(h);\n    }\n    else\n    {\n        #if MW_USART_MODULES_ENABLED == 1\n        status = getReadErrorStatus(h);\n        #endif\n    }\n    #else\n    status = getReadErrorStatus(h);\n    #endif\n    *receivedLength = dataToRead;\n    return status;\n}\n\n#if MW_USART_MODULES_ENABLED == 1\n\n/* DMA RX Interrupt Handler */\n#if defined (MW_GPDMA)\n    void UART_RXDMAInterruptHandler(UART_Type_T *h ,uint32_t  (*checkActiveFlag)(DMA_TypeDef *DMAx, uint32_t rxdmastream),  void (*clearActiveFlag)(DMA_TypeDef *DMAx, uint32_t rxdmastream))\n#else\nvoid UART_RXDMAInterruptHandler(UART_Type_T *h ,uint32_t  (*checkActiveFlag)(DMA_TypeDef *DMAx),  void (*clearActiveFlag)(DMA_TypeDef *DMAx))\n#endif\n{\n    /* Check transfer-complete interrupt */\n    #if defined (MW_GPDMA)\n    if (LL_DMA_IsEnabledIT_TC(h->rxdmaPeripheralPtr, h->rxdmastream) && (checkActiveFlag(h->rxdmaPeripheralPtr, h->rxdmastream)))\n    #else\n    if (LL_DMA_IsEnabledIT_TC(h->rxdmaPeripheralPtr, h->rxdmastream) && (checkActiveFlag(h->rxdmaPeripheralPtr)))\n    #endif\n        /* Clear transfer complete interrupt flag */\n    {\n            #if defined (MW_GPDMA)\n            clearActiveFlag(h->rxdmaPeripheralPtr, h->rxdmastream);\n        #else\n        clearActiveFlag(h->rxdmaPeripheralPtr);\n        #endif\n        if(h->buffer.writeRollOver == 1)\n        {\n            h->errorStatus =  h->errorStatus |  MW_SCI_RX_BUFFER_FULL;\n            h->buffer.readPos = 0;\n        }\n        h->buffer.writeRollOver = 1;\n\n        /* Start DMA again when DMA mode is Normal */\n\n            #if defined(MW_GPDMA)\n        if (( (h->disableDMAIntOnError == 0) || ((h->disableDMAIntOnError == 1) && ((h->errorStatus == MW_SCI_SUCCESS) || (h->errorStatus == MW_SCI_RX_BUFFER_FULL)))))\n        #else\n        if ((LL_DMA_MODE_NORMAL == LL_DMA_GetMode(h->rxdmaPeripheralPtr, h->rxdmastream)) && ( (h->disableDMAIntOnError == 0) ||\n                                                                                              ((h->disableDMAIntOnError == 1) && ((h->errorStatus == MW_SCI_SUCCESS) || (h->errorStatus == MW_SCI_RX_BUFFER_FULL)))))\n        #endif\n        {\n            #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            LL_DMA_DisableChannel(h->rxdmaPeripheralPtr, h->rxdmastream);\n            #else\n            LL_DMA_DisableStream(h->rxdmaPeripheralPtr, h->rxdmastream);\n            #endif\n            /* Set length to receive */\n                    #if defined (MW_GPDMA)\n                LL_DMA_SetDestAddress(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, (uint32_t)(h->buffer.rxBufferPtr));\n                LL_DMA_SetBlkDataLength(h->rxdmaPeripheralPtr, h->rxdmastream, h->buffer.rxBufferSize);\n            #else\n            LL_DMA_SetDataLength(h->rxdmaPeripheralPtr, h->rxdmastream, h->buffer.rxBufferSize);\n            #endif\n            /* Start DMA again */\n            #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            LL_DMA_EnableChannel(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n            #else\n            LL_DMA_EnableStream(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n            #endif\n        }\n    }\n}\n\n/*DMA TX Interrupt Handler */\n#if defined(MW_GPDMA)\nvoid UART_TXDMAInterruptHandler(UART_Type_T *h ,uint32_t  (*checkActiveFlag)(DMA_TypeDef *DMAx, uint32_t txdmastream),  void (*clearActiveFlag)(DMA_TypeDef *DMAx, uint32_t txdmastream))\n#else\nvoid UART_TXDMAInterruptHandler(UART_Type_T *h ,uint32_t  (*checkActiveFlag)(DMA_TypeDef *DMAx),  void (*clearActiveFlag)(DMA_TypeDef *DMAx))\n#endif\n{\n    /* Check transfer-complete interrupt */\n    #if defined(MW_GPDMA)\n    if (LL_DMA_IsEnabledIT_TC(h->txdmaPeripheralPtr, h->txdmastream) && (checkActiveFlag(h->txdmaPeripheralPtr, h->txdmastream)))\n        /* Clear transfer complete interrupt flag */\n    {\n        clearActiveFlag(h->txdmaPeripheralPtr, h->txdmastream);\n\n    #else\n    if (LL_DMA_IsEnabledIT_TC(h->txdmaPeripheralPtr, h->txdmastream) && (checkActiveFlag(h->txdmaPeripheralPtr)))\n        /* Clear transfer complete interrupt flag */\n    {\n        clearActiveFlag(h->txdmaPeripheralPtr);\n        /* Start DMA again when DMA mode is Normal */\n        if (LL_DMA_MODE_NORMAL == LL_DMA_GetMode(h->txdmaPeripheralPtr, h->txdmastream))\n    #endif\n        {\n            /* Data equal to h->txDMATransferLength has been transmitted so update the h->sentPos */\n            h->buffer.sentPos = h->buffer.sentPos + h->txDMATransferLength;\n            if(h->buffer.sentPos == h->buffer.txBufferSize)\n            {\n                h->buffer.sentPos = 0;\n            }\n            h->txdmaEnabled = 0;\n            /*If buffer not empty, then start the DMA with length equal to length of data in buffer */\n            if(h->buffer.sentPos < h->buffer.writePos)\n            {\n                h->txDMATransferLength = h->buffer.writePos - h->buffer.sentPos;\n                #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_DMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n                #else\n                LL_DMA_DisableStream(h->txdmaPeripheralPtr, h->txdmastream);\n                #endif\n                    #if defined (MW_GPDMA)\n                    LL_DMA_SetSrcAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                    LL_DMA_SetBlkDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #else\n                LL_DMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                LL_DMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #endif\n                #if defined(MW_DCACHE_ENABLED) // Clean cache if enabled before starting DMA\n                SCB_CleanDCache_by_Addr((uint32_t *)&h->buffer.txBufferPtr[0], h->buffer.txBufferSize);\n                #endif\n                #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_DMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #else\n                LL_DMA_EnableStream(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #endif\n                h->txdmaEnabled = 1;\n            }\n            else if(h->buffer.sentPos > h->buffer.writePos)\n            {\n                h->txDMATransferLength = h->buffer.txBufferSize - h->buffer.sentPos;\n                #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_DMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n                #else\n                LL_DMA_DisableStream(h->txdmaPeripheralPtr, h->txdmastream);\n                #endif\n                    #if defined (MW_GPDMA)\n                    LL_DMA_SetSrcAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                    LL_DMA_SetBlkDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #else\n                LL_DMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                LL_DMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #endif\n                #if defined(MW_DCACHE_ENABLED) // Clean cache if enabled before starting DMA\n                SCB_CleanDCache_by_Addr((uint32_t *)&h->buffer.txBufferPtr[0], h->buffer.txBufferSize);\n                #endif\n                #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_DMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #else\n                LL_DMA_EnableStream(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #endif\n                h->txdmaEnabled = 1;\n            }\n        }\n\n    }\n}\n\n\n/* Check if RXNE flag is active */\nuint8_T UART_IsActiveFlagRXNE(UART_Type_T *h)\n{\n    uint8_T ret = (uint8_T)LL_USART_IsActiveFlag_RXNE(h->peripheralPtr) || (uint8_T)LL_USART_IsActiveFlag_ORE(h->peripheralPtr);\n    if(1 == ret)\n    {\n        // Store if any error occurred\n        // Clear RXNE flag by reading the data\n        if((h->buffer.writeRollOver == 1) && (h->buffer.toReadPos == h->buffer.readPos) )\n        {\n            h->buffer.readPos++;\n            if(h->buffer.readPos == h->buffer.rxBufferSize)\n            {\n                h->buffer.readPos = 0;\n            }\n            h->errorStatus =  h->errorStatus |  MW_SCI_RX_BUFFER_FULL;\n        }\n        UART_IsActiveFlagError(h);\n        h->buffer.rxBufferPtr[h->buffer.toReadPos] = LL_USART_ReceiveData8((USART_TypeDef*)h->peripheralPtr) ;\n        //Update the readPos\n        if((h->buffer.toReadPos + 1) == h->buffer.rxBufferSize)\n        {\n            h->buffer.toReadPos  = 0;\n            h->buffer.writeRollOver = 1;\n        }\n        else\n        {\n            h->buffer.toReadPos++;\n        }\n    }\n    return ret;\n}\n\n/*Check if error flag is active */\nvoid UART_IsActiveFlagError(UART_Type_T *h)\n{\n    uint8_T ret = 0;\n\n    if(1 == LL_USART_IsActiveFlag_ORE(h->peripheralPtr))\n    {\n        h->errorStatus = h->errorStatus | MW_SCI_ORE_ERROR;\n        ret = 1;\n    }\n    if(1 == LL_USART_IsActiveFlag_FE(h->peripheralPtr))\n    {\n        h->errorStatus = h->errorStatus | MW_SCI_FRAME_ERROR;\n        ret = 1;\n    }\n    if(1 == LL_USART_IsActiveFlag_NE(h->peripheralPtr))\n    {\n        h->errorStatus = h->errorStatus | MW_SCI_NOISE_ERROR;\n        ret = 1;\n    }\n    if(1 == LL_USART_IsActiveFlag_PE(h->peripheralPtr))\n    {\n        h->errorStatus = h->errorStatus | MW_SCI_PARITY_ERROR;\n        ret = 1;\n    }\n\n    if(ret == 1)\n    {\n        if(h->disableDMAIntOnError == 1)\n        {\n            if((h->mode & UART_RX_INTERRUPT_MODE) == UART_RX_INTERRUPT_MODE)\n            {\n                LL_USART_DisableIT_RXNE(h->peripheralPtr);\n            }\n            else\n            {\n                // LL_DMA_DisableStream(h->rxdmaPeripheralPtr, h->rxdmastream);\n                LL_USART_DisableDMAReq_RX(h->peripheralPtr);\n            }\n        }\n        LL_USART_ClearFlag_PE(h->peripheralPtr); //Clearing this flag will clear all ORE,NE,FE and PE flags\n\n        #if defined(STM32F7) || defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n        LL_USART_ClearFlag_ORE(h->peripheralPtr);\n        LL_USART_ClearFlag_FE(h->peripheralPtr);\n        LL_USART_ClearFlag_NE(h->peripheralPtr);\n        #endif\n    }\n}\n\n/* Check if TXE flag is active*/\nuint8_T UART_IsActiveFlagTXE(UART_Type_T *h)\n{\n    uint8_T ret = (uint8_T)LL_USART_IsActiveFlag_TXE(h->peripheralPtr);\n    if(1 == ret)\n    {\n        /*If buffer is not empty, transmit a byte and update sentPos */\n        if (h->buffer.sentPos != h->buffer.writePos)\n        {\n            LL_USART_TransmitData8((USART_TypeDef*)h->peripheralPtr,h->buffer.txBufferPtr[h->buffer.sentPos]);\n\n            if((h->buffer.sentPos + 1) == h->buffer.txBufferSize)\n            {\n                h->buffer.sentPos = 0;\n            }\n            else\n            {\n                h->buffer.sentPos++;\n            }\n        }\n        else /*Disable TXE interrupt if buffer is empty */\n        {\n            LL_USART_DisableIT_TXE(h->peripheralPtr);\n            h->txeEnabled = 0;\n        }\n    }\n    return ret;\n}\n#if defined(MW_USART1_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART1_TXE_INTERRUPT_ENABLED ) || defined(MW_USART1_RX_DMA_ENABLED)\nvoid USART1_IRQHandler(void)\n{\n    #ifdef MW_USART1_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart1);\n    #endif\n\n    #if defined(MW_USART1_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart1);\n    #endif\n\n    #ifdef MW_USART1_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart1);\n    #endif\n}\n#endif\n\n#if defined(MW_USART2_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART2_TXE_INTERRUPT_ENABLED ) || defined(MW_USART2_RX_DMA_ENABLED)\nvoid USART2_IRQHandler(void)\n{\n    #ifdef MW_USART2_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart2);\n    #endif\n\n    #if defined(MW_USART2_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart2);\n    #endif\n\n    #ifdef MW_USART2_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart2);\n    #endif\n}\n#endif\n\n#if defined(MW_USART3_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART3_TXE_INTERRUPT_ENABLED ) || defined(MW_USART3_RX_DMA_ENABLED)\nvoid USART3_IRQHandler(void)\n{\n    #ifdef MW_USART3_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart3);\n    #endif\n    #if defined(MW_USART3_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart3);\n    #endif\n\n    #ifdef MW_USART3_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart3);\n    #endif\n}\n#endif\n\n#if defined(MW_UART4_RXNE_INTERRUPT_ENABLED ) || defined(MW_UART4_TXE_INTERRUPT_ENABLED ) || defined(MW_UART4_RX_DMA_ENABLED)\nvoid UART4_IRQHandler(void)\n{\n    #ifdef MW_UART4_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart4);\n    #endif\n\n    #if  defined(MW_UART4_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart4);\n    #endif\n\n    #ifdef MW_UART4_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart4);\n    #endif\n}\n#endif\n\n#if defined(MW_UART5_RXNE_INTERRUPT_ENABLED ) || defined(MW_UART5_TXE_INTERRUPT_ENABLED )|| defined(MW_UART5_RX_DMA_ENABLED)\nvoid UART5_IRQHandler(void)\n{\n    #ifdef MW_UART5_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart5);\n    #endif\n\n    #if defined(MW_UART5_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart5);\n    #endif\n\n    #ifdef MW_UART5_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart5);\n    #endif\n}\n#endif\n\n#if defined(MW_USART6_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART6_TXE_INTERRUPT_ENABLED ) || defined(MW_USART6_RX_DMA_ENABLED)\nvoid USART6_IRQHandler(void)\n{\n    #ifdef MW_USART6_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart6);\n    #endif\n\n    #if defined(MW_USART6_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart6);\n    #endif\n\n    #ifdef MW_USART6_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart6);\n    #endif\n}\n#endif\n\n#if defined(MW_UART7_RXNE_INTERRUPT_ENABLED ) || defined(MW_UART7_TXE_INTERRUPT_ENABLED ) || defined(MW_UART7_RX_DMA_ENABLED)\nvoid UART7_IRQHandler(void)\n{\n    #ifdef MW_UART7_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart7);\n    #endif\n\n    #if  defined(MW_UART7_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart7);\n    #endif\n\n    #ifdef MW_UART7_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart7);\n    #endif\n}\n#endif\n\n#if defined(MW_UART8_RXNE_INTERRUPT_ENABLED ) || defined(MW_UART8_TXE_INTERRUPT_ENABLED ) || defined(MW_UART8_RX_DMA_ENABLED)\nvoid UART8_IRQHandler(void)\n{\n    #ifdef MW_UART8_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart8);\n    #endif\n\n    #if  defined(MW_UART8_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart8);\n    #endif\n\n    #ifdef MW_UART8_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart8);\n    #endif\n}\n#endif\n#if defined(MW_UART9_RXNE_INTERRUPT_ENABLED ) || defined(MW_UART9_TXE_INTERRUPT_ENABLED ) || defined(MW_UART9_RX_DMA_ENABLED)\nvoid UART9_IRQHandler(void)\n{\n    #ifdef MW_UART9_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart9);\n    #endif\n\n    #if  defined(MW_UART9_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart9);\n    #endif\n\n    #ifdef MW_UART9_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart9);\n    #endif\n}\n#endif\n\n#if defined(MW_USART10_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART10_TXE_INTERRUPT_ENABLED ) || defined(MW_USART10_RX_DMA_ENABLED)\nvoid USART10_IRQHandler(void)\n{\n    #ifdef MW_USART10_RXNE_INTERRUPT_ENABLED\n    UART_IsActiveFlagRXNE(&mw_usart10);\n    #endif\n\n    #if defined(MW_USART10_RX_DMA_ENABLED)\n    UART_IsActiveFlagError(&mw_usart10);\n    #endif\n\n    #ifdef MW_USART10_TXE_INTERRUPT_ENABLED\n    UART_IsActiveFlagTXE(&mw_usart10);\n    #endif\n}\n#endif\n\n\n\n#ifdef MW_USART1_TX_DMA_ENABLED\nGETIRQ_NAME(MW_USART1_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart1, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART1_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART1_TX_DMA_STREAM));\n\n}\n#endif\n#ifdef MW_USART1_RX_DMA_ENABLED\nGETIRQ_NAME(MW_USART1_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart1, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART1_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART1_RX_DMA_STREAM));\n\n}\n#endif\n#ifdef MW_USART2_TX_DMA_ENABLED\nGETIRQ_NAME(MW_USART2_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart2, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART2_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART2_TX_DMA_STREAM));\n\n}\n#endif\n\n#ifdef MW_USART2_RX_DMA_ENABLED\nGETIRQ_NAME(MW_USART2_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart2, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART2_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART2_RX_DMA_STREAM));\n\n}\n#endif\n\n#ifdef MW_USART3_TX_DMA_ENABLED\nGETIRQ_NAME(MW_USART3_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart3, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART3_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART3_TX_DMA_STREAM));\n\n}\n#endif\n#ifdef MW_USART3_RX_DMA_ENABLED\nGETIRQ_NAME(MW_USART3_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart3, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART3_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART3_RX_DMA_STREAM));\n}\n#endif\n\n\n#ifdef MW_UART4_TX_DMA_ENABLED\nGETIRQ_NAME(MW_UART4_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart4, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART4_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART4_TX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_UART4_RX_DMA_ENABLED\nGETIRQ_NAME(MW_UART4_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart4, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART4_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART4_RX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_UART5_TX_DMA_ENABLED\nGETIRQ_NAME(MW_UART5_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart5, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART5_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART5_TX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_UART5_RX_DMA_ENABLED\nGETIRQ_NAME(MW_UART5_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart5, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART5_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART5_RX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_USART6_TX_DMA_ENABLED\nGETIRQ_NAME(MW_USART6_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart6, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART6_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART6_TX_DMA_STREAM));\n\n}\n#endif\n#ifdef MW_USART6_RX_DMA_ENABLED\nGETIRQ_NAME(MW_USART6_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart6, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART6_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART6_RX_DMA_STREAM));\n\n}\n#endif\n\n#ifdef MW_UART7_TX_DMA_ENABLED\nGETIRQ_NAME(MW_UART7_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart7, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART7_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART7_TX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_UART7_RX_DMA_ENABLED\nGETIRQ_NAME(MW_UART7_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart7, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART7_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART7_RX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_UART8_TX_DMA_ENABLED\nGETIRQ_NAME(MW_UART8_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart8, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART8_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART8_TX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_UART8_RX_DMA_ENABLED\nGETIRQ_NAME(MW_UART8_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart8, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART8_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART8_RX_DMA_STREAM));\n}\n#endif\n#ifdef MW_UART9_TX_DMA_ENABLED\nGETIRQ_NAME(MW_UART9_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart9, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART9_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART9_TX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_UART9_RX_DMA_ENABLED\nGETIRQ_NAME(MW_UART9_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart9, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_UART9_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_UART9_RX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_USART10_TX_DMA_ENABLED\nGETIRQ_NAME(MW_USART10_TX_DMA_ENABLED)\n{\n    UART_TXDMAInterruptHandler(&mw_usart10, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART10_TX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART10_TX_DMA_STREAM));\n}\n#endif\n\n#ifdef MW_USART10_RX_DMA_ENABLED\nGETIRQ_NAME(MW_USART10_RX_DMA_ENABLED)\n{\n    UART_RXDMAInterruptHandler(&mw_usart10, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_USART10_RX_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_USART10_RX_DMA_STREAM));\n}\n#endif\n\n/**************Internal Functions ****************************************************************************/\n\nvoid UART_ConfigureReceiveDMA(UART_Type_T *h)\n{\n        #if defined (MW_GPDMA)\n        LL_DMA_ConfigAddresses(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream,\n                           LL_USART_DMA_GetRegAddr(h->peripheralPtr, LL_USART_DMA_REG_DATA_RECEIVE),\n                           (uint32_t)h->buffer.rxBufferPtr);\n    \n        LL_DMA_SetBlkDataLength(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, h->buffer.rxBufferSize);\n    #else\n    LL_DMA_ConfigAddresses(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream,\n                           #if defined(STM32F7) ||  defined(STM32H7) || defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                           LL_USART_DMA_GetRegAddr(h->peripheralPtr, LL_USART_DMA_REG_DATA_RECEIVE),\n                           #else\n                           LL_USART_DMA_GetRegAddr(h->peripheralPtr),\n                           #endif\n                           (uint32_t)h->buffer.rxBufferPtr,\n                           LL_DMA_DIRECTION_PERIPH_TO_MEMORY);\n    LL_DMA_SetDataLength(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, h->buffer.rxBufferSize);\n    #endif\n    /* Enable TC interrupts */\n    LL_DMA_EnableIT_TC(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n    #if defined(STM32F3)\n    /* Enable Memory increment */\n    LL_DMA_SetMemoryIncMode(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream, LL_DMA_MEMORY_INCREMENT);\n    #endif\n    /* Enable DMA */\n    LL_USART_EnableDMAReq_RX(h->peripheralPtr);\n    ((USART_TypeDef *)h->peripheralPtr)->CR3 |= USART_CR3_DMAR;\n    /* Enable USART and DMA Stream */\n    #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n    LL_DMA_EnableChannel(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n    #else\n    LL_DMA_EnableStream(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n    #endif\n}\n\n/*Configure UART Transmit DMA */\nvoid UART_ConfigureTransmitDMA(UART_Type_T *h)\n{\n        #if defined (MW_GPDMA)\n        LL_DMA_ConfigAddresses(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream,\n                               (uint32_t)h->buffer.txBufferPtr,\n                           LL_USART_DMA_GetRegAddr(h->peripheralPtr, LL_USART_DMA_REG_DATA_TRANSMIT)\n                           );\n    #else\n    LL_DMA_ConfigAddresses(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream,\n                           (uint32_t)h->buffer.txBufferPtr,\n                           #if defined(STM32F7) ||  defined(STM32H7)  || defined(STM32G4) || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32F3)\n                           LL_USART_DMA_GetRegAddr(h->peripheralPtr, LL_USART_DMA_REG_DATA_TRANSMIT),\n                           #else\n                           LL_USART_DMA_GetRegAddr(h->peripheralPtr),\n                           #endif\n                           LL_DMA_DIRECTION_MEMORY_TO_PERIPH);\n    #endif\n    /* Enable  TC interrupts */\n    LL_DMA_EnableIT_TC(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n    /* Enable DMA */\n    LL_USART_EnableDMAReq_TX(h->peripheralPtr);\n}\n\nuint16_T getReadErrorStatus(UART_Type_T *h)\n{\n    uint16_T status = MW_SCI_SUCCESS;\n    if((h->errorStatus & MW_SCI_RX_BUFFER_FULL) == MW_SCI_RX_BUFFER_FULL) // If buffer is full, show in same step in interrupt mode\n    {\n        status = status |  MW_SCI_RX_BUFFER_FULL;\n        h->errorStatus &= ~MW_SCI_RX_BUFFER_FULL;\n    }\n    #if defined(STM32F7) || defined(STM32H7) || defined(STM32G4) || defined(STM32WB) || defined(STM32L4) || defined(STM32F3)\n    if(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(h->peripheralPtr) && LL_USART_IsEnabledAutoBaud(h->peripheralPtr))\n    {\n        if(LL_USART_IsActiveFlag_ABR(h->peripheralPtr) && LL_USART_IsActiveFlag_ABRE(h->peripheralPtr))\n        {\n            status = status |  MW_SCI_ARBE_ERROR;\n            LL_USART_RequestAutoBaudRate(h->peripheralPtr);\n        }\n    }\n    #endif\n    if(h->disableDMAIntOnError == 0) // If h->disableDMAIntOnError is 0, output the error status if this step itself\n    {\n        status = status | h->errorStatus;\n        h->errorStatus = MW_SCI_SUCCESS;\n    }\n    else if ((h->disableDMAIntOnError == 1) && (getAvailableDataInBuffer(h) == 0) && (h->errorStatus != MW_SCI_SUCCESS)) //Output error status only when last byte (erroneous) is read\n    {\n        status = status | h->errorStatus;\n        h->errorStatus = MW_SCI_SUCCESS;\n        if((h->mode & UART_RX_INTERRUPT_MODE) == UART_RX_INTERRUPT_MODE)\n        {\n            LL_USART_ReceiveData8((USART_TypeDef*)h->peripheralPtr);\n            LL_USART_ClearFlag_ORE(h->peripheralPtr);\n            LL_USART_EnableIT_RXNE(h->peripheralPtr);\n        }\n        else\n        {\n            LL_USART_ReceiveData8((USART_TypeDef*)h->peripheralPtr);\n            LL_USART_ClearFlag_ORE(h->peripheralPtr);\n            /* Enable DMA */\n            LL_USART_EnableDMAReq_RX(h->peripheralPtr);\n        }\n    }\n    return status ;\n}\n\n/* Initialize UART module */\nUART_Type_T * MW_UART_Initialize(UART_Type_T  * SCIModule)\n{\n    UART_Type_T * mw_usart;\n    switch ((uint32_t)((UART_Type_T *)SCIModule)->peripheralPtr)\n    {\n    #if defined(USART1) && defined(MW_USART1_ENABLED)\n        case ((uint32_t)USART1):\n            mw_usart = &mw_usart1;\n            break;\n            #endif\n            #if defined(USART2) && defined(MW_USART2_ENABLED)\n        case ((uint32_t)USART2):\n            mw_usart = &mw_usart2;\n            break;\n            #endif\n\n            #if defined(USART3) && defined(MW_USART3_ENABLED)\n        case ((uint32_t)USART3):\n            mw_usart = &mw_usart3;\n            break;\n            #endif\n\n            #if defined(UART4) && defined(MW_UART4_ENABLED)\n        case ((uint32_t)UART4):\n            mw_usart = &mw_usart4;\n            break;\n            #endif\n\n            #if defined(UART5) && defined(MW_UART5_ENABLED)\n        case ((uint32_t)UART5):\n            mw_usart = &mw_usart5;\n            break;\n            #endif\n\n            #if defined(USART6) && defined(MW_USART6_ENABLED)\n        case ((uint32_t)USART6):\n            mw_usart = &mw_usart6;\n            break;\n            #endif\n\n            #if defined(UART7) && defined(MW_UART7_ENABLED)\n        case ((uint32_t)UART7):\n            mw_usart = &mw_usart7;\n            break;\n            #endif\n\n            #if defined(UART8) && defined(MW_UART8_ENABLED)\n        case ((uint32_t)UART8):\n            mw_usart = &mw_usart8;\n            break;\n            #endif\n            #if defined(UART9) && defined(MW_UART9_ENABLED)\n        case ((uint32_t)UART9):\n            mw_usart = &mw_usart9;\n            break;\n            #endif\n\n            #if defined(USART10) && defined(MW_USART10_ENABLED)\n        case ((uint32_t)USART10):\n            mw_usart = &mw_usart10;\n            break;\n            #endif\n\n        default:\n            mw_usart = NULL;\n            break;\n    }\n    if (mw_usart != NULL)\n    {\n        mw_usart->enableRxOrTx |=  ((UART_Type_T *)SCIModule)->enableRxOrTx;\n        mw_usart->mode |= ((UART_Type_T *)SCIModule)->mode;\n        mw_usart->peripheralPtr = ((UART_Type_T *)SCIModule)->peripheralPtr;\n        mw_usart->errorStatus = MW_SCI_SUCCESS;\n        mw_usart->uartStatus =  MW_SCI_SUCCESS ;\n        LL_USART_Disable(mw_usart->peripheralPtr);\n        if (UART_ENABLE_RX == (((UART_Type_T *)SCIModule)->enableRxOrTx & UART_ENABLE_RX))\n        {\n            mw_usart->buffer.rxBufferSize = ((UART_Type_T *)SCIModule)->buffer.rxBufferSize;\n            mw_usart->buffer.rxBufferPtr = ((UART_Type_T *)SCIModule)->buffer.rxBufferPtr;\n            mw_usart->buffer.readPos = 0;\n            mw_usart->buffer.toReadPos = 0;\n            mw_usart->disableDMAIntOnError = ((UART_Type_T *)SCIModule)->disableDMAIntOnError;\n            mw_usart->buffer.writeRollOver = 0;\n            /* configure for DMA Rx */\n            if ((mw_usart->mode & UART_RX_DMA_MODE) == UART_RX_DMA_MODE)\n            {\n                mw_usart->rxdmaPeripheralPtr = (DMA_TypeDef *)((UART_Type_T *)SCIModule)->rxdmaPeripheralPtr;\n                mw_usart->rxdmastream = ((UART_Type_T *)SCIModule)->rxdmastream;\n                UART_ConfigureReceiveDMA(mw_usart);\n                LL_USART_EnableIT_ERROR(mw_usart->peripheralPtr);\n                LL_USART_EnableIT_PE(mw_usart->peripheralPtr);\n            }\n            /*Configure interrupts for Rx with interrupts */\n            else if ((mw_usart->mode & UART_RX_INTERRUPT_MODE) == UART_RX_INTERRUPT_MODE)\n            {\n                LL_USART_EnableIT_RXNE(mw_usart->peripheralPtr);\n            }\n        }\n        if (UART_ENABLE_TX == (((UART_Type_T *)SCIModule)->enableRxOrTx & UART_ENABLE_TX))\n        {\n            mw_usart->buffer.txBufferSize = ((UART_Type_T *)SCIModule)->buffer.txBufferSize;\n            mw_usart->buffer.txBufferPtr = ((UART_Type_T *)SCIModule)->buffer.txBufferPtr;\n            mw_usart->buffer.writePos = 0;\n            mw_usart->buffer.sentPos = 0;\n            mw_usart->txeEnabled = 0;\n            mw_usart->txdmaEnabled = 0;\n            /* configure for DMA Tx */\n            if ((mw_usart->mode & UART_TX_DMA_MODE) == UART_TX_DMA_MODE)\n            {\n                mw_usart->txdmaPeripheralPtr = (DMA_TypeDef *)((UART_Type_T *)SCIModule)->txdmaPeripheralPtr;\n                mw_usart->txdmastream = ((UART_Type_T *)SCIModule)->txdmastream;\n                mw_usart->txDMATransferLength = 0;\n                UART_ConfigureTransmitDMA(mw_usart);\n            }\n        }\n        LL_USART_Enable(mw_usart->peripheralPtr);\n        switch ((uint32_t)((UART_Type_T *)SCIModule)->peripheralPtr)\n    {\n    #if defined(USART1) && defined(MW_USART1_ENABLED)\n        case ((uint32_t)USART1):\n            #if defined(MW_USART1_RX_DMA_ENABLED) || defined(MW_USART1_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART1_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(USART1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(USART1_IRQn);\n            #endif\n            break;\n            #endif\n            #if defined(USART2) && defined(MW_USART2_ENABLED)\n        case ((uint32_t)USART2):\n             \n            #if defined(MW_USART2_RX_DMA_ENABLED) || defined(MW_USART2_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART2_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(USART2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(USART2_IRQn);\n            #endif\n            break;\n            #endif\n\n            #if defined(USART3) && defined(MW_USART3_ENABLED)\n        case ((uint32_t)USART3):\n             \n           #if defined(MW_USART3_RX_DMA_ENABLED) || defined(MW_USART3_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART3_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(USART3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(USART3_IRQn);\n           #endif\n            break;\n            #endif\n\n            #if defined(UART4) && defined(MW_UART4_ENABLED)\n        case ((uint32_t)UART4):\n            \n            #if defined(MW_UART4_RX_DMA_ENABLED) || defined(MW_UART4_RXNE_INTERRUPT_ENABLED ) || defined(MW_UART4_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(UART4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(UART4_IRQn);\n            #endif\n            break;\n            #endif\n\n            #if defined(UART5) && defined(MW_UART5_ENABLED)\n        case ((uint32_t)UART5):\n            \n            #if defined(MW_UART5_RX_DMA_ENABLED) || defined(MW_UART5_RXNE_INTERRUPT_ENABLED ) || defined(MW_UART5_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(UART5_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(UART5_IRQn);\n            #endif\n            break;\n            #endif\n\n            #if defined(USART6) && defined(MW_USART6_ENABLED)\n        case ((uint32_t)USART6):\n            \n            #if defined(MW_USART6_RX_DMA_ENABLED) || defined(MW_USART6_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART6_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(USART6_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(USART6_IRQn);\n            #endif\n            break;\n            #endif\n\n            #if defined(UART7) && defined(MW_UART7_ENABLED)\n        case ((uint32_t)UART7):\n            \n            #if defined(MW_UART7_RX_DMA_ENABLED) || defined(MW_UART7_RXNE_INTERRUPT_ENABLED )|| defined(MW_UART7_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(UART7_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(UART7_IRQn);\n            #endif\n            break;\n            #endif\n\n            #if defined(UART8) && defined(MW_UART8_ENABLED)\n        case ((uint32_t)UART8):\n            \n            #if defined(MW_UART8_RX_DMA_ENABLED) || defined(MW_UART8_RXNE_INTERRUPT_ENABLED )|| defined(MW_UART8_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(UART8_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(UART8_IRQn);\n            #endif\n            break;\n            #endif\n            #if defined(UART9) && defined(MW_UART9_ENABLED)\n        case ((uint32_t)UART9):\n            \n            #if defined(MW_UART9_RX_DMA_ENABLED) || defined(MW_UART9_RXNE_INTERRUPT_ENABLED )|| defined(MW_UART9_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(UART9_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(UART9_IRQn);\n            #endif\n            break;\n            #endif\n\n            #if defined(USART10) && defined(MW_USART10_ENABLED)\n        case ((uint32_t)USART10):\n            \n            #if defined(MW_USART10_RX_DMA_ENABLED) || defined(MW_USART10_RXNE_INTERRUPT_ENABLED ) || defined(MW_USART10_TXE_INTERRUPT_ENABLED )\n            NVIC_SetPriority(USART10_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n            NVIC_EnableIRQ(USART10_IRQn);\n            #endif\n            break;\n            #endif\n\n        default:\n            mw_usart = NULL;\n            break;\n    }\n    }\n    return mw_usart;\n}\n\n/* Receive the data over UART in Polling mode*/\nMW_SCI_Status_Type MW_UART_ReceiveUsingPolling(UART_Type_T * h, void * RxDataPtr, uint32_T RxDataLength, uint32_T * receivedLength, uint32_T timeout)\n{\n    uint8_T *rxData = (uint8_T *)RxDataPtr;\n    *receivedLength = 0;\n    if(MW_SCI_RX_BUSY == (h->uartStatus & MW_SCI_RX_BUSY))\n    {\n        return MW_SCI_RX_BUSY;\n    }\n    else\n    {\n        h->uartStatus |= MW_SCI_RX_BUSY ;\n        uint32_T dataCounter;\n        uint16_T status = MW_SCI_SUCCESS;\n        uint32_T initialTime = 0;\n\n        for (dataCounter = 0; dataCounter < RxDataLength; dataCounter++)\n        {\n\n            if (0 == LL_USART_IsActiveFlag_RXNE((USART_TypeDef*)h->peripheralPtr))\n            {\n                if (timeout > 0)\n                {\n                    initialTime = GET_CURRENT_TIME();\n                    while ((0 == LL_USART_IsActiveFlag_RXNE((USART_TypeDef*)h->peripheralPtr)) && (returnTimeElapsed(initialTime, 1) <= (timeout)));\n                    if (returnTimeElapsed(initialTime, 1) > (timeout) )\n                    {\n                        status = status | MW_SCI_DATA_NOT_AVAILABLE ;\n                        h->uartStatus &= ~MW_SCI_RX_BUSY ;\n                        return status;\n                    }\n                }\n                else{\n                    status = status | MW_SCI_DATA_NOT_AVAILABLE ;\n                    h->uartStatus &= ~MW_SCI_RX_BUSY ;\n                    return status;\n                }\n            }\n\n            #if defined(STM32F7) || defined(STM32H7) || defined(STM32G4) || defined(STM32WB) || defined(STM32L4) || defined(STM32F3)\n            if(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(h->peripheralPtr) && LL_USART_IsEnabledAutoBaud(h->peripheralPtr))\n            {\n                if(LL_USART_IsActiveFlag_ABR(h->peripheralPtr) && LL_USART_IsActiveFlag_ABRE(h->peripheralPtr))\n                {\n                    status = status |  MW_SCI_ARBE_ERROR;\n                    LL_USART_RequestAutoBaudRate(h->peripheralPtr);\n                }\n            }\n            #endif\n            if(1 == LL_USART_IsActiveFlag_ORE(h->peripheralPtr))\n            {\n                status = status | MW_SCI_ORE_ERROR;\n            }\n            if(1 == LL_USART_IsActiveFlag_FE(h->peripheralPtr))\n            {\n                status = status | MW_SCI_FRAME_ERROR;\n            }\n            if(1 == LL_USART_IsActiveFlag_NE(h->peripheralPtr))\n            {\n                status = status | MW_SCI_NOISE_ERROR;\n            }\n            if(1 == LL_USART_IsActiveFlag_PE(h->peripheralPtr))\n            {\n                status = status | MW_SCI_PARITY_ERROR;\n            }\n            rxData[dataCounter] = LL_USART_ReceiveData8((USART_TypeDef*)h->peripheralPtr);\n            if(status != MW_SCI_SUCCESS)\n            {\n                LL_USART_ClearFlag_PE(h->peripheralPtr); //Clearing this flag will clear all ORE,NE,FE and PE flags for STM32F4\n                #if defined(STM32F7) || defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_USART_ClearFlag_ORE(h->peripheralPtr);\n                LL_USART_ClearFlag_FE(h->peripheralPtr);\n                LL_USART_ClearFlag_NE(h->peripheralPtr);\n                #endif\n            }\n            (*receivedLength)++ ;\n\n        }\n        h->uartStatus &= ~MW_SCI_RX_BUSY ;\n        return status;\n    }\n}\n\n/* Receive the data over UART using DMA/Interrupt and buffer */\nMW_SCI_Status_Type MW_UART_ReceiveUsingBuffer(UART_Type_T * h, void * RxDataPtr, uint32_T RxDataLength, uint32_T * receivedLength)\n{\n    *receivedLength = 0;\n    if(MW_SCI_RX_BUSY == (h->uartStatus & MW_SCI_RX_BUSY))\n    {\n        return MW_SCI_RX_BUSY;\n    }\n    else\n    {\n        h->uartStatus |= MW_SCI_RX_BUSY ;\n        MW_SCI_Status_Type status = readDataFromBuffer(h,(uint8_T *)RxDataPtr, RxDataLength, receivedLength);\n        h->uartStatus &= ~MW_SCI_RX_BUSY ;\n        return status ;\n    }\n}\n\n/* Transmit the data over UART in Polling mode*/\nMW_SCI_Status_Type MW_UART_TransmitUsingPolling(UART_Type_T * h, void * TxDataPtr, uint32_T TxDataLength, uint32_T timeout, uint32_T *sentDataLength)\n{\n    *sentDataLength = 0;\n    uint8_T * TxData = (uint8_T *)TxDataPtr ;\n    if(MW_SCI_TX_BUSY == (h->uartStatus & MW_SCI_TX_BUSY))\n    {\n        return MW_SCI_TX_BUSY;\n    }\n    else\n    {\n        h->uartStatus |= MW_SCI_TX_BUSY ;\n        uint32_T dataCounter = 0;\n        uint32_T initialTime = 0;\n\n\n        for (dataCounter = 0; dataCounter < TxDataLength; dataCounter++)\n        {\n            if (0 == LL_USART_IsActiveFlag_TXE((USART_TypeDef*)h->peripheralPtr))\n            {\n                if (timeout > 0)\n                {\n                    initialTime = GET_CURRENT_TIME();\n                    while ((0 == LL_USART_IsActiveFlag_TXE((USART_TypeDef*)h->peripheralPtr)) && (returnTimeElapsed(initialTime, 1) <= (timeout)));\n                    if(returnTimeElapsed(initialTime, 1) > (timeout) )\n                    {\n                        *sentDataLength = dataCounter;\n                        h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                        return MW_SCI_TX_FAILED;\n                    }\n                }\n                else\n                {\n                    *sentDataLength = dataCounter;\n                    h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                    return MW_SCI_TX_FAILED;\n                }\n            }\n            LL_USART_TransmitData8((USART_TypeDef*)h->peripheralPtr,TxData[dataCounter]);\n        }\n\n        if (0 == LL_USART_IsActiveFlag_TC((USART_TypeDef*)h->peripheralPtr))\n        {\n            if (timeout > 0)\n            {\n                initialTime = GET_CURRENT_TIME();\n                while ((0 == LL_USART_IsActiveFlag_TC((USART_TypeDef*)h->peripheralPtr)) &&  (returnTimeElapsed(initialTime, 1) <= (timeout)))\n                    if (returnTimeElapsed(initialTime, 1) > (timeout) )\n                    {\n                        *sentDataLength = (TxDataLength - 1);\n                        h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                        return MW_SCI_TX_FAILED;\n                    }\n            }\n            else\n            {\n                *sentDataLength = (TxDataLength - 1);\n                h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                return MW_SCI_TX_FAILED;\n            }\n        }\n\n        *sentDataLength = TxDataLength;\n        h->uartStatus &= ~MW_SCI_TX_BUSY ;\n        return MW_SCI_SUCCESS;\n    }\n}\n\n/* Transmit the data over UART in Interrupt mode*/\nMW_SCI_Status_Type MW_UART_TransmitUsingInterrupt(UART_Type_T * h, void * TxDataPtr, uint32_T TxDataLength, uint32_T timeout,uint32_T *sentDataLength)\n{\n    *sentDataLength = 0;\n    if(MW_SCI_TX_BUSY == (h->uartStatus & MW_SCI_TX_BUSY))\n    {\n        return MW_SCI_TX_BUSY;\n    }\n    else\n    {\n        if (TxDataLength > 0)\n        {\n            h->uartStatus |= MW_SCI_TX_BUSY ;\n            if(copyToTransmitBuffer(h,(uint8_T *)TxDataPtr,TxDataLength,timeout) == 1)\n            {\n                h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                return MW_SCI_TX_FAILED ;\n            }\n            if(h->txeEnabled == 0)\n            {\n                LL_USART_TransmitData8((USART_TypeDef*)h->peripheralPtr,h->buffer.txBufferPtr[h->buffer.sentPos]);\n                if((h->buffer.sentPos + 1) == h->buffer.txBufferSize)\n                {\n                    h->buffer.sentPos = 0;\n                }\n                else\n                {\n                    h->buffer.sentPos++;\n                }\n\n                if(h->buffer.sentPos != h->buffer.writePos)\n                {\n                    h->txeEnabled = 1;\n                    LL_USART_EnableIT_TXE(h->peripheralPtr);\n                }\n            }\n            *sentDataLength = TxDataLength;\n            h->uartStatus &= ~MW_SCI_TX_BUSY ;\n        }\n        return MW_SCI_SUCCESS;\n    }\n}\n\n\n/* Transmit the data over UART in DMA mode*/\nMW_SCI_Status_Type MW_UART_TransmitUsingDMA(UART_Type_T * h, void * TxDataPtr, uint32_T TxDataLength, uint32_T timeout,uint32_T *sentDataLength)\n{\n    *sentDataLength = 0;\n    if(MW_SCI_TX_BUSY == (h->uartStatus & MW_SCI_TX_BUSY))\n    {\n        return MW_SCI_TX_BUSY;\n    }\n    else\n    {\n        if (TxDataLength > 0)\n        {\n            h->uartStatus |= MW_SCI_TX_BUSY ;\n            uint32_T intialWritePos = h->buffer.writePos ;\n            if(copyToTransmitBuffer(h,(uint8_T *)TxDataPtr,TxDataLength,timeout) == 1)\n            {\n                h->uartStatus &= ~MW_SCI_TX_BUSY ;\n                return MW_SCI_TX_FAILED ;\n            }\n            if(h->txdmaEnabled == 0)\n            {\n                if(h->buffer.writePos < h->buffer.sentPos)\n                {\n                    h->txDMATransferLength = h->buffer.txBufferSize - intialWritePos;\n                }\n                else\n                {\n                    h->txDMATransferLength = TxDataLength ;\n                }\n                h->txdmaEnabled = 1;\n                #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_DMA_DisableChannel(h->txdmaPeripheralPtr, h->txdmastream);\n                #else\n                LL_DMA_DisableStream(h->txdmaPeripheralPtr, h->txdmastream);\n                #endif\n                    #if defined (MW_GPDMA)\n                    LL_DMA_SetSrcAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                    LL_DMA_SetBlkDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, h->txDMATransferLength);\n                #else\n                LL_DMA_SetMemoryAddress(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream, (uint32_t)(h->buffer.txBufferPtr +  h->buffer.sentPos));\n                LL_DMA_SetDataLength(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream,  h->txDMATransferLength);\n                #endif\n                #if defined(MW_DCACHE_ENABLED) // Clean cache if enabled before starting DMA\n                SCB_CleanDCache_by_Addr((uint32_t *)&h->buffer.txBufferPtr[0], h->buffer.txBufferSize);\n                #endif\n                #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_DMA_EnableChannel(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #else\n                LL_DMA_EnableStream(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n                #endif\n            }\n            *sentDataLength = TxDataLength;\n            h->uartStatus &= ~MW_SCI_TX_BUSY ;\n        }\n        return MW_SCI_SUCCESS;\n    }\n\n}\n\n/* Release SCI module */\nvoid MW_UART_DeInit(UART_Type_T * h)\n{\n    /* Disable USART */\n    LL_USART_Disable(h->peripheralPtr);\n    /*Disable Interrupts and DMA */\n    if (UART_TX_DMA_MODE == (h->mode & UART_TX_DMA_MODE))\n    {\n        LL_DMA_DisableIT_TC(h->txdmaPeripheralPtr, (uint32_t)h->txdmastream);\n        LL_USART_DisableDMAReq_TX(h->peripheralPtr);\n    }\n    else if(UART_TX_INTERRUPT_MODE == (h->mode & UART_TX_INTERRUPT_MODE))\n    {\n        LL_USART_DisableIT_TXE(h->peripheralPtr);\n    }\n\n    if (UART_RX_DMA_MODE == (h->mode & UART_RX_DMA_MODE))\n    {\n        LL_USART_DisableIT_ERROR(h->peripheralPtr);\n        LL_USART_DisableIT_PE(h->peripheralPtr);\n        LL_DMA_DisableIT_TC(h->rxdmaPeripheralPtr, (uint32_t)h->rxdmastream);\n        LL_USART_DisableDMAReq_RX(h->peripheralPtr);\n    }\n    else if(UART_RX_INTERRUPT_MODE == (h->mode & UART_RX_INTERRUPT_MODE))\n    {\n        LL_USART_DisableIT_RXNE(h->peripheralPtr);\n    }\n}\n\n#endif\n\n/* LocalWords:  dma nbDataPos RXNE rxdma rxdmastream TXE UART\n*/\n"},{"name":"syscalls.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\STM32CubeIDE\\Application\\User\\Core","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\n ******************************************************************************\n * @file      syscalls.c\n * @author    Auto-generated by STM32CubeIDE\n * @brief     STM32CubeIDE Minimal System calls file\n *\n *            For more information about which c-functions\n *            need which of these lowlevel functions\n *            please consult the Newlib libc-manual\n ******************************************************************************\n * @attention\n *\n * Copyright (c) 2020-2024 STMicroelectronics.\n * All rights reserved.\n *\n * This software is licensed under terms that can be found in the LICENSE file\n * in the root directory of this software component.\n * If no LICENSE file comes with this software, it is provided AS-IS.\n *\n ******************************************************************************\n */\n\n/* Includes */\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdio.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/times.h>\n\n\n/* Variables */\nextern int __io_putchar(int ch) __attribute__((weak));\nextern int __io_getchar(void) __attribute__((weak));\n\n\nchar *__env[1] = { 0 };\nchar **environ = __env;\n\n\n/* Functions */\nvoid initialise_monitor_handles()\n{\n}\n\nint _getpid(void)\n{\n  return 1;\n}\n\nint _kill(int pid, int sig)\n{\n  (void)pid;\n  (void)sig;\n  errno = EINVAL;\n  return -1;\n}\n\nvoid _exit (int status)\n{\n  _kill(status, -1);\n  while (1) {}    /* Make sure we hang here */\n}\n\n__attribute__((weak)) int _read(int file, char *ptr, int len)\n{\n  (void)file;\n  int DataIdx;\n\n  for (DataIdx = 0; DataIdx < len; DataIdx++)\n  {\n    *ptr++ = __io_getchar();\n  }\n\n  return len;\n}\n\n__attribute__((weak)) int _write(int file, char *ptr, int len)\n{\n  (void)file;\n  int DataIdx;\n\n  for (DataIdx = 0; DataIdx < len; DataIdx++)\n  {\n    __io_putchar(*ptr++);\n  }\n  return len;\n}\n\nint _close(int file)\n{\n  (void)file;\n  return -1;\n}\n\n\nint _fstat(int file, struct stat *st)\n{\n  (void)file;\n  st->st_mode = S_IFCHR;\n  return 0;\n}\n\nint _isatty(int file)\n{\n  (void)file;\n  return 1;\n}\n\nint _lseek(int file, int ptr, int dir)\n{\n  (void)file;\n  (void)ptr;\n  (void)dir;\n  return 0;\n}\n\nint _open(char *path, int flags, ...)\n{\n  (void)path;\n  (void)flags;\n  /* Pretend like we always fail */\n  return -1;\n}\n\nint _wait(int *status)\n{\n  (void)status;\n  errno = ECHILD;\n  return -1;\n}\n\nint _unlink(char *name)\n{\n  (void)name;\n  errno = ENOENT;\n  return -1;\n}\n\nint _times(struct tms *buf)\n{\n  (void)buf;\n  return -1;\n}\n\nint _stat(char *file, struct stat *st)\n{\n  (void)file;\n  st->st_mode = S_IFCHR;\n  return 0;\n}\n\nint _link(char *old, char *new)\n{\n  (void)old;\n  (void)new;\n  errno = EMLINK;\n  return -1;\n}\n\nint _fork(void)\n{\n  errno = EAGAIN;\n  return -1;\n}\n\nint _execve(char *name, char **argv, char **env)\n{\n  (void)name;\n  (void)argv;\n  (void)env;\n  errno = ENOMEM;\n  return -1;\n}\n"},{"name":"sysmem.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\STM32CubeIDE\\Application\\User\\Core","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\n ******************************************************************************\n * @file      sysmem.c\n * @author    Generated by STM32CubeIDE\n * @brief     STM32CubeIDE System Memory calls file\n *\n *            For more information about which C functions\n *            need which of these lowlevel functions\n *            please consult the newlib libc manual\n ******************************************************************************\n * @attention\n *\n * Copyright (c) 2024 STMicroelectronics.\n * All rights reserved.\n *\n * This software is licensed under terms that can be found in the LICENSE file\n * in the root directory of this software component.\n * If no LICENSE file comes with this software, it is provided AS-IS.\n *\n ******************************************************************************\n */\n\n/* Includes */\n#include <errno.h>\n#include <stdint.h>\n\n/**\n * Pointer to the current high watermark of the heap usage\n */\nstatic uint8_t *__sbrk_heap_end = NULL;\n\n/**\n * @brief _sbrk() allocates memory to the newlib heap and is used by malloc\n *        and others from the C library\n *\n * @verbatim\n * ############################################################################\n * #  .data  #  .bss  #       newlib heap       #          MSP stack          #\n * #         #        #                         # Reserved by _Min_Stack_Size #\n * ############################################################################\n * ^-- RAM start      ^-- _end                             _estack, RAM end --^\n * @endverbatim\n *\n * This implementation starts allocating at the '_end' linker symbol\n * The '_Min_Stack_Size' linker symbol reserves a memory for the MSP stack\n * The implementation considers '_estack' linker symbol to be RAM end\n * NOTE: If the MSP stack, at any point during execution, grows larger than the\n * reserved size, please increase the '_Min_Stack_Size'.\n *\n * @param incr Memory size\n * @return Pointer to allocated memory\n */\nvoid *_sbrk(ptrdiff_t incr)\n{\n  extern uint8_t _end; /* Symbol defined in the linker script */\n  extern uint8_t _estack; /* Symbol defined in the linker script */\n  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */\n  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;\n  const uint8_t *max_heap = (uint8_t *)stack_limit;\n  uint8_t *prev_heap_end;\n\n  /* Initialize heap end at first call */\n  if (NULL == __sbrk_heap_end)\n  {\n    __sbrk_heap_end = &_end;\n  }\n\n  /* Protect heap from growing into the reserved MSP stack */\n  if (__sbrk_heap_end + incr > max_heap)\n  {\n    errno = ENOMEM;\n    return (void *)-1;\n  }\n\n  prev_heap_end = __sbrk_heap_end;\n  __sbrk_heap_end += incr;\n\n  return (void *)prev_heap_end;\n}\n"},{"name":"system_stm32f7xx.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\3ph_pil\\Core\\Src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/**\r\n  ******************************************************************************\r\n  * @file    system_stm32f7xx.c\r\n  * @author  MCD Application Team\r\n  * @brief   CMSIS Cortex-M7 Device Peripheral Access Layer System Source File.\r\n  *\r\n  *   This file provides two functions and one global variable to be called from \r\n  *   user application:\r\n  *      - SystemInit(): This function is called at startup just after reset and \r\n  *                      before branch to main program. This call is made inside\r\n  *                      the \"startup_stm32f7xx.s\" file.\r\n  *\r\n  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used\r\n  *                                  by the user application to setup the SysTick \r\n  *                                  timer or configure other parameters.\r\n  *                                     \r\n  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must\r\n  *                                 be called whenever the core clock is changed\r\n  *                                 during program execution.\r\n  *\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2016 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/** @addtogroup CMSIS\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup stm32f7xx_system\r\n  * @{\r\n  */  \r\n  \r\n/** @addtogroup STM32F7xx_System_Private_Includes\r\n  * @{\r\n  */\r\n\r\n#include \"stm32f7xx.h\"\r\n\r\n#if !defined  (HSE_VALUE) \r\n  #define HSE_VALUE    ((uint32_t)25000000) /*!< Default value of the External oscillator in Hz */\r\n#endif /* HSE_VALUE */\r\n\r\n#if !defined  (HSI_VALUE)\r\n  #define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz*/\r\n#endif /* HSI_VALUE */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F7xx_System_Private_TypesDefinitions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F7xx_System_Private_Defines\r\n  * @{\r\n  */\r\n\r\n/************************* Miscellaneous Configuration ************************/\r\n\r\n/* Note: Following vector table addresses must be defined in line with linker\r\n         configuration. */\r\n/*!< Uncomment the following line if you need to relocate the vector table\r\n     anywhere in Flash or Sram, else the vector table is kept at the automatic\r\n     remap of boot address selected */\r\n/* #define USER_VECT_TAB_ADDRESS */\r\n\r\n#if defined(USER_VECT_TAB_ADDRESS)\r\n/*!< Uncomment the following line if you need to relocate your vector Table\r\n     in Sram else user remap will be done in Flash. */\r\n/* #define VECT_TAB_SRAM */\r\n#if defined(VECT_TAB_SRAM)\r\n#define VECT_TAB_BASE_ADDRESS   RAMDTCM_BASE    /*!< Vector Table base address field.\r\n                                                     This value must be a multiple of 0x200. */\r\n#define VECT_TAB_OFFSET         0x00000000U     /*!< Vector Table base offset field.\r\n                                                     This value must be a multiple of 0x200. */\r\n#else\r\n#define VECT_TAB_BASE_ADDRESS   FLASH_BASE      /*!< Vector Table base address field.\r\n                                                     This value must be a multiple of 0x200. */\r\n#define VECT_TAB_OFFSET         0x00000000U     /*!< Vector Table base offset field.\r\n                                                     This value must be a multiple of 0x200. */\r\n#endif /* VECT_TAB_SRAM */\r\n#endif /* USER_VECT_TAB_ADDRESS */\r\n/******************************************************************************/\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F7xx_System_Private_Macros\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F7xx_System_Private_Variables\r\n  * @{\r\n  */\r\n\r\n  /* This variable is updated in three ways:\r\n      1) by calling CMSIS function SystemCoreClockUpdate()\r\n      2) by calling HAL API function HAL_RCC_GetHCLKFreq()\r\n      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency \r\n         Note: If you use this function to configure the system clock; then there\r\n               is no need to call the 2 first functions listed above, since SystemCoreClock\r\n               variable is updated automatically.\r\n  */\r\n  uint32_t SystemCoreClock = 16000000;\r\n  const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};\r\n  const uint8_t APBPrescTable[8] = {0, 0, 0, 0, 1, 2, 3, 4};\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F7xx_System_Private_FunctionPrototypes\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F7xx_System_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Setup the microcontroller system\r\n  *         Initialize the Embedded Flash Interface, the PLL and update the \r\n  *         SystemFrequency variable.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid SystemInit(void)\r\n{\r\n  /* FPU settings ------------------------------------------------------------*/\r\n#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)\r\n  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */\r\n#endif\r\n\r\n  /* Configure the Vector Table location -------------------------------------*/\r\n#if defined(USER_VECT_TAB_ADDRESS)\r\n  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */\r\n#endif /* USER_VECT_TAB_ADDRESS */\r\n}\r\n\r\n/**\r\n   * @brief  Update SystemCoreClock variable according to Clock Register Values.\r\n  *         The SystemCoreClock variable contains the core clock (HCLK), it can\r\n  *         be used by the user application to setup the SysTick timer or configure\r\n  *         other parameters.\r\n  *           \r\n  * @note   Each time the core clock (HCLK) changes, this function must be called\r\n  *         to update SystemCoreClock variable value. Otherwise, any configuration\r\n  *         based on this variable will be incorrect.         \r\n  *     \r\n  * @note   - The system frequency computed by this function is not the real \r\n  *           frequency in the chip. It is calculated based on the predefined \r\n  *           constant and the selected clock source:\r\n  *             \r\n  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)\r\n  *                                              \r\n  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)\r\n  *                          \r\n  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) \r\n  *             or HSI_VALUE(*) multiplied/divided by the PLL factors.\r\n  *         \r\n  *         (*) HSI_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value\r\n  *             16 MHz) but the real value may vary depending on the variations\r\n  *             in voltage and temperature.   \r\n  *    \r\n  *         (**) HSE_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value\r\n  *              25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *              frequency of the crystal used. Otherwise, this function may\r\n  *              have wrong result.\r\n  *                \r\n  *         - The result of this function could be not correct when using fractional\r\n  *           value for HSE crystal.\r\n  *     \r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid SystemCoreClockUpdate(void)\r\n{\r\n  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;\r\n  \r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n  tmp = RCC->CFGR & RCC_CFGR_SWS;\r\n\r\n  switch (tmp)\r\n  {\r\n    case 0x00:  /* HSI used as system clock source */\r\n      SystemCoreClock = HSI_VALUE;\r\n      break;\r\n    case 0x04:  /* HSE used as system clock source */\r\n      SystemCoreClock = HSE_VALUE;\r\n      break;\r\n    case 0x08:  /* PLL used as system clock source */\r\n\r\n      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N\r\n         SYSCLK = PLL_VCO / PLL_P\r\n         */    \r\n      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;\r\n      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;\r\n      \r\n      if (pllsource != 0)\r\n      {\r\n        /* HSE used as PLL clock source */\r\n        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);\r\n      }\r\n      else\r\n      {\r\n        /* HSI used as PLL clock source */\r\n        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      \r\n      }\r\n\r\n      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;\r\n      SystemCoreClock = pllvco/pllp;\r\n      break;\r\n    default:\r\n      SystemCoreClock = HSI_VALUE;\r\n      break;\r\n  }\r\n  /* Compute HCLK frequency --------------------------------------------------*/\r\n  /* Get HCLK prescaler */\r\n  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];\r\n  /* HCLK frequency */\r\n  SystemCoreClock >>= tmp;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n  \r\n/**\r\n  * @}\r\n  */    \r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"xil_common.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2011-2022 The MathWorks, Inc. */\n\n/*\n * File: xil_common.h\n *\n * SIL/PIL common definitions\n */\n\n#ifndef __XIL_COMMON_H__\n#define __XIL_COMMON_H__\n\n#include \"rtwtypes.h\"\n\n#include <string.h> /* include definition of size_t */\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n# if defined(__LCC__)\n#   define UNUSED_PARAMETER(x)                                   /* do nothing */\n# else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#   define UNUSED_PARAMETER(x)         (void) (x)\n# endif\n#endif\n\n/* MIN is typically used in data stream implementations */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n#endif\n"},{"name":"xil_data_stream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2007-2022 The MathWorks, Inc. */\n\n#define USE_XILTGTAPPSVC_ERROR\n#define USE_XILTGTAPPSVC_SUCCESS\n#include \"comms_interface.h\"\n#ifndef USING_CS_API    \n#include \"rtiostream.h\"\n#include \"rtiostream_utils.h\"\n#endif\n#include \"xil_data_stream.h\"\n#include \"xil_interface_lib.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n#ifdef USING_CS_API\n    #define XIL_TX_BUFFER_MEMUNIT_SIZE xilTgtAppSvcGetMaxPayloadCapacity()\n    #define BUFFER_HEADER_SIZE 0\n    #define COMMAND_COMPLETE_SIZE (sizeof(MemUnit_T))\n#else\n    #include \"rx_tx_buffer_sizes.h\"\n#endif\n\n#define COMMAND_COMPLETE_IDX 0\n#define WRITE_DATA_BUFFER_IDX (COMMAND_COMPLETE_IDX + COMMAND_COMPLETE_SIZE)\n#define USED_WRITE_BUFFER_SIZE (COMMAND_COMPLETE_SIZE + xilWriteDataAvail)\n#define WRITE_BUFFER_SIZE (XIL_TX_BUFFER_MEMUNIT_SIZE - COMMAND_COMPLETE_SIZE - BUFFER_HEADER_SIZE)\n\n\nstatic void* pBuffer;\nstatic IOUnit_T* xilWriteDataPtr;\nstatic uint16_T xilWriteDataAvail;\nstatic MemUnit_T* commandResponseType;\n\n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetXILWriteBuffer(void) {\n    \n    /* Ask the CS to allocate a buffer that the XIL app service will use for\n     * transmission\n     */\n    IOUnit_T* xilWriteBuffer;\n    if (!xilTgtAppSvcAllocBuffer(&pBuffer, XIL_TX_BUFFER_MEMUNIT_SIZE)) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    xilWriteBuffer = xilTgtAppSvcGetBufferDataPtr(pBuffer);\n    \n    /* set commandResponseType and xilWriteDataPtr pointer */\n    commandResponseType = (MemUnit_T *) &xilWriteBuffer[COMMAND_COMPLETE_IDX];\n    xilWriteDataPtr = &xilWriteBuffer[WRITE_DATA_BUFFER_IDX];\n    \n    /* ready for next command */\n    xilWriteDataAvail = 0;\n    *commandResponseType = XIL_COMMAND_NOT_COMPLETE;\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\nXIL_INTERFACE_LIB_ERROR_CODE silpilInit(void) {\n    \n    /* Create XIL service */\n    if ((boolean_T) xilTgtAppSvcCreate() != XILTGTAPPSVC_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    /* Reset write buffer */\n    return resetXILWriteBuffer();\n}\n\n/* send pending writes */\nstatic XIL_DATA_STREAM_ERROR_CODE sendWriteBuffer(void) {\n       \n    if ((boolean_T) xilTgtAppSvcSend(pBuffer, USED_WRITE_BUFFER_SIZE) == XILTGTAPPSVC_ERROR) {\n        return XIL_DATA_FLUSH_ERROR;\n    }\n    \n   /* reset */\n   if (resetXILWriteBuffer()!= XIL_INTERFACE_LIB_SUCCESS) {\n\t   return XIL_DATA_FLUSH_ERROR;\n   }\n   \n   return XIL_DATA_STREAM_SUCCESS;\n}\n\nXIL_DATA_STREAM_ERROR_CODE xilWriteData(const MemUnit_T * src, uint32_T size) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   const IOUnit_T * srcPtr = (const IOUnit_T *) src;   \n   size_t transferAmount;\n   uint16_T bufferAvail;\n  \n   /* block until all data is processed */\n   while (size > 0) {      \n      /* send if we have a full message worth of data */   \n      if (xilWriteDataAvail == WRITE_BUFFER_SIZE) {\n         errorCode = sendWriteBuffer();\n         if (errorCode != XIL_DATA_STREAM_SUCCESS) {\n            return errorCode;\n         }\n      }\n      bufferAvail = WRITE_BUFFER_SIZE - xilWriteDataAvail;\n      transferAmount = (uint16_T) MIN(bufferAvail, size);\n      /* copy data into write buffer */\n      memcpy((void *) xilWriteDataPtr, srcPtr, transferAmount);\n      size -= (uint32_T) transferAmount;\n      xilWriteDataAvail += (uint16_T) transferAmount;\n      srcPtr += transferAmount;\n      xilWriteDataPtr += transferAmount;\n   }\n   return errorCode;\n}\n\nXIL_DATA_STREAM_ERROR_CODE xilReadData(MemUnit_T * dst, uint32_T size) {\n\n    XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n     \n    static IOUnit_T* currentBufferPosition = NULL;\n    static uint16_T currentBufSize = 0;\n    uint16_T readAmount;\n    int32_T index = 0;\n    int rtIOStreamErrorStatus;\n    IOUnit_T * dstPtr = (IOUnit_T *) dst;\n\n    while (size > 0)\n    {\n        if (currentBufSize > 0) {\n\n            readAmount = (uint16_T) MIN(currentBufSize, size);\n            memcpy(dstPtr+index, currentBufferPosition, (size_t)readAmount);\n\n            currentBufSize -= readAmount;\n            currentBufferPosition +=readAmount;\n            size -= (uint32_T)readAmount;\n\n            if (size == 0) {\n                /* If we've satisfied the data request we're done, return */\n                return errorCode;\n            }\n\n            /*Buffer empty and more data needed get new data*/\n            index += (int32_T)readAmount;\n        }\n\n        /* Get NEW DATA */\n#ifdef USING_CS_API\n        {\n            uint16_T tmpSize = 0;\n            static uint8_T * tmpData;\n            static boolean_T firstTime = true;\n\n            /*If we've previously read a message free it before getting the next*/\n            if (!firstTime)\n            {\n                xilTgtAppSvcFreeLastReceivedData();\n            }\n            \n            /*Block until a message has been received*/\n            while (tmpSize == 0)\n            {\n                tmpData = xilTgtAppSvcGetReceivedData(&tmpSize);\n            }\n\n            /*Update first time flag*/\n            firstTime = false;\n\n            /*Setup buffer position and size from message data*/\n            currentBufSize = tmpSize;\n            currentBufferPosition = (IOUnit_T *)tmpData;\n        }\n#else\n        rtIOStreamErrorStatus = rtiostreamReadMessage(&currentBufferPosition, &currentBufSize);\n\n        if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t    \treturn XIL_READ_DATA_ERROR;\n\n    \n#endif\n    }\n\n    return errorCode;\n}\n\n\n\nXIL_DATA_STREAM_ERROR_CODE xilDataFlush(MemUnit_T isEndOfXILStep) {\n    \n    /* final part of command */\n    if (isEndOfXILStep) {\n        *commandResponseType = XIL_STEP_COMPLETE;\n    } else {\n        *commandResponseType = XIL_COMMAND_COMPLETE;\n    }\n\n    /* send the write buffer */\n    if (sendWriteBuffer() == XIL_DATA_FLUSH_ERROR){\n        return XIL_DATA_FLUSH_ERROR;\n    }\n    \n    return XIL_DATA_STREAM_SUCCESS;\n\n}\n\nvoid silpilTerminate(void) {\n    xilTgtAppSvcDestroy();\n}\n\n\n"},{"name":"xil_data_stream.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2007-2016 The MathWorks, Inc. */\n\n/* \n * File: xil_data_stream.h\n */\n\n#ifndef XIL_DATA_STREAM_H\n#define XIL_DATA_STREAM_H\n\n#include \"xil_common.h\"\n#include \"xil_error_codes.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetXILWriteBuffer(void);\n/* copy specified amount of data from the address specified to the output stream */\nXIL_DATA_STREAM_ERROR_CODE xilWriteData(const MemUnit_T *, uint32_T);\n/* copy specified amount of data from the input stream to address specified */\nXIL_DATA_STREAM_ERROR_CODE xilReadData(MemUnit_T *, uint32_T );\n/* flush any buffered writes */\nXIL_DATA_STREAM_ERROR_CODE xilDataFlush(MemUnit_T isEndOfXILStep);\n/* initialize SIL/PIL service */ \nXIL_INTERFACE_LIB_ERROR_CODE silpilInit(void);\n/* terminate SIL/PIL service */\nvoid silpilTerminate(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_instrumentation.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\pil","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\r\n * File: xil_instrumentation.c\r\n *\r\n * Code generated for instrumentation.\r\n *\r\n */\r\n\r\n#include \"xil_instrumentation.h\"\r\n\r\n/* Code instrumentation offset(s) for model ctrl_ez */\r\n#define taskTimeStart_ctrl_ez_offset   0\r\n#define taskTimeEnd_ctrl_ez_offset     0\r\n\r\n/* A function parameter may be intentionally unused */\r\n#ifndef UNUSED_PARAMETER\r\n# if defined(__LCC__)\r\n#   define UNUSED_PARAMETER(x)\r\n# else\r\n#   define UNUSED_PARAMETER(x)         (void) (x)\r\n# endif\r\n#endif\r\n\r\n#define SIZEOF_TIMER_TYPE              sizeof(uint32_T)\r\n\r\nstatic uint32_T xsd_xil_timer_corrected = 0;\r\nstatic uint32_T xsd_xil_timer_unfreeze = 0;\r\nstatic uint32_T xsd_xil_freezing_busy = 0;\r\nvoid xilUploadProfilingData(uint32_T sectionId)\r\n{\r\n  xilUploadCodeInstrData((void *)(&xsd_xil_timer_corrected), (uint32_T)\r\n    (SIZEOF_TIMER_TYPE), sectionId);\r\n}\r\n\r\n/* The internal freeze and unfreeze methods cannot be nested.\r\n * The customer-visible implementation avoids nesting problems.\r\n * Update the value of the corrected timer to exclude time\r\n * spent in the instrumentation code\r\n */\r\n#define xilProfilingTimerFreezeInternal() { \\\r\n xsd_xil_timer_corrected = xsd_xil_timer_corrected + (((uint32_T)(profileTimerRead())) - xsd_xil_timer_unfreeze); \\\r\n}\r\n#define xilProfilingTimerUnFreezeInternal() { \\\r\n xsd_xil_timer_unfreeze = (uint32_T) (profileTimerRead()); \\\r\n}\r\n\r\nvoid xilProfilingTimerFreeze(void)\r\n{\r\n  if (xsd_xil_freezing_busy == 0) {\r\n    xilProfilingTimerFreezeInternal();\r\n  }                                    /* if */\r\n}\r\n\r\nvoid xilProfilingTimerUnFreeze(void)\r\n{\r\n  if (xsd_xil_freezing_busy == 0) {\r\n    xilProfilingTimerUnFreezeInternal();\r\n  }                                    /* if */\r\n}\r\n\r\n/* Tic/Toc methods for task profiling */\r\n#define taskTimeStart(id)              { \\\r\n xilUploadProfilingData(id); \\\r\n xilProfilingTimerUnFreezeInternal(); \\\r\n}\r\n#define taskTimeEnd(id)                { \\\r\n uint32_T sectionIdNeg = id; \\\r\n sectionIdNeg = ~sectionIdNeg; \\\r\n xilProfilingTimerFreezeInternal(); \\\r\n xilUploadProfilingData(sectionIdNeg); \\\r\n}\r\n\r\n/* Code instrumentation method(s) for model ctrl_ez */\r\nvoid taskTimeStart_ctrl_ez(uint32_T sectionId)\r\n{\r\n  taskTimeStart(taskTimeStart_ctrl_ez_offset + sectionId);\r\n}\r\n\r\nvoid taskTimeEnd_ctrl_ez(uint32_T sectionId)\r\n{\r\n  taskTimeEnd(taskTimeEnd_ctrl_ez_offset + sectionId);\r\n}\r\n"},{"name":"xil_instrumentation.h","type":"header","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\pil","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\r\n * File: xil_instrumentation.h\r\n *\r\n * Code generated for instrumentation.\r\n *\r\n */\r\n\r\n/* Functions with a C call interface */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n#include \"profiler_timer.h\"\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n#include \"rtwtypes.h\"\r\n\r\n/* Upload code instrumentation data point */\r\nvoid xilUploadCodeInstrData(\r\n  void* pData, uint32_T numMemUnits, uint32_T sectionId);\r\n\r\n/* Uploads data */\r\nvoid xilUploadProfilingData(uint32_T sectionId);\r\n\r\n/* Pause/restart the timer while running code associated with storing and uploading the data. */\r\nvoid xilProfilingTimerFreeze(void);\r\nvoid xilProfilingTimerUnFreeze(void);\r\n\r\n/* Code instrumentation method(s) for model ctrl_ez */\r\nvoid taskTimeStart_ctrl_ez(uint32_T sectionId);\r\nvoid taskTimeEnd_ctrl_ez(uint32_T sectionId);\r\n"},{"name":"xil_interface.c","type":"source","group":"SILPIL","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\slprj\\ert\\ctrl_ez\\pil","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\r\n * File: xil_interface.c\r\n *\r\n * PIL generated interface for code: \"ctrl_ez\"\r\n *\r\n */\r\n\r\n#include \"ctrl_ez.h\"\r\n#include \"ctrl_ez_private.h\"\r\n#include \"xil_interface.h\"\r\n#include \"xil_instrumentation.h\"\r\n\r\n/* Functions with a C call interface */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n#include \"xil_data_stream.h\"\r\n#include \"codeinstr_data_stream.h\"\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n/* interface data */\r\nfloat i_ia;\r\n\r\n/* interface data */\r\nfloat i_ib;\r\n\r\n/* interface data */\r\nfloat i_ic;\r\n\r\n/* interface data */\r\nfloat i_ov_out;\r\n\r\n/* interface data */\r\nfloat i_w;\r\n\r\n/* interface data */\r\nfloat i_lock_pll;\r\n\r\n/* interface data */\r\nfloat i_sine;\r\n\r\n/* interface data */\r\nfloat i_cos_p;\r\n\r\n/* interface data */\r\nfloat i_va;\r\n\r\n/* interface data */\r\nfloat i_vc;\r\n\r\n/* interface data */\r\nfloat i_vb;\r\n\r\n/* interface data */\r\nfloat o_o_Qa;\r\n\r\n/* interface data */\r\nfloat o_Qb;\r\n\r\n/* interface data */\r\nfloat o_Qc;\r\n\r\n/* interface data */\r\nbool o_lock;\r\nstatic XILIOData xil_fcnid0_task1_output_u[12];\r\nstatic XILIOData xil_fcnid0_task1_y[5];\r\nstatic XILIOData xil_fcnid0_system_initialize_y[5];\r\n\r\n/* In-the-Loop Interface functions - see xil_interface.h */\r\nXIL_INTERFACE_ERROR_CODE xilProcessParams(uint32_T xilFcnId)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nvoid xilUploadCodeInstrData(void * pData, uint32_T numMemUnits, uint32_T\r\n  sectionId)\r\n{\r\n  /* Send code instrumentation data to host */\r\n  if (codeInstrWriteData((MemUnit_T *) &numMemUnits, sizeof(numMemUnits)) !=\r\n      XIL_DATA_STREAM_SUCCESS) {\r\n    for (;;) ;\r\n  }\r\n\r\n  if (codeInstrWriteData((MemUnit_T *) &sectionId, sizeof(uint32_T)) !=\r\n      XIL_DATA_STREAM_SUCCESS) {\r\n    for (;;) ;\r\n  }\r\n\r\n  if (codeInstrWriteData((MemUnit_T *) pData, numMemUnits) !=\r\n      XIL_DATA_STREAM_SUCCESS) {\r\n    for (;;) ;\r\n  }\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetDataTypeInfo(void)\r\n{\r\n  {\r\n    /* send response id code */\r\n    MemUnit_T memUnitData = XIL_RESPONSE_TYPE_SIZE;\r\n    if (xilWriteData(&memUnitData, sizeof(memUnitData)) !=\r\n        XIL_DATA_STREAM_SUCCESS) {\r\n      return XIL_INTERFACE_COMMS_FAILURE;\r\n    }\r\n\r\n    /* send type id */\r\n    memUnitData = 1;\r\n    if (xilWriteData(&memUnitData, sizeof(memUnitData)) !=\r\n        XIL_DATA_STREAM_SUCCESS) {\r\n      return XIL_INTERFACE_COMMS_FAILURE;\r\n    }\r\n\r\n    /* PIL_FLOAT_SIZE should only be already defined for MathWorks testing */\r\n#ifndef PIL_FLOAT_SIZE\r\n#define PIL_FLOAT_SIZE                 sizeof(float)\r\n#endif\r\n\r\n    /* send size in bytes */\r\n    memUnitData = (MemUnit_T) PIL_FLOAT_SIZE;\r\n\r\n#ifndef HOST_WORD_ADDRESSABLE_TESTING\r\n\r\n    /* convert MemUnits to bytes */\r\n    memUnitData *= MEM_UNIT_BYTES;\r\n\r\n#endif\r\n\r\n    if (xilWriteData(&memUnitData, sizeof(memUnitData)) !=\r\n        XIL_DATA_STREAM_SUCCESS) {\r\n      return XIL_INTERFACE_COMMS_FAILURE;\r\n    }\r\n  }\r\n\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilInitialize(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  {\r\n  }\r\n\r\n  /* initialize output storage owned by In-the-Loop */\r\n  {\r\n    o_o_Qa = 0;\r\n  }\r\n\r\n  {\r\n    o_Qb = 0;\r\n  }\r\n\r\n  {\r\n    o_Qc = 0;\r\n  }\r\n\r\n  {\r\n    o_lock = 0;\r\n  }\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    /* No Function to Call */\r\n    /* Call all Get class methods */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilPause(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  if (xilFcnId == 0) {\r\n    /* Nothing to do */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }                                    /* if */\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilSystemInitialize(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    taskTimeStart_ctrl_ez(1U);\r\n    ctrl_ez_Init(&(o_o_Qa));\r\n    taskTimeEnd_ctrl_ez(1U);\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilSystemReset(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    /* No Function to Call */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetHostToTargetData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  *xilIOData = 0;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }\r\n\r\n  switch (xilCommandType) {\r\n   case XIL_OUTPUT_COMMAND:\r\n    {\r\n      static int initComplete = 0;\r\n      if (!initComplete) {\r\n        uint32_T tableIdx = 0;\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_ia);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_ib);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_ic);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_ov_out);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_w);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_lock_pll);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_sine);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_cos_p);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_va);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_vc);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(i_vb);\r\n          xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        xil_fcnid0_task1_output_u[tableIdx].memUnitLength = 0;\r\n        xil_fcnid0_task1_output_u[tableIdx++].address = (MemUnit_T *) 0;\r\n        initComplete = 1;\r\n      }                                /* if */\r\n\r\n      *xilIOData = &xil_fcnid0_task1_output_u[0];\r\n      break;\r\n    }\r\n\r\n   case XIL_DISABLE_COMMAND:\r\n    {\r\n      errorCode = xilGetHostToTargetData(xilFcnId, XIL_OUTPUT_COMMAND,\r\n        xilCommandIdx, xilIOData);\r\n      return errorCode;\r\n    }\r\n\r\n   default:\r\n    errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n    break;\r\n  }\r\n\r\n  UNUSED_PARAMETER(xilCommandIdx);\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetTargetToHostPreData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData, MemUnit_T responseId, uint32_T serverFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  *xilIOData = 0;\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }                                    /* if */\r\n\r\n  errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n  UNUSED_PARAMETER(xilCommandType);\r\n  UNUSED_PARAMETER(xilCommandIdx);\r\n  UNUSED_PARAMETER(responseId);\r\n  UNUSED_PARAMETER(serverFcnId);\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilOutput(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  switch (xilTID) {\r\n   case 1:\r\n    /* Call all Set class methods */\r\n    taskTimeStart_ctrl_ez(2U);\r\n    ctrl_ez_trigger_ctrl_ez(&(i_ia), &(i_ib), &(i_ic), &(i_ov_out), &(i_w),\r\n      &(i_lock_pll), &(i_sine), &(i_cos_p), &(i_va), &(i_vc), &(i_vb), &(o_o_Qa),\r\n      &(o_Qb), &(o_Qc), &(o_lock));\r\n    taskTimeEnd_ctrl_ez(2U);\r\n\r\n    /* Call all Get class methods */\r\n    break;\r\n\r\n   default:\r\n    return XIL_INTERFACE_UNKNOWN_TID;\r\n  }\r\n\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilUpdate(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  /* No Update Function */\r\n  UNUSED_PARAMETER(xilTID);\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetTargetToHostData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData, MemUnit_T responseId, uint32_T serverFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  *xilIOData = 0;\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }\r\n\r\n  switch (xilCommandType) {\r\n   case XIL_OUTPUT_COMMAND:\r\n    {\r\n      static int initComplete = 0;\r\n      if (!initComplete) {\r\n        uint32_T tableIdx = 0;\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_o_Qa);\r\n          xil_fcnid0_task1_y[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_y[tableIdx++].address = (MemUnit_T *) dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_Qb);\r\n          xil_fcnid0_task1_y[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_y[tableIdx++].address = (MemUnit_T *) dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_Qc);\r\n          xil_fcnid0_task1_y[tableIdx].memUnitLength = 1 * sizeof(float);\r\n          xil_fcnid0_task1_y[tableIdx++].address = (MemUnit_T *) dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_lock);\r\n          xil_fcnid0_task1_y[tableIdx].memUnitLength = 1 * sizeof(bool);\r\n          xil_fcnid0_task1_y[tableIdx++].address = (MemUnit_T *) dataAddress;\r\n        }\r\n\r\n        xil_fcnid0_task1_y[tableIdx].memUnitLength = 0;\r\n        xil_fcnid0_task1_y[tableIdx++].address = (MemUnit_T *) 0;\r\n        initComplete = 1;\r\n      }                                /* if */\r\n\r\n      {\r\n        if (xilWriteData(&responseId, sizeof(responseId)) !=\r\n            XIL_DATA_STREAM_SUCCESS) {\r\n          return XIL_INTERFACE_COMMS_FAILURE;\r\n        }                              /* if */\r\n\r\n        if (responseId == XIL_RESPONSE_CS_REQUEST_SERVICE) {\r\n          if (xilWriteData((MemUnit_T *) &serverFcnId, sizeof(serverFcnId)) !=\r\n              XIL_DATA_STREAM_SUCCESS) {\r\n            return XIL_INTERFACE_COMMS_FAILURE;\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      *xilIOData = &xil_fcnid0_task1_y[0];\r\n      break;\r\n    }\r\n\r\n   case XIL_DISABLE_COMMAND:\r\n    {\r\n      MemUnit_T lResponseId = XIL_RESPONSE_OUTPUT_DATA;\r\n      uint32_T lServerFcnId = 0;\r\n      errorCode = xilGetTargetToHostData(xilFcnId, XIL_OUTPUT_COMMAND,\r\n        xilCommandIdx, xilIOData, lResponseId, lServerFcnId);\r\n      return errorCode;\r\n    }\r\n\r\n   case XIL_SYSTEM_INITIALIZE_COMMAND:\r\n    {\r\n      static int initComplete = 0;\r\n      if (!initComplete) {\r\n        uint32_T tableIdx = 0;\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_o_Qa);\r\n          xil_fcnid0_system_initialize_y[tableIdx].memUnitLength = 1 * sizeof\r\n            (float);\r\n          xil_fcnid0_system_initialize_y[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_Qb);\r\n          xil_fcnid0_system_initialize_y[tableIdx].memUnitLength = 1 * sizeof\r\n            (float);\r\n          xil_fcnid0_system_initialize_y[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_Qc);\r\n          xil_fcnid0_system_initialize_y[tableIdx].memUnitLength = 1 * sizeof\r\n            (float);\r\n          xil_fcnid0_system_initialize_y[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_lock);\r\n          xil_fcnid0_system_initialize_y[tableIdx].memUnitLength = 1 * sizeof\r\n            (bool);\r\n          xil_fcnid0_system_initialize_y[tableIdx++].address = (MemUnit_T *)\r\n            dataAddress;\r\n        }\r\n\r\n        xil_fcnid0_system_initialize_y[tableIdx].memUnitLength = 0;\r\n        xil_fcnid0_system_initialize_y[tableIdx++].address = (MemUnit_T *) 0;\r\n        initComplete = 1;\r\n      }                                /* if */\r\n\r\n      {\r\n        if (xilWriteData(&responseId, sizeof(responseId)) !=\r\n            XIL_DATA_STREAM_SUCCESS) {\r\n          return XIL_INTERFACE_COMMS_FAILURE;\r\n        }                              /* if */\r\n\r\n        if (responseId == XIL_RESPONSE_CS_REQUEST_SERVICE) {\r\n          if (xilWriteData((MemUnit_T *) &serverFcnId, sizeof(serverFcnId)) !=\r\n              XIL_DATA_STREAM_SUCCESS) {\r\n            return XIL_INTERFACE_COMMS_FAILURE;\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      *xilIOData = &xil_fcnid0_system_initialize_y[0];\r\n      break;\r\n    }\r\n\r\n   default:\r\n    errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n    break;\r\n  }\r\n\r\n  UNUSED_PARAMETER(xilCommandIdx);\r\n  UNUSED_PARAMETER(responseId);\r\n  UNUSED_PARAMETER(serverFcnId);\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilTerminate(uint32_T xilFcnId)\r\n{\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }                                    /* if */\r\n\r\n  /* Invoke any terminate Function */\r\n  /* No Function to Call */\r\n\r\n  /* Free Opaque Region Based Data */\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilInitTargetData(void)\r\n{\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilEnable(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  UNUSED_PARAMETER(xilTID);\r\n\r\n  /* No Enable Function - this function should never be called */\r\n  return XIL_INTERFACE_UNKNOWN_TID;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilDisable(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  UNUSED_PARAMETER(xilTID);\r\n\r\n  /* No Disable Function - this function should never be called */\r\n  return XIL_INTERFACE_UNKNOWN_TID;\r\n}\r\n"},{"name":"xil_interface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2019 The MathWorks, Inc. */\n\n/* \n * File: xil_interface.h\n *\n * SIL/PIL interface functions\n */\n\n#ifndef __XIL_INTERFACE_H__\n#define __XIL_INTERFACE_H__\n\n/* include rtwtypes.h & XILIOData */\n#include \"xil_interface_common.h\"\n\n/* Generated xil_interface.c may use xilCommandDispatchAndResponse for client/server */\n#include \"xil_interface_lib.h\"\n\n/* xil_interface.c|cpp always presents a C \n * function-call interface for xil_interface_lib.c */\n#ifdef __cplusplus\nextern \"C\" {  /* sbcheck:ok:extern_c needed to ensure correct linking*/\n#endif\n\n/* Get data type information - called from mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilGetDataTypeInfo(void);\n\n/* Process Parameters - called from mdlProcessParameters / mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilProcessParams(uint32_T);\n\n/* Initialize - called from mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilInitialize(uint32_T);\n\n/* System Initialize - called from mdlSystemInitialize (or mdlInitializeConditions) */\nextern XIL_INTERFACE_ERROR_CODE xilSystemInitialize(uint32_T);\n\n/* System Reset - called from mdlSystemReset */\nextern XIL_INTERFACE_ERROR_CODE xilSystemReset(uint32_T);\n\n/* Initialize input XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetHostToTargetData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **);\n\n/* Output - called from mdlOutputs */\nextern XIL_INTERFACE_ERROR_CODE xilOutput(uint32_T, uint32_T);\n\n/* Update - called from mdlOutputs (not mdlUpdate) */\nextern XIL_INTERFACE_ERROR_CODE xilUpdate(uint32_T, uint32_T);\n\n/* Initialize output XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetTargetToHostData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **, MemUnit_T responseId, uint32_T serverFcnId);\n\n/* Initialize state output XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetTargetToHostPreData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **, MemUnit_T responseId, uint32_T serverFcnId);\n\n/* Initialize complex data objects */\nextern XIL_INTERFACE_ERROR_CODE xilInitTargetData(void);\n\n/* Terminate - called from mdlTerminate */\nextern XIL_INTERFACE_ERROR_CODE xilTerminate(uint32_T);\n\n/* Enable - called from mdlEnable */\nextern XIL_INTERFACE_ERROR_CODE xilEnable(uint32_T, uint32_T);\n\n/* Disable - called from mdlDisable */\nextern XIL_INTERFACE_ERROR_CODE xilDisable(uint32_T, uint32_T);\n\n/* Pause - called from mdlSimStatusChange */\nextern XIL_INTERFACE_ERROR_CODE xilPause(uint32_T);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_interface_common.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2022 The MathWorks, Inc. */\n\n/*\n * File: xil_interface_common.h\n *\n * SIL/PIL common definitions\n */\n\n#ifndef __XIL_INTERFACE_COMMON_H__\n#define __XIL_INTERFACE_COMMON_H__\n\n#include \"xil_common.h\"\n\n/* define some error codes */\ntypedef enum {XIL_INTERFACE_SUCCESS=0, \n              XIL_INTERFACE_UNKNOWN_TID,\n              XIL_INTERFACE_UNKNOWN_FCNID,\n              XIL_INTERFACE_COMMS_FAILURE,\n              XIL_INTERFACE_MEMORY_ALLOCATION_ERROR,\n              XIL_INTERFACE_OFFLOADED_PROCESSING} XIL_INTERFACE_ERROR_CODE;\n\ntypedef enum {XIL_PROCESSDATA_SUCCESS=0, \n              XIL_PROCESSDATA_DATA_STREAM_ERROR, \n              XIL_PROCESSDATA_IO_TYPE_ERROR} XIL_PROCESSDATA_ERROR_CODE;\n\ntypedef enum {XIL_INIT_COMMAND = 0, \n              XIL_INITIALIZE_COMMAND,\n              XIL_SYSTEM_INITIALIZE_COMMAND,\n              XIL_OUTPUT_COMMAND, \n              XIL_TERMINATE_COMMAND, \n              XIL_ENABLE_COMMAND,\n              XIL_DISABLE_COMMAND, \n              XIL_CONST_OUTPUT_COMMAND, \n              XIL_PROCESS_PARAMS_COMMAND,\n              XIL_CLIENT_SERVER_COMMAND,\n              XIL_SHUTDOWN_COMMAND,\n              XIL_UPDATE_COMMAND,\n              XIL_SYSTEM_RESET_COMMAND,\n              XIL_PAUSE_COMMAND} XIL_COMMAND_TYPE_ENUM;\n\n/* define response ids */\ntypedef enum {XIL_RESPONSE_ERROR=0, \n              XIL_RESPONSE_OUTPUT_PRE_DATA,\n              XIL_RESPONSE_OUTPUT_DATA,              \n              XIL_RESPONSE_PRINTF,\n              XIL_RESPONSE_FOPEN,\n              XIL_RESPONSE_FPRINTF,\n              XIL_RESPONSE_SIGNAL_RAISED,\n              XIL_RESPONSE_EXCEPTION,\n              XIL_RESPONSE_TYPE_SIZE,\n              XIL_RESPONSE_CS_REQUEST_SERVICE              \n              } XIL_RESPONSE_ID;\n\n/* define receive states */\ntypedef enum {XIL_INVALID_STATE=-1,\n              XIL_READ_COMMAND_CODE,\n              XIL_READ_FCNID,\n              XIL_READ_XILTID,\n              XIL_PROCESS_TARGET_TO_HOST_PRE_DATA,\n              XIL_PROCESS_HOST_TO_TARGET_DATA,\n              XIL_CALL_XILINTERFACE,\n              XIL_PROCESS_TARGET_TO_HOST_DATA,\n              XIL_COMPLETE} XIL_HANDLE_RECV_STATE;\n\n/* Defines what states we need to save to make xilProcessMsg re-entrant. \n * This is used by client/server commands which could happen in the middle \n * of a step */\ntypedef struct xilProcessMsgContextSwitch {\n\tXIL_HANDLE_RECV_STATE state;\n\tXIL_COMMAND_TYPE_ENUM command;\n\tuint32_T commandIdx;\n\tuint32_T fcnId;\n} XIL_PROCESS_MSG_CONTEXT_SWITCH;\n\n/* XILIOData is defined as a start address\n * and length in MemUnits */\ntypedef struct xilIOData {\n   uint32_T memUnitLength;\n   MemUnit_T * address;\n} XILIOData;\n\n#endif\n"},{"name":"xil_interface_lib.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2019 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib.c\n *\n * SIL/PIL support library\n *\n */\n\n#include \"xil_interface_lib.h\"\n#include \"xil_interface_lib_private.h\"\n#include \"xil_data_stream.h\"\n#include \"codeinstr_data_stream.h\"\n#include \"xil_interface.h\"\n#include \"coder_assumptions_app.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n#ifdef LDRA_ENABLED\n#include \"code_coverage_utils.h\"\n#endif /* LDRA_ENABLED */\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    void swapBytes(MemUnit_T * const buffer, uint32_T size);\n    static XIL_DATA_STREAM_ERROR_CODE xilReadDataAndSwapBytes(MemUnit_T * dst, uint32_T size);\n#endif /* HOST_BIG_ENDIAN_PROTOCOL_TESTING */\n\n/* Internal state variable holding information about the\n * XILIOData currently being processed. \n *\n * Note: this variable is shared by UDATA processing code\n * and YDATA processing code and used for all IO.\n *\n */\nstatic XILIOData * xilIODataPtr;\nstatic int isShutdownCommand = 0;\nstatic int processMsgSuccess = 1;\n\n/* xilProcessMsg current context (cc)*/\nstatic XIL_PROCESS_MSG_CONTEXT_SWITCH cc = {XIL_READ_COMMAND_CODE, XIL_INIT_COMMAND, 0, 0};\n\n/* static functions */\nstatic void restoreProcessMsgContext(XIL_PROCESS_MSG_CONTEXT_SWITCH cachedCtx) {\n    cc.state      = cachedCtx.state;\n    cc.command    = cachedCtx.command;\n    cc.commandIdx = cachedCtx.commandIdx;\n    cc.fcnId      = cachedCtx.fcnId;\n}\n\nstatic void getNextXILIOData(void) {\n   /* increment xilIOData ptr if we have not reached the end */\n   if (xilIODataPtr->memUnitLength!=0) {\n      xilIODataPtr++;\n   }\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processHostToTargetData(uint32_T fcnId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx)  {\n    \n    /* this function receives some arbitrary data size that needs to be \n     * into the appropriate memory addresses. Since it is not guaranteed \n     * that we will copy all the required data in one go, we need to keep \n     * track of which address (and size) in xilIODataPtr we last copied \n     * to so we can continue copying the remaining data the next time we \n     * receive them.\n     */\n    static MemUnit_T * uDataAddress = NULL;\n    static uint32_T uDataLength = 0;\n    int processingComplete = 0;\n        \n\t/* initialize uDataAddress and uDataLength if necessary*/\n    if (uDataAddress == NULL) {\n\t\t/* initialise xilIODataPtr before beginning to process data */\n\t\tif (xilGetHostToTargetData(fcnId, command, commandIdx, &xilIODataPtr)) {\n\t\t\t/* no udata processing to be done - we're complete */\n\t\t\tprocessingComplete = 1;\t\t\t\n\t\t\treturn XIL_PROCESSDATA_SUCCESS;\n\t\t}\n\n        uDataAddress = xilIODataPtr->address;\n        uDataLength = xilIODataPtr->memUnitLength;\n    }\n    \n    while(!(processingComplete)) {\n        xilReadData(uDataAddress, uDataLength);\n        getNextXILIOData();\n            \n        if (xilIODataPtr->memUnitLength == 0) {\n            /* done processing all xilIOData */                \n            processingComplete = 1;\n            uDataAddress = NULL;\n        } else {\n            /* reset our pointer to next xilIOData */\n            uDataAddress = xilIODataPtr->address;\n            uDataLength = xilIODataPtr->memUnitLength;\n        }\n    }\n\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processTargetToHostData(uint32_T fcnId,\n        MemUnit_T responseId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx,\n        uint32_T serverFcnId)  {\n        \n    int moreXILData = 1;\n    \n    /* initialise before beginning to process data */    \n    if (xilGetTargetToHostData(fcnId, command, commandIdx, &xilIODataPtr, responseId, serverFcnId)) {\n        /* no ydata processing to be done - we're complete */        \n        return XIL_PROCESSDATA_SUCCESS;\n    }\n\n    while(moreXILData) {\n        if (xilWriteData(xilIODataPtr->address, xilIODataPtr->memUnitLength) != XIL_DATA_STREAM_SUCCESS) {            \n            return XIL_PROCESSDATA_DATA_STREAM_ERROR;\n        }\n        /* get next xilIOData */\n        getNextXILIOData();\n        if (xilIODataPtr->memUnitLength == 0) {\n            moreXILData = 0;\n        }\n    }\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processTargetToHostPreData(uint32_T fcnId,\n        MemUnit_T responseId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx)  {\n        \n    int moreXILData = 1;\n    uint32_T serverFcnId = 0; /*Default server function ID*/\n    \n    /* initialise before beginning to process data */    \n    if (xilGetTargetToHostPreData(fcnId, command, commandIdx, &xilIODataPtr, responseId, serverFcnId)) {\n        /* no ydata processing to be done - we're complete */        \n        return XIL_PROCESSDATA_SUCCESS;\n    }\n    \n    while(moreXILData) {\n        if (xilWriteData(xilIODataPtr->address, xilIODataPtr->memUnitLength) != XIL_DATA_STREAM_SUCCESS) {            \n            return XIL_PROCESSDATA_DATA_STREAM_ERROR;\n        }\n        /* get next xilIOData */\n        getNextXILIOData();\n        if (xilIODataPtr->memUnitLength == 0) {\n            moreXILData = 0;\n        }\n    }\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_INTERFACE_LIB_ERROR_CODE finalizeCommandResponse(XIL_RESPONSE_ERROR_ID errorId, MemUnit_T isEndOfXILStep)  {\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n    /* flush the output stream\n     * before beginning next command */\n    if (codeInstrDataFlush() != XIL_DATA_STREAM_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n\n   /* only send the error id if necessary */\n   if (errorId != XIL_RESPONSE_ERROR_SUCCESS) {\n      /* send response id code */\n      MemUnit_T memUnitData = XIL_RESPONSE_ERROR;\n      if (xilWriteData(&memUnitData, sizeof(memUnitData)) != XIL_DATA_STREAM_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;      \n      }\n      /* send error id */\n\t  memUnitData = (MemUnit_T) errorId;\n      if (xilWriteData(&memUnitData, sizeof(memUnitData)) != XIL_DATA_STREAM_SUCCESS) {\n         return XIL_INTERFACE_LIB_ERROR;      \n      }\t  \n   }\n   /* flush the output stream \n    * before beginning next command */\n   if (xilDataFlush(isEndOfXILStep) != XIL_DATA_STREAM_SUCCESS) {\n      return XIL_INTERFACE_LIB_ERROR;      \n   }   \n   return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* Given current state and command, compute the next state for handleReceive */\nstatic XIL_HANDLE_RECV_STATE computeNextState(XIL_HANDLE_RECV_STATE state, XIL_COMMAND_TYPE_ENUM command) {\n    \n    XIL_HANDLE_RECV_STATE nextState;\n    \n    switch(state) {\n        case XIL_READ_COMMAND_CODE:\n            switch(command) {\n                case XIL_INIT_COMMAND:                    \n                case XIL_CONST_OUTPUT_COMMAND:\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_READ_FCNID;\n                    break;\n                case XIL_SHUTDOWN_COMMAND:\n                    nextState = XIL_READ_FCNID;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_READ_FCNID:\n            switch(command) {\n                case XIL_INIT_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                case XIL_CONST_OUTPUT_COMMAND:\n                    nextState = XIL_PROCESS_TARGET_TO_HOST_DATA;\n                    break;\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                    nextState = XIL_PROCESS_HOST_TO_TARGET_DATA;\n                    break;\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:  \n                case XIL_UPDATE_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_READ_XILTID;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;            \n        case XIL_READ_XILTID:\n            switch(command) {\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                    nextState = XIL_PROCESS_HOST_TO_TARGET_DATA;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_HOST_TO_TARGET_DATA:\n            switch(command) {\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:                \n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_PROCESS_TARGET_TO_HOST_PRE_DATA;\n                    break;\n                case XIL_CLIENT_SERVER_COMMAND:\n                    nextState = XIL_COMPLETE;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_TARGET_TO_HOST_PRE_DATA:\n            switch(command) {\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_CALL_XILINTERFACE:\n            switch(command) {\n                case XIL_UPDATE_COMMAND:\n                case XIL_INIT_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                    nextState = XIL_COMPLETE;\n                    break;\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_CONST_OUTPUT_COMMAND:\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:                \n                case XIL_OUTPUT_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                case XIL_TERMINATE_COMMAND:   \n                    nextState = XIL_PROCESS_TARGET_TO_HOST_DATA;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_TARGET_TO_HOST_DATA:\n            /* done */\n            nextState = XIL_COMPLETE;\n            break;\n        default:\n            nextState = XIL_INVALID_STATE;\n            break;\n    }\n    return nextState;\n}\n\n#define XIL_COMMAND_TYPE_SIZE sizeof(MemUnit_T)\n#define XIL_COMMAND_CODE_IDX 0\n#define XIL_COMMAND_FCNID_IDX (XIL_COMMAND_CODE_IDX + XIL_COMMAND_TYPE_SIZE)\n#define XIL_COMMAND_FCNID_SIZE sizeof(uint32_T)\n#define XIL_COMMAND_XILTID_IDX (XIL_COMMAND_FCNID_IDX + XIL_COMMAND_FCNID_SIZE)\n#define XIL_COMMAND_XILTID_SIZE sizeof(uint32_T)\n#define XIL_COMMAND_ERROR_STATUS_SIZE sizeof(MemUnit_T)\n\n#define XIL_RUN_EXIT_ERROR processMsgSuccess = 0;      \\\n                           return\n#define XIL_RUN_EXIT return\n\n#define XIL_EXIT_ERROR_IF_INVALID_STATE if (cc.state == XIL_INVALID_STATE) {      \\\n                                         XIL_RUN_EXIT_ERROR;                   \\\n                                      }                                                                                           \n\nstatic void xilReadCommandCode(void) {\n    MemUnit_T commandCode;    \n    if (cc.state==XIL_READ_COMMAND_CODE) {\n        /* read commandCode */\n\n        xilReadData(&(commandCode), XIL_COMMAND_TYPE_SIZE);\n\n        /* cast from the MemUnit commandCode to the enumeration commandCode */\n        cc.command = (XIL_COMMAND_TYPE_ENUM) commandCode;\n            \n        if (cc.command == XIL_SHUTDOWN_COMMAND) {\n\t\t\t/* Terminate this process when XIL simulation is complete */\n            isShutdownCommand = 1;             \n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_TERMINATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        } else {\n            /* compute next state */\n            cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n        }\n    }\n}\n                           \nvoid xilProcessMsg(void) { \n    /* read commandCode */\n    xilReadCommandCode();\n    \n    if (cc.state==XIL_READ_FCNID) {\n        /* read fcnId */\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n        xilReadDataAndSwapBytes(((MemUnit_T*)&(cc.fcnId)), XIL_COMMAND_FCNID_SIZE);\n#else\n        xilReadData(((MemUnit_T*)&(cc.fcnId)), XIL_COMMAND_FCNID_SIZE);\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n        \n\n            \n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n        \n        \n    if (cc.state==XIL_READ_XILTID) {\n        /* read commandIdx */\n        \n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n        xilReadDataAndSwapBytes(((MemUnit_T*)&(cc.commandIdx)), XIL_COMMAND_XILTID_SIZE);\n#else\n        xilReadData(((MemUnit_T*)&(cc.commandIdx)), XIL_COMMAND_XILTID_SIZE);\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n        \n    if (cc.state == XIL_PROCESS_HOST_TO_TARGET_DATA) {\n        /* process inputs if required by command */\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        /* process data from host */\n        processDataError = processHostToTargetData(cc.fcnId, cc.command, cc.commandIdx);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_UDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n            \n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE\n    }\n        \n    if (cc.state == XIL_PROCESS_TARGET_TO_HOST_PRE_DATA) {\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        /* process data from target */\n        processDataError = processTargetToHostPreData(cc.fcnId, XIL_RESPONSE_OUTPUT_PRE_DATA, cc.command, cc.commandIdx);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_YDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n\n    if (cc.state == XIL_CALL_XILINTERFACE) {\n        /* call xilInterface function */\n        switch(cc.command) {\n#ifndef OUT_OF_PROCESS_EXEC\n            case XIL_INIT_COMMAND:\n            {\n#if CODER_ASSUMPTIONS_ENABLED == 1\n                /* run validation of coder assumptions */\n                if (coderAssumptionsRun() != XIL_INTERFACE_LIB_SUCCESS) {\n                    XIL_RUN_EXIT_ERROR;\n                } \n#endif\n                if (xilGetDataTypeInfo() != XIL_INTERFACE_SUCCESS) {\n                    XIL_RUN_EXIT_ERROR;\n                }\n                if (xilInitTargetData() != XIL_INTERFACE_SUCCESS) {\n                    XIL_RUN_EXIT_ERROR;\n                }\n                break;\n            }\n            case XIL_CONST_OUTPUT_COMMAND:\n                /* no function */\n                break;\n            case XIL_PROCESS_PARAMS_COMMAND:\n                if (xilProcessParams(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_PARAMS, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_INITIALIZE_COMMAND:\n                if (xilInitialize(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_PAUSE_COMMAND:\n                if (xilPause(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_SYSTEM_INITIALIZE_COMMAND:\n                if (xilSystemInitialize(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SYSTEM_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_TERMINATE_COMMAND:\n                if (xilTerminate(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_TERMINATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_ENABLE_COMMAND:\n                if (xilEnable(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_ENABLE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_DISABLE_COMMAND:\n                if (xilDisable(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_DISABLE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_UPDATE_COMMAND:\n                if (xilUpdate(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_UPDATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    } else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n#endif\n            case XIL_OUTPUT_COMMAND:\n                if (xilOutput(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_OUTPUT, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n#ifndef OUT_OF_PROCESS_EXEC\n            case XIL_SYSTEM_RESET_COMMAND:\n                if (xilSystemReset(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SYSTEM_RESET, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }                     \n                break;\n#endif\n            default:\n                XIL_RUN_EXIT_ERROR;\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n    if (cc.state == XIL_PROCESS_TARGET_TO_HOST_DATA) {\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        uint32_T serverFcnId = 0; /* Default server function ID */\n        /* process data from target */\n        processDataError = processTargetToHostData(cc.fcnId, XIL_RESPONSE_OUTPUT_DATA, cc.command, cc.commandIdx, serverFcnId);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_YDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n        /*break;*/\n    }\n        \n\n#ifdef LDRA_ENABLED\n    /* upload code coverage execution history from target*/\n    if (cc.command == XIL_TERMINATE_COMMAND) {\n        callTargetUploadFcns();\n    }\n#endif /* LDRA_ENABLED */\n                \n    /* client/server commands could be executed in the middle of a step */\n    if ((cc.state == XIL_COMPLETE) && (cc.command != XIL_CLIENT_SERVER_COMMAND)) { \n        /* finalize the response */\n        MemUnit_T isEndOfXILStep = 1;\n        if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SUCCESS, isEndOfXILStep) != XIL_INTERFACE_LIB_SUCCESS) {\n            XIL_RUN_EXIT_ERROR;\n        }\n        \n        /* reset state */\n        cc.state = XIL_READ_COMMAND_CODE;\n    }\n\n    XIL_RUN_EXIT;\n    \n}\n\nXIL_INTERFACE_LIB_ERROR_CODE xilRun(void) {\n    XIL_INTERFACE_LIB_ERROR_CODE errorCode = XIL_INTERFACE_LIB_SUCCESS;\n\n    /* read one msg and pass to owning application */\n    xilProcessMsg();\n    \n    if (processMsgSuccess) {        \n        if (isShutdownCommand) {\n            errorCode = XIL_INTERFACE_LIB_TERMINATE;\n        } else {\n            errorCode = XIL_INTERFACE_LIB_SUCCESS;\n        }\n        \n    } else {\n        errorCode = XIL_INTERFACE_LIB_ERROR;\n    }\n    return errorCode;\n}\n\n/* Dispatch and receive client/server commands within a step */\nvoid xilCommandDispatchAndResponse(XIL_COMMAND_TYPE_ENUM xilCommandType, \n                                   uint32_T xilCommandIdx, uint32_T xilFcnId, \n                                   uint32_T svrFcnId, MemUnit_T xilResponseId,\n                                   XIL_PROCESS_MSG_CONTEXT_SWITCH callerCtx) {\n\n    /* define a binary flag, each CS command needs to process a response */\n    int needToProcessCSResponse = 1;\n    \n    /* send input data to the host */\n    if (processTargetToHostData(xilFcnId, xilResponseId, xilCommandType, \n            xilCommandIdx, svrFcnId) == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n        restoreProcessMsgContext(callerCtx);\n        XIL_RUN_EXIT_ERROR;\n    }\n    \n    /* finalize the response */\n    {\n        MemUnit_T isEndOfXILStep = 0;\n        if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SUCCESS, isEndOfXILStep) !=\n                XIL_INTERFACE_LIB_SUCCESS) {\n            restoreProcessMsgContext(callerCtx);\n            XIL_RUN_EXIT_ERROR;\n        }\n    }\n    \n    /* reset state for new context, recursive calls are safe because all\n     * the caller contexts (callerCtx) are cached in the stack */\n    cc.state = XIL_READ_COMMAND_CODE;\n    \n    while(needToProcessCSResponse) {\n        /* read next command requested by the host */\n        xilReadCommandCode();\n        if (cc.command == XIL_CLIENT_SERVER_COMMAND) {\n            /* if the host sent a response to the server call, process it\n             * and then exit the loop. Otherwise, process the current \n             * command and read the next one */\n            needToProcessCSResponse = 0;\n        }\n        /* process response data sent by host */\n        if (xilRun() != XIL_INTERFACE_LIB_SUCCESS) {\n            restoreProcessMsgContext(callerCtx);\n            XIL_RUN_EXIT_ERROR;\n        }\n    }\n    \n    restoreProcessMsgContext(callerCtx);\n    \n}\n\nXIL_PROCESS_MSG_CONTEXT_SWITCH xilGetCurrentProcessMsgContext(void) {\n    /* return the current context (cc) */\n    return cc;\n}\n\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n\nvoid swapBytes(MemUnit_T * const buffer, uint32_T size) {\n    MemUnit_T tmp;\n    MemUnit_T *headPtr;\n    MemUnit_T *tailPtr;\n    uint32_T idx;\n\n    for(idx = 0; idx < size/2; idx ++) {\n        headPtr = buffer + idx; \n        tailPtr = buffer + size -1 - idx;\n        tmp = *headPtr;\n        *headPtr = *tailPtr;\n        *tailPtr = tmp;\n    }\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE xilReadDataAndSwapBytes(MemUnit_T * dst, uint32_T size) {\n    XIL_DATA_STREAM_ERROR_CODE readDataVal = xilReadData(dst, size);\n\n    if (readDataVal == XIL_DATA_STREAM_SUCCESS) {\n        swapBytes(dst, size);\n    }\n    return readDataVal;\n}\n\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n"},{"name":"xil_interface_lib.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2021 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib.h\n *\n * SIL/PIL support library\n */\n\n#ifndef __XIL_INTERFACE_LIB_H__\n#define __XIL_INTERFACE_LIB_H__\n\n#include \"xil_error_codes.h\"\n#include \"xil_common.h\"\n#include \"xil_interface_common.h\" \n\n/* always present a C function-call interface for xil_interface_lib.c */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* xil interface functions to be called from main */\nextern XIL_INTERFACE_LIB_ERROR_CODE xilInit(const int argc, \n                                            void *argv[]);\nextern XIL_INTERFACE_LIB_ERROR_CODE xilRun(void);\n\n/* terminate XIL communications */\nextern XIL_INTERFACE_LIB_ERROR_CODE xilTerminateComms(void);\n\n/* XIL exception handler */\nextern void xilExceptionHandler(const char*,const char*);\n\n/* Dispatch and receive client/server commands within a step */\nextern void xilCommandDispatchAndResponse(XIL_COMMAND_TYPE_ENUM xilCommandType, \n                                          uint32_T xilCommandIdx, uint32_T xilFcnId,\n                                          uint32_T serverFcnId, MemUnit_T xilResponseId,\n                                          XIL_PROCESS_MSG_CONTEXT_SWITCH callerCtx);\n\n/* return the current context (cc) */\nextern XIL_PROCESS_MSG_CONTEXT_SWITCH xilGetCurrentProcessMsgContext(void);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_interface_lib_private.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2022 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib_private.h\n *\n * SIL/PIL support library\n */\n\n#ifndef __XIL_INTERFACE_LIB_PRIVATE_H__\n#define __XIL_INTERFACE_LIB_PRIVATE_H__\n\n#include \"xil_interface_common.h\"\n\n/* define error response error ids */\ntypedef enum {XIL_RESPONSE_ERROR_SUCCESS=0,\n              XIL_RESPONSE_ERROR_PROCESS_UDATA,\n              XIL_RESPONSE_ERROR_PROCESS_YDATA, \n              XIL_RESPONSE_ERROR_PROCESS_PARAMS, \n              XIL_RESPONSE_ERROR_INITIALIZE,\n              XIL_RESPONSE_ERROR_SYSTEM_INITIALIZE, \n              XIL_RESPONSE_ERROR_OUTPUT, \n              XIL_RESPONSE_ERROR_UPDATE,\n              XIL_RESPONSE_ERROR_TERMINATE,\n              XIL_RESPONSE_ERROR_ENABLE, \n              XIL_RESPONSE_ERROR_DISABLE, \n              XIL_RESPONSE_ERROR_SYSTEM_RESET} XIL_RESPONSE_ERROR_ID;\n\n/* static functions */\nstatic void getNextXILIOData(void);\n  \nstatic XIL_HANDLE_RECV_STATE computeNextState(\n        XIL_HANDLE_RECV_STATE currentState,\n        XIL_COMMAND_TYPE_ENUM command);\n\n\n#endif\n"},{"name":"xil_rtiostream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_XILTGTAPPSVC_SUCCESS\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n/* XIL buffer is statically allocated for rtiostream-based implementation */\nstatic IOUnit_T xilWriteBuffer[XIL_TX_BUFFER_MEMUNIT_SIZE];\n\nextern uint8_T xilTgtAppSvcCreate(void) {\n    return XILTGTAPPSVC_SUCCESS;\n}\n\nextern void xilTgtAppSvcDestroy(void) {\n}\n\n/* Allocation method simply returns the statically allocated buffer */\nextern uint8_T xilTgtAppSvcAllocBuffer(\n        void** ppBuf,\n        const uint16_T dataSize) {\n    \n    /* buffer is already statically allocated */\n    *ppBuf = &xilWriteBuffer[APPLICATION_ID_IDX];\n    \n    UNUSED_PARAMETER(dataSize);\n    \n    /* nothing to do as buffer is already statically allocated */\n    return XILTGTAPPSVC_SUCCESS;\n}\n\n/* return pointer to XIL buffer data */\nextern IOUnit_T * xilTgtAppSvcGetBufferDataPtr(\n        void* const pBuf) {\n    \n    /* buffer is already statically allocated */\n    UNUSED_PARAMETER(pBuf);\n       \n    return &xilWriteBuffer[PAYLOAD_IDX];\n}\n\n/* send data over rtiostream */\nextern uint8_T xilTgtAppSvcSend(\n        void* const pBuf,        \n        const uint16_T dataSize) {\n    \n    return (uint8_T)commsEnqueueBuffer(pBuf, XIL_RTIOSTREAM_BASED_SERVICE_ID, dataSize);\n}\n\n"},{"name":"xil_services.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2023 The MathWorks, Inc. */\n\n#ifdef XIL_SIGNAL_HANDLER\n    #include <signal.h>\n    #include <stdio.h>\n    #include <stdlib.h>\n    #if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n        #include <execinfo.h>\n        #define MAX_STACKTRACE 12\n    #endif\n#endif\n\n/* Adding support to enable/disable FTZ/DAZ\n * x86/amd64 : native, _MM_SET_FLUSH_ZERO_MODE() and _MM_SET_DENORMALS_ZERO_MODE()\n * AArch64   : emulated _MM_SET_FLUSH_ZERO_MODE() and _MM_SET_DENORMALS_ZERO_MODE()\n */\n#if defined(SIL_DISABLE_SUBNORMAL_SUPPORT) && (SIL_DISABLE_SUBNORMAL_SUPPORT >= 1)\n    #if (defined(__APPLE__) && defined(__aarch64__))\n        /* AArch64 cannot emulate FTZ and DAZ behavior exclusively\n         * Enabling FPCR.FZ (bit24) is same as enabling both MXCSR.FTZ and MXCSR.DAZ\n         * Emulated _MM_SET_FLUSH_ZERO_MODE()/_MM_SET_DENORMALS_ZERO_MODE for AArch64\n         * modify the same AArch64 FPCR.FZ bit\n         */\n\n        /* x86/amd64 MXCSR masks */\n        #define _MM_FLUSH_ZERO_MASK (0x8000U)\n        #define _MM_FLUSH_ZERO_ON   (0x8000U)\n        #define _MM_FLUSH_ZERO_OFF  (0x0000U)\n\n        #define _MM_DENORMALS_ZERO_MASK (0x0040U)\n        #define _MM_DENORMALS_ZERO_ON   (0x0040U)\n        #define _MM_DENORMALS_ZERO_OFF  (0x0000U)\n\n        /* AArch64 FPCR */\n        typedef struct {\n            uint16_t res0;\n            uint8_t  res1  : 6;\n            uint8_t  bit22 : 1;\n            uint8_t  bit23 : 1;\n            uint8_t  bit24 : 1;\n            uint8_t  res2  : 7;\n            uint32_t res3;\n        } fpcr_bitfield;\n\n        union {\n            fpcr_bitfield field;\n            uint64_t value;\n        } r;\n\n        #if SIL_DISABLE_SUBNORMAL_SUPPORT == 1\n            #define _MM_SET_FLUSH_ZERO_MODE(x)      _mw_set_flush_zero_mode(x)\n            #define _MM_SET_DENORMALS_ZERO_MODE(x)  _mw_set_denormals_zero_mode(x)\n\n            /* 'flag' here is the entire x86/amd64 MXCSR register */\n            static inline void _mw_set_flush_zero_mode(unsigned int flag) {\n                __asm__ __volatile__(\"mrs %0, FPCR\" : \"=r\"(r.value));    /* read */\n                r.field.bit24 = ((flag & _MM_FLUSH_ZERO_MASK) == _MM_FLUSH_ZERO_ON);\n                __asm__ __volatile__(\"msr FPCR, %0\" ::\"r\"(r));           /* write */\n            }\n\n            /* 'flag' here is the entire x86/amd64 MXCSR register */\n            static inline void _mw_set_denormals_zero_mode(unsigned int flag) {\n                __asm__ __volatile__(\"mrs %0, FPCR\" : \"=r\"(r.value));    /* read */\n                r.field.bit24 = ((flag & _MM_DENORMALS_ZERO_MASK) == _MM_DENORMALS_ZERO_ON);\n                __asm__ __volatile__(\"msr FPCR, %0\" ::\"r\"(r));           /* write */\n            }\n        #else\n            #error \"SIL_DISABLE_SUBNORMAL_SUPPORT values other than [1,2] are not supported\"\n        #endif\n    #else\n        #include <immintrin.h>\n    #endif\n#endif\n\n#define USE_COMMS_SUCCESS\n#include \"xil_error_codes.h\"\n#include \"xil_interface_lib.h\"\n#include \"xil_data_stream.h\"\n#include \"comms_interface.h\"\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n#include \"codeinstr_data_stream.h\"\n#endif\n\n#ifndef CODER_ASSUMPTIONS_ENABLED\n   #error \"CODER_ASSUMPTIONS_ENABLED should always be defined!\"\n#endif\n\n#if CODER_ASSUMPTIONS_ENABLED == 1\n#include \"coder_assumptions_data_stream.h\"\n#endif\n\n#ifdef XIL_SIGNAL_HANDLER\n/* define signal handler codes */\ntypedef enum {XIL_SIGNAL_SIGFPE=0, \n              XIL_SIGNAL_SIGILL,\n              XIL_SIGNAL_ABRT,\n              XIL_SIGNAL_SEGV,\n              XIL_SIGNAL_EXIT,\n              XIL_SIGNAL_UNKNOWN} XIL_SIGNAL_RAISED;\n\nstatic void xilDispatchResponseSigRaised(XIL_SIGNAL_RAISED responseSignal) {\n  /* Write XIL Response Signal Raised to buffer */\n  MemUnit_T memUnitData = XIL_RESPONSE_SIGNAL_RAISED;\n  fflush(stderr);\n  xilWriteData(&memUnitData, sizeof(memUnitData));\n  \n  /* Write Signal enum to buffer */\n  memUnitData = (MemUnit_T)responseSignal;\n  xilWriteData(&memUnitData, sizeof(memUnitData));\n  \n  /* Dispatch buffer to host */\n  xilDataFlush((MemUnit_T)1);\n  xilTerminateComms();\n}\n\nstatic void raiseExitSignal(void){\n  /* Dispatch response signal raised */ \n  XIL_SIGNAL_RAISED xilResponseSignal = XIL_SIGNAL_EXIT;\n  xilDispatchResponseSigRaised(xilResponseSignal);\n}\n\nstatic void XILSigHandler(int32_T sigNo)\n{\n  XIL_SIGNAL_RAISED xilResponseSignal;\n  \n  switch (sigNo)\n  {\n    case SIGFPE:\n    {\n        /* Erroneous arithmetic operation, such as division by zero */\n        xilResponseSignal = XIL_SIGNAL_SIGFPE;\n        break;\n    }\n    case SIGILL:\n    {\n        /* Illegal, malformed, unknown or privileged instruction */\n        xilResponseSignal = XIL_SIGNAL_SIGILL;\n        break;\n    }\n    case SIGABRT:\n    {\n        /* Signal abort */\n        xilResponseSignal = XIL_SIGNAL_ABRT;\n        break;\n    }\n    case SIGSEGV:\n    {\n        /* Segmentation violation */\n        #if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n            void *array[MAX_STACKTRACE];\n            int bt_size = 0;\n        #endif\n            \n        xilResponseSignal = XIL_SIGNAL_SEGV;\n            \n        #if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n            bt_size = backtrace(array, MAX_STACKTRACE);\n            backtrace_symbols_fd(array, bt_size, 2);\n        #endif\n        break;\n    }\n    default:\n    {\n        xilResponseSignal = XIL_SIGNAL_UNKNOWN;\n        break;\n    }\n  }\n  xilDispatchResponseSigRaised(xilResponseSignal);\n}\n#endif\n\n/* Entry point (called from sil_main.c & pil_main.c) to initialize services */\nXIL_INTERFACE_LIB_ERROR_CODE xilInit(const int argc, void *argv[]) {\n    \n    if (commsInit(argc, argv) != COMMS_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    if (silpilInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n#ifdef CODE_INSTRUMENTATION_ENABLED\n    if (codeInstrInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n    \n#if CODER_ASSUMPTIONS_ENABLED == 1\n    if (coderAssumptionsInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n\n#ifdef XIL_SIGNAL_HANDLER\n    /* register callback for when program makes an exit request */\n    atexit(raiseExitSignal);\n    /* register signals to catch */\n    signal(SIGFPE, XILSigHandler);  /* Erroneous arithmetic operation */\n    signal(SIGILL, XILSigHandler);  /* Illegal operation */\n    signal(SIGABRT, XILSigHandler); /* Abort signal */\n    signal(SIGSEGV, XILSigHandler); /* Segmentation violation */\n#endif\n\n#ifdef SIL_DISABLE_SUBNORMAL_SUPPORT\n    #if SIL_DISABLE_SUBNORMAL_SUPPORT == 1\n        _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);\n        #ifdef __GNUC__\n        /* Disable diagnostic warning thrown by GCC for _MM_SET_DENORMALS_ZERO_MODE due to sign conversion */\n            #pragma GCC diagnostic push\n            #pragma GCC diagnostic ignored \"-Wsign-conversion\"\n                _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);\n            #pragma GCC diagnostic pop\n        #else\n            _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);\n        #endif\n    #endif\n#endif\n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* Entry point (called from sil_main.c & pil_main.c) to terminate services */\nXIL_INTERFACE_LIB_ERROR_CODE xilTerminateComms(void) {\n    \n    silpilTerminate();\n    \n#ifdef CODE_INSTRUMENTATION_ENABLED\n    codeInstrTerminate();\n#endif\n    \n#if CODER_ASSUMPTIONS_ENABLED == 1\n    coderAssumptionsTerminate();\n#endif\n    \n    commsTerminate();\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n\n/* Entry point (called from sil_main.c & pil_main.c) to send exception information back to host */\nvoid xilExceptionHandler(const char *exception, const char *exceptionType){\n\n    uint8_T type = (uint8_T)(XIL_RESPONSE_EXCEPTION);\n    uint32_T exceptionLength = (uint32_T)(strlen(exception));\n    uint32_T exceptionTypeLength = (uint32_T)(strlen(exceptionType));\n     \n    #ifdef XIL_SIGNAL_HANDLER\n        fflush(stderr);\n    #endif\n\n    xilWriteData((const MemUnit_T*)&type,sizeof(type));\n\n    xilWriteData((const MemUnit_T*)&exceptionLength,sizeof(exceptionLength));\n    xilWriteData((const MemUnit_T*)exception,(uint32_T)(exceptionLength*sizeof(*exception)));\n    \n    xilWriteData((const MemUnit_T*)&exceptionTypeLength,sizeof(exceptionTypeLength));\n    xilWriteData((const MemUnit_T*)exceptionType,(uint32_T)(exceptionTypeLength*sizeof(*exceptionType)));\n\n    xilDataFlush((MemUnit_T)1);\n}\n"},{"name":"xilcomms_rtiostream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_COMMS_ERROR\n#define USE_COMMS_SUCCESS\n#include \"xilcomms_rtiostream.h\"\n#include \"comms_interface.h\"\n#include \"rtiostream.h\"\n#include \"rtiostream_utils.h\"\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"XILTgtAppSvc.h\"\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include \"xil_data_stream.h\"\n#endif\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    extern void swapBytes(MemUnit_T * const buffer, uint32_T size);\n#endif /* HOST_BIG_ENDIAN_PROTOCOL_TESTING */\n\n/* call xilProcessMsg */\nextern void xilProcessMsg(void);\n\n/* store stream handle */\nstatic int streamID;\n\n/* allocate the buffers */\nstatic IOUnit_T xilCommsBuffer[RTIOSTREAM_RX_BUFFER_SIZE];\n\n\n/* open rtiostream */\nint commsInit(const int argc, void * argv[]){\n    \n    streamID = rtIOStreamOpen(argc, argv);\n    if (streamID == RTIOSTREAM_ERROR) {\n        return COMMS_ERROR;\n    }\n    return COMMS_SUCCESS;\n}\n\n/* close rtiostream */\nint commsTerminate(void) {    \n    if (rtIOStreamClose(streamID) == RTIOSTREAM_NO_ERROR) {\n        return COMMS_SUCCESS;\n    } else {\n        return COMMS_ERROR;\n    }\n}\n\n/* call rtIOStreamBlockingSend to send data*/\nint commsEnqueueBuffer(        \n        void* const pBuf,\n        const uint8_T appId,\n        const uint16_T dataSize) {\n    \n    int rtIOStreamErrorStatus;\n    IOUnit_T* appBuffer;\n    MemUnit_T appIdMemUnit = (MemUnit_T)appId;\n    uint32_T writeDataAvail = (uint32_T)dataSize;   \n    uint32_T transferSize = writeDataAvail + BUFFER_HEADER_SIZE;           \n\n    /* write size and application id before sending the buffer */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n    /* writeDataAvail is in terms of IOUnit_T (uint8_T) - convert to MemUnit_T's\n     * abort if writeDataAvail does not divide exactly */\n    uint32_T writeDataAvailMemUnits = writeDataAvail / MEM_UNIT_BYTES;\n    uint32_T memUnitsRemainder = writeDataAvail % MEM_UNIT_BYTES;\n    if (memUnitsRemainder != 0) {\n        fprintf(stderr,\"Target application aborted: the number of available Bytes in the \" \\\n            \"TargetToHost TX Buffer (%d B) does not divide exactly by the number of \" \\\n            \"Bytes per MemUnit (%d B).\\n\", writeDataAvail, MEM_UNIT_BYTES);\n        /* this condition can happen only when the buffer is full with the first\n         * chunk of outgoing data, at this point the host will not be midway through\n         * receiving a response. Therefore, it is ok to drop the pending data. */\n        resetXILWriteBuffer();\n        /* send the abort message */\n        abort();\n    }\n    \n#else\n    uint32_T writeDataAvailMemUnits = writeDataAvail;\n#endif\n    \n    /* get the pointer for the application buffer of the given app id */\n    appBuffer = (IOUnit_T*) pBuf;\n\tif (appBuffer == NULL) {\n\t\t/* early return */\n\t\treturn COMMS_ERROR;\n\t}\n        \n    UNUSED_PARAMETER(pBuf);\n    \n    memcpy((void *) &appBuffer[APPLICATION_ID_IDX], &appIdMemUnit, sizeof(appIdMemUnit));        \n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    /* swap the bytes of the playload size that will be sent to the host */\n    swapBytes((MemUnit_T*)(&writeDataAvailMemUnits), sizeof(writeDataAvailMemUnits));\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n    memcpy((void *) &appBuffer[PAYLOAD_SIZE_IDX], &writeDataAvailMemUnits, sizeof(writeDataAvailMemUnits));    \n    \n   /* Blocks until all requested outgoing data is sent */\n   rtIOStreamErrorStatus = rtIOStreamBlockingSend(streamID,\n                                                 (const void *) appBuffer,\n                                                 transferSize);\n                                                      \n   if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n         return COMMS_ERROR;\n   \n   return COMMS_SUCCESS;\n}\n\nint rtiostreamReadMessage(IOUnit_T ** currentBufferPosition, uint16_T *currentBufSize) {\n    \n    int rtIOStreamErrorStatus;\n    uint32_T dataSize = 0;\n    MemUnit_T appId;\n\n\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &appId,\n        sizeof(appId));\n\n    if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t    return COMMS_ERROR;\n\n    \n    /* receive size of data contained in the buffer */\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &dataSize,\n        sizeof(dataSize));\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    /* swap the bytes of the dataSize sent from the host */\n    swapBytes((MemUnit_T*)(&dataSize), sizeof(dataSize));\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n    if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t\treturn COMMS_ERROR;\n\n    \n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n\t/* dataSize is in terms of MemUnit_T - convert to IOUnit_T (uint8_T). Note\n     * that dataSize will not overflow since the host already divided dataSize \n\t * by memUnit_T before transmission, so this multiplication should be safe\n     * and won't overflow.\n\t */\n    dataSize *= MEM_UNIT_BYTES;\n#endif\n\n    /* receive the data */\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &(xilCommsBuffer[0]),\n        dataSize);\n\n    *currentBufferPosition = &(xilCommsBuffer[0]);\n    *currentBufSize = (uint16_T)dataSize;\n\n    return COMMS_SUCCESS;\n}\n\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};