var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"ctrl_ez","ref":true,"files":[{"name":"ctrl_ez.c","type":"source","group":"model","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_ref\\ctrl_ez","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ctrl_ez.c\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.628\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Apr 27 18:14:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"ctrl_ez.h\"\r\n#include <stdbool.h>\r\n#include \"ctrl_ez_private.h\"\r\n#include \"mw_cmsis.h\"\r\n#include \"arm_math.h\"\r\n#include <math.h>\r\n#include <stdint.h>\r\n#include \"plook_u32ff_evenc.h\"\r\n#include \"intrp1d_fu32fl.h\"\r\n\r\n/* Exported block states */\r\nfloat filter_IA;                       /* 'Data Store Memory' (':2047') */\r\nfloat filter_IB;                       /* 'Data Store Memory1' (':2049') */\r\nfloat filter_IC;                       /* 'Data Store Memory2' (':2051') */\r\n\r\n/* Block states (default storage) */\r\nDW_ctrl_ez_f_T ctrl_ez_DW;\r\n\r\n/* System initialize for referenced model: 'ctrl_ez' */\r\nvoid ctrl_ez_Init(float *rty_Qa)\r\n{\r\n  /* SystemInitialize for RootInportFunctionCallGenerator generated from: 'trigger_ctrl_ez' (':21') incorporates:\r\n   *  SubSystem: 'ctrl_ez_fcn' (':498')\r\n   */\r\n  /* InitializeConditions for Memory: 'Memory' (':561') */\r\n  ctrl_ez_DW.Memory_PreviousInput = true;\r\n\r\n  /* SystemInitialize for Enabled SubSystem: 'ctrl' (':1270') */\r\n  /* InitializeConditions for DiscreteIntegrator: 'Accumulator' (':1396') */\r\n  ctrl_ez_DW.Accumulator_PrevResetState = 2;\r\n\r\n  /* End of SystemInitialize for SubSystem: 'ctrl' (':1270') */\r\n\r\n  /* SystemInitialize for SignalConversion generated from: 'Qa' (':570') */\r\n  *rty_Qa = ctrl_ez_DW.T2[0];\r\n\r\n  /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: 'trigger_ctrl_ez' (':21') */\r\n}\r\n\r\n/* Output and update for referenced model: 'ctrl_ez' */\r\nvoid ctrl_ez_trigger_ctrl_ez(const float *rtu_ia, const float *rtu_ib, const\r\n  float *rtu_ic, const float *rtu_ov_out, const float *rtu_w, const float\r\n  *rtu_lock_pll, const float *rtu_sine, const float *rtu_cos, const float\r\n  *rtu_va, const float *rtu_vc, const float *rtu_vb, float *rty_Qa, float\r\n  *rty_Qb, float *rty_Qc, bool *rty_lock)\r\n{\r\n  float rtb_Switch1[2];\r\n  float tmp[2];\r\n  float iq_integ;\r\n  float rtb_Delay1;\r\n  float rtb_Gain;\r\n  float rtb_algDD_o1;\r\n  float rtb_algDD_o2;\r\n  float rtb_one_by_3;\r\n  float rtb_vd_park_l;\r\n  float rtb_vq_park_o;\r\n  int32_t rtb_Accumulator_o2;\r\n  int32_t y;\r\n  uint32_t bpIdx;\r\n  uint8_t quadrantInfo;\r\n  bool isReciprocal;\r\n  static const float tableData_c[16] = { 0.0F, 0.010594652F, 0.0210962314F,\r\n    0.0314164795F, 0.0414761603F, 0.0512081906F, 0.0605594702F, 0.0694913715F,\r\n    0.0779791325F, 0.0860104337F, 0.0935835242F, 0.100705102F, 0.107388355F,\r\n    0.113651067F, 0.11951407F, 0.125F };\r\n\r\n  /* RootInportFunctionCallGenerator generated from: 'trigger_ctrl_ez' (':21') incorporates:\r\n   *  SubSystem: 'ctrl_ez_fcn' (':498')\r\n   */\r\n  /* Switch: 'Switch1' (':831:483') incorporates:\r\n   *  Constant: 'FilterConstant' (':831:478')\r\n   *  Constant: 'OneMinusFilterConstant' (':831:480')\r\n   */\r\n  rtb_Switch1[0] = 0.8F;\r\n  rtb_Switch1[1] = 0.2F;\r\n\r\n  /* Product: 'Product1' (':831:365') incorporates:\r\n   *  UnitDelay: 'Unit Delay' (':831:366')\r\n   */\r\n  mw_arm_scale_1_f32(&rtb_Switch1[1], &ctrl_ez_DW.UnitDelay_DSTATE[0],\r\n                     &ctrl_ez_DW.fv[0], 3U);\r\n\r\n  /* Sum: 'Add1' (':831:360') incorporates:\r\n   *  Product: 'Product' (':831:364')\r\n   *  Product: 'Product1' (':831:365')\r\n   */\r\n  ctrl_ez_DW.Kalphabeta0[0] = *rtu_ia * rtb_Switch1[0];\r\n  ctrl_ez_DW.Kalphabeta0[1] = *rtu_ib * rtb_Switch1[0];\r\n  ctrl_ez_DW.Kalphabeta0[2] = *rtu_ic * rtb_Switch1[0];\r\n  mw_arm_add_f32(&ctrl_ez_DW.Kalphabeta0[0], &ctrl_ez_DW.fv[0],\r\n                 &ctrl_ez_DW.Add1[0], 3U);\r\n\r\n  /* DataStoreWrite: 'Data Store Write' (':2046') */\r\n  filter_IA = ctrl_ez_DW.Add1[0];\r\n\r\n  /* DataStoreWrite: 'Data Store Write1' (':2048') */\r\n  filter_IB = ctrl_ez_DW.Add1[1];\r\n\r\n  /* DataStoreWrite: 'Data Store Write2' (':2050') */\r\n  filter_IC = ctrl_ez_DW.Add1[2];\r\n\r\n  /* Switch: 'Switch' (':562') incorporates:\r\n   *  Constant: 'Pi1' (':1837')\r\n   *  Logic: 'AND' (':1985')\r\n   *  Memory: 'Memory' (':561')\r\n   *  RelationalOperator: 'Equal' (':1807')\r\n   */\r\n  *rty_lock = (((*rtu_w < 0.0F) || (*rtu_lock_pll == 0.0F)) &&\r\n               ctrl_ez_DW.Memory_PreviousInput);\r\n\r\n  /* Gain: 'one_by_3' (':2058:648') incorporates:\r\n   *  Sum: 'Sum' (':2058:644')\r\n   */\r\n  rtb_one_by_3 = ((*rtu_va + *rtu_vb) + *rtu_vc) * 0.333333343F;\r\n\r\n  /* Gain: 'Kalphabeta0' (':2058:641') incorporates:\r\n   *  Gain: 'one_by_sqrt3_' (':2058:649')\r\n   *  Sum: 'Sum1' (':2058:645')\r\n   *  Sum: 'Sum2' (':2058:646')\r\n   */\r\n  ctrl_ez_DW.fv[0] = *rtu_va - rtb_one_by_3;\r\n  ctrl_ez_DW.fv[1] = (*rtu_vb - *rtu_vc) * 0.577350259F;\r\n  ctrl_ez_DW.fv[2] = rtb_one_by_3;\r\n  mw_arm_mult_f32((float *)&rtCP_Kalphabeta0_Gain_h[0], &ctrl_ez_DW.fv[0],\r\n                  &ctrl_ez_DW.Kalphabeta0[0], 3U);\r\n\r\n  /* Outputs for Enabled SubSystem: 'ctrl' (':1270') incorporates:\r\n   *  EnablePort: 'Enable' (':1272')\r\n   */\r\n  /* Logic: 'NOT' (':591') */\r\n  if (!*rty_lock) {\r\n    /* Gain: 'one_by_3' (':1278:648') incorporates:\r\n     *  Sum: 'Sum' (':1278:644')\r\n     */\r\n    rtb_one_by_3 = ((ctrl_ez_DW.Add1[0] + ctrl_ez_DW.Add1[1]) + ctrl_ez_DW.Add1\r\n                    [2]) * 0.333333343F;\r\n\r\n    /* Gain: 'Kalphabeta0' (':1278:641') incorporates:\r\n     *  Gain: 'one_by_sqrt3_' (':1278:649')\r\n     *  Sum: 'Sum1' (':1278:645')\r\n     *  Sum: 'Sum2' (':1278:646')\r\n     */\r\n    ctrl_ez_DW.fv[0] = ctrl_ez_DW.Add1[0] - rtb_one_by_3;\r\n    ctrl_ez_DW.fv[1] = (ctrl_ez_DW.Add1[1] - ctrl_ez_DW.Add1[2]) * 0.577350259F;\r\n    ctrl_ez_DW.fv[2] = rtb_one_by_3;\r\n    mw_arm_mult_f32((float *)&rtCP_Kalphabeta0_Gain[0], &ctrl_ez_DW.fv[0],\r\n                    &ctrl_ez_DW.Kalphabeta0_d[0], 3U);\r\n\r\n    /* MATLAB Function: 'park_tf' (':2017') */\r\n    rtb_vq_park_o = *rtu_sine * ctrl_ez_DW.Kalphabeta0_d[1] + *rtu_cos *\r\n      ctrl_ez_DW.Kalphabeta0_d[0];\r\n    rtb_vd_park_l = *rtu_sine * ctrl_ez_DW.Kalphabeta0_d[0] - *rtu_cos *\r\n      ctrl_ez_DW.Kalphabeta0_d[1];\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1374') */\r\n    if (ctrl_ez_DW.Accumulator_DSTATE == 50.0F) {\r\n      rtb_Accumulator_o2 = 1;\r\n    } else if (ctrl_ez_DW.Accumulator_DSTATE == -50.0F) {\r\n      rtb_Accumulator_o2 = -1;\r\n    } else {\r\n      rtb_Accumulator_o2 = 0;\r\n    }\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n    rtb_one_by_3 = ctrl_ez_DW.Accumulator_DSTATE_a;\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n    if (ctrl_ez_DW.Accumulator_DSTATE_a > 100.0F) {\r\n      /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n      rtb_one_by_3 = 100.0F;\r\n    } else if (ctrl_ez_DW.Accumulator_DSTATE_a < -100.0F) {\r\n      /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n      rtb_one_by_3 = -100.0F;\r\n    }\r\n\r\n    /* Delay: 'Delay1' (':1399') */\r\n    rtb_Delay1 = ctrl_ez_DW.Delay1_DSTATE;\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1396') incorporates:\r\n     *  Delay: 'Delay1' (':1399')\r\n     */\r\n    if ((ctrl_ez_DW.Delay1_DSTATE > 0.0F) &&\r\n        (ctrl_ez_DW.Accumulator_PrevResetState <= 0)) {\r\n      ctrl_ez_DW.Accumulator_DSTATE_p = 0.0F;\r\n    }\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n    iq_integ = ctrl_ez_DW.Accumulator_DSTATE_p;\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n    if (ctrl_ez_DW.Accumulator_DSTATE_p > 500.0F) {\r\n      /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n      iq_integ = 500.0F;\r\n    } else if (ctrl_ez_DW.Accumulator_DSTATE_p < -500.0F) {\r\n      /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n      iq_integ = -500.0F;\r\n    }\r\n\r\n    /* Outputs for Atomic SubSystem: 'Two inputs CRL' (':2068:778') */\r\n    /* AlgorithmDescriptorDelegate generated from: 'a16' (':2068:761') incorporates:\r\n     *  Constant: 'Constant' (':1324')\r\n     *  Constant: 'Constant1' (':1337')\r\n     *  DiscreteIntegrator: 'Accumulator' (':1374')\r\n     *  Gain: 'Gain1' (':1389')\r\n     *  Gain: 'Gain1' (':1400')\r\n     *  Gain: 'Gain1' (':1378')\r\n     *  Gain: 'Gain' (':1333')\r\n     *  Gain: 'Gain1' (':1342')\r\n     *  MATLAB Function: 'park_tf' (':2016')\r\n     *  Sum: 'Add2' (':1386')\r\n     *  Sum: 'Add2' (':1397')\r\n     *  Sum: 'Add2' (':1375')\r\n     *  Sum: 'Sum1' (':1323')\r\n     *  Sum: 'Sum2' (':1328')\r\n     *  Sum: 'Sum3' (':1332')\r\n     *  Sum: 'Sum4' (':1336')\r\n     *  Sum: 'Sum5' (':1341')\r\n     */\r\n    arm_inv_park_f32(((*rtu_sine * ctrl_ez_DW.Kalphabeta0[0] - *rtu_cos *\r\n                       ctrl_ez_DW.Kalphabeta0[1]) + 0.0471238904F *\r\n                      rtb_vq_park_o) - (8.0F * ((0.3F * (700.0F - *rtu_ov_out) +\r\n      ctrl_ez_DW.Accumulator_DSTATE) - rtb_vd_park_l) + rtb_one_by_3),\r\n                     ((*rtu_sine * ctrl_ez_DW.Kalphabeta0[1] + *rtu_cos *\r\n                       ctrl_ez_DW.Kalphabeta0[0]) - 0.0471238904F *\r\n                      rtb_vd_park_l) - (8.0F * (0.0F - rtb_vq_park_o) + iq_integ),\r\n                     &rtb_algDD_o1, &rtb_algDD_o2, *rtu_sine, *rtu_cos);\r\n\r\n    /* End of Outputs for SubSystem: 'Two inputs CRL' (':2068:778') */\r\n\r\n    /* Outputs for Atomic SubSystem: 'atan2' (':2028') */\r\n    /* Trigonometry: 'Atan2' (':2028:325') */\r\n    if ((rtb_algDD_o1 == 0.0F) && (rtb_algDD_o2 == 0.0F)) {\r\n      rtb_Gain = 0.0F;\r\n    } else {\r\n      isReciprocal = false;\r\n      if (rtb_algDD_o2 < 0.0F) {\r\n        if (rtb_algDD_o1 < 0.0F) {\r\n          quadrantInfo = 3U;\r\n        } else {\r\n          quadrantInfo = 4U;\r\n        }\r\n      } else if (rtb_algDD_o1 < 0.0F) {\r\n        quadrantInfo = 2U;\r\n      } else {\r\n        quadrantInfo = 1U;\r\n      }\r\n\r\n      rtb_vd_park_l = (float)fabs(rtb_algDD_o1);\r\n      rtb_Gain = (float)fabs(rtb_algDD_o2);\r\n      if (rtb_Gain > rtb_vd_park_l) {\r\n        rtb_vq_park_o = rtb_Gain;\r\n        rtb_Gain = rtb_vd_park_l;\r\n        isReciprocal = true;\r\n      } else {\r\n        rtb_vq_park_o = rtb_vd_park_l;\r\n      }\r\n\r\n      bpIdx = plook_u32ff_evenc(rtb_Gain / rtb_vq_park_o, 0.0F, 0.0666666701F,\r\n        15U, &rtb_vd_park_l);\r\n      rtb_Gain = intrp1d_fu32fl(bpIdx, rtb_vd_park_l, tableData_c);\r\n      if (isReciprocal) {\r\n        rtb_Gain = 0.25F - rtb_Gain;\r\n      }\r\n\r\n      if (quadrantInfo == 2) {\r\n        rtb_Gain = 0.5F - rtb_Gain;\r\n      } else if (quadrantInfo == 3) {\r\n        rtb_Gain -= 0.5F;\r\n      } else if (quadrantInfo == 4) {\r\n        rtb_Gain = -rtb_Gain;\r\n      }\r\n    }\r\n\r\n    rtb_Gain *= 6.28318548F;\r\n\r\n    /* End of Trigonometry: 'Atan2' (':2028:325') */\r\n\r\n    /* MATLAB Function: 'mod_fcn' (':2052') incorporates:\r\n     *  AlgorithmDescriptorDelegate generated from: 'a16' (':2028:305')\r\n     */\r\n    if (rtb_Gain == 0.0F) {\r\n      rtb_vq_park_o = 0.0F;\r\n    } else {\r\n      rtb_vq_park_o = (float)fmod(rtb_Gain, 6.2831854820251465);\r\n      isReciprocal = (rtb_vq_park_o == 0.0F);\r\n      if (!isReciprocal) {\r\n        rtb_Gain = (float)fabs(rtb_Gain / 6.28318548F);\r\n        isReciprocal = ((float)fabs(rtb_Gain - (float)floor(rtb_Gain + 0.5F)) <=\r\n                        1.1920929E-7F * rtb_Gain);\r\n      }\r\n\r\n      if (isReciprocal) {\r\n        rtb_vq_park_o = 0.0F;\r\n      } else if (rtb_vq_park_o < 0.0F) {\r\n        rtb_vq_park_o += 6.28318548F;\r\n      }\r\n    }\r\n\r\n    /* End of MATLAB Function: 'mod_fcn' (':2052') */\r\n    /* End of Outputs for SubSystem: 'atan2' (':2028') */\r\n\r\n    /* MATLAB Function: 'sector_selection' (':1809') */\r\n    if ((rtb_vq_park_o >= 0.0F) && (rtb_vq_park_o < 1.04719758F)) {\r\n      y = 0;\r\n      isReciprocal = true;\r\n    } else if ((rtb_vq_park_o >= 1.04719758F) && (rtb_vq_park_o < 2.09439516F))\r\n    {\r\n      y = 1;\r\n      isReciprocal = false;\r\n    } else if ((rtb_vq_park_o >= 2.09439516F) && (rtb_vq_park_o < 3.14159274F))\r\n    {\r\n      y = 2;\r\n      isReciprocal = true;\r\n    } else if ((rtb_vq_park_o >= 3.14159274F) && (rtb_vq_park_o < 4.18879032F))\r\n    {\r\n      y = 3;\r\n      isReciprocal = false;\r\n    } else if ((rtb_vq_park_o >= 4.18879032F) && (rtb_vq_park_o < 5.23598766F))\r\n    {\r\n      y = 4;\r\n      isReciprocal = true;\r\n    } else if ((rtb_vq_park_o >= 5.23598766F) && (rtb_vq_park_o < 6.28318548F))\r\n    {\r\n      y = 5;\r\n      isReciprocal = false;\r\n    } else {\r\n      y = 1;\r\n      isReciprocal = false;\r\n    }\r\n\r\n    rtb_vq_park_o -= (float)y * 1.04719758F;\r\n\r\n    /* Sqrt: 'Sqrt' (':2027') incorporates:\r\n     *  Product: 'Product' (':2024')\r\n     *  Product: 'Product1' (':2025')\r\n     *  Sum: 'Add' (':2026')\r\n     */\r\n    rtb_Gain = rtb_algDD_o1 * rtb_algDD_o1 + rtb_algDD_o2 * rtb_algDD_o2;\r\n    mw_arm_sqrt_f32(&rtb_Gain, &rtb_algDD_o2, 1U);\r\n\r\n    /* Sum: 'Add1' (':1981:360') incorporates:\r\n     *  Product: 'Product' (':1981:364')\r\n     *  Product: 'Product1' (':1981:365')\r\n     *  UnitDelay: 'Unit Delay' (':1981:366')\r\n     */\r\n    rtb_algDD_o1 = *rtu_ov_out * 0.01F + 0.99F * ctrl_ez_DW.UnitDelay_DSTATE_f;\r\n\r\n    /* Saturate: 'Saturation3' (':1853') */\r\n    if (rtb_algDD_o1 > 2000.0F) {\r\n      rtb_Gain = 2000.0F;\r\n    } else if (rtb_algDD_o1 < 100.0F) {\r\n      rtb_Gain = 100.0F;\r\n    } else {\r\n      rtb_Gain = rtb_algDD_o1;\r\n    }\r\n\r\n    /* End of Saturate: 'Saturation3' (':1853') */\r\n\r\n    /* Saturate: 'Saturation' (':1823') incorporates:\r\n     *  Constant: 'Constant' (':1789')\r\n     *  Constant: 'Constant1' (':1792')\r\n     *  Product: 'Divide1' (':1795')\r\n     *  Sum: 'Add1' (':1790')\r\n     *  Trigonometry: 'Sin' (':2063')\r\n     *  Trigonometry: 'Sin1' (':2064')\r\n     */\r\n    tmp[0] = (float)sin(1.04719758F - rtb_vq_park_o) * rtb_algDD_o2 *\r\n      1.73205078F / rtb_Gain;\r\n    tmp[1] = (float)sin(rtb_vq_park_o) * rtb_algDD_o2 * 1.73205078F / rtb_Gain;\r\n    mw_arm_saturate_f32(&tmp[0], (float *)&rtCP_Saturation_LowerSat, (float *)\r\n                        &rtCP_Saturation_UpperSat, &rtb_Switch1[0], 2U);\r\n\r\n    /* Sum: 'Sum of Elements' (':1941') */\r\n    rtb_vq_park_o = rtb_Switch1[0] + rtb_Switch1[1];\r\n\r\n    /* Switch: 'Switch' (':1877') */\r\n    if (isReciprocal) {\r\n      ctrl_ez_DW.TmpSignalConversionAtSelect[0] = rtb_Switch1[0];\r\n      ctrl_ez_DW.TmpSignalConversionAtSelect[1] = rtb_Switch1[1];\r\n    } else {\r\n      ctrl_ez_DW.TmpSignalConversionAtSelect[0] = rtb_Switch1[1];\r\n      ctrl_ez_DW.TmpSignalConversionAtSelect[1] = rtb_Switch1[0];\r\n    }\r\n\r\n    /* End of Switch: 'Switch' (':1877') */\r\n\r\n    /* Saturate: 'Saturation2' (':1825') incorporates:\r\n     *  Constant: 'Constant2' (':1797')\r\n     *  Sum: 'Add2' (':1799')\r\n     */\r\n    if (1.0F - rtb_vq_park_o > 1.0F) {\r\n      rtb_Gain = 1.0F;\r\n    } else if (1.0F - rtb_vq_park_o < 0.0F) {\r\n      rtb_Gain = 0.0F;\r\n    } else {\r\n      rtb_Gain = 1.0F - rtb_vq_park_o;\r\n    }\r\n\r\n    /* Gain: 'Gain' (':1802') incorporates:\r\n     *  Saturate: 'Saturation2' (':1825')\r\n     */\r\n    rtb_Gain *= 0.5F;\r\n\r\n    /* Sum: 'Add3' (':1803') */\r\n    rtb_vq_park_o = ctrl_ez_DW.TmpSignalConversionAtSelect[1] + rtb_Gain;\r\n\r\n    /* Saturate: 'Saturation4' (':1872') */\r\n    if (rtb_vq_park_o > 1.0F) {\r\n      rtb_vq_park_o = 1.0F;\r\n    } else if (rtb_vq_park_o < 0.0F) {\r\n      rtb_vq_park_o = 0.0F;\r\n    }\r\n\r\n    /* End of Saturate: 'Saturation4' (':1872') */\r\n\r\n    /* LookupNDDirect: 'Direct Lookup Table (n-D)' (':1813') incorporates:\r\n     *  MATLAB Function: 'sector_selection' (':1809')\r\n     *\r\n     * About 'Direct Lookup Table (n-D)' (':1813'):\r\n     *  2-dimensional Direct Look-Up returning a Column,\r\n     *  which is contiguous for column-major array\r\n     *     Remove protection against out-of-range input in generated code: 'on'\r\n     *   */\r\n    y *= 3;\r\n    ctrl_ez_DW.iv[0] = 0;\r\n    ctrl_ez_DW.iv[1] = 1;\r\n    ctrl_ez_DW.iv[2] = 2;\r\n    mw_arm_bias_2_q31(&ctrl_ez_DW.iv[0], &y, &ctrl_ez_DW.iv1[0], 3U);\r\n\r\n    /* Sum: 'Add4' (':1804') */\r\n    rtb_vd_park_l = ctrl_ez_DW.TmpSignalConversionAtSelect[0] + rtb_vq_park_o;\r\n\r\n    /* SignalConversion generated from: 'Selector' (':1810') */\r\n    ctrl_ez_DW.Kalphabeta0[0] = rtb_Gain;\r\n    ctrl_ez_DW.Kalphabeta0[1] = rtb_vq_park_o;\r\n\r\n    /* Saturate: 'Saturation5' (':1873') */\r\n    if (rtb_vd_park_l > 1.0F) {\r\n      /* SignalConversion generated from: 'Selector' (':1810') */\r\n      ctrl_ez_DW.Kalphabeta0[2] = 1.0F;\r\n    } else if (rtb_vd_park_l < 0.0F) {\r\n      /* SignalConversion generated from: 'Selector' (':1810') */\r\n      ctrl_ez_DW.Kalphabeta0[2] = 0.0F;\r\n    } else {\r\n      /* SignalConversion generated from: 'Selector' (':1810') */\r\n      ctrl_ez_DW.Kalphabeta0[2] = rtb_vd_park_l;\r\n    }\r\n\r\n    /* End of Saturate: 'Saturation5' (':1873') */\r\n\r\n    /* Saturate: 'Saturation1' (':1937') incorporates:\r\n     *  LookupNDDirect: 'Direct Lookup Table (n-D)' (':1813')\r\n     *  Selector: 'Selector' (':1810')\r\n     *\r\n     * About 'Direct Lookup Table (n-D)' (':1813'):\r\n     *  2-dimensional Direct Look-Up returning a Column,\r\n     *  which is contiguous for column-major array\r\n     *     Remove protection against out-of-range input in generated code: 'on'\r\n     *   */\r\n    ctrl_ez_DW.fv[0] = ctrl_ez_DW.Kalphabeta0[(int32_t)\r\n      rtCP_DirectLookupTablenD_table[ctrl_ez_DW.iv1[0]] - 1];\r\n    ctrl_ez_DW.fv[1] = ctrl_ez_DW.Kalphabeta0[(int32_t)\r\n      rtCP_DirectLookupTablenD_table[ctrl_ez_DW.iv1[1]] - 1];\r\n    ctrl_ez_DW.fv[2] = ctrl_ez_DW.Kalphabeta0[(int32_t)\r\n      rtCP_DirectLookupTablenD_table[ctrl_ez_DW.iv1[2]] - 1];\r\n\r\n    /* Saturate: 'Saturation1' (':1937') incorporates:\r\n     *  Selector: 'Selector' (':1810')\r\n     */\r\n    mw_arm_saturate_f32(&ctrl_ez_DW.fv[0], (float *)&rtCP_Saturation1_LowerSat,\r\n                        (float *)&rtCP_Saturation1_UpperSat, &ctrl_ez_DW.T2[0],\r\n                        3U);\r\n\r\n    /* SignalConversion generated from: 'Qb' (':1369') */\r\n    *rty_Qb = ctrl_ez_DW.T2[1];\r\n\r\n    /* SignalConversion generated from: 'Qc' (':1370') */\r\n    *rty_Qc = ctrl_ez_DW.T2[2];\r\n\r\n    /* Update for DiscreteIntegrator: 'Accumulator' (':1374') */\r\n    if (ctrl_ez_DW.Accumulator_DSTATE > 50.0F) {\r\n      ctrl_ez_DW.Accumulator_DSTATE = 50.0F;\r\n    } else if (ctrl_ez_DW.Accumulator_DSTATE < -50.0F) {\r\n      ctrl_ez_DW.Accumulator_DSTATE = -50.0F;\r\n    }\r\n\r\n    /* End of Update for DiscreteIntegrator: 'Accumulator' (':1374') */\r\n\r\n    /* Update for Delay: 'Delay' (':1933') */\r\n    ctrl_ez_DW.Delay_DSTATE[0] = ctrl_ez_DW.Delay_DSTATE[1];\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1385') */\r\n    if (rtb_one_by_3 == 100.0F) {\r\n      /* Update for Delay: 'Delay' (':1933') */\r\n      ctrl_ez_DW.Delay_DSTATE[1] = 1.0F;\r\n    } else if (rtb_one_by_3 == -100.0F) {\r\n      /* Update for Delay: 'Delay' (':1933') */\r\n      ctrl_ez_DW.Delay_DSTATE[1] = -1.0F;\r\n    } else {\r\n      /* Update for Delay: 'Delay' (':1933') */\r\n      ctrl_ez_DW.Delay_DSTATE[1] = 0.0F;\r\n    }\r\n\r\n    /* Update for DiscreteIntegrator: 'Accumulator' (':1385') */\r\n    ctrl_ez_DW.Accumulator_DSTATE_a = rtb_one_by_3;\r\n\r\n    /* DiscreteIntegrator: 'Accumulator' (':1396') */\r\n    if (iq_integ == 500.0F) {\r\n      /* Update for Delay: 'Delay1' (':1399') */\r\n      ctrl_ez_DW.Delay1_DSTATE = 1.0F;\r\n    } else if (iq_integ == -500.0F) {\r\n      /* Update for Delay: 'Delay1' (':1399') */\r\n      ctrl_ez_DW.Delay1_DSTATE = -1.0F;\r\n    } else {\r\n      /* Update for Delay: 'Delay1' (':1399') */\r\n      ctrl_ez_DW.Delay1_DSTATE = 0.0F;\r\n    }\r\n\r\n    /* Update for DiscreteIntegrator: 'Accumulator' (':1396') */\r\n    ctrl_ez_DW.Accumulator_DSTATE_p = iq_integ;\r\n    if (rtb_Delay1 > 0.0F) {\r\n      ctrl_ez_DW.Accumulator_PrevResetState = 1;\r\n    } else if (rtb_Delay1 < 0.0F) {\r\n      ctrl_ez_DW.Accumulator_PrevResetState = -1;\r\n    } else if (rtb_Delay1 == 0.0F) {\r\n      ctrl_ez_DW.Accumulator_PrevResetState = 0;\r\n    } else {\r\n      ctrl_ez_DW.Accumulator_PrevResetState = 2;\r\n    }\r\n\r\n    /* End of Update for DiscreteIntegrator: 'Accumulator' (':1396') */\r\n\r\n    /* Update for UnitDelay: 'Unit Delay' (':1981:366') */\r\n    ctrl_ez_DW.UnitDelay_DSTATE_f = rtb_algDD_o1;\r\n\r\n    /* Update for Delay: 'Delay1' (':1377') */\r\n    ctrl_ez_DW.Delay1_DSTATE_e = (float)rtb_Accumulator_o2;\r\n  }\r\n\r\n  /* End of Logic: 'NOT' (':591') */\r\n  /* End of Outputs for SubSystem: 'ctrl' (':1270') */\r\n\r\n  /* SignalConversion generated from: 'Qa' (':570') */\r\n  *rty_Qa = ctrl_ez_DW.T2[0];\r\n\r\n  /* Update for UnitDelay: 'Unit Delay' (':831:366') */\r\n  ctrl_ez_DW.UnitDelay_DSTATE[0] = ctrl_ez_DW.Add1[0];\r\n  ctrl_ez_DW.UnitDelay_DSTATE[1] = ctrl_ez_DW.Add1[1];\r\n  ctrl_ez_DW.UnitDelay_DSTATE[2] = ctrl_ez_DW.Add1[2];\r\n\r\n  /* Update for Memory: 'Memory' (':561') */\r\n  ctrl_ez_DW.Memory_PreviousInput = *rty_lock;\r\n\r\n  /* End of Outputs for RootInportFunctionCallGenerator generated from: 'trigger_ctrl_ez' (':21') */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ctrl_ez.h","type":"header","group":"model","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_ref\\ctrl_ez","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ctrl_ez.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.628\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Apr 27 18:14:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ctrl_ez_h_\r\n#define ctrl_ez_h_\r\n#ifndef ctrl_ez_COMMON_INCLUDES_\r\n#define ctrl_ez_COMMON_INCLUDES_\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n#endif                                 /* ctrl_ez_COMMON_INCLUDES_ */\r\n\r\n#include \"ctrl_ez_types.h\"\r\n\r\n/*\r\n * Exported States\r\n *\r\n * Note: Exported states are block states with an exported global\r\n * storage class designation.  Code generation will declare the memory for these\r\n * states and exports their symbols.\r\n *\r\n */\r\nextern float filter_IA;                /* 'Data Store Memory' (':2047') */\r\nextern float filter_IB;                /* 'Data Store Memory1' (':2049') */\r\nextern float filter_IC;                /* 'Data Store Memory2' (':2051') */\r\nextern void ctrl_ez_Init(float *rty_Qa);\r\nextern void ctrl_ez_trigger_ctrl_ez(const float *rtu_ia, const float *rtu_ib,\r\n  const float *rtu_ic, const float *rtu_ov_out, const float *rtu_w, const float *\r\n  rtu_lock_pll, const float *rtu_sine, const float *rtu_cos, const float *rtu_va,\r\n  const float *rtu_vc, const float *rtu_vb, float *rty_Qa, float *rty_Qb, float *\r\n  rty_Qc, bool *rty_lock);\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block 'Delay' (':869') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'Gain' (':1968') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'indexing' (':2053:76:605') : Unused code path elimination\r\n * Block 'offset' (':2053:76:657') : Unused code path elimination\r\n * Block 'sine_table_values' (':2053:76:549') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'indexing' (':2056:76:605') : Unused code path elimination\r\n * Block 'offset' (':2056:76:657') : Unused code path elimination\r\n * Block 'sine_table_values' (':2056:76:549') : Unused code path elimination\r\n * Block 'Bias' (':1856') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'convert_pu' (':2053:76:652') : Eliminated nontunable gain of 1\r\n * Block 'convert_pu' (':2056:76:652') : Eliminated nontunable gain of 1\r\n * Block synthesized block : Eliminate redundant data type conversion\r\n * Block 'Offset' (':2068:753') : Unused code path elimination\r\n * Block 'One' (':1981:479') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'UseInputPort' (':1981:484') : Unused code path elimination\r\n * Block 'a' (':1981:844') : Unused code path elimination\r\n * Block 'One' (':831:479') : Unused code path elimination\r\n * Block synthesized block : Unused code path elimination\r\n * Block 'UseInputPort' (':831:484') : Unused code path elimination\r\n * Block 'a' (':831:844') : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is 'block_name' ('SID'), where block_name is the name of the block\r\n * and SID is the Simulink identifier of the block without the model name.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system(':3')    - opens block with Simulink identifier 'model:3'\r\n */\r\n\r\n/*-\r\n * Requirements for model: ctrl_ez\r\n\r\n\r\n */\r\n#endif                                 /* ctrl_ez_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ctrl_ez_private.h","type":"header","group":"model","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_ref\\ctrl_ez","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ctrl_ez_private.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.628\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Apr 27 18:14:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ctrl_ez_private_h_\r\n#define ctrl_ez_private_h_\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n#include \"ctrl_ez_types.h\"\r\n\r\n/* Block signals and states (default storage) for model 'ctrl_ez' */\r\ntypedef struct {\r\n  float T2[3];                         /* 'Saturation1' (':1937') */\r\n  float UnitDelay_DSTATE[3];           /* 'Unit Delay' (':831:366') */\r\n  float Delay_DSTATE[2];               /* 'Delay' (':1933') */\r\n  float Add1[3];                       /* 'Add1' (':831:360') */\r\n  float Kalphabeta0[3];                /* 'Kalphabeta0' (':2058:641') */\r\n  float Kalphabeta0_d[3];              /* 'Kalphabeta0' (':1278:641') */\r\n  float TmpSignalConversionAtSelect[3];\r\n  float fv[3];\r\n  float Accumulator_DSTATE;            /* 'Accumulator' (':1374') */\r\n  float Accumulator_DSTATE_a;          /* 'Accumulator' (':1385') */\r\n  float Delay1_DSTATE;                 /* 'Delay1' (':1399') */\r\n  float Accumulator_DSTATE_p;          /* 'Accumulator' (':1396') */\r\n  float UnitDelay_DSTATE_f;            /* 'Unit Delay' (':1981:366') */\r\n  float Delay1_DSTATE_e;               /* 'Delay1' (':1377') */\r\n  int32_t iv[3];\r\n  int32_t iv1[3];\r\n  int8_t Accumulator_PrevResetState;   /* 'Accumulator' (':1396') */\r\n  bool Memory_PreviousInput;           /* 'Memory' (':561') */\r\n} DW_ctrl_ez_f_T;\r\n\r\nextern const float rtCP_pooled_eByeztG9SgGB[3];\r\nextern const float rtCP_pooled_69zDzzp3SdVd;\r\nextern const float rtCP_pooled_HkVECsDp1mOJ;\r\nextern const float rtCP_pooled_c9mIltOBYHuW[18];\r\nextern const float rtCP_pooled_IpZ2KYFD0cMi;\r\nextern const float rtCP_pooled_XyS18C52bdd7;\r\n\r\n#define rtCP_Kalphabeta0_Gain          rtCP_pooled_eByeztG9SgGB  /* Computed Parameter: rtCP_Kalphabeta0_Gain\r\n                                                                  * Referenced by: 'Kalphabeta0' (':1278:641')\r\n                                                                  */\r\n#define rtCP_Saturation_UpperSat       rtCP_pooled_69zDzzp3SdVd  /* Computed Parameter: rtCP_Saturation_UpperSat\r\n                                                                  * Referenced by: 'Saturation' (':1823')\r\n                                                                  */\r\n#define rtCP_Saturation_LowerSat       rtCP_pooled_HkVECsDp1mOJ  /* Computed Parameter: rtCP_Saturation_LowerSat\r\n                                                                  * Referenced by: 'Saturation' (':1823')\r\n                                                                  */\r\n#define rtCP_DirectLookupTablenD_table rtCP_pooled_c9mIltOBYHuW  /* Computed Parameter: rtCP_DirectLookupTablenD_table\r\n                                                                  * Referenced by: 'Direct Lookup Table (n-D)' (':1813')\r\n                                                                  */\r\n#define rtCP_Saturation1_UpperSat      rtCP_pooled_IpZ2KYFD0cMi  /* Computed Parameter: rtCP_Saturation1_UpperSat\r\n                                                                  * Referenced by: 'Saturation1' (':1937')\r\n                                                                  */\r\n#define rtCP_Saturation1_LowerSat      rtCP_pooled_XyS18C52bdd7  /* Computed Parameter: rtCP_Saturation1_LowerSat\r\n                                                                  * Referenced by: 'Saturation1' (':1937')\r\n                                                                  */\r\n#define rtCP_Kalphabeta0_Gain_h        rtCP_pooled_eByeztG9SgGB  /* Computed Parameter: rtCP_Kalphabeta0_Gain_h\r\n                                                                  * Referenced by: 'Kalphabeta0' (':2058:641')\r\n                                                                  */\r\n\r\n/* Block states (default storage) */\r\nextern DW_ctrl_ez_f_T ctrl_ez_DW;\r\n\r\n#endif                                 /* ctrl_ez_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ctrl_ez_types.h","type":"header","group":"model","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_ref\\ctrl_ez","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ctrl_ez_types.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.628\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Apr 27 18:14:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ctrl_ez_types_h_\r\n#define ctrl_ez_types_h_\r\n#endif                                 /* ctrl_ez_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"const_params.c","type":"source","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_shared","tag":"","groupDisplay":"Shared files","code":"/*\r\n * const_params.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"ctrl_ez\".\r\n *\r\n * Model version              : 1.628\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Sun Apr 27 14:15:04 2025\r\n */\r\n#include <stdbool.h>\n#include <stdint.h>\n\nextern const float rtCP_pooled_69zDzzp3SdVd;\nconst float rtCP_pooled_69zDzzp3SdVd =   1.0F;\n\nextern const float rtCP_pooled_HkVECsDp1mOJ;\nconst float rtCP_pooled_HkVECsDp1mOJ =   0.0F;\n\nextern const float rtCP_pooled_IpZ2KYFD0cMi;\nconst float rtCP_pooled_IpZ2KYFD0cMi =   0.97F;\n\nextern const float rtCP_pooled_XyS18C52bdd7;\nconst float rtCP_pooled_XyS18C52bdd7 =   0.03F;\n\nextern const float rtCP_pooled_c9mIltOBYHuW[18];\nconst float rtCP_pooled_c9mIltOBYHuW[18] = {   3.0F, 2.0F, 1.0F, 2.0F, 3.0F, 1.0F, 1.0F, 3.0F, 2.0F, 1.0F, 2.0F, 3.0F, 2.0F, 1.0F, 3.0F, 3.0F, 1.0F, 2.0F } ;\n\nextern const float rtCP_pooled_eByeztG9SgGB[3];\nconst float rtCP_pooled_eByeztG9SgGB[3] = {   1.22474492F, 1.22474492F, 1.73205078F } ;\n"},{"name":"intrp1d_fu32fl.c","type":"source","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_shared","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: intrp1d_fu32fl.c\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.628\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Apr 27 14:15:04 2025\r\n */\r\n\r\n#include \"intrp1d_fu32fl.h\"\r\n#include <stdint.h>\r\n\r\nfloat intrp1d_fu32fl(uint32_t bpIndex, float frac, const float table[])\r\n{\r\n  float yL_0d0;\r\n\r\n  /* Column-major Interpolation 1-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Overflow mode: 'wrapping'\r\n   */\r\n  yL_0d0 = table[bpIndex];\r\n  return (table[bpIndex + 1U] - yL_0d0) * frac + yL_0d0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"intrp1d_fu32fl.h","type":"header","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_shared","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: intrp1d_fu32fl.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.628\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Apr 27 14:15:04 2025\r\n */\r\n\r\n#ifndef intrp1d_fu32fl_h_\r\n#define intrp1d_fu32fl_h_\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n\r\nextern float intrp1d_fu32fl(uint32_t bpIndex, float frac, const float table[]);\r\n\r\n#endif                                 /* intrp1d_fu32fl_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mw_cmsis.h","type":"header","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_shared","tag":"","groupDisplay":"Shared files","code":"/* Copyright 2015-2023 The MathWorks, Inc. */\n\n/****************************************************\n*                                                   *   \n* Wrapper functions for CMSIS functions             *\n*                                                   *  \n****************************************************/\n\n#ifndef MW_CMSIS_H\n#define MW_CMSIS_H\n\n#include \"arm_math.h\"\n#include <stdint.h>\n #include <stdbool.h>\n\n#define mw_arm_vlog_f32(pSrc, pDst, blockSize) arm_vlog_f32((float32_t *)pSrc, (float32_t *)pDst, blockSize)\n#define mw_arm_vexp_f32(pSrc, pDst, blockSize) arm_vexp_f32((float32_t *)pSrc, (float32_t *)pDst, blockSize)\n\n#define mw_arm_abs_f32(pSrc, pDst, blockSize) arm_abs_f32((float32_t *)pSrc, (float32_t *)pDst, blockSize)\n#define mw_arm_abs_q7(pSrc, pDst, blockSize) arm_abs_q7((q7_t *)pSrc, (q7_t *)pDst, blockSize) \n#define mw_arm_abs_q15(pSrc, pDst, blockSize) arm_abs_q15((q15_t *)pSrc, (q15_t *)pDst, blockSize) \n#define mw_arm_abs_q31(pSrc, pDst, blockSize) arm_abs_q31((q31_t *)pSrc, (q31_t *)pDst, blockSize) \n\n#define mw_arm_sqrt_f32(pIn, pOut, blockSize) {\\\nif ((blockSize) == 1) { \\\n    arm_sqrt_f32(*(pIn), (pOut)); \\\n} else { \\\n    uint32_t i;\\\n    float32_t *pInput, *pOutput;\\\n    pInput = (float32_t *)pIn;\\\n    pOutput = (float32_t *)pOut;\\\n    for(i=0;i<blockSize;i++){\\\n        arm_sqrt_f32((float32_t)pInput[i],pOutput);\\\n        pOutput++;}\\\n    }\\\n}\n\n#define mw_arm_float_to_q31(pSrc, pDst, blockSize) arm_float_to_q31((float32_t *)pSrc, (q31_t *)pDst, blockSize)\n#define mw_arm_float_to_q15(pSrc, pDst, blockSize) arm_float_to_q15((float32_t *)pSrc, (q15_t *)pDst, blockSize)\n#define mw_arm_float_to_q7(pSrc, pDst, blockSize) arm_float_to_q7((float32_t *)pSrc, (q7_t *)pDst, blockSize)\n\n#define mw_arm_q15_to_float(pSrc, pDst, blockSize) arm_q15_to_float((q15_t *)pSrc, (float32_t *)pDst, blockSize)\n#define mw_arm_q15_to_q31(pSrc, pDst, blockSize) arm_q15_to_q31((q15_t *)pSrc, (q31_t *)pDst, blockSize)\n#define mw_arm_q15_to_q7(pSrc, pDst, blockSize) arm_q15_to_q7((q15_t *)pSrc, (q7_t *)pDst, blockSize)\n\n#define mw_arm_q31_to_float(pSrc, pDst, blockSize) arm_q31_to_float((q31_t *)pSrc, (float32_t *)pDst, blockSize)\n#define mw_arm_q31_to_q15(pSrc, pDst, blockSize) arm_q31_to_q15((q31_t *)pSrc, (q15_t *)pDst, blockSize)\n#define mw_arm_q31_to_q7(pSrc, pDst, blockSize) arm_q31_to_q7((q31_t *)pSrc, (q7_t *)pDst, blockSize)\n\n#define mw_arm_q7_to_float(pSrc, pDst, blockSize) arm_q7_to_float((q7_t *)pSrc, (float32_t *)pDst, blockSize)\n#define mw_arm_q7_to_q31(pSrc, pDst, blockSize) arm_q7_to_q31((q7_t *)pSrc, (q31_t *)pDst, blockSize)\n#define mw_arm_q7_to_q15(pSrc, pDst, blockSize) arm_q7_to_q15((q7_t *)pSrc, (q15_t *)pDst, blockSize)\n\n#define mw_arm_add_f32(pSrcA, pSrcB, pDst, blockSize) arm_add_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\n#define mw_arm_add_q31(pSrcA, pSrcB, pDst, blockSize) arm_add_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\n#define mw_arm_add_q15(pSrcA, pSrcB, pDst, blockSize) arm_add_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\n#define mw_arm_add_q7(pSrcA, pSrcB, pDst, blockSize)  arm_add_q7((q7_t *)pSrcA, (q7_t *)pSrcB, (q7_t *)pDst, blockSize)\n\n#define mw_arm_sub_f32(pSrcA, pSrcB, pDst, blockSize) arm_sub_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\n#define mw_arm_sub_q31(pSrcA, pSrcB, pDst, blockSize) arm_sub_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\n#define mw_arm_sub_q15(pSrcA, pSrcB, pDst, blockSize) arm_sub_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\n#define mw_arm_sub_q7(pSrcA, pSrcB, pDst, blockSize)  arm_sub_q7((q7_t *)pSrcA, (q7_t *)pSrcB, (q7_t *)pDst, blockSize)\n\n#define mw_arm_mult_f32(pSrcA, pSrcB, pDst, blockSize) arm_mult_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\n#define mw_arm_mult_q31(pSrcA, pSrcB, pDst, blockSize) arm_mult_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\n#define mw_arm_mult_q15(pSrcA, pSrcB, pDst, blockSize) arm_mult_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\n#define mw_arm_mult_q7(pSrcA, pSrcB, pDst, blockSize)  arm_mult_q7((q7_t *)pSrcA, (q7_t *)pSrcB, (q7_t *)pDst, blockSize)\n\n#define mw_arm_cmplx_conj_f32(pSrc, pDst, numSamples) arm_cmplx_conj_f32((float32_t *)pSrc, (float32_t *)pDst, numSamples)\n#define mw_arm_cmplx_conj_q31(pSrc, pDst, numSamples) arm_cmplx_conj_q31((q31_t *)pSrc, (q31_t *)pDst, numSamples)\n#define mw_arm_cmplx_conj_q15(pSrc, pDst, numSamples) arm_cmplx_conj_q15((q15_t *)pSrc, (q15_t *)pDst, numSamples)\n\n#define mw_arm_cmplx_mult_cmplx_f32(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_cmplx_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\n#define mw_arm_cmplx_mult_cmplx_q31(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_cmplx_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\n#define mw_arm_cmplx_mult_cmplx_q15(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_cmplx_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\n\n#define mw_arm_cmplx_mult_real_f32(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_real_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\n#define mw_arm_cmplx_mult_real_q31(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_real_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\n#define mw_arm_cmplx_mult_real_q15(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_real_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\n\n#define mw_arm_rshift_q15(pSrc, shiftBits, pDst, blockSize) arm_shift_q15 ((q15_t *)pSrc, -(shiftBits),(q15_t *)pDst, blockSize)\n#define mw_arm_rshift_q31(pSrc, shiftBits, pDst, blockSize) arm_shift_q31 ((q31_t *)pSrc, -(shiftBits), (q31_t *)pDst, blockSize)\n#define mw_arm_rshift_q7(pSrc, shiftBits, pDst, blockSize) arm_shift_q7 ((q7_t *)pSrc,  -(shiftBits), (q7_t *)pDst, blockSize)\n\n#define mw_arm_shift_q15(pSrc, shiftBits, pDst, blockSize) arm_shift_q15 ((q15_t *)pSrc, shiftBits,(q15_t *)pDst, blockSize)\n#define mw_arm_shift_q31(pSrc, shiftBits, pDst, blockSize) arm_shift_q31 ((q31_t *)pSrc, shiftBits, (q31_t *)pDst, blockSize)\n#define mw_arm_shift_q7(pSrc, shiftBits, pDst, blockSize) arm_shift_q7 ((q7_t *)pSrc, shiftBits, (q7_t *)pDst, blockSize)\n\n#define mw_arm_scale_1_f32(scaleValue, pSrc, pDst, blockSize) arm_scale_f32 ((float32_t *)pSrc, *scaleValue, (float32_t *)pDst, blockSize)\n#define mw_arm_scale_1_q7(scaleValue, pSrc, pDst, blockSize, scaleShift) arm_scale_q7 ((q7_t *)pSrc, *scaleValue, scaleShift, (q7_t *)pDst, blockSize)\n#define mw_arm_scale_1_q15(scaleValue, pSrc, pDst, blockSize, scaleShift) arm_scale_q15 ((q15_t *)pSrc, *scaleValue, scaleShift, (q15_t *)pDst, blockSize)\n#define mw_arm_scale_1_q31(scaleValue, pSrc, pDst, blockSize, scaleShift) arm_scale_q31 ((q31_t *)pSrc, *scaleValue, scaleShift, (q31_t *)pDst, blockSize)\n\n#define mw_arm_scale_2_f32(pSrc, scaleValue, pDst, blockSize) arm_scale_f32 ((float32_t *)pSrc, *scaleValue, (float32_t *)pDst, blockSize)\n#define mw_arm_scale_2_q7(pSrc, scaleValue, pDst, blockSize, scaleShift) arm_scale_q7 ((q7_t *)pSrc, *scaleValue, scaleShift, (q7_t *)pDst, blockSize)\n#define mw_arm_scale_2_q15(pSrc, scaleValue, pDst, blockSize, scaleShift) arm_scale_q15 ((q15_t *)pSrc, *scaleValue, scaleShift, (q15_t *)pDst, blockSize)\n#define mw_arm_scale_2_q31(pSrc, scaleValue, pDst, blockSize, scaleShift) arm_scale_q31 ((q31_t *)pSrc, *scaleValue, scaleShift, (q31_t *)pDst, blockSize)\n\n#define mw_arm_bias_1_f32(biasValue, pSrc, pDst, blockSize) arm_offset_f32 ((float32_t *)pSrc, *biasValue, (float32_t *)pDst, blockSize)\n#define mw_arm_bias_1_q7(biasValue, pSrc, pDst, blockSize) arm_offset_q7 ((q7_t *)pSrc, *biasValue, (q7_t *)pDst, blockSize)\n#define mw_arm_bias_1_q15(biasValue, pSrc, pDst, blockSize) arm_offset_q15 ((q15_t *)pSrc, *biasValue, (q15_t *)pDst, blockSize)\n#define mw_arm_bias_1_q31(biasValue, pSrc, pDst, blockSize) arm_offset_q31 ((q31_t *)pSrc, *biasValue, (q31_t *)pDst, blockSize)\n\n#define mw_arm_bias_2_f32(pSrc, biasValue, pDst, blockSize) arm_offset_f32 ((float32_t *)pSrc, *biasValue, (float32_t *)pDst, blockSize)\n#define mw_arm_bias_2_q7(pSrc, biasValue, pDst, blockSize) arm_offset_q7 ((q7_t *)pSrc, *biasValue, (q7_t *)pDst, blockSize)\n#define mw_arm_bias_2_q15(pSrc, biasValue, pDst, blockSize) arm_offset_q15 ((q15_t *)pSrc, *biasValue, (q15_t *)pDst, blockSize)\n#define mw_arm_bias_2_q31(pSrc, biasValue, pDst, blockSize) arm_offset_q31 ((q31_t *)pSrc, *biasValue, (q31_t *)pDst, blockSize)\n\n#define mw_arm_dot_prod_f32(pSrcA, pSrcB, pDst, blockSize) arm_dot_prod_f32 ((float32_t *)pSrcA,  (float32_t *)pSrcB, blockSize, (float32_t *)pDst)\n#define mw_arm_dot_prod_q7(pSrcA, pSrcB, pDst, blockSize) arm_dot_prod_q7 ((q7_t *)pSrcA,  (q7_t *)pSrcB, blockSize, (q31_t *)(pDst))\n#define mw_arm_dot_prod_q15(pSrcA, pSrcB, pDst, blockSize) arm_dot_prod_q15 ((q15_t *)pSrcA, (q15_t *) pSrcB, blockSize, (q63_t *) (pDst))\n#define mw_arm_dot_prod_q31(pSrcA, pSrcB, pDst, blockSize) arm_dot_prod_q31 ((q31_t *)pSrcA,  (q31_t *)pSrcB, blockSize, (q63_t *)(pDst))\n\n#define mw_arm_saturate_q15(pSrcIn, pSrcMin, pSrcMax, pDst, blockSize) arm_clip_q15 ((q15_t *)pSrcIn, (q15_t *)pDst, (q15_t)(*pSrcMin), (q15_t)(*pSrcMax), blockSize)\n#define mw_arm_saturate_q31(pSrcIn, pSrcMin, pSrcMax, pDst, blockSize) arm_clip_q31 ((q31_t *)pSrcIn, (q31_t *)pDst, (q31_t)(*pSrcMin), (q31_t)(*pSrcMax), blockSize)\n#define mw_arm_saturate_q7(pSrcIn, pSrcMin, pSrcMax, pDst, blockSize) arm_clip_q7 ((q7_t *)pSrcIn, (q7_t *)pDst, (q7_t)(*pSrcMin), (q7_t)(*pSrcMax), blockSize)\n#define mw_arm_saturate_f32(pSrcIn, pSrcMin, pSrcMax, pDst, blockSize) arm_clip_f32 ((float32_t *)pSrcIn, (float32_t *)pDst, *pSrcMin, *pSrcMax, blockSize)\n\n#define mw_arm_uminus_f32(pSrc, pDst, blockSize) arm_negate_f32((float32_t *)pSrc, (float32_t *)pDst, blockSize)\n#define mw_arm_uminus_q31(pSrc, pDst, blockSize) arm_negate_q31((q31_t *)pSrc, (q31_t *)pDst, blockSize)\n#define mw_arm_uminus_q15(pSrc, pDst, blockSize) arm_negate_q15((q15_t *)pSrc, (q15_t *)pDst, blockSize)\n#define mw_arm_uminus_q7(pSrc, pDst, blockSize)  arm_negate_q7((q7_t *)pSrc, (q7_t *)pDst, blockSize)\n\n#define mw_arm_and_uint32(pSrcA, pSrcB, pDst, blockSize) arm_and_u32((uint32_t *)(uint32_t *)pSrcA, (uint32_t *)pSrcB, (uint32_t *)pDst, blockSize)\n#define mw_arm_and_uint16(pSrcA, pSrcB, pDst, blockSize) arm_and_u16((uint16_t *)pSrcA, (uint16_t *)pSrcB, (uint16_t *)pDst, blockSize)\n#define mw_arm_and_uint8(pSrcA, pSrcB, pDst, blockSize) arm_and_u8((uint8_t *)pSrcA, (uint8_t *)pSrcB, (uint8_t *)pDst, blockSize)\n\n#define mw_arm_or_uint32(pSrcA, pSrcB, pDst, blockSize) arm_or_u32((uint32_t *)pSrcA, (uint32_t *)pSrcB, (uint32_t *)pDst, blockSize)\n#define mw_arm_or_uint16(pSrcA, pSrcB, pDst, blockSize) arm_or_u16((uint16_t *)pSrcA, (uint16_t *)pSrcB, (uint16_t *)pDst, blockSize)\n#define mw_arm_or_uint8(pSrcA, pSrcB, pDst, blockSize) arm_or_u8((uint8_t *)pSrcA, (uint8_t *)pSrcB, (uint8_t *)pDst, blockSize)\n\n#define mw_arm_xor_uint32(pSrcA, pSrcB, pDst, blockSize) arm_xor_u32((uint32_t *)pSrcA, (uint32_t *)pSrcB, (uint32_t *)pDst, blockSize)\n#define mw_arm_xor_uint16(pSrcA, pSrcB, pDst, blockSize) arm_xor_u16((uint16_t *)pSrcA, (uint16_t *)pSrcB, (uint16_t *)pDst, blockSize)\n#define mw_arm_xor_uint8(pSrcA, pSrcB, pDst, blockSize) arm_xor_u8((uint8_t *)pSrcA, (uint8_t *)pSrcB, (uint8_t *)pDst, blockSize)\n\n#define mw_arm_not_uint32(pSrc, pDst, blockSize) arm_not_u32((uint32_t *)pSrc, (uint32_t *)pDst, blockSize)\n#define mw_arm_not_uint16(pSrc, pDst, blockSize) arm_not_u16((uint16_t *)pSrc, (uint16_t *)pDst, blockSize)\n#define mw_arm_not_uint8(pSrc, pDst, blockSize) arm_not_u8((uint8_t *)pSrc, (uint8_t *)pDst, blockSize)\n\n#define mw_arm_saturate_q15(pSrcIn, pSrcMin, pSrcMax, pDst, blockSize) arm_clip_q15 ((q15_t *)pSrcIn, (q15_t *)pDst, (q15_t)(*pSrcMin), (q15_t)(*pSrcMax), blockSize)\n#define mw_arm_saturate_q31(pSrcIn, pSrcMin, pSrcMax, pDst, blockSize) arm_clip_q31 ((q31_t *)pSrcIn, (q31_t *)pDst, (q31_t)(*pSrcMin), (q31_t)(*pSrcMax), blockSize)\n#define mw_arm_saturate_q7(pSrcIn, pSrcMin, pSrcMax, pDst, blockSize) arm_clip_q7 ((q7_t *)pSrcIn, (q7_t *)pDst, (q7_t)(*pSrcMin), (q7_t)(*pSrcMax), blockSize)\n#define mw_arm_saturate_f32(pSrcIn, pSrcMin, pSrcMax, pDst, blockSize) arm_clip_f32 ((float32_t *)pSrcIn, (float32_t *)pDst, *pSrcMin, *pSrcMax, blockSize)\n\n#endif\n"},{"name":"plook_u32ff_evenc.c","type":"source","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_shared","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: plook_u32ff_evenc.c\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.628\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Apr 27 14:15:04 2025\r\n */\r\n\r\n#include \"plook_u32ff_evenc.h\"\r\n#include <stdint.h>\r\n\r\nuint32_t plook_u32ff_evenc(float u, float bp0, float bpSpace, uint32_t maxIndex,\r\n  float *fraction)\r\n{\r\n  float fbpIndex;\r\n  float invSpc;\r\n  uint32_t bpIndex;\r\n\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'even'\r\n     Extrapolation method: 'Clip'\r\n     Use previous index: 'off'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u <= bp0) {\r\n    bpIndex = 0U;\r\n    *fraction = 0.0F;\r\n  } else {\r\n    invSpc = 1.0F / bpSpace;\r\n    fbpIndex = (u - bp0) * invSpc;\r\n    if (fbpIndex < maxIndex) {\r\n      bpIndex = (uint32_t)fbpIndex;\r\n      *fraction = (u - ((float)(uint32_t)fbpIndex * bpSpace + bp0)) * invSpc;\r\n    } else {\r\n      bpIndex = maxIndex - 1U;\r\n      *fraction = 1.0F;\r\n    }\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"plook_u32ff_evenc.h","type":"header","group":"sharedutility","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_shared","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: plook_u32ff_evenc.h\r\n *\r\n * Code generated for Simulink model 'ctrl_ez'.\r\n *\r\n * Model version                  : 1.628\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Apr 27 14:15:04 2025\r\n */\r\n\r\n#ifndef plook_u32ff_evenc_h_\r\n#define plook_u32ff_evenc_h_\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n\r\nextern uint32_t plook_u32ff_evenc(float u, float bp0, float bpSpace, uint32_t\r\n  maxIndex, float *fraction);\r\n\r\n#endif                                 /* plook_u32ff_evenc_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Source","type":"other","group":"legacy","path":"C:\\Users\\Angel\\Desktop\\hil\\pfc3ph\\stf7\\matlab\\ctrl_ez\\ARMCortex-M\\_ref\\ctrl_ez\\..\\..\\..\\..\\..\\stf7\\pfc3van\\Drivers\\CMSIS","tag":"","groupDisplay":"Other files"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};