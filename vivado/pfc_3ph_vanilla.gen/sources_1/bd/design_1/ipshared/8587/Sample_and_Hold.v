// -------------------------------------------------------------
// 
// File Name: verilog_1\hdlsrc\gm_pfcvan3ph_s\Sample_and_Hold.v
// Created: 2024-12-08 17:13:30
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Sample_and_Hold
// Source Path: gm_pfcvan3ph_s/FPGA/HDL Subsystem/HDL Algorithm/DA_MATRIX/Sample and Hold
// Hierarchy Level: 4
// Model version: 1.182
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Sample_and_Hold
          (clk,
           reset,
           enb,
           enb_1_200_1,
           enb_1_200_0,
           In_0,
           In_1,
           In_2,
           In_3,
           In_4,
           In_5,
           In_6,
           In_7,
           In_8,
           In_9,
           In_10,
           In_11,
           In_12,
           In_13,
           In_14,
           Trigger,
           alpha_0,
           alpha_1,
           alpha_2,
           alpha_3,
           alpha_4,
           alpha_5,
           alpha_6,
           alpha_7,
           alpha_8,
           alpha_9,
           alpha_10,
           alpha_11,
           alpha_12,
           alpha_13,
           alpha_14);


  input   clk;
  input   reset;
  input   enb;
  input   enb_1_200_1;
  input   enb_1_200_0;
  input   signed [29:0] In_0;  // sfix30_En13
  input   signed [29:0] In_1;  // sfix30_En13
  input   signed [29:0] In_2;  // sfix30_En13
  input   signed [29:0] In_3;  // sfix30_En13
  input   signed [29:0] In_4;  // sfix30_En13
  input   signed [29:0] In_5;  // sfix30_En13
  input   signed [29:0] In_6;  // sfix30_En13
  input   signed [29:0] In_7;  // sfix30_En13
  input   signed [29:0] In_8;  // sfix30_En13
  input   signed [29:0] In_9;  // sfix30_En13
  input   signed [29:0] In_10;  // sfix30_En13
  input   signed [29:0] In_11;  // sfix30_En13
  input   signed [29:0] In_12;  // sfix30_En13
  input   signed [29:0] In_13;  // sfix30_En13
  input   signed [29:0] In_14;  // sfix30_En13
  input   Trigger;
  output  signed [29:0] alpha_0;  // sfix30_En13
  output  signed [29:0] alpha_1;  // sfix30_En13
  output  signed [29:0] alpha_2;  // sfix30_En13
  output  signed [29:0] alpha_3;  // sfix30_En13
  output  signed [29:0] alpha_4;  // sfix30_En13
  output  signed [29:0] alpha_5;  // sfix30_En13
  output  signed [29:0] alpha_6;  // sfix30_En13
  output  signed [29:0] alpha_7;  // sfix30_En13
  output  signed [29:0] alpha_8;  // sfix30_En13
  output  signed [29:0] alpha_9;  // sfix30_En13
  output  signed [29:0] alpha_10;  // sfix30_En13
  output  signed [29:0] alpha_11;  // sfix30_En13
  output  signed [29:0] alpha_12;  // sfix30_En13
  output  signed [29:0] alpha_13;  // sfix30_En13
  output  signed [29:0] alpha_14;  // sfix30_En13


  wire Trigger_delay_ctrl_const_out;
  reg  Trigger_delay_ctrl_const_out_1;
  reg  Trigger_delay_ctrl_const_out_2;
  wire Trigger_delay_ctrl_delay_out;
  reg  Trigger_delay_ctrl_delay_out_1;
  wire Trigger_delay_Initial_Val_out;
  reg  Trigger_delay_bypass_reg;  // ufix1
  wire Trigger_delay_out;
  wire Trigger_delay_out_1;
  reg  Trigger_delay_out_2;
  wire Trigger_delayed;
  reg  Trigger_delayed_1;
  wire Trigger_delayed_inverted;
  reg  Trigger_delayed_inverted_1;
  reg  [1:0] rd_6_reg;  // ufix1 [2]
  wire Trigger_1;
  wire Trigger_emulated;
  reg  Trigger_emulated_1;
  wire out0_bypass_ctrl_const_out;
  reg  out0_bypass_ctrl_const_out_1;
  reg  out0_bypass_ctrl_const_out_2;
  wire out0_bypass_ctrl_delay_out;
  reg  [1:0] rd_9_reg;  // ufix1 [2]
  wire out0_bypass_ctrl_delay_out_1;
  wire signed [29:0] out0_bypass_Initial_Val_out [0:14];  // sfix30_En13 [15]
  reg signed [29:0] rd_10_reg [0:14];  // sfix30 [15]
  wire signed [29:0] rd_10_reg_next [0:14];  // sfix30_En13 [15]
  wire signed [29:0] out0_bypass_Initial_Val_out_1 [0:14];  // sfix30_En13 [15]
  wire signed [29:0] In [0:14];  // sfix30_En13 [15]
  reg signed [29:0] rd_5_reg [0:44];  // sfix30 [45]
  reg signed [29:0] rd_5_reg_next [0:44];  // sfix30_En13 [45]
  reg signed [29:0] In_15 [0:14];  // sfix30_En13 [15]
  reg signed [29:0] out0_bypass_out [0:14];  // sfix30_En13 [15]
  reg signed [29:0] In_16 [0:14];  // sfix30_En13 [15]
  reg signed [29:0] rd_11_reg [0:14];  // sfix30 [15]
  wire signed [29:0] rd_11_reg_next [0:14];  // sfix30_En13 [15]
  wire signed [29:0] In_17 [0:14];  // sfix30_En13 [15]
  reg signed [29:0] out0_bypass_bypass_reg [0:14];  // sfix30 [15]
  reg signed [29:0] out0_bypass_bypass_reg_next [0:14];  // sfix30_En13 [15]
  wire signed [29:0] out0_bypass_out_1 [0:14];  // sfix30_En13 [15]
  reg signed [29:0] rd_12_reg [0:29];  // sfix30 [30]
  reg signed [29:0] rd_12_reg_next [0:29];  // sfix30_En13 [30]
  reg signed [29:0] out0_bypass_out_2 [0:14];  // sfix30_En13 [15]
  reg signed [29:0] In_last_value [0:14];  // sfix30_En13 [15]
  reg signed [29:0] rd_13_reg [0:29];  // sfix30 [30]
  reg signed [29:0] rd_13_reg_next [0:29];  // sfix30_En13 [30]
  reg signed [29:0] In_last_value_1 [0:14];  // sfix30_En13 [15]
  reg signed [31:0] rd_10_t_0_1;  // int32
  reg signed [31:0] rd_10_t_1;  // int32
  reg signed [31:0] rd_5_t_0_0;  // int32
  reg signed [31:0] rd_5_t_1;  // int32
  reg signed [31:0] rd_5_t_0_1;  // int32
  reg signed [31:0] rd_5_t_1_0;  // int32
  reg signed [31:0] rd_11_t_0_1;  // int32
  reg signed [31:0] rd_11_t_1;  // int32
  reg signed [31:0] out0_bypass_bypass_t_0_0;  // int32
  reg signed [31:0] out0_bypass_bypass_t_1;  // int32
  reg signed [31:0] out0_bypass_bypass_t_2;  // int32
  reg signed [31:0] out0_bypass_bypass_t_0_1;  // int32
  reg signed [31:0] out0_bypass_bypass_t_1_0;  // int32
  reg signed [31:0] rd_12_t_0_0;  // int32
  reg signed [31:0] rd_12_t_0_1;  // int32
  reg signed [31:0] rd_12_t_1;  // int32
  reg signed [31:0] out0_bypass_switch_t_0_0;  // int32
  reg signed [31:0] out0_bypass_switch_t_1;  // int32
  reg signed [31:0] rd_13_t_0_0;  // int32
  reg signed [31:0] rd_13_t_0_1;  // int32
  reg signed [31:0] rd_13_t_1;  // int32
  reg signed [31:0] InbypassMux_t_0_0;  // int32
  reg signed [31:0] InbypassMux_t_1;  // int32


  assign Trigger_delay_ctrl_const_out = 1'b1;

  always @(posedge clk or posedge reset)
    begin : Trigger_delay_ctrl_delay_output_process
      if (reset == 1'b1) begin
        Trigger_delay_ctrl_const_out_1 <= 1'b0;
      end
      else begin
        if (enb_1_200_1) begin
          Trigger_delay_ctrl_const_out_1 <= Trigger_delay_ctrl_const_out;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        Trigger_delay_ctrl_const_out_2 <= 1'b0;
      end
      else begin
        if (enb_1_200_0) begin
          Trigger_delay_ctrl_const_out_2 <= Trigger_delay_ctrl_const_out_1;
        end
      end
    end

  assign Trigger_delay_ctrl_delay_out = Trigger_delay_ctrl_const_out_2;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        Trigger_delay_ctrl_delay_out_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_delay_ctrl_delay_out_1 <= Trigger_delay_ctrl_delay_out;
        end
      end
    end

  assign Trigger_delay_Initial_Val_out = 1'b1;

  always @(posedge clk or posedge reset)
    begin : Trigger_delay_bypass_process
      if (reset == 1'b1) begin
        Trigger_delay_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_200_1) begin
          Trigger_delay_bypass_reg <= Trigger;
        end
      end
    end

  assign Trigger_delay_out = (enb_1_200_1 == 1'b1 ? Trigger :
              Trigger_delay_bypass_reg);

  assign Trigger_delay_out_1 = Trigger_delay_out;

  always @(posedge clk or posedge reset)
    begin : rd_0_process
      if (reset == 1'b1) begin
        Trigger_delay_out_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_delay_out_2 <= Trigger_delay_out_1;
        end
      end
    end

  assign Trigger_delayed = (Trigger_delay_ctrl_delay_out_1 == 1'b0 ? Trigger_delay_Initial_Val_out :
              Trigger_delay_out_2);

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        Trigger_delayed_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_delayed_1 <= Trigger_delayed;
        end
      end
    end

  assign Trigger_delayed_inverted =  ~ Trigger_delayed_1;

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        Trigger_delayed_inverted_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_delayed_inverted_1 <= Trigger_delayed_inverted;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_6_process
      if (reset == 1'b1) begin
        rd_6_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          rd_6_reg[0] <= Trigger;
          rd_6_reg[1] <= rd_6_reg[0];
        end
      end
    end

  assign Trigger_1 = rd_6_reg[1];

  assign Trigger_emulated = Trigger_delayed_inverted_1 & Trigger_1;

  always @(posedge clk or posedge reset)
    begin : rd_7_process
      if (reset == 1'b1) begin
        Trigger_emulated_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_emulated_1 <= Trigger_emulated;
        end
      end
    end

  assign out0_bypass_ctrl_const_out = 1'b1;

  always @(posedge clk or posedge reset)
    begin : out0_bypass_ctrl_delay_output_process
      if (reset == 1'b1) begin
        out0_bypass_ctrl_const_out_1 <= 1'b0;
      end
      else begin
        if (enb_1_200_1) begin
          out0_bypass_ctrl_const_out_1 <= out0_bypass_ctrl_const_out;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_8_process
      if (reset == 1'b1) begin
        out0_bypass_ctrl_const_out_2 <= 1'b0;
      end
      else begin
        if (enb_1_200_0) begin
          out0_bypass_ctrl_const_out_2 <= out0_bypass_ctrl_const_out_1;
        end
      end
    end

  assign out0_bypass_ctrl_delay_out = out0_bypass_ctrl_const_out_2;

  always @(posedge clk or posedge reset)
    begin : rd_9_process
      if (reset == 1'b1) begin
        rd_9_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          rd_9_reg[0] <= out0_bypass_ctrl_delay_out;
          rd_9_reg[1] <= rd_9_reg[0];
        end
      end
    end

  assign out0_bypass_ctrl_delay_out_1 = rd_9_reg[1];

  assign out0_bypass_Initial_Val_out[0] = 30'sb000000001001000100000000000000;
  assign out0_bypass_Initial_Val_out[1] = 30'sb000000001001000100000000000000;
  assign out0_bypass_Initial_Val_out[2] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[3] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[4] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[5] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[6] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[7] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[8] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[9] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[10] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[11] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[12] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[13] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[14] = 30'sb000000000000000000000000000000;

  always @(posedge clk or posedge reset)
    begin : rd_10_process
      if (reset == 1'b1) begin
        for(rd_10_t_1 = 32'sd0; rd_10_t_1 <= 32'sd14; rd_10_t_1 = rd_10_t_1 + 32'sd1) begin
          rd_10_reg[rd_10_t_1] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_10_t_0_1 = 32'sd0; rd_10_t_0_1 <= 32'sd14; rd_10_t_0_1 = rd_10_t_0_1 + 32'sd1) begin
            rd_10_reg[rd_10_t_0_1] <= rd_10_reg_next[rd_10_t_0_1];
          end
        end
      end
    end
  genvar t_0_02;
  generate
    for(t_0_02 = 32'sd0; t_0_02 <= 32'sd14; t_0_02 = t_0_02 + 32'sd1) begin:rd_10_reg_next_gen
      assign out0_bypass_Initial_Val_out_1[t_0_02] = rd_10_reg[t_0_02];
      assign rd_10_reg_next[t_0_02] = out0_bypass_Initial_Val_out[t_0_02];
    end
  endgenerate

  assign In[0] = In_0;
  assign In[1] = In_1;
  assign In[2] = In_2;
  assign In[3] = In_3;
  assign In[4] = In_4;
  assign In[5] = In_5;
  assign In[6] = In_6;
  assign In[7] = In_7;
  assign In[8] = In_8;
  assign In[9] = In_9;
  assign In[10] = In_10;
  assign In[11] = In_11;
  assign In[12] = In_12;
  assign In[13] = In_13;
  assign In[14] = In_14;

  always @(posedge clk or posedge reset)
    begin : rd_5_process
      if (reset == 1'b1) begin
        for(rd_5_t_1_0 = 32'sd0; rd_5_t_1_0 <= 32'sd44; rd_5_t_1_0 = rd_5_t_1_0 + 32'sd1) begin
          rd_5_reg[rd_5_t_1_0] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_5_t_0_1 = 32'sd0; rd_5_t_0_1 <= 32'sd44; rd_5_t_0_1 = rd_5_t_0_1 + 32'sd1) begin
            rd_5_reg[rd_5_t_0_1] <= rd_5_reg_next[rd_5_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(rd_5_t_0_0 = 32'sd0; rd_5_t_0_0 <= 32'sd14; rd_5_t_0_0 = rd_5_t_0_0 + 32'sd1) begin
      In_15[rd_5_t_0_0] = rd_5_reg[32'sd30 + rd_5_t_0_0];
      rd_5_reg_next[rd_5_t_0_0] = In[rd_5_t_0_0];
    end
    for(rd_5_t_1 = 32'sd0; rd_5_t_1 <= 32'sd29; rd_5_t_1 = rd_5_t_1 + 32'sd1) begin
      rd_5_reg_next[rd_5_t_1 + 32'sd15] = rd_5_reg[rd_5_t_1];
    end

  end

  always @(posedge clk or posedge reset)
    begin : rd_11_process
      if (reset == 1'b1) begin
        for(rd_11_t_1 = 32'sd0; rd_11_t_1 <= 32'sd14; rd_11_t_1 = rd_11_t_1 + 32'sd1) begin
          rd_11_reg[rd_11_t_1] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_11_t_0_1 = 32'sd0; rd_11_t_0_1 <= 32'sd14; rd_11_t_0_1 = rd_11_t_0_1 + 32'sd1) begin
            rd_11_reg[rd_11_t_0_1] <= rd_11_reg_next[rd_11_t_0_1];
          end
        end
      end
    end
  genvar t_0_011;
  generate
    for(t_0_011 = 32'sd0; t_0_011 <= 32'sd14; t_0_011 = t_0_011 + 32'sd1) begin:rd_11_reg_next_gen
      assign In_17[t_0_011] = rd_11_reg[t_0_011];
      assign rd_11_reg_next[t_0_011] = In_16[t_0_011];
    end
  endgenerate

  always @(posedge clk or posedge reset)
    begin : out0_bypass_bypass_process
      if (reset == 1'b1) begin
        for(out0_bypass_bypass_t_1_0 = 32'sd0; out0_bypass_bypass_t_1_0 <= 32'sd14; out0_bypass_bypass_t_1_0 = out0_bypass_bypass_t_1_0 + 32'sd1) begin
          out0_bypass_bypass_reg[out0_bypass_bypass_t_1_0] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb_1_200_1) begin
          for(out0_bypass_bypass_t_0_1 = 32'sd0; out0_bypass_bypass_t_0_1 <= 32'sd14; out0_bypass_bypass_t_0_1 = out0_bypass_bypass_t_0_1 + 32'sd1) begin
            out0_bypass_bypass_reg[out0_bypass_bypass_t_0_1] <= out0_bypass_bypass_reg_next[out0_bypass_bypass_t_0_1];
          end
        end
      end
    end

  always @* begin
    if (enb_1_200_1 == 1'b1) begin
      for(out0_bypass_bypass_t_1 = 32'sd0; out0_bypass_bypass_t_1 <= 32'sd14; out0_bypass_bypass_t_1 = out0_bypass_bypass_t_1 + 32'sd1) begin
        out0_bypass_out[out0_bypass_bypass_t_1] = In_17[out0_bypass_bypass_t_1];
      end
    end
    else begin
      for(out0_bypass_bypass_t_0_0 = 32'sd0; out0_bypass_bypass_t_0_0 <= 32'sd14; out0_bypass_bypass_t_0_0 = out0_bypass_bypass_t_0_0 + 32'sd1) begin
        out0_bypass_out[out0_bypass_bypass_t_0_0] = out0_bypass_bypass_reg[out0_bypass_bypass_t_0_0];
      end
    end

    for(out0_bypass_bypass_t_2 = 32'sd0; out0_bypass_bypass_t_2 <= 32'sd14; out0_bypass_bypass_t_2 = out0_bypass_bypass_t_2 + 32'sd1) begin
      out0_bypass_bypass_reg_next[out0_bypass_bypass_t_2] = In_17[out0_bypass_bypass_t_2];
    end

  end

  assign out0_bypass_out_1[0] = out0_bypass_out[0];
  assign out0_bypass_out_1[1] = out0_bypass_out[1];
  assign out0_bypass_out_1[2] = out0_bypass_out[2];
  assign out0_bypass_out_1[3] = out0_bypass_out[3];
  assign out0_bypass_out_1[4] = out0_bypass_out[4];
  assign out0_bypass_out_1[5] = out0_bypass_out[5];
  assign out0_bypass_out_1[6] = out0_bypass_out[6];
  assign out0_bypass_out_1[7] = out0_bypass_out[7];
  assign out0_bypass_out_1[8] = out0_bypass_out[8];
  assign out0_bypass_out_1[9] = out0_bypass_out[9];
  assign out0_bypass_out_1[10] = out0_bypass_out[10];
  assign out0_bypass_out_1[11] = out0_bypass_out[11];
  assign out0_bypass_out_1[12] = out0_bypass_out[12];
  assign out0_bypass_out_1[13] = out0_bypass_out[13];
  assign out0_bypass_out_1[14] = out0_bypass_out[14];

  always @(posedge clk or posedge reset)
    begin : rd_12_process
      if (reset == 1'b1) begin
        for(rd_12_t_1 = 32'sd0; rd_12_t_1 <= 32'sd29; rd_12_t_1 = rd_12_t_1 + 32'sd1) begin
          rd_12_reg[rd_12_t_1] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_12_t_0_1 = 32'sd0; rd_12_t_0_1 <= 32'sd29; rd_12_t_0_1 = rd_12_t_0_1 + 32'sd1) begin
            rd_12_reg[rd_12_t_0_1] <= rd_12_reg_next[rd_12_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(rd_12_t_0_0 = 32'sd0; rd_12_t_0_0 <= 32'sd14; rd_12_t_0_0 = rd_12_t_0_0 + 32'sd1) begin
      out0_bypass_out_2[rd_12_t_0_0] = rd_12_reg[32'sd15 + rd_12_t_0_0];
      rd_12_reg_next[rd_12_t_0_0] = out0_bypass_out_1[rd_12_t_0_0];
      rd_12_reg_next[rd_12_t_0_0 + 32'sd15] = rd_12_reg[rd_12_t_0_0];
    end

  end

  always @* begin
    if (out0_bypass_ctrl_delay_out_1 == 1'b0) begin
      for(out0_bypass_switch_t_1 = 32'sd0; out0_bypass_switch_t_1 <= 32'sd14; out0_bypass_switch_t_1 = out0_bypass_switch_t_1 + 32'sd1) begin
        In_last_value[out0_bypass_switch_t_1] = out0_bypass_Initial_Val_out_1[out0_bypass_switch_t_1];
      end
    end
    else begin
      for(out0_bypass_switch_t_0_0 = 32'sd0; out0_bypass_switch_t_0_0 <= 32'sd14; out0_bypass_switch_t_0_0 = out0_bypass_switch_t_0_0 + 32'sd1) begin
        In_last_value[out0_bypass_switch_t_0_0] = out0_bypass_out_2[out0_bypass_switch_t_0_0];
      end
    end
  end

  always @(posedge clk or posedge reset)
    begin : rd_13_process
      if (reset == 1'b1) begin
        for(rd_13_t_1 = 32'sd0; rd_13_t_1 <= 32'sd29; rd_13_t_1 = rd_13_t_1 + 32'sd1) begin
          rd_13_reg[rd_13_t_1] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_13_t_0_1 = 32'sd0; rd_13_t_0_1 <= 32'sd29; rd_13_t_0_1 = rd_13_t_0_1 + 32'sd1) begin
            rd_13_reg[rd_13_t_0_1] <= rd_13_reg_next[rd_13_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(rd_13_t_0_0 = 32'sd0; rd_13_t_0_0 <= 32'sd14; rd_13_t_0_0 = rd_13_t_0_0 + 32'sd1) begin
      In_last_value_1[rd_13_t_0_0] = rd_13_reg[32'sd15 + rd_13_t_0_0];
      rd_13_reg_next[rd_13_t_0_0] = In_last_value[rd_13_t_0_0];
      rd_13_reg_next[rd_13_t_0_0 + 32'sd15] = rd_13_reg[rd_13_t_0_0];
    end

  end

  always @* begin
    if (Trigger_emulated_1 == 1'b0) begin
      for(InbypassMux_t_1 = 32'sd0; InbypassMux_t_1 <= 32'sd14; InbypassMux_t_1 = InbypassMux_t_1 + 32'sd1) begin
        In_16[InbypassMux_t_1] = In_last_value_1[InbypassMux_t_1];
      end
    end
    else begin
      for(InbypassMux_t_0_0 = 32'sd0; InbypassMux_t_0_0 <= 32'sd14; InbypassMux_t_0_0 = InbypassMux_t_0_0 + 32'sd1) begin
        In_16[InbypassMux_t_0_0] = In_15[InbypassMux_t_0_0];
      end
    end
  end

  assign alpha_0 = In_16[0];

  assign alpha_1 = In_16[1];

  assign alpha_2 = In_16[2];

  assign alpha_3 = In_16[3];

  assign alpha_4 = In_16[4];

  assign alpha_5 = In_16[5];

  assign alpha_6 = In_16[6];

  assign alpha_7 = In_16[7];

  assign alpha_8 = In_16[8];

  assign alpha_9 = In_16[9];

  assign alpha_10 = In_16[10];

  assign alpha_11 = In_16[11];

  assign alpha_12 = In_16[12];

  assign alpha_13 = In_16[13];

  assign alpha_14 = In_16[14];

endmodule  // Sample_and_Hold

