// -------------------------------------------------------------
// 
// File Name: verilog_1\hdlsrc\gm_pfcvan3ph_s\Sample_and_Hold1.v
// Created: 2024-12-08 17:13:30
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Sample_and_Hold1
// Source Path: gm_pfcvan3ph_s/FPGA/HDL Subsystem/HDL Algorithm/DA_MATRIX/Sample and Hold1
// Hierarchy Level: 4
// Model version: 1.182
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Sample_and_Hold1
          (clk,
           reset,
           enb,
           enb_1_200_1,
           enb_1_200_0,
           In_0,
           In_1,
           In_2,
           In_3,
           In_4,
           In_5,
           In_6,
           In_7,
           In_8,
           In_9,
           In_10,
           In_11,
           In_12,
           In_13,
           In_14,
           In_15,
           In_16,
           In_17,
           In_18,
           In_19,
           Trigger,
           alpha_0,
           alpha_1,
           alpha_2,
           alpha_3,
           alpha_4,
           alpha_5,
           alpha_6,
           alpha_7,
           alpha_8,
           alpha_9,
           alpha_10,
           alpha_11,
           alpha_12,
           alpha_13,
           alpha_14,
           alpha_15,
           alpha_16,
           alpha_17,
           alpha_18,
           alpha_19);


  input   clk;
  input   reset;
  input   enb;
  input   enb_1_200_1;
  input   enb_1_200_0;
  input   signed [29:0] In_0;  // sfix30_En13
  input   signed [29:0] In_1;  // sfix30_En13
  input   signed [29:0] In_2;  // sfix30_En13
  input   signed [29:0] In_3;  // sfix30_En13
  input   signed [29:0] In_4;  // sfix30_En13
  input   signed [29:0] In_5;  // sfix30_En13
  input   signed [29:0] In_6;  // sfix30_En13
  input   signed [29:0] In_7;  // sfix30_En13
  input   signed [29:0] In_8;  // sfix30_En13
  input   signed [29:0] In_9;  // sfix30_En13
  input   signed [29:0] In_10;  // sfix30_En13
  input   signed [29:0] In_11;  // sfix30_En13
  input   signed [29:0] In_12;  // sfix30_En13
  input   signed [29:0] In_13;  // sfix30_En13
  input   signed [29:0] In_14;  // sfix30_En13
  input   signed [29:0] In_15;  // sfix30_En13
  input   signed [29:0] In_16;  // sfix30_En13
  input   signed [29:0] In_17;  // sfix30_En13
  input   signed [29:0] In_18;  // sfix30_En13
  input   signed [29:0] In_19;  // sfix30_En13
  input   Trigger;
  output  signed [29:0] alpha_0;  // sfix30_En13
  output  signed [29:0] alpha_1;  // sfix30_En13
  output  signed [29:0] alpha_2;  // sfix30_En13
  output  signed [29:0] alpha_3;  // sfix30_En13
  output  signed [29:0] alpha_4;  // sfix30_En13
  output  signed [29:0] alpha_5;  // sfix30_En13
  output  signed [29:0] alpha_6;  // sfix30_En13
  output  signed [29:0] alpha_7;  // sfix30_En13
  output  signed [29:0] alpha_8;  // sfix30_En13
  output  signed [29:0] alpha_9;  // sfix30_En13
  output  signed [29:0] alpha_10;  // sfix30_En13
  output  signed [29:0] alpha_11;  // sfix30_En13
  output  signed [29:0] alpha_12;  // sfix30_En13
  output  signed [29:0] alpha_13;  // sfix30_En13
  output  signed [29:0] alpha_14;  // sfix30_En13
  output  signed [29:0] alpha_15;  // sfix30_En13
  output  signed [29:0] alpha_16;  // sfix30_En13
  output  signed [29:0] alpha_17;  // sfix30_En13
  output  signed [29:0] alpha_18;  // sfix30_En13
  output  signed [29:0] alpha_19;  // sfix30_En13


  wire Trigger_delay_ctrl_const_out;
  reg  Trigger_delay_ctrl_const_out_1;
  reg  Trigger_delay_ctrl_const_out_2;
  wire Trigger_delay_ctrl_delay_out;
  reg  Trigger_delay_ctrl_delay_out_1;
  wire Trigger_delay_Initial_Val_out;
  reg  Trigger_delay_bypass_reg;  // ufix1
  wire Trigger_delay_out;
  wire Trigger_delay_out_1;
  reg  Trigger_delay_out_2;
  wire Trigger_delayed;
  reg  Trigger_delayed_1;
  wire Trigger_delayed_inverted;
  reg  Trigger_delayed_inverted_1;
  reg  [1:0] rd_6_reg;  // ufix1 [2]
  wire Trigger_1;
  wire Trigger_emulated;
  reg  Trigger_emulated_1;
  wire out0_bypass_ctrl_const_out;
  reg  out0_bypass_ctrl_const_out_1;
  reg  out0_bypass_ctrl_const_out_2;
  wire out0_bypass_ctrl_delay_out;
  reg  [1:0] rd_9_reg;  // ufix1 [2]
  wire out0_bypass_ctrl_delay_out_1;
  wire signed [29:0] out0_bypass_Initial_Val_out [0:19];  // sfix30_En13 [20]
  reg signed [29:0] rd_10_reg [0:19];  // sfix30 [20]
  wire signed [29:0] rd_10_reg_next [0:19];  // sfix30_En13 [20]
  wire signed [29:0] out0_bypass_Initial_Val_out_1 [0:19];  // sfix30_En13 [20]
  wire signed [29:0] delayIn0;  // sfix30_En13
  wire signed [29:0] delayIn1;  // sfix30_En13
  wire signed [29:0] delayIn2;  // sfix30_En13
  wire signed [29:0] delayIn3;  // sfix30_En13
  wire [119:0] mergedInput;  // ufix120
  reg [119:0] mergedDelay_regin;  // ufix120
  reg [1:0] mergedDelay_waddr;  // ufix2
  wire mergedDelay_wrenb;  // ufix1
  reg [1:0] mergedDelay_raddr;  // ufix2
  wire [119:0] mergedDelay_regout;  // ufix120
  reg [119:0] mergedOutput;  // ufix120
  wire signed [29:0] delayIn4;  // sfix30_En13
  wire signed [29:0] delayIn5;  // sfix30_En13
  wire signed [29:0] delayIn6;  // sfix30_En13
  wire signed [29:0] delayIn7;  // sfix30_En13
  wire [119:0] mergedInput_1;  // ufix120
  reg [119:0] mergedDelay_regin_1;  // ufix120
  reg [1:0] mergedDelay_waddr_1;  // ufix2
  wire mergedDelay_wrenb_1;  // ufix1
  reg [1:0] mergedDelay_raddr_1;  // ufix2
  wire [119:0] mergedDelay_regout_1;  // ufix120
  reg [119:0] mergedOutput_1;  // ufix120
  wire signed [29:0] delayIn8;  // sfix30_En13
  wire signed [29:0] delayIn9;  // sfix30_En13
  wire signed [29:0] delayIn10;  // sfix30_En13
  wire signed [29:0] delayIn11;  // sfix30_En13
  wire [119:0] mergedInput_2;  // ufix120
  reg [119:0] mergedDelay_regin_2;  // ufix120
  reg [1:0] mergedDelay_waddr_2;  // ufix2
  wire mergedDelay_wrenb_2;  // ufix1
  reg [1:0] mergedDelay_raddr_2;  // ufix2
  wire [119:0] mergedDelay_regout_2;  // ufix120
  reg [119:0] mergedOutput_2;  // ufix120
  wire signed [29:0] delayIn12;  // sfix30_En13
  wire signed [29:0] delayIn13;  // sfix30_En13
  wire signed [29:0] delayIn14;  // sfix30_En13
  wire signed [29:0] delayIn15;  // sfix30_En13
  wire [119:0] mergedInput_3;  // ufix120
  reg [119:0] mergedDelay_regin_3;  // ufix120
  reg [1:0] mergedDelay_waddr_3;  // ufix2
  wire mergedDelay_wrenb_3;  // ufix1
  reg [1:0] mergedDelay_raddr_3;  // ufix2
  wire [119:0] mergedDelay_regout_3;  // ufix120
  reg [119:0] mergedOutput_3;  // ufix120
  wire signed [29:0] delayIn16;  // sfix30_En13
  wire signed [29:0] delayIn17;  // sfix30_En13
  wire signed [29:0] delayIn18;  // sfix30_En13
  wire signed [29:0] delayIn19;  // sfix30_En13
  wire [119:0] mergedInput_4;  // ufix120
  reg [119:0] mergedDelay_regin_4;  // ufix120
  reg [1:0] mergedDelay_waddr_4;  // ufix2
  wire mergedDelay_wrenb_4;  // ufix1
  reg [1:0] mergedDelay_raddr_4;  // ufix2
  wire [119:0] mergedDelay_regout_4;  // ufix120
  reg [119:0] mergedOutput_4;  // ufix120
  wire [29:0] slicedInput;  // ufix30
  wire signed [29:0] delayOut0;  // sfix30_En13
  wire [29:0] slicedInput_1;  // ufix30
  wire signed [29:0] delayOut1;  // sfix30_En13
  wire [29:0] slicedInput_2;  // ufix30
  wire signed [29:0] delayOut2;  // sfix30_En13
  wire [29:0] slicedInput_3;  // ufix30
  wire signed [29:0] delayOut3;  // sfix30_En13
  wire [29:0] slicedInput_4;  // ufix30
  wire signed [29:0] delayOut4;  // sfix30_En13
  wire [29:0] slicedInput_5;  // ufix30
  wire signed [29:0] delayOut5;  // sfix30_En13
  wire [29:0] slicedInput_6;  // ufix30
  wire signed [29:0] delayOut6;  // sfix30_En13
  wire [29:0] slicedInput_7;  // ufix30
  wire signed [29:0] delayOut7;  // sfix30_En13
  wire [29:0] slicedInput_8;  // ufix30
  wire signed [29:0] delayOut8;  // sfix30_En13
  wire [29:0] slicedInput_9;  // ufix30
  wire signed [29:0] delayOut9;  // sfix30_En13
  wire [29:0] slicedInput_10;  // ufix30
  wire signed [29:0] delayOut10;  // sfix30_En13
  wire [29:0] slicedInput_11;  // ufix30
  wire signed [29:0] delayOut11;  // sfix30_En13
  wire [29:0] slicedInput_12;  // ufix30
  wire signed [29:0] delayOut12;  // sfix30_En13
  wire [29:0] slicedInput_13;  // ufix30
  wire signed [29:0] delayOut13;  // sfix30_En13
  wire [29:0] slicedInput_14;  // ufix30
  wire signed [29:0] delayOut14;  // sfix30_En13
  wire [29:0] slicedInput_15;  // ufix30
  wire signed [29:0] delayOut15;  // sfix30_En13
  wire [29:0] slicedInput_16;  // ufix30
  wire signed [29:0] delayOut16;  // sfix30_En13
  wire [29:0] slicedInput_17;  // ufix30
  wire signed [29:0] delayOut17;  // sfix30_En13
  wire [29:0] slicedInput_18;  // ufix30
  wire signed [29:0] delayOut18;  // sfix30_En13
  wire [29:0] slicedInput_19;  // ufix30
  wire signed [29:0] delayOut19;  // sfix30_En13
  wire signed [29:0] In [0:19];  // sfix30_En13 [20]
  reg signed [29:0] out0_bypass_out [0:19];  // sfix30_En13 [20]
  reg signed [29:0] In_20 [0:19];  // sfix30_En13 [20]
  reg signed [29:0] rd_11_reg [0:19];  // sfix30 [20]
  wire signed [29:0] rd_11_reg_next [0:19];  // sfix30_En13 [20]
  wire signed [29:0] In_21 [0:19];  // sfix30_En13 [20]
  reg signed [29:0] out0_bypass_bypass_reg [0:19];  // sfix30 [20]
  reg signed [29:0] out0_bypass_bypass_reg_next [0:19];  // sfix30_En13 [20]
  wire signed [29:0] out0_bypass_out_1 [0:19];  // sfix30_En13 [20]
  reg signed [29:0] rd_12_reg [0:39];  // sfix30 [40]
  reg signed [29:0] rd_12_reg_next [0:39];  // sfix30_En13 [40]
  reg signed [29:0] out0_bypass_out_2 [0:19];  // sfix30_En13 [20]
  reg signed [29:0] In_last_value [0:19];  // sfix30_En13 [20]
  reg signed [29:0] rd_13_reg [0:39];  // sfix30 [40]
  reg signed [29:0] rd_13_reg_next [0:39];  // sfix30_En13 [40]
  reg signed [29:0] In_last_value_1 [0:19];  // sfix30_En13 [20]
  reg signed [31:0] rd_10_t_0_1;  // int32
  reg signed [31:0] rd_10_t_1;  // int32
  reg signed [31:0] rd_11_t_0_1;  // int32
  reg signed [31:0] rd_11_t_1;  // int32
  reg signed [31:0] out0_bypass_bypass_t_0_0;  // int32
  reg signed [31:0] out0_bypass_bypass_t_1;  // int32
  reg signed [31:0] out0_bypass_bypass_t_2;  // int32
  reg signed [31:0] out0_bypass_bypass_t_0_1;  // int32
  reg signed [31:0] out0_bypass_bypass_t_1_0;  // int32
  reg signed [31:0] rd_12_t_0_0;  // int32
  reg signed [31:0] rd_12_t_0_1;  // int32
  reg signed [31:0] rd_12_t_1;  // int32
  reg signed [31:0] out0_bypass_switch_t_0_0;  // int32
  reg signed [31:0] out0_bypass_switch_t_1;  // int32
  reg signed [31:0] rd_13_t_0_0;  // int32
  reg signed [31:0] rd_13_t_0_1;  // int32
  reg signed [31:0] rd_13_t_1;  // int32
  reg signed [31:0] InbypassMux_t_0_0;  // int32
  reg signed [31:0] InbypassMux_t_1;  // int32


  assign Trigger_delay_ctrl_const_out = 1'b1;

  always @(posedge clk or posedge reset)
    begin : Trigger_delay_ctrl_delay_output_process
      if (reset == 1'b1) begin
        Trigger_delay_ctrl_const_out_1 <= 1'b0;
      end
      else begin
        if (enb_1_200_1) begin
          Trigger_delay_ctrl_const_out_1 <= Trigger_delay_ctrl_const_out;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        Trigger_delay_ctrl_const_out_2 <= 1'b0;
      end
      else begin
        if (enb_1_200_0) begin
          Trigger_delay_ctrl_const_out_2 <= Trigger_delay_ctrl_const_out_1;
        end
      end
    end

  assign Trigger_delay_ctrl_delay_out = Trigger_delay_ctrl_const_out_2;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        Trigger_delay_ctrl_delay_out_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_delay_ctrl_delay_out_1 <= Trigger_delay_ctrl_delay_out;
        end
      end
    end

  assign Trigger_delay_Initial_Val_out = 1'b1;

  always @(posedge clk or posedge reset)
    begin : Trigger_delay_bypass_process
      if (reset == 1'b1) begin
        Trigger_delay_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_200_1) begin
          Trigger_delay_bypass_reg <= Trigger;
        end
      end
    end

  assign Trigger_delay_out = (enb_1_200_1 == 1'b1 ? Trigger :
              Trigger_delay_bypass_reg);

  assign Trigger_delay_out_1 = Trigger_delay_out;

  always @(posedge clk or posedge reset)
    begin : rd_0_process
      if (reset == 1'b1) begin
        Trigger_delay_out_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_delay_out_2 <= Trigger_delay_out_1;
        end
      end
    end

  assign Trigger_delayed = (Trigger_delay_ctrl_delay_out_1 == 1'b0 ? Trigger_delay_Initial_Val_out :
              Trigger_delay_out_2);

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        Trigger_delayed_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_delayed_1 <= Trigger_delayed;
        end
      end
    end

  assign Trigger_delayed_inverted =  ~ Trigger_delayed_1;

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        Trigger_delayed_inverted_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_delayed_inverted_1 <= Trigger_delayed_inverted;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_6_process
      if (reset == 1'b1) begin
        rd_6_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          rd_6_reg[0] <= Trigger;
          rd_6_reg[1] <= rd_6_reg[0];
        end
      end
    end

  assign Trigger_1 = rd_6_reg[1];

  assign Trigger_emulated = Trigger_delayed_inverted_1 & Trigger_1;

  always @(posedge clk or posedge reset)
    begin : rd_7_process
      if (reset == 1'b1) begin
        Trigger_emulated_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Trigger_emulated_1 <= Trigger_emulated;
        end
      end
    end

  assign out0_bypass_ctrl_const_out = 1'b1;

  always @(posedge clk or posedge reset)
    begin : out0_bypass_ctrl_delay_output_process
      if (reset == 1'b1) begin
        out0_bypass_ctrl_const_out_1 <= 1'b0;
      end
      else begin
        if (enb_1_200_1) begin
          out0_bypass_ctrl_const_out_1 <= out0_bypass_ctrl_const_out;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_8_process
      if (reset == 1'b1) begin
        out0_bypass_ctrl_const_out_2 <= 1'b0;
      end
      else begin
        if (enb_1_200_0) begin
          out0_bypass_ctrl_const_out_2 <= out0_bypass_ctrl_const_out_1;
        end
      end
    end

  assign out0_bypass_ctrl_delay_out = out0_bypass_ctrl_const_out_2;

  always @(posedge clk or posedge reset)
    begin : rd_9_process
      if (reset == 1'b1) begin
        rd_9_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          rd_9_reg[0] <= out0_bypass_ctrl_delay_out;
          rd_9_reg[1] <= rd_9_reg[0];
        end
      end
    end

  assign out0_bypass_ctrl_delay_out_1 = rd_9_reg[1];

  assign out0_bypass_Initial_Val_out[0] = 30'sb000000000000001011011001100110;
  assign out0_bypass_Initial_Val_out[1] = 30'sb000000001001000100000000000000;
  assign out0_bypass_Initial_Val_out[2] = 30'sb000000000000001011011001100110;
  assign out0_bypass_Initial_Val_out[3] = 30'sb000000001001000100000000000000;
  assign out0_bypass_Initial_Val_out[4] = 30'sb000000000000001011011001100110;
  assign out0_bypass_Initial_Val_out[5] = 30'sb000000001001000100000000000000;
  assign out0_bypass_Initial_Val_out[6] = 30'sb000000000000001010000000000000;
  assign out0_bypass_Initial_Val_out[7] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[8] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[9] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[10] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[11] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[12] = 30'sb000000000000000000000000000000;
  assign out0_bypass_Initial_Val_out[13] = 30'sb000000000000001011011001100110;
  assign out0_bypass_Initial_Val_out[14] = 30'sb000000001001000100000000000000;
  assign out0_bypass_Initial_Val_out[15] = 30'sb000000000000001011011001100110;
  assign out0_bypass_Initial_Val_out[16] = 30'sb000000001001000100000000000000;
  assign out0_bypass_Initial_Val_out[17] = 30'sb000000000000001011011001100110;
  assign out0_bypass_Initial_Val_out[18] = 30'sb000000001001000100000000000000;
  assign out0_bypass_Initial_Val_out[19] = 30'sb000000010010001000000000000000;

  always @(posedge clk or posedge reset)
    begin : rd_10_process
      if (reset == 1'b1) begin
        for(rd_10_t_1 = 32'sd0; rd_10_t_1 <= 32'sd19; rd_10_t_1 = rd_10_t_1 + 32'sd1) begin
          rd_10_reg[rd_10_t_1] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_10_t_0_1 = 32'sd0; rd_10_t_0_1 <= 32'sd19; rd_10_t_0_1 = rd_10_t_0_1 + 32'sd1) begin
            rd_10_reg[rd_10_t_0_1] <= rd_10_reg_next[rd_10_t_0_1];
          end
        end
      end
    end
  genvar t_0_02;
  generate
    for(t_0_02 = 32'sd0; t_0_02 <= 32'sd19; t_0_02 = t_0_02 + 32'sd1) begin:rd_10_reg_next_gen
      assign out0_bypass_Initial_Val_out_1[t_0_02] = rd_10_reg[t_0_02];
      assign rd_10_reg_next[t_0_02] = out0_bypass_Initial_Val_out[t_0_02];
    end
  endgenerate

  assign delayIn0 = In_0;

  assign delayIn1 = In_1;

  assign delayIn2 = In_2;

  assign delayIn3 = In_3;

  assign mergedInput = {delayIn0, delayIn1, delayIn2, delayIn3};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 2'b00;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 2'b01) begin
            mergedDelay_waddr <= 2'b00;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 2'b01;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 2'b01) begin
            mergedDelay_raddr <= 2'b00;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 2'b01;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(2),
                              .DataWidth(120)
                              )
                            u_ShiftRegisterRAM (.clk(clk),
                                                .enb(enb),
                                                .wr_din(mergedDelay_regin),
                                                .wr_addr(mergedDelay_waddr),
                                                .wr_en(mergedDelay_wrenb),  // ufix1
                                                .rd_addr(mergedDelay_raddr),
                                                .dout(mergedDelay_regout)
                                                );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign delayIn4 = In_4;

  assign delayIn5 = In_5;

  assign delayIn6 = In_6;

  assign delayIn7 = In_7;

  assign mergedInput_1 = {delayIn4, delayIn5, delayIn6, delayIn7};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_reginc_1_process
      if (reset == 1'b1) begin
        mergedDelay_regin_1 <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_1 <= mergedInput_1;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_wr_1_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_1 <= 2'b00;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_1 >= 2'b01) begin
            mergedDelay_waddr_1 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_1 <= mergedDelay_waddr_1 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_1 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_rd_1_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_1 <= 2'b01;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_1 >= 2'b01) begin
            mergedDelay_raddr_1 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_1 <= mergedDelay_raddr_1 + 2'b01;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(2),
                              .DataWidth(120)
                              )
                            u_ShiftRegisterRAM_1 (.clk(clk),
                                                  .enb(enb),
                                                  .wr_din(mergedDelay_regin_1),
                                                  .wr_addr(mergedDelay_waddr_1),
                                                  .wr_en(mergedDelay_wrenb_1),  // ufix1
                                                  .rd_addr(mergedDelay_raddr_1),
                                                  .dout(mergedDelay_regout_1)
                                                  );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_regoutc_1_process
      if (reset == 1'b1) begin
        mergedOutput_1 <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_1 <= mergedDelay_regout_1;
        end
      end
    end

  assign delayIn8 = In_8;

  assign delayIn9 = In_9;

  assign delayIn10 = In_10;

  assign delayIn11 = In_11;

  assign mergedInput_2 = {delayIn8, delayIn9, delayIn10, delayIn11};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_reginc_2_process
      if (reset == 1'b1) begin
        mergedDelay_regin_2 <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_2 <= mergedInput_2;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_wr_2_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_2 <= 2'b00;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_2 >= 2'b01) begin
            mergedDelay_waddr_2 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_2 <= mergedDelay_waddr_2 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_2 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_rd_2_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_2 <= 2'b01;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_2 >= 2'b01) begin
            mergedDelay_raddr_2 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_2 <= mergedDelay_raddr_2 + 2'b01;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(2),
                              .DataWidth(120)
                              )
                            u_ShiftRegisterRAM_2 (.clk(clk),
                                                  .enb(enb),
                                                  .wr_din(mergedDelay_regin_2),
                                                  .wr_addr(mergedDelay_waddr_2),
                                                  .wr_en(mergedDelay_wrenb_2),  // ufix1
                                                  .rd_addr(mergedDelay_raddr_2),
                                                  .dout(mergedDelay_regout_2)
                                                  );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_regoutc_2_process
      if (reset == 1'b1) begin
        mergedOutput_2 <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_2 <= mergedDelay_regout_2;
        end
      end
    end

  assign delayIn12 = In_12;

  assign delayIn13 = In_13;

  assign delayIn14 = In_14;

  assign delayIn15 = In_15;

  assign mergedInput_3 = {delayIn12, delayIn13, delayIn14, delayIn15};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_reginc_3_process
      if (reset == 1'b1) begin
        mergedDelay_regin_3 <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_3 <= mergedInput_3;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_wr_3_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_3 <= 2'b00;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_3 >= 2'b01) begin
            mergedDelay_waddr_3 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_3 <= mergedDelay_waddr_3 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_3 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_rd_3_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_3 <= 2'b01;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_3 >= 2'b01) begin
            mergedDelay_raddr_3 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_3 <= mergedDelay_raddr_3 + 2'b01;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(2),
                              .DataWidth(120)
                              )
                            u_ShiftRegisterRAM_3 (.clk(clk),
                                                  .enb(enb),
                                                  .wr_din(mergedDelay_regin_3),
                                                  .wr_addr(mergedDelay_waddr_3),
                                                  .wr_en(mergedDelay_wrenb_3),  // ufix1
                                                  .rd_addr(mergedDelay_raddr_3),
                                                  .dout(mergedDelay_regout_3)
                                                  );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_regoutc_3_process
      if (reset == 1'b1) begin
        mergedOutput_3 <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_3 <= mergedDelay_regout_3;
        end
      end
    end

  assign delayIn16 = In_16;

  assign delayIn17 = In_17;

  assign delayIn18 = In_18;

  assign delayIn19 = In_19;

  assign mergedInput_4 = {delayIn16, delayIn17, delayIn18, delayIn19};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_reginc_4_process
      if (reset == 1'b1) begin
        mergedDelay_regin_4 <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_4 <= mergedInput_4;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_wr_4_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_4 <= 2'b00;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_4 >= 2'b01) begin
            mergedDelay_waddr_4 <= 2'b00;
          end
          else begin
            mergedDelay_waddr_4 <= mergedDelay_waddr_4 + 2'b01;
          end
        end
      end
    end

  assign mergedDelay_wrenb_4 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_rd_4_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_4 <= 2'b01;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_4 >= 2'b01) begin
            mergedDelay_raddr_4 <= 2'b00;
          end
          else begin
            mergedDelay_raddr_4 <= mergedDelay_raddr_4 + 2'b01;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(2),
                              .DataWidth(120)
                              )
                            u_ShiftRegisterRAM_4 (.clk(clk),
                                                  .enb(enb),
                                                  .wr_din(mergedDelay_regin_4),
                                                  .wr_addr(mergedDelay_waddr_4),
                                                  .wr_en(mergedDelay_wrenb_4),  // ufix1
                                                  .rd_addr(mergedDelay_raddr_4),
                                                  .dout(mergedDelay_regout_4)
                                                  );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_regoutc_4_process
      if (reset == 1'b1) begin
        mergedOutput_4 <= 120'h000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_4 <= mergedDelay_regout_4;
        end
      end
    end

  assign slicedInput = mergedOutput[119:90];

  assign delayOut0 = slicedInput;

  assign slicedInput_1 = mergedOutput[89:60];

  assign delayOut1 = slicedInput_1;

  assign slicedInput_2 = mergedOutput[59:30];

  assign delayOut2 = slicedInput_2;

  assign slicedInput_3 = mergedOutput[29:0];

  assign delayOut3 = slicedInput_3;

  assign slicedInput_4 = mergedOutput_1[119:90];

  assign delayOut4 = slicedInput_4;

  assign slicedInput_5 = mergedOutput_1[89:60];

  assign delayOut5 = slicedInput_5;

  assign slicedInput_6 = mergedOutput_1[59:30];

  assign delayOut6 = slicedInput_6;

  assign slicedInput_7 = mergedOutput_1[29:0];

  assign delayOut7 = slicedInput_7;

  assign slicedInput_8 = mergedOutput_2[119:90];

  assign delayOut8 = slicedInput_8;

  assign slicedInput_9 = mergedOutput_2[89:60];

  assign delayOut9 = slicedInput_9;

  assign slicedInput_10 = mergedOutput_2[59:30];

  assign delayOut10 = slicedInput_10;

  assign slicedInput_11 = mergedOutput_2[29:0];

  assign delayOut11 = slicedInput_11;

  assign slicedInput_12 = mergedOutput_3[119:90];

  assign delayOut12 = slicedInput_12;

  assign slicedInput_13 = mergedOutput_3[89:60];

  assign delayOut13 = slicedInput_13;

  assign slicedInput_14 = mergedOutput_3[59:30];

  assign delayOut14 = slicedInput_14;

  assign slicedInput_15 = mergedOutput_3[29:0];

  assign delayOut15 = slicedInput_15;

  assign slicedInput_16 = mergedOutput_4[119:90];

  assign delayOut16 = slicedInput_16;

  assign slicedInput_17 = mergedOutput_4[89:60];

  assign delayOut17 = slicedInput_17;

  assign slicedInput_18 = mergedOutput_4[59:30];

  assign delayOut18 = slicedInput_18;

  assign slicedInput_19 = mergedOutput_4[29:0];

  assign delayOut19 = slicedInput_19;

  assign In[0] = delayOut0;
  assign In[1] = delayOut1;
  assign In[2] = delayOut2;
  assign In[3] = delayOut3;
  assign In[4] = delayOut4;
  assign In[5] = delayOut5;
  assign In[6] = delayOut6;
  assign In[7] = delayOut7;
  assign In[8] = delayOut8;
  assign In[9] = delayOut9;
  assign In[10] = delayOut10;
  assign In[11] = delayOut11;
  assign In[12] = delayOut12;
  assign In[13] = delayOut13;
  assign In[14] = delayOut14;
  assign In[15] = delayOut15;
  assign In[16] = delayOut16;
  assign In[17] = delayOut17;
  assign In[18] = delayOut18;
  assign In[19] = delayOut19;

  always @(posedge clk or posedge reset)
    begin : rd_11_process
      if (reset == 1'b1) begin
        for(rd_11_t_1 = 32'sd0; rd_11_t_1 <= 32'sd19; rd_11_t_1 = rd_11_t_1 + 32'sd1) begin
          rd_11_reg[rd_11_t_1] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_11_t_0_1 = 32'sd0; rd_11_t_0_1 <= 32'sd19; rd_11_t_0_1 = rd_11_t_0_1 + 32'sd1) begin
            rd_11_reg[rd_11_t_0_1] <= rd_11_reg_next[rd_11_t_0_1];
          end
        end
      end
    end
  genvar t_0_011;
  generate
    for(t_0_011 = 32'sd0; t_0_011 <= 32'sd19; t_0_011 = t_0_011 + 32'sd1) begin:rd_11_reg_next_gen
      assign In_21[t_0_011] = rd_11_reg[t_0_011];
      assign rd_11_reg_next[t_0_011] = In_20[t_0_011];
    end
  endgenerate

  always @(posedge clk or posedge reset)
    begin : out0_bypass_bypass_process
      if (reset == 1'b1) begin
        for(out0_bypass_bypass_t_1_0 = 32'sd0; out0_bypass_bypass_t_1_0 <= 32'sd19; out0_bypass_bypass_t_1_0 = out0_bypass_bypass_t_1_0 + 32'sd1) begin
          out0_bypass_bypass_reg[out0_bypass_bypass_t_1_0] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb_1_200_1) begin
          for(out0_bypass_bypass_t_0_1 = 32'sd0; out0_bypass_bypass_t_0_1 <= 32'sd19; out0_bypass_bypass_t_0_1 = out0_bypass_bypass_t_0_1 + 32'sd1) begin
            out0_bypass_bypass_reg[out0_bypass_bypass_t_0_1] <= out0_bypass_bypass_reg_next[out0_bypass_bypass_t_0_1];
          end
        end
      end
    end

  always @* begin
    if (enb_1_200_1 == 1'b1) begin
      for(out0_bypass_bypass_t_1 = 32'sd0; out0_bypass_bypass_t_1 <= 32'sd19; out0_bypass_bypass_t_1 = out0_bypass_bypass_t_1 + 32'sd1) begin
        out0_bypass_out[out0_bypass_bypass_t_1] = In_21[out0_bypass_bypass_t_1];
      end
    end
    else begin
      for(out0_bypass_bypass_t_0_0 = 32'sd0; out0_bypass_bypass_t_0_0 <= 32'sd19; out0_bypass_bypass_t_0_0 = out0_bypass_bypass_t_0_0 + 32'sd1) begin
        out0_bypass_out[out0_bypass_bypass_t_0_0] = out0_bypass_bypass_reg[out0_bypass_bypass_t_0_0];
      end
    end

    for(out0_bypass_bypass_t_2 = 32'sd0; out0_bypass_bypass_t_2 <= 32'sd19; out0_bypass_bypass_t_2 = out0_bypass_bypass_t_2 + 32'sd1) begin
      out0_bypass_bypass_reg_next[out0_bypass_bypass_t_2] = In_21[out0_bypass_bypass_t_2];
    end

  end

  assign out0_bypass_out_1[0] = out0_bypass_out[0];
  assign out0_bypass_out_1[1] = out0_bypass_out[1];
  assign out0_bypass_out_1[2] = out0_bypass_out[2];
  assign out0_bypass_out_1[3] = out0_bypass_out[3];
  assign out0_bypass_out_1[4] = out0_bypass_out[4];
  assign out0_bypass_out_1[5] = out0_bypass_out[5];
  assign out0_bypass_out_1[6] = out0_bypass_out[6];
  assign out0_bypass_out_1[7] = out0_bypass_out[7];
  assign out0_bypass_out_1[8] = out0_bypass_out[8];
  assign out0_bypass_out_1[9] = out0_bypass_out[9];
  assign out0_bypass_out_1[10] = out0_bypass_out[10];
  assign out0_bypass_out_1[11] = out0_bypass_out[11];
  assign out0_bypass_out_1[12] = out0_bypass_out[12];
  assign out0_bypass_out_1[13] = out0_bypass_out[13];
  assign out0_bypass_out_1[14] = out0_bypass_out[14];
  assign out0_bypass_out_1[15] = out0_bypass_out[15];
  assign out0_bypass_out_1[16] = out0_bypass_out[16];
  assign out0_bypass_out_1[17] = out0_bypass_out[17];
  assign out0_bypass_out_1[18] = out0_bypass_out[18];
  assign out0_bypass_out_1[19] = out0_bypass_out[19];

  always @(posedge clk or posedge reset)
    begin : rd_12_process
      if (reset == 1'b1) begin
        for(rd_12_t_1 = 32'sd0; rd_12_t_1 <= 32'sd39; rd_12_t_1 = rd_12_t_1 + 32'sd1) begin
          rd_12_reg[rd_12_t_1] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_12_t_0_1 = 32'sd0; rd_12_t_0_1 <= 32'sd39; rd_12_t_0_1 = rd_12_t_0_1 + 32'sd1) begin
            rd_12_reg[rd_12_t_0_1] <= rd_12_reg_next[rd_12_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(rd_12_t_0_0 = 32'sd0; rd_12_t_0_0 <= 32'sd19; rd_12_t_0_0 = rd_12_t_0_0 + 32'sd1) begin
      out0_bypass_out_2[rd_12_t_0_0] = rd_12_reg[32'sd20 + rd_12_t_0_0];
      rd_12_reg_next[rd_12_t_0_0] = out0_bypass_out_1[rd_12_t_0_0];
      rd_12_reg_next[rd_12_t_0_0 + 32'sd20] = rd_12_reg[rd_12_t_0_0];
    end

  end

  always @* begin
    if (out0_bypass_ctrl_delay_out_1 == 1'b0) begin
      for(out0_bypass_switch_t_1 = 32'sd0; out0_bypass_switch_t_1 <= 32'sd19; out0_bypass_switch_t_1 = out0_bypass_switch_t_1 + 32'sd1) begin
        In_last_value[out0_bypass_switch_t_1] = out0_bypass_Initial_Val_out_1[out0_bypass_switch_t_1];
      end
    end
    else begin
      for(out0_bypass_switch_t_0_0 = 32'sd0; out0_bypass_switch_t_0_0 <= 32'sd19; out0_bypass_switch_t_0_0 = out0_bypass_switch_t_0_0 + 32'sd1) begin
        In_last_value[out0_bypass_switch_t_0_0] = out0_bypass_out_2[out0_bypass_switch_t_0_0];
      end
    end
  end

  always @(posedge clk or posedge reset)
    begin : rd_13_process
      if (reset == 1'b1) begin
        for(rd_13_t_1 = 32'sd0; rd_13_t_1 <= 32'sd39; rd_13_t_1 = rd_13_t_1 + 32'sd1) begin
          rd_13_reg[rd_13_t_1] <= 30'sb000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_13_t_0_1 = 32'sd0; rd_13_t_0_1 <= 32'sd39; rd_13_t_0_1 = rd_13_t_0_1 + 32'sd1) begin
            rd_13_reg[rd_13_t_0_1] <= rd_13_reg_next[rd_13_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(rd_13_t_0_0 = 32'sd0; rd_13_t_0_0 <= 32'sd19; rd_13_t_0_0 = rd_13_t_0_0 + 32'sd1) begin
      In_last_value_1[rd_13_t_0_0] = rd_13_reg[32'sd20 + rd_13_t_0_0];
      rd_13_reg_next[rd_13_t_0_0] = In_last_value[rd_13_t_0_0];
      rd_13_reg_next[rd_13_t_0_0 + 32'sd20] = rd_13_reg[rd_13_t_0_0];
    end

  end

  always @* begin
    if (Trigger_emulated_1 == 1'b0) begin
      for(InbypassMux_t_1 = 32'sd0; InbypassMux_t_1 <= 32'sd19; InbypassMux_t_1 = InbypassMux_t_1 + 32'sd1) begin
        In_20[InbypassMux_t_1] = In_last_value_1[InbypassMux_t_1];
      end
    end
    else begin
      for(InbypassMux_t_0_0 = 32'sd0; InbypassMux_t_0_0 <= 32'sd19; InbypassMux_t_0_0 = InbypassMux_t_0_0 + 32'sd1) begin
        In_20[InbypassMux_t_0_0] = In[InbypassMux_t_0_0];
      end
    end
  end

  assign alpha_0 = In_20[0];

  assign alpha_1 = In_20[1];

  assign alpha_2 = In_20[2];

  assign alpha_3 = In_20[3];

  assign alpha_4 = In_20[4];

  assign alpha_5 = In_20[5];

  assign alpha_6 = In_20[6];

  assign alpha_7 = In_20[7];

  assign alpha_8 = In_20[8];

  assign alpha_9 = In_20[9];

  assign alpha_10 = In_20[10];

  assign alpha_11 = In_20[11];

  assign alpha_12 = In_20[12];

  assign alpha_13 = In_20[13];

  assign alpha_14 = In_20[14];

  assign alpha_15 = In_20[15];

  assign alpha_16 = In_20[16];

  assign alpha_17 = In_20[17];

  assign alpha_18 = In_20[18];

  assign alpha_19 = In_20[19];

endmodule  // Sample_and_Hold1

