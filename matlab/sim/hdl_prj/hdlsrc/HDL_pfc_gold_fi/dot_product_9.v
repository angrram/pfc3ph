// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\HDL_pfc_gold_fi\dot_product_9.v
// Created: 2024-12-27 09:23:12
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dot_product_9
// Source Path: HDL_pfc_gold_fi/simscape_system/HDL Subsystem/Fixed-Point State-Space/hNNewMatrixB/dot_product_9
// Hierarchy Level: 3
// Model version: 1.63
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dot_product_9
          (clk,
           reset,
           enb,
           in1_0,
           in1_1,
           in1_2,
           in1_3,
           in1_4,
           in1_5,
           in1_6,
           in1_7,
           in1_8,
           in2_0,
           in2_1,
           in2_2,
           in2_3,
           in2_4,
           in2_5,
           in2_6,
           in2_7,
           in2_8,
           out1);


  input   clk;
  input   reset;
  input   enb;
  input   signed [24:0] in1_0;  // sfix25_En31
  input   signed [24:0] in1_1;  // sfix25_En31
  input   signed [24:0] in1_2;  // sfix25_En31
  input   signed [24:0] in1_3;  // sfix25_En31
  input   signed [24:0] in1_4;  // sfix25_En31
  input   signed [24:0] in1_5;  // sfix25_En31
  input   signed [24:0] in1_6;  // sfix25_En31
  input   signed [24:0] in1_7;  // sfix25_En31
  input   signed [24:0] in1_8;  // sfix25_En31
  input   signed [24:0] in2_0;  // sfix25_En13
  input   signed [24:0] in2_1;  // sfix25_En13
  input   signed [24:0] in2_2;  // sfix25_En13
  input   signed [24:0] in2_3;  // sfix25_En13
  input   signed [24:0] in2_4;  // sfix25_En13
  input   signed [24:0] in2_5;  // sfix25_En13
  input   signed [24:0] in2_6;  // sfix25_En13
  input   signed [24:0] in2_7;  // sfix25_En13
  input   signed [24:0] in2_8;  // sfix25_En13
  output  signed [49:0] out1;  // sfix50_En44


  wire [124:0] mergedInput;  // ufix125
  reg [124:0] mergedDelay_regin;  // ufix125
  reg [2:0] mergedDelay_waddr;  // ufix3
  wire mergedDelay_wrenb;  // ufix1
  reg [2:0] mergedDelay_raddr;  // ufix3
  wire [124:0] mergedDelay_regout;  // ufix125
  reg [124:0] mergedOutput;  // ufix125
  wire [99:0] mergedInput_1;  // ufix100
  reg [99:0] mergedDelay_regin_1;  // ufix100
  reg [2:0] mergedDelay_waddr_1;  // ufix3
  wire mergedDelay_wrenb_1;  // ufix1
  reg [2:0] mergedDelay_raddr_1;  // ufix3
  wire [99:0] mergedDelay_regout_1;  // ufix100
  reg [99:0] mergedOutput_1;  // ufix100
  wire [24:0] slicedInput;  // ufix25
  wire signed [24:0] delayOut0;  // sfix25_En31
  wire [24:0] slicedInput_1;  // ufix25
  wire signed [24:0] delayOut1;  // sfix25_En31
  wire [24:0] slicedInput_2;  // ufix25
  wire signed [24:0] delayOut2;  // sfix25_En31
  wire [24:0] slicedInput_3;  // ufix25
  wire signed [24:0] delayOut3;  // sfix25_En31
  wire [24:0] slicedInput_4;  // ufix25
  wire signed [24:0] delayOut4;  // sfix25_En31
  wire [24:0] slicedInput_5;  // ufix25
  wire signed [24:0] delayOut5;  // sfix25_En31
  wire [24:0] slicedInput_6;  // ufix25
  wire signed [24:0] delayOut6;  // sfix25_En31
  wire [24:0] slicedInput_7;  // ufix25
  wire signed [24:0] delayOut7;  // sfix25_En31
  wire [24:0] slicedInput_8;  // ufix25
  wire signed [24:0] delayOut8;  // sfix25_En31
  wire signed [24:0] mul_in1 [0:8];  // sfix25_En31 [9]
  wire signed [24:0] mul_in2 [0:8];  // sfix25_En13 [9]
  reg signed [24:0] mul_in2_1 [0:8];  // sfix25_En13 [9]
  wire signed [49:0] mul_out1 [0:8];  // sfix50_En44 [9]
  reg signed [49:0] mul_out1_1 [0:8];  // sfix50_En44 [9]
  wire signed [49:0] mul_out1_0;  // sfix50_En44
  wire signed [49:0] mul_out1_2;  // sfix50_En44
  wire signed [49:0] mul_out1_4;  // sfix50_En44
  wire signed [49:0] mul_out1_6;  // sfix50_En44
  wire signed [49:0] mul_out1_1_1;  // sfix50_En44
  wire signed [49:0] sum_stage1_1;  // sfix50_En44
  wire signed [49:0] mul_out1_3;  // sfix50_En44
  wire signed [49:0] sum_stage1_2;  // sfix50_En44
  wire signed [49:0] sum_stage2_1;  // sfix50_En44
  wire signed [49:0] mul_out1_5;  // sfix50_En44
  wire signed [49:0] sum_stage1_3;  // sfix50_En44
  wire signed [49:0] mul_out1_7;  // sfix50_En44
  wire signed [49:0] sum_stage1_4;  // sfix50_En44
  wire signed [49:0] sum_stage2_2;  // sfix50_En44
  wire signed [49:0] sum_stage3_1;  // sfix50_En44
  wire signed [49:0] mul_out1_8;  // sfix50_En44
  wire signed [49:0] sum_stage4_1;  // sfix50_En44
  reg signed [31:0] HwModeRegister1_t_0_0;  // int32
  reg signed [31:0] HwModeRegister1_t_1;  // int32
  reg signed [31:0] PipelineRegister_t_0_0;  // int32
  reg signed [31:0] PipelineRegister_t_1;  // int32


  assign mergedInput = {in1_0, in1_1, in1_2, in1_3, in1_4};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 125'h00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 3
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 3'b000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 3'b011) begin
            mergedDelay_waddr <= 3'b000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 3'b001;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 3
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 3'b001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 3'b011) begin
            mergedDelay_raddr <= 3'b000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 3'b001;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(3),
                              .DataWidth(125)
                              )
                            u_ShiftRegisterRAM (.clk(clk),
                                                .enb(enb),
                                                .wr_din(mergedDelay_regin),
                                                .wr_addr(mergedDelay_waddr),
                                                .wr_en(mergedDelay_wrenb),  // ufix1
                                                .rd_addr(mergedDelay_raddr),
                                                .dout(mergedDelay_regout)
                                                );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 125'h00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign mergedInput_1 = {in1_5, in1_6, in1_7, in1_8};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_1_process
      if (reset == 1'b1) begin
        mergedDelay_regin_1 <= 100'h0000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_1 <= mergedInput_1;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 3
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_1_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_1 <= 3'b000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_1 >= 3'b011) begin
            mergedDelay_waddr_1 <= 3'b000;
          end
          else begin
            mergedDelay_waddr_1 <= mergedDelay_waddr_1 + 3'b001;
          end
        end
      end
    end

  assign mergedDelay_wrenb_1 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 3
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_1_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_1 <= 3'b001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_1 >= 3'b011) begin
            mergedDelay_raddr_1 <= 3'b000;
          end
          else begin
            mergedDelay_raddr_1 <= mergedDelay_raddr_1 + 3'b001;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(3),
                              .DataWidth(100)
                              )
                            u_ShiftRegisterRAM_1 (.clk(clk),
                                                  .enb(enb),
                                                  .wr_din(mergedDelay_regin_1),
                                                  .wr_addr(mergedDelay_waddr_1),
                                                  .wr_en(mergedDelay_wrenb_1),  // ufix1
                                                  .rd_addr(mergedDelay_raddr_1),
                                                  .dout(mergedDelay_regout_1)
                                                  );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_1_process
      if (reset == 1'b1) begin
        mergedOutput_1 <= 100'h0000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_1 <= mergedDelay_regout_1;
        end
      end
    end

  assign slicedInput = mergedOutput[124:100];

  assign delayOut0 = slicedInput;

  assign slicedInput_1 = mergedOutput[99:75];

  assign delayOut1 = slicedInput_1;

  assign slicedInput_2 = mergedOutput[74:50];

  assign delayOut2 = slicedInput_2;

  assign slicedInput_3 = mergedOutput[49:25];

  assign delayOut3 = slicedInput_3;

  assign slicedInput_4 = mergedOutput[24:0];

  assign delayOut4 = slicedInput_4;

  assign slicedInput_5 = mergedOutput_1[99:75];

  assign delayOut5 = slicedInput_5;

  assign slicedInput_6 = mergedOutput_1[74:50];

  assign delayOut6 = slicedInput_6;

  assign slicedInput_7 = mergedOutput_1[49:25];

  assign delayOut7 = slicedInput_7;

  assign slicedInput_8 = mergedOutput_1[24:0];

  assign delayOut8 = slicedInput_8;

  assign mul_in1[0] = delayOut0;
  assign mul_in1[1] = delayOut1;
  assign mul_in1[2] = delayOut2;
  assign mul_in1[3] = delayOut3;
  assign mul_in1[4] = delayOut4;
  assign mul_in1[5] = delayOut5;
  assign mul_in1[6] = delayOut6;
  assign mul_in1[7] = delayOut7;
  assign mul_in1[8] = delayOut8;

  assign mul_in2[0] = in2_0;
  assign mul_in2[1] = in2_1;
  assign mul_in2[2] = in2_2;
  assign mul_in2[3] = in2_3;
  assign mul_in2[4] = in2_4;
  assign mul_in2[5] = in2_5;
  assign mul_in2[6] = in2_6;
  assign mul_in2[7] = in2_7;
  assign mul_in2[8] = in2_8;

  always @(posedge clk)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        for(HwModeRegister1_t_1 = 32'sd0; HwModeRegister1_t_1 <= 32'sd8; HwModeRegister1_t_1 = HwModeRegister1_t_1 + 32'sd1) begin
          mul_in2_1[HwModeRegister1_t_1] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister1_t_0_0 = 32'sd0; HwModeRegister1_t_0_0 <= 32'sd8; HwModeRegister1_t_0_0 = HwModeRegister1_t_0_0 + 32'sd1) begin
            mul_in2_1[HwModeRegister1_t_0_0] <= mul_in2[HwModeRegister1_t_0_0];
          end
        end
      end
    end

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space

  genvar t_0_01;
  generate
    for(t_0_01 = 32'sd0; t_0_01 <= 32'sd8; t_0_01 = t_0_01 + 32'sd1) begin:mul_out1_gen
      assign mul_out1[t_0_01] = mul_in1[t_0_01] * mul_in2_1[t_0_01];
    end
  endgenerate

  always @(posedge clk)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        for(PipelineRegister_t_1 = 32'sd0; PipelineRegister_t_1 <= 32'sd8; PipelineRegister_t_1 = PipelineRegister_t_1 + 32'sd1) begin
          mul_out1_1[PipelineRegister_t_1] <= 50'sh0000000000000;
        end
      end
      else begin
        if (enb) begin
          for(PipelineRegister_t_0_0 = 32'sd0; PipelineRegister_t_0_0 <= 32'sd8; PipelineRegister_t_0_0 = PipelineRegister_t_0_0 + 32'sd1) begin
            mul_out1_1[PipelineRegister_t_0_0] <= mul_out1[PipelineRegister_t_0_0];
          end
        end
      end
    end

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign mul_out1_0 = mul_out1_1[0];

  assign mul_out1_2 = mul_out1_1[2];

  assign mul_out1_4 = mul_out1_1[4];

  assign mul_out1_6 = mul_out1_1[6];

  assign mul_out1_1_1 = mul_out1_1[1];

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sum_stage1_1 = mul_out1_0 + mul_out1_1_1;

  assign mul_out1_3 = mul_out1_1[3];

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sum_stage1_2 = mul_out1_2 + mul_out1_3;

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sum_stage2_1 = sum_stage1_1 + sum_stage1_2;

  assign mul_out1_5 = mul_out1_1[5];

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sum_stage1_3 = mul_out1_4 + mul_out1_5;

  assign mul_out1_7 = mul_out1_1[7];

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sum_stage1_4 = mul_out1_6 + mul_out1_7;

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sum_stage2_2 = sum_stage1_3 + sum_stage1_4;

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sum_stage3_1 = sum_stage2_1 + sum_stage2_2;

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign mul_out1_8 = mul_out1_1[8];

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sum_stage4_1 = sum_stage3_1 + mul_out1_8;

  assign out1 = sum_stage4_1;

endmodule  // dot_product_9

