// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\HDL_pfc_gold_fi\HDL_Subsystem.v
// Created: 2024-12-27 09:23:12
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: HDL_Subsystem
// Source Path: HDL_pfc_gold_fi/simscape_system/HDL Subsystem
// Hierarchy Level: 1
// Model version: 1.63
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module HDL_Subsystem
          (clk,
           reset,
           enb,
           enb_1_37_1,
           enb_1_37_0,
           I_load_in,
           ic_in_MOSFET,
           ic_in_MOSFET1,
           ic_in_MOSFET2,
           ic_in_MOSFET3,
           ic_in_MOSFET4,
           ic_in_MOSFET5,
           va,
           vb,
           vc,
           sch_ctr_36,
           I_load,
           is_out_MOSFET,
           vs_out_MOSFET,
           is_out_MOSFET1,
           vs_out_MOSFET1,
           is_out_MOSFET2,
           vs_out_MOSFET2,
           is_out_MOSFET3,
           vs_out_MOSFET3,
           is_out_MOSFET4,
           vs_out_MOSFET4,
           is_out_MOSFET5,
           vs_out_MOSFET5,
           Vout,
           Ib,
           Ic,
           Ia,
           Vb_1,
           Vc_1,
           Va_1);


  input   clk;
  input   reset;
  input   enb;
  input   enb_1_37_1;
  input   enb_1_37_0;
  input   signed [17:0] I_load_in;  // sfix18_En8
  input   signed [17:0] ic_in_MOSFET;  // sfix18_En8
  input   signed [17:0] ic_in_MOSFET1;  // sfix18_En8
  input   signed [17:0] ic_in_MOSFET2;  // sfix18_En8
  input   signed [17:0] ic_in_MOSFET3;  // sfix18_En8
  input   signed [17:0] ic_in_MOSFET4;  // sfix18_En8
  input   signed [17:0] ic_in_MOSFET5;  // sfix18_En8
  input   signed [17:0] va;  // sfix18_En8
  input   signed [17:0] vb;  // sfix18_En8
  input   signed [17:0] vc;  // sfix18_En8
  input   [5:0] sch_ctr_36;  // ufix6
  output  signed [17:0] I_load;  // sfix18_En6
  output  signed [17:0] is_out_MOSFET;  // sfix18_En6
  output  signed [17:0] vs_out_MOSFET;  // sfix18_En6
  output  signed [17:0] is_out_MOSFET1;  // sfix18_En6
  output  signed [17:0] vs_out_MOSFET1;  // sfix18_En6
  output  signed [17:0] is_out_MOSFET2;  // sfix18_En6
  output  signed [17:0] vs_out_MOSFET2;  // sfix18_En6
  output  signed [17:0] is_out_MOSFET3;  // sfix18_En6
  output  signed [17:0] vs_out_MOSFET3;  // sfix18_En6
  output  signed [17:0] is_out_MOSFET4;  // sfix18_En6
  output  signed [17:0] vs_out_MOSFET4;  // sfix18_En6
  output  signed [17:0] is_out_MOSFET5;  // sfix18_En6
  output  signed [17:0] vs_out_MOSFET5;  // sfix18_En6
  output  signed [17:0] Vout;  // sfix18_En6
  output  signed [17:0] Ib;  // sfix18_En6
  output  signed [17:0] Ic;  // sfix18_En6
  output  signed [17:0] Ia;  // sfix18_En6
  output  signed [17:0] Vb_1;  // sfix18_En6
  output  signed [17:0] Vc_1;  // sfix18_En6
  output  signed [17:0] Va_1;  // sfix18_En6


  wire signed [17:0] I_load_in_1;  // sfix18_En8
  wire signed [17:0] va_2;  // sfix18_En8
  wire signed [17:0] vb_2;  // sfix18_En8
  wire signed [17:0] vc_2;  // sfix18_En8
  wire [71:0] mergedInput;  // ufix72
  reg [71:0] mergedDelay_regin;  // ufix72
  reg [2:0] mergedDelay_waddr;  // ufix3
  wire mergedDelay_wrenb;  // ufix1
  reg [2:0] mergedDelay_raddr;  // ufix3
  wire [71:0] mergedDelay_regout;  // ufix72
  reg [71:0] mergedOutput;  // ufix72
  wire [17:0] slicedInput;  // ufix18
  wire signed [17:0] I_load_in_2;  // sfix18_En8
  wire [17:0] slicedInput_1;  // ufix18
  wire signed [17:0] va_3;  // sfix18_En8
  wire [17:0] slicedInput_2;  // ufix18
  wire signed [17:0] vb_3;  // sfix18_En8
  wire [17:0] slicedInput_3;  // ufix18
  wire signed [17:0] vc_3;  // sfix18_En8
  wire signed [17:0] Input_Concat_out1 [0:9];  // sfix18_En8 [10]
  wire signed [24:0] Data_Type_Conversion_out1 [0:9];  // sfix25_En13 [10]
  wire signed [24:0] matrixDOutSignal_0;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_1;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_2;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_3;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_4;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_5;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_6;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_7;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_8;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_9;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_10;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_11;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_12;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_13;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_14;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_15;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_16;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_17;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_18;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal_19;  // sfix25_En13
  wire signed [24:0] matrixDOutSignal [0:19];  // sfix25_En13 [20]
  reg signed [24:0] matrixDOutSignal_20 [0:19];  // sfix25_En13 [20]
  wire State_ctrl_const_out;
  reg  State_ctrl_delay_out;
  wire State_ctrl_delay_out_1;
  wire streaming_partition_streamed_enb_phase_0_6;
  wire enb_gated;
  reg [2:0] counterSig;  // ufix3
  wire signed [24:0] State_Initial_Val_out [0:6];  // sfix25_En13 [7]
  wire signed [24:0] State_Initial_Val_out_0;  // sfix25_En13
  wire signed [24:0] State_Initial_Val_out_1;  // sfix25_En13
  wire signed [24:0] State_Initial_Val_out_2;  // sfix25_En13
  wire signed [24:0] State_Initial_Val_out_3;  // sfix25_En13
  wire signed [24:0] State_Initial_Val_out_4;  // sfix25_En13
  wire signed [24:0] State_Initial_Val_out_5;  // sfix25_En13
  wire signed [24:0] State_Initial_Val_out_6;  // sfix25_En13
  wire signed [24:0] State_Initial_Val_out_unbuffer;  // sfix25_En13
  wire enb_counter_ge_13_1;
  wire enb_counter_le_19_1;
  wire streaming_partition_streamed_enb_phase_13_6;
  wire enb_gated_1;
  reg [2:0] counterSig_1;  // ufix3
  wire signed [24:0] matrixBOutSignal_0;  // sfix25_En13
  wire signed [24:0] matrixBOutSignal_1;  // sfix25_En13
  wire signed [24:0] matrixBOutSignal_2;  // sfix25_En13
  wire signed [24:0] matrixBOutSignal_3;  // sfix25_En13
  wire signed [24:0] matrixBOutSignal_4;  // sfix25_En13
  wire signed [24:0] matrixBOutSignal_5;  // sfix25_En13
  wire signed [24:0] matrixBOutSignal_6;  // sfix25_En13
  wire signed [24:0] matrixBOutSignal_unbuffer;  // sfix25_En13
  reg signed [24:0] matrixBOutSignal_unbuffer_1;  // sfix25_En13
  reg [2:0] counterSig_2;  // ufix3
  wire streaming_partition_streamed_enb_phase_6_0;
  wire enb_counter_ge_14_1;
  wire enb_counter_le_19_2;
  wire streaming_partition_streamed_enb_phase_14_5;
  wire enb_gated_2;
  wire streaming_partition_streamed_enb_phase_20_0;
  wire streaming_partition_streamed_enb_phase_0_5;
  wire enb_gated_3;
  reg signed [24:0] State_out [0:6];  // sfix25_En13 [7]
  wire signed [24:0] State_out_6;  // sfix25_En13
  wire signed [24:0] State_out_5;  // sfix25_En13
  wire signed [24:0] State_out_4;  // sfix25_En13
  wire signed [24:0] State_out_3;  // sfix25_En13
  wire signed [24:0] State_out_2;  // sfix25_En13
  wire signed [24:0] State_out_1;  // sfix25_En13
  wire signed [24:0] delayInSignal;  // sfix25_En13
  reg signed [24:0] delayInSignal_held;  // sfix25_En13
  wire signed [24:0] sumStateEqOutSignal;  // sfix25_En13
  reg signed [24:0] delayInSignal_1 [0:5];  // sfix25_En13 [6]
  wire signed [24:0] delayOutSignal;  // sfix25_En13
  reg signed [24:0] delayOutSignal_held;  // sfix25_En13
  wire signed [24:0] delayOutSignal_1;  // sfix25_En13
  reg signed [24:0] delayOutSignal_2 [0:5];  // sfix25_En13 [6]
  wire signed [24:0] delayOutSignal_5;  // sfix25_En13
  wire signed [24:0] delayOutSignal_4;  // sfix25_En13
  wire signed [24:0] delayOutSignal_3;  // sfix25_En13
  wire signed [24:0] delayOutSignal_2_1;  // sfix25_En13
  wire signed [24:0] delayOutSignal_1_1;  // sfix25_En13
  wire signed [24:0] delayOutSignal_0;  // sfix25_En13
  wire signed [24:0] matrixAOutSignal_0;  // sfix25_En13
  wire signed [24:0] matrixAOutSignal_1;  // sfix25_En13
  wire signed [24:0] matrixAOutSignal_2;  // sfix25_En13
  wire signed [24:0] matrixAOutSignal_3;  // sfix25_En13
  wire signed [24:0] matrixAOutSignal_4;  // sfix25_En13
  wire signed [24:0] matrixAOutSignal_5;  // sfix25_En13
  wire signed [24:0] matrixAOutSignal_6;  // sfix25_En13
  wire signed [24:0] matrixAOutSignal_unbuffer;  // sfix25_En13
  reg signed [24:0] tapped_delay_reg [0:5];  // sfix25 [6]
  reg signed [24:0] tapped_delay_reg_next [0:5];  // sfix25_En13 [6]
  wire signed [24:0] delayInSignal_2 [0:6];  // sfix25_En13 [7]
  reg signed [24:0] delayInSignal_3 [0:6];  // sfix25_En13 [7]
  reg signed [24:0] State_bypass_reg [0:6];  // sfix25 [7]
  reg signed [24:0] State_bypass_reg_next [0:6];  // sfix25_En13 [7]
  wire signed [24:0] State_out_0;  // sfix25_En13
  wire signed [24:0] State_out_unbuffer;  // sfix25_En13
  reg signed [24:0] tapped_delay_reg_1 [0:5];  // sfix25 [6]
  reg signed [24:0] tapped_delay_reg_next_1 [0:5];  // sfix25_En13 [6]
  wire signed [24:0] matrixCOutSignal_0;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_1;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_2;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_3;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_4;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_5;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_6;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_7;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_8;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_9;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_10;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_11;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_12;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_13;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_14;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_15;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_16;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_17;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_18;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal_19;  // sfix25_En13
  wire signed [24:0] matrixCOutSignal [0:19];  // sfix25_En13 [20]
  wire signed [24:0] sumOutputEqOutSignal [0:19];  // sfix25_En13 [20]
  wire signed [24:0] out0 [0:19];  // sfix25_En13 [20]
  wire signed [17:0] Data_Type_Conversion1_out1 [0:19];  // sfix18_En6 [20]
  wire signed [17:0] I_load_1;  // sfix18_En6
  reg signed [17:0] t_bypass_reg;  // sfix18
  wire signed [17:0] Vout_1;  // sfix18_En6
  reg signed [17:0] t1_bypass_reg;  // sfix18
  wire signed [17:0] Ib_1;  // sfix18_En6
  reg signed [17:0] t2_bypass_reg;  // sfix18
  wire signed [17:0] Ic_1;  // sfix18_En6
  reg signed [17:0] t3_bypass_reg;  // sfix18
  wire signed [17:0] Ia_1;  // sfix18_En6
  reg signed [17:0] t4_bypass_reg;  // sfix18
  wire signed [17:0] Vb_4;  // sfix18_En6
  reg signed [17:0] t5_bypass_reg;  // sfix18
  wire signed [17:0] Vc_4;  // sfix18_En6
  reg signed [17:0] t6_bypass_reg;  // sfix18
  wire signed [17:0] Va_4;  // sfix18_En6
  reg signed [17:0] t7_bypass_reg;  // sfix18
  reg signed [31:0] delayMatch_t_0_0;  // int32
  reg signed [31:0] delayMatch_t_1;  // int32
  reg signed [31:0] tapped_delay_t_0_0;  // int32
  reg signed [31:0] tapped_delay_t_1;  // int32
  reg signed [31:0] tapped_delay_t_0_1;  // int32
  reg signed [31:0] tapped_delay_t_1_0;  // int32
  reg signed [31:0] crp_out_delay_t_0_0;  // int32
  reg signed [31:0] crp_out_delay_t_1;  // int32
  reg signed [31:0] State_bypass_t_0_0;  // int32
  reg signed [31:0] State_bypass_t_1;  // int32
  reg signed [31:0] State_bypass_t_2;  // int32
  reg signed [31:0] State_bypass_t_0_1;  // int32
  reg signed [31:0] State_bypass_t_1_0;  // int32
  reg signed [31:0] tapped_delay_t_0_01;  // int32
  reg signed [31:0] tapped_delay_t_11;  // int32


  assign I_load_in_1 = I_load_in;

  assign va_2 = va;

  assign vb_2 = vb;

  assign vc_2 = vc;

  assign mergedInput = {I_load_in_1, va_2, vb_2, vc_2};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 72'h000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 3'b000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 3'b010) begin
            mergedDelay_waddr <= 3'b000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 3'b001;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 2
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 3'b001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 3'b010) begin
            mergedDelay_raddr <= 3'b000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 3'b001;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(3),
                              .DataWidth(72)
                              )
                            u_ShiftRegisterRAM (.clk(clk),
                                                .enb(enb),
                                                .wr_din(mergedDelay_regin),
                                                .wr_addr(mergedDelay_waddr),
                                                .wr_en(mergedDelay_wrenb),  // ufix1
                                                .rd_addr(mergedDelay_raddr),
                                                .dout(mergedDelay_regout)
                                                );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 72'h000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign slicedInput = mergedOutput[71:54];

  assign I_load_in_2 = slicedInput;

  assign slicedInput_1 = mergedOutput[53:36];

  assign va_3 = slicedInput_1;

  assign slicedInput_2 = mergedOutput[35:18];

  assign vb_3 = slicedInput_2;

  assign slicedInput_3 = mergedOutput[17:0];

  assign vc_3 = slicedInput_3;

  // <S5>/Input Concat
  assign Input_Concat_out1[0] = I_load_in_2;
  assign Input_Concat_out1[1] = ic_in_MOSFET;
  assign Input_Concat_out1[2] = ic_in_MOSFET1;
  assign Input_Concat_out1[3] = ic_in_MOSFET2;
  assign Input_Concat_out1[4] = ic_in_MOSFET3;
  assign Input_Concat_out1[5] = ic_in_MOSFET4;
  assign Input_Concat_out1[6] = ic_in_MOSFET5;
  assign Input_Concat_out1[7] = va_3;
  assign Input_Concat_out1[8] = vb_3;
  assign Input_Concat_out1[9] = vc_3;

  // <S5>/Data Type Conversion

  genvar ii2;
  generate
    for(ii2 = 32'sd0; ii2 <= 32'sd9; ii2 = ii2 + 32'sd1) begin:Data_Type_Conversion_out1_gen
      assign Data_Type_Conversion_out1[ii2] = {{2{Input_Concat_out1[ii2][17]}}, {Input_Concat_out1[ii2], 5'b00000}};
    end
  endgenerate

  // <S5>/Fixed-Point State-Space
  hNNewMatrixD u_Sparse_Matrix_Vector_Product3 (.clk(clk),
                                                .reset(reset),
                                                .enb(enb),
                                                .in0_0(Data_Type_Conversion_out1[0]),  // sfix25_En13
                                                .in0_1(Data_Type_Conversion_out1[1]),  // sfix25_En13
                                                .in0_2(Data_Type_Conversion_out1[2]),  // sfix25_En13
                                                .in0_3(Data_Type_Conversion_out1[3]),  // sfix25_En13
                                                .in0_4(Data_Type_Conversion_out1[4]),  // sfix25_En13
                                                .in0_5(Data_Type_Conversion_out1[5]),  // sfix25_En13
                                                .in0_6(Data_Type_Conversion_out1[6]),  // sfix25_En13
                                                .in0_7(Data_Type_Conversion_out1[7]),  // sfix25_En13
                                                .in0_8(Data_Type_Conversion_out1[8]),  // sfix25_En13
                                                .in0_9(Data_Type_Conversion_out1[9]),  // sfix25_En13
                                                .enb_counter(sch_ctr_36),  // ufix6
                                                .matrixDOutSignal_0(matrixDOutSignal_0),  // sfix25_En13
                                                .matrixDOutSignal_1(matrixDOutSignal_1),  // sfix25_En13
                                                .matrixDOutSignal_2(matrixDOutSignal_2),  // sfix25_En13
                                                .matrixDOutSignal_3(matrixDOutSignal_3),  // sfix25_En13
                                                .matrixDOutSignal_4(matrixDOutSignal_4),  // sfix25_En13
                                                .matrixDOutSignal_5(matrixDOutSignal_5),  // sfix25_En13
                                                .matrixDOutSignal_6(matrixDOutSignal_6),  // sfix25_En13
                                                .matrixDOutSignal_7(matrixDOutSignal_7),  // sfix25_En13
                                                .matrixDOutSignal_8(matrixDOutSignal_8),  // sfix25_En13
                                                .matrixDOutSignal_9(matrixDOutSignal_9),  // sfix25_En13
                                                .matrixDOutSignal_10(matrixDOutSignal_10),  // sfix25_En13
                                                .matrixDOutSignal_11(matrixDOutSignal_11),  // sfix25_En13
                                                .matrixDOutSignal_12(matrixDOutSignal_12),  // sfix25_En13
                                                .matrixDOutSignal_13(matrixDOutSignal_13),  // sfix25_En13
                                                .matrixDOutSignal_14(matrixDOutSignal_14),  // sfix25_En13
                                                .matrixDOutSignal_15(matrixDOutSignal_15),  // sfix25_En13
                                                .matrixDOutSignal_16(matrixDOutSignal_16),  // sfix25_En13
                                                .matrixDOutSignal_17(matrixDOutSignal_17),  // sfix25_En13
                                                .matrixDOutSignal_18(matrixDOutSignal_18),  // sfix25_En13
                                                .matrixDOutSignal_19(matrixDOutSignal_19)  // sfix25_En13
                                                );

  assign matrixDOutSignal[0] = matrixDOutSignal_0;
  assign matrixDOutSignal[1] = matrixDOutSignal_1;
  assign matrixDOutSignal[2] = matrixDOutSignal_2;
  assign matrixDOutSignal[3] = matrixDOutSignal_3;
  assign matrixDOutSignal[4] = matrixDOutSignal_4;
  assign matrixDOutSignal[5] = matrixDOutSignal_5;
  assign matrixDOutSignal[6] = matrixDOutSignal_6;
  assign matrixDOutSignal[7] = matrixDOutSignal_7;
  assign matrixDOutSignal[8] = matrixDOutSignal_8;
  assign matrixDOutSignal[9] = matrixDOutSignal_9;
  assign matrixDOutSignal[10] = matrixDOutSignal_10;
  assign matrixDOutSignal[11] = matrixDOutSignal_11;
  assign matrixDOutSignal[12] = matrixDOutSignal_12;
  assign matrixDOutSignal[13] = matrixDOutSignal_13;
  assign matrixDOutSignal[14] = matrixDOutSignal_14;
  assign matrixDOutSignal[15] = matrixDOutSignal_15;
  assign matrixDOutSignal[16] = matrixDOutSignal_16;
  assign matrixDOutSignal[17] = matrixDOutSignal_17;
  assign matrixDOutSignal[18] = matrixDOutSignal_18;
  assign matrixDOutSignal[19] = matrixDOutSignal_19;

  always @(posedge clk)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        for(delayMatch_t_1 = 32'sd0; delayMatch_t_1 <= 32'sd19; delayMatch_t_1 = delayMatch_t_1 + 32'sd1) begin
          matrixDOutSignal_20[delayMatch_t_1] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(delayMatch_t_0_0 = 32'sd0; delayMatch_t_0_0 <= 32'sd19; delayMatch_t_0_0 = delayMatch_t_0_0 + 32'sd1) begin
            matrixDOutSignal_20[delayMatch_t_0_0] <= matrixDOutSignal[delayMatch_t_0_0];
          end
        end
      end
    end

  assign State_ctrl_const_out = 1'b1;

  always @(posedge clk)
    begin : State_ctrl_delay_process
      if (reset == 1'b1) begin
        State_ctrl_delay_out <= 1'b0;
      end
      else begin
        if (enb_1_37_0) begin
          State_ctrl_delay_out <= State_ctrl_const_out;
        end
      end
    end

  assign State_ctrl_delay_out_1 = State_ctrl_delay_out;

  assign streaming_partition_streamed_enb_phase_0_6 = sch_ctr_36 <= 6'b000110;

  assign enb_gated = streaming_partition_streamed_enb_phase_0_6 && enb;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 6
  always @(posedge clk)
    begin : ctr_0_6_process
      if (reset == 1'b1) begin
        counterSig <= 3'b000;
      end
      else begin
        if (enb_gated) begin
          if (counterSig >= 3'b110) begin
            counterSig <= 3'b000;
          end
          else begin
            counterSig <= counterSig + 3'b001;
          end
        end
      end
    end

  assign State_Initial_Val_out[0] = 25'sb0000000000000000000000000;
  assign State_Initial_Val_out[1] = 25'sb0000000000000000000000000;
  assign State_Initial_Val_out[2] = 25'sb0000000000000000000000000;
  assign State_Initial_Val_out[3] = 25'sb0000000000000000000000000;
  assign State_Initial_Val_out[4] = 25'sb0000000000000000000000000;
  assign State_Initial_Val_out[5] = 25'sb0000000000000000000000000;
  assign State_Initial_Val_out[6] = 25'sb0010010001000000000000000;

  assign State_Initial_Val_out_0 = State_Initial_Val_out[0];

  assign State_Initial_Val_out_1 = State_Initial_Val_out[1];

  assign State_Initial_Val_out_2 = State_Initial_Val_out[2];

  assign State_Initial_Val_out_3 = State_Initial_Val_out[3];

  assign State_Initial_Val_out_4 = State_Initial_Val_out[4];

  assign State_Initial_Val_out_5 = State_Initial_Val_out[5];

  assign State_Initial_Val_out_6 = State_Initial_Val_out[6];

  assign State_Initial_Val_out_unbuffer = (counterSig == 3'b000 ? State_Initial_Val_out_0 :
              (counterSig == 3'b001 ? State_Initial_Val_out_1 :
              (counterSig == 3'b010 ? State_Initial_Val_out_2 :
              (counterSig == 3'b011 ? State_Initial_Val_out_3 :
              (counterSig == 3'b100 ? State_Initial_Val_out_4 :
              (counterSig == 3'b101 ? State_Initial_Val_out_5 :
              State_Initial_Val_out_6))))));

  assign enb_counter_ge_13_1 = sch_ctr_36 >= 6'b001101;

  assign enb_counter_le_19_1 = sch_ctr_36 <= 6'b010011;

  assign streaming_partition_streamed_enb_phase_13_6 = enb_counter_ge_13_1 & enb_counter_le_19_1;

  assign enb_gated_1 = streaming_partition_streamed_enb_phase_13_6 && enb;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 6
  always @(posedge clk)
    begin : ctr_0_6_1_process
      if (reset == 1'b1) begin
        counterSig_1 <= 3'b000;
      end
      else begin
        if (enb_gated_1) begin
          if (counterSig_1 >= 3'b110) begin
            counterSig_1 <= 3'b000;
          end
          else begin
            counterSig_1 <= counterSig_1 + 3'b001;
          end
        end
      end
    end

  // <S5>/Fixed-Point State-Space
  hNNewMatrixB u_Sparse_Matrix_Vector_Product (.clk(clk),
                                               .reset(reset),
                                               .enb(enb),
                                               .in0_0(Data_Type_Conversion_out1[0]),  // sfix25_En13
                                               .in0_1(Data_Type_Conversion_out1[1]),  // sfix25_En13
                                               .in0_2(Data_Type_Conversion_out1[2]),  // sfix25_En13
                                               .in0_3(Data_Type_Conversion_out1[3]),  // sfix25_En13
                                               .in0_4(Data_Type_Conversion_out1[4]),  // sfix25_En13
                                               .in0_5(Data_Type_Conversion_out1[5]),  // sfix25_En13
                                               .in0_6(Data_Type_Conversion_out1[6]),  // sfix25_En13
                                               .in0_7(Data_Type_Conversion_out1[7]),  // sfix25_En13
                                               .in0_8(Data_Type_Conversion_out1[8]),  // sfix25_En13
                                               .in0_9(Data_Type_Conversion_out1[9]),  // sfix25_En13
                                               .enb_counter(sch_ctr_36),  // ufix6
                                               .matrixBOutSignal_0(matrixBOutSignal_0),  // sfix25_En13
                                               .matrixBOutSignal_1(matrixBOutSignal_1),  // sfix25_En13
                                               .matrixBOutSignal_2(matrixBOutSignal_2),  // sfix25_En13
                                               .matrixBOutSignal_3(matrixBOutSignal_3),  // sfix25_En13
                                               .matrixBOutSignal_4(matrixBOutSignal_4),  // sfix25_En13
                                               .matrixBOutSignal_5(matrixBOutSignal_5),  // sfix25_En13
                                               .matrixBOutSignal_6(matrixBOutSignal_6)  // sfix25_En13
                                               );

  assign matrixBOutSignal_unbuffer = (counterSig_1 == 3'b000 ? matrixBOutSignal_0 :
              (counterSig_1 == 3'b001 ? matrixBOutSignal_1 :
              (counterSig_1 == 3'b010 ? matrixBOutSignal_2 :
              (counterSig_1 == 3'b011 ? matrixBOutSignal_3 :
              (counterSig_1 == 3'b100 ? matrixBOutSignal_4 :
              (counterSig_1 == 3'b101 ? matrixBOutSignal_5 :
              matrixBOutSignal_6))))));

  always @(posedge clk)
    begin : delayMatch_1_process
      if (reset == 1'b1) begin
        matrixBOutSignal_unbuffer_1 <= 25'sb0000000000000000000000000;
      end
      else begin
        if (enb) begin
          matrixBOutSignal_unbuffer_1 <= matrixBOutSignal_unbuffer;
        end
      end
    end

  always @(posedge clk)
    begin : delayMatch1_process
      if (reset == 1'b1) begin
        counterSig_2 <= 3'b000;
      end
      else begin
        if (enb) begin
          counterSig_2 <= counterSig_1;
        end
      end
    end

  assign streaming_partition_streamed_enb_phase_6_0 = sch_ctr_36 == 6'b000110;

  assign enb_counter_ge_14_1 = sch_ctr_36 >= 6'b001110;

  assign enb_counter_le_19_2 = sch_ctr_36 <= 6'b010011;

  assign streaming_partition_streamed_enb_phase_14_5 = enb_counter_ge_14_1 & enb_counter_le_19_2;

  assign enb_gated_2 = streaming_partition_streamed_enb_phase_14_5 && enb;

  assign streaming_partition_streamed_enb_phase_20_0 = sch_ctr_36 == 6'b010100;

  assign streaming_partition_streamed_enb_phase_0_5 = sch_ctr_36 <= 6'b000101;

  assign enb_gated_3 = streaming_partition_streamed_enb_phase_0_5 && enb;

  assign State_out_6 = State_out[6];

  assign State_out_5 = State_out[5];

  assign State_out_4 = State_out[4];

  assign State_out_3 = State_out[3];

  assign State_out_2 = State_out[2];

  assign State_out_1 = State_out[1];

  always @(posedge clk)
    begin : delayInSignal_state_process
      if (reset == 1'b1) begin
        delayInSignal_held <= 25'sb0000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayInSignal_held <= delayInSignal;
        end
      end
    end

  assign delayInSignal = (streaming_partition_streamed_enb_phase_20_0 == 1'b0 ? delayInSignal_held :
              sumStateEqOutSignal);

  always @(posedge clk)
    begin : delayOutSignal_state_process
      if (reset == 1'b1) begin
        delayOutSignal_held <= 25'sb0000000000000000000000000;
      end
      else begin
        if (enb) begin
          delayOutSignal_held <= delayOutSignal;
        end
      end
    end

  assign delayOutSignal = (streaming_partition_streamed_enb_phase_6_0 == 1'b0 ? delayOutSignal_held :
              delayOutSignal_1);

  assign delayOutSignal_5 = delayOutSignal_2[5];

  assign delayOutSignal_4 = delayOutSignal_2[4];

  assign delayOutSignal_3 = delayOutSignal_2[3];

  assign delayOutSignal_2_1 = delayOutSignal_2[2];

  assign delayOutSignal_1_1 = delayOutSignal_2[1];

  // <S5>/Fixed-Point State-Space
  hNNewMatrixA u_Sparse_Matrix_Vector_Product1 (.clk(clk),
                                                .reset(reset),
                                                .enb(enb),
                                                .delayOutSignal_0(delayOutSignal_0),  // sfix25_En13
                                                .delayOutSignal_1(delayOutSignal_1_1),  // sfix25_En13
                                                .delayOutSignal_2(delayOutSignal_2_1),  // sfix25_En13
                                                .delayOutSignal_3(delayOutSignal_3),  // sfix25_En13
                                                .delayOutSignal_4(delayOutSignal_4),  // sfix25_En13
                                                .delayOutSignal_5(delayOutSignal_5),  // sfix25_En13
                                                .delayOutSignal_6(delayOutSignal),  // sfix25_En13
                                                .enb_counter(sch_ctr_36),  // ufix6
                                                .matrixAOutSignal_0(matrixAOutSignal_0),  // sfix25_En13
                                                .matrixAOutSignal_1(matrixAOutSignal_1),  // sfix25_En13
                                                .matrixAOutSignal_2(matrixAOutSignal_2),  // sfix25_En13
                                                .matrixAOutSignal_3(matrixAOutSignal_3),  // sfix25_En13
                                                .matrixAOutSignal_4(matrixAOutSignal_4),  // sfix25_En13
                                                .matrixAOutSignal_5(matrixAOutSignal_5),  // sfix25_En13
                                                .matrixAOutSignal_6(matrixAOutSignal_6)  // sfix25_En13
                                                );

  assign matrixAOutSignal_unbuffer = (counterSig_2 == 3'b000 ? matrixAOutSignal_0 :
              (counterSig_2 == 3'b001 ? matrixAOutSignal_1 :
              (counterSig_2 == 3'b010 ? matrixAOutSignal_2 :
              (counterSig_2 == 3'b011 ? matrixAOutSignal_3 :
              (counterSig_2 == 3'b100 ? matrixAOutSignal_4 :
              (counterSig_2 == 3'b101 ? matrixAOutSignal_5 :
              matrixAOutSignal_6))))));

  // <S5>/Fixed-Point State-Space
  // <S5>/Fixed-Point State-Space
  assign sumStateEqOutSignal = matrixBOutSignal_unbuffer_1 + matrixAOutSignal_unbuffer;

  always @(posedge clk)
    begin : tapped_delay_process
      if (reset == 1'b1) begin
        for(tapped_delay_t_1_0 = 32'sd0; tapped_delay_t_1_0 <= 32'sd5; tapped_delay_t_1_0 = tapped_delay_t_1_0 + 32'sd1) begin
          tapped_delay_reg[tapped_delay_t_1_0] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb_gated_2) begin
          for(tapped_delay_t_0_1 = 32'sd0; tapped_delay_t_0_1 <= 32'sd5; tapped_delay_t_0_1 = tapped_delay_t_0_1 + 32'sd1) begin
            tapped_delay_reg[tapped_delay_t_0_1] <= tapped_delay_reg_next[tapped_delay_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(tapped_delay_t_0_0 = 32'sd0; tapped_delay_t_0_0 <= 32'sd5; tapped_delay_t_0_0 = tapped_delay_t_0_0 + 32'sd1) begin
      delayInSignal_1[tapped_delay_t_0_0] = tapped_delay_reg[tapped_delay_t_0_0];
    end
    for(tapped_delay_t_1 = 32'sd0; tapped_delay_t_1 <= 32'sd4; tapped_delay_t_1 = tapped_delay_t_1 + 32'sd1) begin
      tapped_delay_reg_next[tapped_delay_t_1] = tapped_delay_reg[32'sd1 + tapped_delay_t_1];
    end

    tapped_delay_reg_next[5] = sumStateEqOutSignal;
  end

  assign delayInSignal_2[0] = delayInSignal_1[0];
  assign delayInSignal_2[1] = delayInSignal_1[1];
  assign delayInSignal_2[2] = delayInSignal_1[2];
  assign delayInSignal_2[3] = delayInSignal_1[3];
  assign delayInSignal_2[4] = delayInSignal_1[4];
  assign delayInSignal_2[5] = delayInSignal_1[5];
  assign delayInSignal_2[6] = delayInSignal;

  always @(posedge clk)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        for(crp_out_delay_t_1 = 32'sd0; crp_out_delay_t_1 <= 32'sd6; crp_out_delay_t_1 = crp_out_delay_t_1 + 32'sd1) begin
          delayInSignal_3[crp_out_delay_t_1] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay_t_0_0 = 32'sd0; crp_out_delay_t_0_0 <= 32'sd6; crp_out_delay_t_0_0 = crp_out_delay_t_0_0 + 32'sd1) begin
            delayInSignal_3[crp_out_delay_t_0_0] <= delayInSignal_2[crp_out_delay_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : State_bypass_process
      if (reset == 1'b1) begin
        for(State_bypass_t_1_0 = 32'sd0; State_bypass_t_1_0 <= 32'sd6; State_bypass_t_1_0 = State_bypass_t_1_0 + 32'sd1) begin
          State_bypass_reg[State_bypass_t_1_0] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb_1_37_1) begin
          for(State_bypass_t_0_1 = 32'sd0; State_bypass_t_0_1 <= 32'sd6; State_bypass_t_0_1 = State_bypass_t_0_1 + 32'sd1) begin
            State_bypass_reg[State_bypass_t_0_1] <= State_bypass_reg_next[State_bypass_t_0_1];
          end
        end
      end
    end

  always @* begin
    if (enb_1_37_1 == 1'b1) begin
      for(State_bypass_t_1 = 32'sd0; State_bypass_t_1 <= 32'sd6; State_bypass_t_1 = State_bypass_t_1 + 32'sd1) begin
        State_out[State_bypass_t_1] = delayInSignal_3[State_bypass_t_1];
      end
    end
    else begin
      for(State_bypass_t_0_0 = 32'sd0; State_bypass_t_0_0 <= 32'sd6; State_bypass_t_0_0 = State_bypass_t_0_0 + 32'sd1) begin
        State_out[State_bypass_t_0_0] = State_bypass_reg[State_bypass_t_0_0];
      end
    end

    for(State_bypass_t_2 = 32'sd0; State_bypass_t_2 <= 32'sd6; State_bypass_t_2 = State_bypass_t_2 + 32'sd1) begin
      State_bypass_reg_next[State_bypass_t_2] = delayInSignal_3[State_bypass_t_2];
    end

  end

  assign State_out_0 = State_out[0];

  assign State_out_unbuffer = (counterSig == 3'b000 ? State_out_0 :
              (counterSig == 3'b001 ? State_out_1 :
              (counterSig == 3'b010 ? State_out_2 :
              (counterSig == 3'b011 ? State_out_3 :
              (counterSig == 3'b100 ? State_out_4 :
              (counterSig == 3'b101 ? State_out_5 :
              State_out_6))))));

  assign delayOutSignal_1 = (State_ctrl_delay_out_1 == 1'b0 ? State_Initial_Val_out_unbuffer :
              State_out_unbuffer);

  always @(posedge clk)
    begin : tapped_delay_1_process
      if (reset == 1'b1) begin
        for(tapped_delay_t_1_0 = 32'sd0; tapped_delay_t_1_0 <= 32'sd5; tapped_delay_t_1_0 = tapped_delay_t_1_0 + 32'sd1) begin
          tapped_delay_reg_1[tapped_delay_t_1_0] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb_gated_3) begin
          for(tapped_delay_t_0_1 = 32'sd0; tapped_delay_t_0_1 <= 32'sd5; tapped_delay_t_0_1 = tapped_delay_t_0_1 + 32'sd1) begin
            tapped_delay_reg_1[tapped_delay_t_0_1] <= tapped_delay_reg_next_1[tapped_delay_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(tapped_delay_t_0_01 = 32'sd0; tapped_delay_t_0_01 <= 32'sd5; tapped_delay_t_0_01 = tapped_delay_t_0_01 + 32'sd1) begin
      delayOutSignal_2[tapped_delay_t_0_01] = tapped_delay_reg_1[tapped_delay_t_0_01];
    end
    for(tapped_delay_t_11 = 32'sd0; tapped_delay_t_11 <= 32'sd4; tapped_delay_t_11 = tapped_delay_t_11 + 32'sd1) begin
      tapped_delay_reg_next_1[tapped_delay_t_11] = tapped_delay_reg_1[32'sd1 + tapped_delay_t_11];
    end

    tapped_delay_reg_next_1[5] = delayOutSignal_1;
  end

  assign delayOutSignal_0 = delayOutSignal_2[0];

  // <S5>/Fixed-Point State-Space
  hNNewMatrixC u_Sparse_Matrix_Vector_Product2 (.clk(clk),
                                                .reset(reset),
                                                .enb(enb),
                                                .delayOutSignal_0(delayOutSignal_0),  // sfix25_En13
                                                .delayOutSignal_1(delayOutSignal_1_1),  // sfix25_En13
                                                .delayOutSignal_2(delayOutSignal_2_1),  // sfix25_En13
                                                .delayOutSignal_3(delayOutSignal_3),  // sfix25_En13
                                                .delayOutSignal_4(delayOutSignal_4),  // sfix25_En13
                                                .delayOutSignal_5(delayOutSignal_5),  // sfix25_En13
                                                .delayOutSignal_6(delayOutSignal),  // sfix25_En13
                                                .enb_counter(sch_ctr_36),  // ufix6
                                                .matrixCOutSignal_0(matrixCOutSignal_0),  // sfix25_En13
                                                .matrixCOutSignal_1(matrixCOutSignal_1),  // sfix25_En13
                                                .matrixCOutSignal_2(matrixCOutSignal_2),  // sfix25_En13
                                                .matrixCOutSignal_3(matrixCOutSignal_3),  // sfix25_En13
                                                .matrixCOutSignal_4(matrixCOutSignal_4),  // sfix25_En13
                                                .matrixCOutSignal_5(matrixCOutSignal_5),  // sfix25_En13
                                                .matrixCOutSignal_6(matrixCOutSignal_6),  // sfix25_En13
                                                .matrixCOutSignal_7(matrixCOutSignal_7),  // sfix25_En13
                                                .matrixCOutSignal_8(matrixCOutSignal_8),  // sfix25_En13
                                                .matrixCOutSignal_9(matrixCOutSignal_9),  // sfix25_En13
                                                .matrixCOutSignal_10(matrixCOutSignal_10),  // sfix25_En13
                                                .matrixCOutSignal_11(matrixCOutSignal_11),  // sfix25_En13
                                                .matrixCOutSignal_12(matrixCOutSignal_12),  // sfix25_En13
                                                .matrixCOutSignal_13(matrixCOutSignal_13),  // sfix25_En13
                                                .matrixCOutSignal_14(matrixCOutSignal_14),  // sfix25_En13
                                                .matrixCOutSignal_15(matrixCOutSignal_15),  // sfix25_En13
                                                .matrixCOutSignal_16(matrixCOutSignal_16),  // sfix25_En13
                                                .matrixCOutSignal_17(matrixCOutSignal_17),  // sfix25_En13
                                                .matrixCOutSignal_18(matrixCOutSignal_18),  // sfix25_En13
                                                .matrixCOutSignal_19(matrixCOutSignal_19)  // sfix25_En13
                                                );

  assign matrixCOutSignal[0] = matrixCOutSignal_0;
  assign matrixCOutSignal[1] = matrixCOutSignal_1;
  assign matrixCOutSignal[2] = matrixCOutSignal_2;
  assign matrixCOutSignal[3] = matrixCOutSignal_3;
  assign matrixCOutSignal[4] = matrixCOutSignal_4;
  assign matrixCOutSignal[5] = matrixCOutSignal_5;
  assign matrixCOutSignal[6] = matrixCOutSignal_6;
  assign matrixCOutSignal[7] = matrixCOutSignal_7;
  assign matrixCOutSignal[8] = matrixCOutSignal_8;
  assign matrixCOutSignal[9] = matrixCOutSignal_9;
  assign matrixCOutSignal[10] = matrixCOutSignal_10;
  assign matrixCOutSignal[11] = matrixCOutSignal_11;
  assign matrixCOutSignal[12] = matrixCOutSignal_12;
  assign matrixCOutSignal[13] = matrixCOutSignal_13;
  assign matrixCOutSignal[14] = matrixCOutSignal_14;
  assign matrixCOutSignal[15] = matrixCOutSignal_15;
  assign matrixCOutSignal[16] = matrixCOutSignal_16;
  assign matrixCOutSignal[17] = matrixCOutSignal_17;
  assign matrixCOutSignal[18] = matrixCOutSignal_18;
  assign matrixCOutSignal[19] = matrixCOutSignal_19;

  // <S5>/Fixed-Point State-Space

  genvar t_0_01;
  generate
    for(t_0_01 = 32'sd0; t_0_01 <= 32'sd19; t_0_01 = t_0_01 + 32'sd1) begin:sumOutputEqOutSignal_gen
      assign sumOutputEqOutSignal[t_0_01] = matrixDOutSignal_20[t_0_01] + matrixCOutSignal[t_0_01];
    end
  endgenerate

  // <S5>/Fixed-Point State-Space
  assign out0[0] = sumOutputEqOutSignal[0];
  assign out0[1] = sumOutputEqOutSignal[1];
  assign out0[2] = sumOutputEqOutSignal[2];
  assign out0[3] = sumOutputEqOutSignal[3];
  assign out0[4] = sumOutputEqOutSignal[4];
  assign out0[5] = sumOutputEqOutSignal[5];
  assign out0[6] = sumOutputEqOutSignal[6];
  assign out0[7] = sumOutputEqOutSignal[7];
  assign out0[8] = sumOutputEqOutSignal[8];
  assign out0[9] = sumOutputEqOutSignal[9];
  assign out0[10] = sumOutputEqOutSignal[10];
  assign out0[11] = sumOutputEqOutSignal[11];
  assign out0[12] = sumOutputEqOutSignal[12];
  assign out0[13] = sumOutputEqOutSignal[13];
  assign out0[14] = sumOutputEqOutSignal[14];
  assign out0[15] = sumOutputEqOutSignal[15];
  assign out0[16] = sumOutputEqOutSignal[16];
  assign out0[17] = sumOutputEqOutSignal[17];
  assign out0[18] = sumOutputEqOutSignal[18];
  assign out0[19] = sumOutputEqOutSignal[19];

  // <S5>/Data Type Conversion1

  genvar ii11;
  generate
    for(ii11 = 32'sd0; ii11 <= 32'sd19; ii11 = ii11 + 32'sd1) begin:Data_Type_Conversion1_out1_gen
      assign Data_Type_Conversion1_out1[ii11] = out0[ii11][24:7];
    end
  endgenerate

  // <S5>/Output Demux
  assign I_load_1 = Data_Type_Conversion1_out1[0];

  always @(posedge clk)
    begin : t_bypass_process
      if (reset == 1'b1) begin
        t_bypass_reg <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_37_1) begin
          t_bypass_reg <= I_load_1;
        end
      end
    end

  assign I_load = (enb_1_37_1 == 1'b1 ? I_load_1 :
              t_bypass_reg);

  assign is_out_MOSFET = Data_Type_Conversion1_out1[1];

  assign vs_out_MOSFET = Data_Type_Conversion1_out1[2];

  assign is_out_MOSFET1 = Data_Type_Conversion1_out1[3];

  assign vs_out_MOSFET1 = Data_Type_Conversion1_out1[4];

  assign is_out_MOSFET2 = Data_Type_Conversion1_out1[5];

  assign vs_out_MOSFET2 = Data_Type_Conversion1_out1[6];

  assign is_out_MOSFET3 = Data_Type_Conversion1_out1[7];

  assign vs_out_MOSFET3 = Data_Type_Conversion1_out1[8];

  assign is_out_MOSFET4 = Data_Type_Conversion1_out1[9];

  assign vs_out_MOSFET4 = Data_Type_Conversion1_out1[10];

  assign is_out_MOSFET5 = Data_Type_Conversion1_out1[11];

  assign vs_out_MOSFET5 = Data_Type_Conversion1_out1[12];

  assign Vout_1 = Data_Type_Conversion1_out1[13];

  always @(posedge clk)
    begin : t1_bypass_process
      if (reset == 1'b1) begin
        t1_bypass_reg <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_37_1) begin
          t1_bypass_reg <= Vout_1;
        end
      end
    end

  assign Vout = (enb_1_37_1 == 1'b1 ? Vout_1 :
              t1_bypass_reg);

  assign Ib_1 = Data_Type_Conversion1_out1[14];

  always @(posedge clk)
    begin : t2_bypass_process
      if (reset == 1'b1) begin
        t2_bypass_reg <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_37_1) begin
          t2_bypass_reg <= Ib_1;
        end
      end
    end

  assign Ib = (enb_1_37_1 == 1'b1 ? Ib_1 :
              t2_bypass_reg);

  assign Ic_1 = Data_Type_Conversion1_out1[15];

  always @(posedge clk)
    begin : t3_bypass_process
      if (reset == 1'b1) begin
        t3_bypass_reg <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_37_1) begin
          t3_bypass_reg <= Ic_1;
        end
      end
    end

  assign Ic = (enb_1_37_1 == 1'b1 ? Ic_1 :
              t3_bypass_reg);

  assign Ia_1 = Data_Type_Conversion1_out1[16];

  always @(posedge clk)
    begin : t4_bypass_process
      if (reset == 1'b1) begin
        t4_bypass_reg <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_37_1) begin
          t4_bypass_reg <= Ia_1;
        end
      end
    end

  assign Ia = (enb_1_37_1 == 1'b1 ? Ia_1 :
              t4_bypass_reg);

  assign Vb_4 = Data_Type_Conversion1_out1[17];

  always @(posedge clk)
    begin : t5_bypass_process
      if (reset == 1'b1) begin
        t5_bypass_reg <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_37_1) begin
          t5_bypass_reg <= Vb_4;
        end
      end
    end

  assign Vb_1 = (enb_1_37_1 == 1'b1 ? Vb_4 :
              t5_bypass_reg);

  assign Vc_4 = Data_Type_Conversion1_out1[18];

  always @(posedge clk)
    begin : t6_bypass_process
      if (reset == 1'b1) begin
        t6_bypass_reg <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_37_1) begin
          t6_bypass_reg <= Vc_4;
        end
      end
    end

  assign Vc_1 = (enb_1_37_1 == 1'b1 ? Vc_4 :
              t6_bypass_reg);

  assign Va_4 = Data_Type_Conversion1_out1[19];

  always @(posedge clk)
    begin : t7_bypass_process
      if (reset == 1'b1) begin
        t7_bypass_reg <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_37_1) begin
          t7_bypass_reg <= Va_4;
        end
      end
    end

  assign Va_1 = (enb_1_37_1 == 1'b1 ? Va_4 :
              t7_bypass_reg);

endmodule  // HDL_Subsystem

