// -------------------------------------------------------------
// 
// File Name: hdl_prj2\hdlsrc\HDL_pfc_gold_fi_og\FET_CTRL.v
// Created: 2025-04-29 18:38:06
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: FET_CTRL
// Source Path: HDL_pfc_gold_fi_og/simscape_system/FET_CTRL
// Hierarchy Level: 1
// Model version: 1.184
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module FET_CTRL
          (clk,
           reset,
           enb_1_37_1,
           enb,
           enb_1_1_1,
           vs_0,
           vs_1,
           vs_2,
           vs_3,
           vs_4,
           vs_5,
           is_0,
           is_1,
           is_2,
           is_3,
           is_4,
           is_5,
           G_0,
           G_1,
           G_2,
           G_3,
           G_4,
           G_5,
           sch_ctr_36,
           ic_0,
           ic_1,
           ic_2,
           ic_3,
           ic_4,
           ic_5);


  input   clk;
  input   reset;
  input   enb_1_37_1;
  input   enb;
  input   enb_1_1_1;
  input   signed [17:0] vs_0;  // sfix18_En6
  input   signed [17:0] vs_1;  // sfix18_En6
  input   signed [17:0] vs_2;  // sfix18_En6
  input   signed [17:0] vs_3;  // sfix18_En6
  input   signed [17:0] vs_4;  // sfix18_En6
  input   signed [17:0] vs_5;  // sfix18_En6
  input   signed [17:0] is_0;  // sfix18_En6
  input   signed [17:0] is_1;  // sfix18_En6
  input   signed [17:0] is_2;  // sfix18_En6
  input   signed [17:0] is_3;  // sfix18_En6
  input   signed [17:0] is_4;  // sfix18_En6
  input   signed [17:0] is_5;  // sfix18_En6
  input   G_0;  // boolean
  input   G_1;  // boolean
  input   G_2;  // boolean
  input   G_3;  // boolean
  input   G_4;  // boolean
  input   G_5;  // boolean
  input   [5:0] sch_ctr_36;  // ufix6
  output  signed [17:0] ic_0;  // sfix18_En8
  output  signed [17:0] ic_1;  // sfix18_En8
  output  signed [17:0] ic_2;  // sfix18_En8
  output  signed [17:0] ic_3;  // sfix18_En8
  output  signed [17:0] ic_4;  // sfix18_En8
  output  signed [17:0] ic_5;  // sfix18_En8


  wire crp_temp_streamed_enb_phase_5_0;
  wire crp_temp_streamed_enb_phase_0_5;
  wire enb_gated;
  reg [2:0] counterSig;  // ufix3
  wire crp_temp_streamed_enb_phase_0_0;
  reg [4:0] mergedDelay_waddr;  // ufix5
  wire mergedDelay_wrenb;  // ufix1
  reg [4:0] mergedDelay_raddr;  // ufix5
  wire G_unbuffer;
  wire [6:0] mergedInput;  // ufix7
  reg [6:0] mergedDelay_regin;  // ufix7
  reg [4:0] mergedDelay_waddr_1;  // ufix5
  wire mergedDelay_wrenb_1;  // ufix1
  reg [4:0] mergedDelay_raddr_1;  // ufix5
  wire [6:0] mergedDelay_regout;  // ufix7
  reg [6:0] mergedOutput;  // ufix7
  wire [2:0] slicedInput;  // ufix3
  wire signed [17:0] vs_unbuffer;  // sfix18_En6
  reg signed [17:0] vs_unbuffer_1;  // sfix18_En6
  wire signed [17:0] kconst;  // sfix18_En22
  reg signed [17:0] kconst_1;  // sfix18_En22
  wire signed [35:0] Gain3_out1;  // sfix36_En28
  reg signed [35:0] Gain3_out1_1;  // sfix36_En28
  wire signed [17:0] Gain3_out1_2;  // sfix18_En12
  reg signed [17:0] HwModeRegister_reg [0:1];  // sfix18 [2]
  wire signed [17:0] HwModeRegister_reg_next [0:1];  // sfix18_En12 [2]
  wire signed [17:0] Gain3_out1_3;  // sfix18_En12
  wire [2:0] slicedInput_1;  // ufix3
  wire signed [17:0] is_unbuffer;  // sfix18_En6
  reg signed [17:0] is_unbuffer_1;  // sfix18_En6
  wire signed [17:0] kconst_2;  // sfix18_En17
  reg signed [17:0] kconst_3;  // sfix18_En17
  wire signed [35:0] on;  // sfix36_En23
  reg signed [35:0] on_1;  // sfix36_En23
  wire signed [17:0] on_2;  // sfix18_En12
  wire signed [18:0] Subtract1_sub_cast;  // sfix19_En12
  wire signed [18:0] Subtract1_sub_cast_1;  // sfix19_En12
  wire signed [18:0] Subtract1_sub_temp;  // sfix19_En12
  wire signed [17:0] Subtract1_out1;  // sfix18_En11
  reg signed [17:0] Subtract1_out1_1;  // sfix18_En11
  wire slicedInput_2;  // ufix1
  wire G_unbuffer_1;
  wire signed [17:0] Constant_out1;  // sfix18_En17
  wire signed [28:0] Equal_cast;  // sfix29_En17
  wire signed [28:0] Equal_cast_1;  // sfix29_En17
  wire Equal_out1;
  wire OR_out1;
  reg  [2:0] HwModeRegister1_reg;  // ufix1 [3]
  wire OR_out1_1;
  wire signed [17:0] Multiply_Add_mul_in1;  // sfix18_En11
  wire signed [18:0] Multiply_Add_mul_cast;  // sfix19_En11
  (* use_dsp  = "yes" *)   wire signed [17:0] mulOutput;  // sfix18_En11
  reg signed [17:0] mulOutput_1;  // sfix18_En11
  wire signed [19:0] Multiply_Add_add_add_cast;  // sfix20_En12
  wire signed [19:0] Multiply_Add_add_add_cast_1;  // sfix20_En12
  wire signed [19:0] Multiply_Add_add_add_temp;  // sfix20_En12
  wire signed [17:0] Multiply_Add_out1;  // sfix18_En12
  reg signed [17:0] Multiply_Add_out1_1;  // sfix18_En12
  wire crp_temp_streamed_enb_phase_32_4;
  wire enb_gated_1;
  reg signed [17:0] Discrete_Time_Integrator_x_reg [0:5];  // sfix18_En8 [6]
  wire signed [17:0] Discrete_Time_Integrator_x_reg_5;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_4;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_3;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_2;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_1;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_u_sat;  // sfix18_En8
  reg signed [17:0] Discrete_Time_Integrator_u_sat_held;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_u_sat_1;  // sfix18_En8
  reg signed [17:0] Discrete_Time_Integrator_u_sat_2 [0:4];  // sfix18_En8 [5]
  reg signed [17:0] Discrete_Time_Integrator_u_sat_3 [0:4];  // sfix18_En8 [5]
  reg [35:0] mergedOutput_1;  // ufix36
  wire [17:0] slicedInput_3;  // ufix18
  wire signed [17:0] Discrete_Time_Integrator_x_reg_unbuffer;  // sfix18_En8
  wire signed [22:0] Subtract_sub_cast;  // sfix23_En12
  wire signed [22:0] Subtract_sub_cast_1;  // sfix23_En12
  wire signed [22:0] Subtract_sub_temp;  // sfix23_En12
  wire signed [17:0] Subtract_out1;  // sfix18_En12
  wire signed [17:0] Discrete_Time_Integrator_indtc;  // sfix18
  wire signed [18:0] gain_cast;  // sfix19_En4
  wire signed [17:0] Discrete_Time_Integrator_u_gain;  // sfix18
  wire signed [17:0] Discrete_Time_Integrator_u_dtc;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_x_reg_unbuffer_1;  // sfix18_En8
  wire [35:0] mergedInput_1;  // ufix36
  reg [35:0] mergedDelay_regin_1;  // ufix36
  wire [35:0] mergedDelay_regout_1;  // ufix36
  wire [17:0] slicedInput_4;  // ufix18
  wire signed [17:0] Discrete_Time_Integrator_x_reg_unbuffer_2;  // sfix18_En8
  wire signed [18:0] adder_add_cast;  // sfix19_En8
  wire signed [18:0] adder_add_cast_1;  // sfix19_En8
  wire signed [18:0] adder_add_temp;  // sfix19_En8
  wire signed [17:0] Discrete_Time_Integrator_u_add;  // sfix18_En8
  reg signed [17:0] tapped_delay_reg [0:4];  // sfix18 [5]
  reg signed [17:0] tapped_delay_reg_next [0:4];  // sfix18_En8 [5]
  wire signed [17:0] Discrete_Time_Integrator_u_sat_4 [0:4];  // sfix18_En8 [5]
  reg signed [17:0] Discrete_Time_Integrator_u_sat_held_1 [0:4];  // sfix18_En8 [5]
  wire signed [17:0] Discrete_Time_Integrator_u_sat_5 [0:5];  // sfix18_En8 [6]
  reg signed [17:0] Discrete_Time_Integrator_reg_bypass_reg [0:5];  // sfix18 [6]
  reg signed [17:0] Discrete_Time_Integrator_reg_bypass_reg_next [0:5];  // sfix18_En8 [6]
  wire signed [17:0] Discrete_Time_Integrator_x_reg_0;  // sfix18_En8
  wire crp_temp_streamed_enb_phase_0_4;
  wire enb_gated_2;
  reg signed [17:0] tapped_delay_reg_1 [0:4];  // sfix18 [5]
  reg signed [17:0] tapped_delay_reg_next_1 [0:4];  // sfix18_En8 [5]
  reg signed [17:0] buffSig [0:4];  // sfix18_En8 [5]
  wire signed [17:0] buffSig_1 [0:4];  // sfix18_En8 [5]
  reg signed [17:0] buffSig_2 [0:4];  // sfix18_En8 [5]
  reg signed [17:0] buffSig_held [0:4];  // sfix18_En8 [5]
  wire signed [17:0] buffSig_3;  // sfix18_En8
  reg signed [17:0] buffSig_held_1;  // sfix18_En8
  reg signed [31:0] HwModeRegister_t_0_0;  // int32
  reg signed [31:0] HwModeRegister_t_1;  // int32
  reg signed [31:0] tapped_delay_t_0_0;  // int32
  reg signed [31:0] tapped_delay_t_1;  // int32
  reg signed [31:0] tapped_delay_t_0_1;  // int32
  reg signed [31:0] tapped_delay_t_1_0;  // int32
  reg signed [31:0] Discrete_Time_Integrator_u_sat_state_t_0_0;  // int32
  reg signed [31:0] Discrete_Time_Integrator_u_sat_state_t_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_u_sat_enb_t_0_0;  // int32
  reg signed [31:0] Discrete_Time_Integrator_u_sat_enb_t_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_0_0;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_2;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_0_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_1_0;  // int32
  reg signed [31:0] tapped_delay_t_0_01;  // int32
  reg signed [31:0] tapped_delay_t_11;  // int32
  reg signed [31:0] buffSig_state_t_0_0;  // int32
  reg signed [31:0] buffSig_state_t_1;  // int32
  reg signed [31:0] buffSig_enb_t_0_0;  // int32
  reg signed [31:0] buffSig_enb_t_1;  // int32


  assign crp_temp_streamed_enb_phase_5_0 = sch_ctr_36 == 6'b000101;

  assign crp_temp_streamed_enb_phase_0_5 = sch_ctr_36 <= 6'b000101;

  assign enb_gated = crp_temp_streamed_enb_phase_0_5 && enb;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk)
    begin : ctr_0_5_process
      if (reset == 1'b1) begin
        counterSig <= 3'b000;
      end
      else begin
        if (enb_gated) begin
          if (counterSig >= 3'b101) begin
            counterSig <= 3'b000;
          end
          else begin
            counterSig <= counterSig + 3'b001;
          end
        end
      end
    end

  assign crp_temp_streamed_enb_phase_0_0 = sch_ctr_36 == 6'b000000;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 29
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 5'b00000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 5'b11101) begin
            mergedDelay_waddr <= 5'b00000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 5'b00001;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 29
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 5'b00001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 5'b11101) begin
            mergedDelay_raddr <= 5'b00000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 5'b00001;
          end
        end
      end
    end

  assign G_unbuffer = (counterSig == 3'b000 ? G_0 :
              (counterSig == 3'b001 ? G_1 :
              (counterSig == 3'b010 ? G_2 :
              (counterSig == 3'b011 ? G_3 :
              (counterSig == 3'b100 ? G_4 :
              G_5)))));

  assign mergedInput = {counterSig, counterSig, G_unbuffer};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 7'b0000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 24
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_1_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_1 <= 5'b00000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_1 >= 5'b11000) begin
            mergedDelay_waddr_1 <= 5'b00000;
          end
          else begin
            mergedDelay_waddr_1 <= mergedDelay_waddr_1 + 5'b00001;
          end
        end
      end
    end

  assign mergedDelay_wrenb_1 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 24
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_1_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_1 <= 5'b00001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_1 >= 5'b11000) begin
            mergedDelay_raddr_1 <= 5'b00000;
          end
          else begin
            mergedDelay_raddr_1 <= mergedDelay_raddr_1 + 5'b00001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(5),
                                     .DataWidth(7)
                                     )
                                   u_ShiftRegisterRAM_Wrapper_generic (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb(enb),
                                                                       .enb_1_1_1(enb_1_1_1),
                                                                       .wr_din(mergedDelay_regin),
                                                                       .wr_addr(mergedDelay_waddr_1),
                                                                       .wr_en(mergedDelay_wrenb_1),  // ufix1
                                                                       .rd_addr(mergedDelay_raddr_1),
                                                                       .dout(mergedDelay_regout)
                                                                       );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 7'b0000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign slicedInput = mergedOutput[3:1];

  assign vs_unbuffer = (slicedInput == 3'b000 ? vs_0 :
              (slicedInput == 3'b001 ? vs_1 :
              (slicedInput == 3'b010 ? vs_2 :
              (slicedInput == 3'b011 ? vs_3 :
              (slicedInput == 3'b100 ? vs_4 :
              vs_5)))));

  always @(posedge clk)
    begin : HwModeRegister5_process
      if (reset == 1'b1) begin
        vs_unbuffer_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          vs_unbuffer_1 <= vs_unbuffer;
        end
      end
    end

  assign kconst = 18'sb010100011110101110;

  always @(posedge clk)
    begin : HwModeRegister6_process
      if (reset == 1'b1) begin
        kconst_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          kconst_1 <= kconst;
        end
      end
    end

  assign Gain3_out1 = vs_unbuffer_1 * kconst_1;
  always @(posedge clk)
    begin : PipelineRegister2_process
      if (reset == 1'b1) begin
        Gain3_out1_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Gain3_out1_1 <= Gain3_out1;
        end
      end
    end

  assign Gain3_out1_2 = Gain3_out1_1[33:16];

  always @(posedge clk)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1 = 32'sd0; HwModeRegister_t_1 <= 32'sd1; HwModeRegister_t_1 = HwModeRegister_t_1 + 32'sd1) begin
          HwModeRegister_reg[HwModeRegister_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_0 = 32'sd0; HwModeRegister_t_0_0 <= 32'sd1; HwModeRegister_t_0_0 = HwModeRegister_t_0_0 + 32'sd1) begin
            HwModeRegister_reg[HwModeRegister_t_0_0] <= HwModeRegister_reg_next[HwModeRegister_t_0_0];
          end
        end
      end
    end

  assign Gain3_out1_3 = HwModeRegister_reg[1];
  assign HwModeRegister_reg_next[0] = Gain3_out1_2;
  assign HwModeRegister_reg_next[1] = HwModeRegister_reg[0];

  assign slicedInput_1 = mergedOutput[6:4];

  assign is_unbuffer = (slicedInput_1 == 3'b000 ? is_0 :
              (slicedInput_1 == 3'b001 ? is_1 :
              (slicedInput_1 == 3'b010 ? is_2 :
              (slicedInput_1 == 3'b011 ? is_3 :
              (slicedInput_1 == 3'b100 ? is_4 :
              is_5)))));

  always @(posedge clk)
    begin : HwModeRegister3_process
      if (reset == 1'b1) begin
        is_unbuffer_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          is_unbuffer_1 <= is_unbuffer;
        end
      end
    end

  assign kconst_2 = 18'sb100000000000000000;

  always @(posedge clk)
    begin : HwModeRegister4_process
      if (reset == 1'b1) begin
        kconst_3 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          kconst_3 <= kconst_2;
        end
      end
    end

  assign on = is_unbuffer_1 * kconst_3;
  always @(posedge clk)
    begin : PipelineRegister1_process
      if (reset == 1'b1) begin
        on_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          on_1 <= on;
        end
      end
    end

  assign on_2 = on_1[28:11];

  assign Subtract1_sub_cast = {on_2[17], on_2};
  assign Subtract1_sub_cast_1 = {Gain3_out1_2[17], Gain3_out1_2};
  assign Subtract1_sub_temp = Subtract1_sub_cast - Subtract1_sub_cast_1;
  assign Subtract1_out1 = Subtract1_sub_temp[18:1];
  always @(posedge clk)
    begin : HwModeRegister_1_process
      if (reset == 1'b1) begin
        Subtract1_out1_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Subtract1_out1_1 <= Subtract1_out1;
        end
      end
    end

  assign slicedInput_2 = mergedOutput[0];

  assign G_unbuffer_1 = slicedInput_2;

  assign Constant_out1 = 18'sb101001100110011010;
  assign Equal_cast = {{11{Constant_out1[17]}}, Constant_out1};
  assign Equal_cast_1 = {vs_unbuffer, 11'b00000000000};
  assign Equal_out1 = Equal_cast >= Equal_cast_1;
  assign OR_out1 = G_unbuffer_1 | Equal_out1;
  always @(posedge clk)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        HwModeRegister1_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          HwModeRegister1_reg[0] <= OR_out1;
          HwModeRegister1_reg[32'sd2:32'sd1] <= HwModeRegister1_reg[32'sd1:32'sd0];
        end
      end
    end

  assign OR_out1_1 = HwModeRegister1_reg[2];

  assign Multiply_Add_mul_in1 = (OR_out1_1 == 1'b1 ? Subtract1_out1_1 :
              18'sb000000000000000000);
  assign Multiply_Add_mul_cast = {Multiply_Add_mul_in1[17], Multiply_Add_mul_in1};
  assign mulOutput = Multiply_Add_mul_cast[17:0];
  always @(posedge clk)
    begin : HwModeRegister_2_process
      if (reset == 1'b1) begin
        mulOutput_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          mulOutput_1 <= mulOutput;
        end
      end
    end

  assign Multiply_Add_add_add_cast = {{2{Gain3_out1_3[17]}}, Gain3_out1_3};
  assign Multiply_Add_add_add_cast_1 = {mulOutput_1[17], {mulOutput_1, 1'b0}};
  assign Multiply_Add_add_add_temp = Multiply_Add_add_add_cast + Multiply_Add_add_add_cast_1;
  assign Multiply_Add_out1 = ((Multiply_Add_add_add_temp[19] == 1'b0) && (Multiply_Add_add_add_temp[18:17] != 2'b00) ? 18'sb011111111111111111 :
              ((Multiply_Add_add_add_temp[19] == 1'b1) && (Multiply_Add_add_add_temp[18:17] != 2'b11) ? 18'sb100000000000000000 :
              $signed(Multiply_Add_add_add_temp[17:0])));
  always @(posedge clk)
    begin : HwModeRegister_3_process
      if (reset == 1'b1) begin
        Multiply_Add_out1_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Multiply_Add_out1_1 <= Multiply_Add_out1;
        end
      end
    end

  assign crp_temp_streamed_enb_phase_32_4 = sch_ctr_36 >= 6'b100000;

  assign enb_gated_1 = crp_temp_streamed_enb_phase_32_4 && enb;

  assign Discrete_Time_Integrator_x_reg_5 = Discrete_Time_Integrator_x_reg[5];

  assign Discrete_Time_Integrator_x_reg_4 = Discrete_Time_Integrator_x_reg[4];

  assign Discrete_Time_Integrator_x_reg_3 = Discrete_Time_Integrator_x_reg[3];

  assign Discrete_Time_Integrator_x_reg_2 = Discrete_Time_Integrator_x_reg[2];

  assign Discrete_Time_Integrator_x_reg_1 = Discrete_Time_Integrator_x_reg[1];

  always @(posedge clk)
    begin : Discrete_Time_Integrator_u_sat_state_process
      if (reset == 1'b1) begin
        Discrete_Time_Integrator_u_sat_held <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_u_sat_held <= Discrete_Time_Integrator_u_sat;
        end
      end
    end

  assign Discrete_Time_Integrator_u_sat = (crp_temp_streamed_enb_phase_0_0 == 1'b0 ? Discrete_Time_Integrator_u_sat_held :
              Discrete_Time_Integrator_u_sat_1);

  assign slicedInput_3 = mergedOutput_1[35:18];

  assign Discrete_Time_Integrator_x_reg_unbuffer = slicedInput_3;

  assign Subtract_sub_cast = {{5{Multiply_Add_out1_1[17]}}, Multiply_Add_out1_1};
  assign Subtract_sub_cast_1 = {Discrete_Time_Integrator_x_reg_unbuffer[17], {Discrete_Time_Integrator_x_reg_unbuffer, 4'b0000}};
  assign Subtract_sub_temp = Subtract_sub_cast - Subtract_sub_cast_1;
  assign Subtract_out1 = Subtract_sub_temp[17:0];
  assign Discrete_Time_Integrator_indtc = Subtract_out1;

  assign gain_cast = {Discrete_Time_Integrator_indtc[17], Discrete_Time_Integrator_indtc};
  assign Discrete_Time_Integrator_u_gain = {{3{gain_cast[18]}}, gain_cast[18:4]};

  assign Discrete_Time_Integrator_u_dtc = Discrete_Time_Integrator_u_gain;

  assign mergedInput_1 = {Discrete_Time_Integrator_x_reg_unbuffer_1, Discrete_Time_Integrator_x_reg_unbuffer_1};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_1_process
      if (reset == 1'b1) begin
        mergedDelay_regin_1 <= 36'h000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_1 <= mergedInput_1;
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(5),
                                     .DataWidth(36)
                                     )
                                   u_ShiftRegisterRAM_Wrapper (.clk(clk),
                                                               .reset(reset),
                                                               .enb(enb),
                                                               .enb_1_1_1(enb_1_1_1),
                                                               .wr_din(mergedDelay_regin_1),
                                                               .wr_addr(mergedDelay_waddr),
                                                               .wr_en(mergedDelay_wrenb),  // ufix1
                                                               .rd_addr(mergedDelay_raddr),
                                                               .dout(mergedDelay_regout_1)
                                                               );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_1_process
      if (reset == 1'b1) begin
        mergedOutput_1 <= 36'h000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_1 <= mergedDelay_regout_1;
        end
      end
    end

  assign slicedInput_4 = mergedOutput_1[17:0];

  assign Discrete_Time_Integrator_x_reg_unbuffer_2 = slicedInput_4;

  assign adder_add_cast = {Discrete_Time_Integrator_x_reg_unbuffer_2[17], Discrete_Time_Integrator_x_reg_unbuffer_2};
  assign adder_add_cast_1 = {Discrete_Time_Integrator_u_dtc[17], Discrete_Time_Integrator_u_dtc};
  assign adder_add_temp = adder_add_cast + adder_add_cast_1;
  assign Discrete_Time_Integrator_u_add = ((adder_add_temp[18] == 1'b0) && (adder_add_temp[17] != 1'b0) ? 18'sb011111111111111111 :
              ((adder_add_temp[18] == 1'b1) && (adder_add_temp[17] != 1'b1) ? 18'sb100000000000000000 :
              $signed(adder_add_temp[17:0])));

  assign Discrete_Time_Integrator_u_sat_1 = (Discrete_Time_Integrator_u_add > 18'sb000110010000000000 ? 18'sb000110010000000000 :
              (Discrete_Time_Integrator_u_add < 18'sb111001110000000000 ? 18'sb111001110000000000 :
              Discrete_Time_Integrator_u_add));

  always @(posedge clk)
    begin : tapped_delay_process
      if (reset == 1'b1) begin
        for(tapped_delay_t_1_0 = 32'sd0; tapped_delay_t_1_0 <= 32'sd4; tapped_delay_t_1_0 = tapped_delay_t_1_0 + 32'sd1) begin
          tapped_delay_reg[tapped_delay_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_gated_1) begin
          for(tapped_delay_t_0_1 = 32'sd0; tapped_delay_t_0_1 <= 32'sd4; tapped_delay_t_0_1 = tapped_delay_t_0_1 + 32'sd1) begin
            tapped_delay_reg[tapped_delay_t_0_1] <= tapped_delay_reg_next[tapped_delay_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(tapped_delay_t_0_0 = 32'sd0; tapped_delay_t_0_0 <= 32'sd4; tapped_delay_t_0_0 = tapped_delay_t_0_0 + 32'sd1) begin
      Discrete_Time_Integrator_u_sat_3[tapped_delay_t_0_0] = tapped_delay_reg[tapped_delay_t_0_0];
    end
    for(tapped_delay_t_1 = 32'sd0; tapped_delay_t_1 <= 32'sd3; tapped_delay_t_1 = tapped_delay_t_1 + 32'sd1) begin
      tapped_delay_reg_next[tapped_delay_t_1] = tapped_delay_reg[32'sd1 + tapped_delay_t_1];
    end

    tapped_delay_reg_next[4] = Discrete_Time_Integrator_u_sat_1;
  end

  assign Discrete_Time_Integrator_u_sat_4[0] = Discrete_Time_Integrator_u_sat_3[0];
  assign Discrete_Time_Integrator_u_sat_4[1] = Discrete_Time_Integrator_u_sat_3[1];
  assign Discrete_Time_Integrator_u_sat_4[2] = Discrete_Time_Integrator_u_sat_3[2];
  assign Discrete_Time_Integrator_u_sat_4[3] = Discrete_Time_Integrator_u_sat_3[3];
  assign Discrete_Time_Integrator_u_sat_4[4] = Discrete_Time_Integrator_u_sat_3[4];

  always @(posedge clk)
    begin : Discrete_Time_Integrator_u_sat_state_1_process
      if (reset == 1'b1) begin
        for(Discrete_Time_Integrator_u_sat_state_t_1 = 32'sd0; Discrete_Time_Integrator_u_sat_state_t_1 <= 32'sd4; Discrete_Time_Integrator_u_sat_state_t_1 = Discrete_Time_Integrator_u_sat_state_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_u_sat_held_1[Discrete_Time_Integrator_u_sat_state_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Discrete_Time_Integrator_u_sat_state_t_0_0 = 32'sd0; Discrete_Time_Integrator_u_sat_state_t_0_0 <= 32'sd4; Discrete_Time_Integrator_u_sat_state_t_0_0 = Discrete_Time_Integrator_u_sat_state_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_u_sat_held_1[Discrete_Time_Integrator_u_sat_state_t_0_0] <= Discrete_Time_Integrator_u_sat_2[Discrete_Time_Integrator_u_sat_state_t_0_0];
          end
        end
      end
    end

  always @* begin
    if (crp_temp_streamed_enb_phase_0_0 == 1'b0) begin
      for(Discrete_Time_Integrator_u_sat_enb_t_1 = 32'sd0; Discrete_Time_Integrator_u_sat_enb_t_1 <= 32'sd4; Discrete_Time_Integrator_u_sat_enb_t_1 = Discrete_Time_Integrator_u_sat_enb_t_1 + 32'sd1) begin
        Discrete_Time_Integrator_u_sat_2[Discrete_Time_Integrator_u_sat_enb_t_1] = Discrete_Time_Integrator_u_sat_held_1[Discrete_Time_Integrator_u_sat_enb_t_1];
      end
    end
    else begin
      for(Discrete_Time_Integrator_u_sat_enb_t_0_0 = 32'sd0; Discrete_Time_Integrator_u_sat_enb_t_0_0 <= 32'sd4; Discrete_Time_Integrator_u_sat_enb_t_0_0 = Discrete_Time_Integrator_u_sat_enb_t_0_0 + 32'sd1) begin
        Discrete_Time_Integrator_u_sat_2[Discrete_Time_Integrator_u_sat_enb_t_0_0] = Discrete_Time_Integrator_u_sat_4[Discrete_Time_Integrator_u_sat_enb_t_0_0];
      end
    end
  end

  assign Discrete_Time_Integrator_u_sat_5[0] = Discrete_Time_Integrator_u_sat_2[0];
  assign Discrete_Time_Integrator_u_sat_5[1] = Discrete_Time_Integrator_u_sat_2[1];
  assign Discrete_Time_Integrator_u_sat_5[2] = Discrete_Time_Integrator_u_sat_2[2];
  assign Discrete_Time_Integrator_u_sat_5[3] = Discrete_Time_Integrator_u_sat_2[3];
  assign Discrete_Time_Integrator_u_sat_5[4] = Discrete_Time_Integrator_u_sat_2[4];
  assign Discrete_Time_Integrator_u_sat_5[5] = Discrete_Time_Integrator_u_sat;

  always @(posedge clk)
    begin : Discrete_Time_Integrator_reg_bypass_process
      if (reset == 1'b1) begin
        for(Discrete_Time_Integrator_reg_bypass_t_1_0 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_1_0 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_1_0 = Discrete_Time_Integrator_reg_bypass_t_1_0 + 32'sd1) begin
          Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_1_37_1) begin
          for(Discrete_Time_Integrator_reg_bypass_t_0_1 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_0_1 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_0_1 = Discrete_Time_Integrator_reg_bypass_t_0_1 + 32'sd1) begin
            Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_0_1] <= Discrete_Time_Integrator_reg_bypass_reg_next[Discrete_Time_Integrator_reg_bypass_t_0_1];
          end
        end
      end
    end

  always @* begin
    if (enb_1_37_1 == 1'b1) begin
      for(Discrete_Time_Integrator_reg_bypass_t_1 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_1 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_1 = Discrete_Time_Integrator_reg_bypass_t_1 + 32'sd1) begin
        Discrete_Time_Integrator_x_reg[Discrete_Time_Integrator_reg_bypass_t_1] = Discrete_Time_Integrator_u_sat_5[Discrete_Time_Integrator_reg_bypass_t_1];
      end
    end
    else begin
      for(Discrete_Time_Integrator_reg_bypass_t_0_0 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_0_0 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_0_0 = Discrete_Time_Integrator_reg_bypass_t_0_0 + 32'sd1) begin
        Discrete_Time_Integrator_x_reg[Discrete_Time_Integrator_reg_bypass_t_0_0] = Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_0_0];
      end
    end

    for(Discrete_Time_Integrator_reg_bypass_t_2 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_2 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_2 = Discrete_Time_Integrator_reg_bypass_t_2 + 32'sd1) begin
      Discrete_Time_Integrator_reg_bypass_reg_next[Discrete_Time_Integrator_reg_bypass_t_2] = Discrete_Time_Integrator_u_sat_5[Discrete_Time_Integrator_reg_bypass_t_2];
    end

  end

  assign Discrete_Time_Integrator_x_reg_0 = Discrete_Time_Integrator_x_reg[0];

  assign Discrete_Time_Integrator_x_reg_unbuffer_1 = (counterSig == 3'b000 ? Discrete_Time_Integrator_x_reg_0 :
              (counterSig == 3'b001 ? Discrete_Time_Integrator_x_reg_1 :
              (counterSig == 3'b010 ? Discrete_Time_Integrator_x_reg_2 :
              (counterSig == 3'b011 ? Discrete_Time_Integrator_x_reg_3 :
              (counterSig == 3'b100 ? Discrete_Time_Integrator_x_reg_4 :
              Discrete_Time_Integrator_x_reg_5)))));

  assign crp_temp_streamed_enb_phase_0_4 = sch_ctr_36 <= 6'b000100;

  assign enb_gated_2 = crp_temp_streamed_enb_phase_0_4 && enb;

  always @(posedge clk)
    begin : tapped_delay_1_process
      if (reset == 1'b1) begin
        for(tapped_delay_t_1_0 = 32'sd0; tapped_delay_t_1_0 <= 32'sd4; tapped_delay_t_1_0 = tapped_delay_t_1_0 + 32'sd1) begin
          tapped_delay_reg_1[tapped_delay_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_gated_2) begin
          for(tapped_delay_t_0_1 = 32'sd0; tapped_delay_t_0_1 <= 32'sd4; tapped_delay_t_0_1 = tapped_delay_t_0_1 + 32'sd1) begin
            tapped_delay_reg_1[tapped_delay_t_0_1] <= tapped_delay_reg_next_1[tapped_delay_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(tapped_delay_t_0_01 = 32'sd0; tapped_delay_t_0_01 <= 32'sd4; tapped_delay_t_0_01 = tapped_delay_t_0_01 + 32'sd1) begin
      buffSig[tapped_delay_t_0_01] = tapped_delay_reg_1[tapped_delay_t_0_01];
    end
    for(tapped_delay_t_11 = 32'sd0; tapped_delay_t_11 <= 32'sd3; tapped_delay_t_11 = tapped_delay_t_11 + 32'sd1) begin
      tapped_delay_reg_next_1[tapped_delay_t_11] = tapped_delay_reg_1[32'sd1 + tapped_delay_t_11];
    end

    tapped_delay_reg_next_1[4] = Discrete_Time_Integrator_x_reg_unbuffer_1;
  end

  assign buffSig_1[0] = buffSig[0];
  assign buffSig_1[1] = buffSig[1];
  assign buffSig_1[2] = buffSig[2];
  assign buffSig_1[3] = buffSig[3];
  assign buffSig_1[4] = buffSig[4];

  always @(posedge clk)
    begin : buffSig_state_process
      if (reset == 1'b1) begin
        for(buffSig_state_t_1 = 32'sd0; buffSig_state_t_1 <= 32'sd4; buffSig_state_t_1 = buffSig_state_t_1 + 32'sd1) begin
          buffSig_held[buffSig_state_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(buffSig_state_t_0_0 = 32'sd0; buffSig_state_t_0_0 <= 32'sd4; buffSig_state_t_0_0 = buffSig_state_t_0_0 + 32'sd1) begin
            buffSig_held[buffSig_state_t_0_0] <= buffSig_2[buffSig_state_t_0_0];
          end
        end
      end
    end

  always @* begin
    if (crp_temp_streamed_enb_phase_5_0 == 1'b0) begin
      for(buffSig_enb_t_1 = 32'sd0; buffSig_enb_t_1 <= 32'sd4; buffSig_enb_t_1 = buffSig_enb_t_1 + 32'sd1) begin
        buffSig_2[buffSig_enb_t_1] = buffSig_held[buffSig_enb_t_1];
      end
    end
    else begin
      for(buffSig_enb_t_0_0 = 32'sd0; buffSig_enb_t_0_0 <= 32'sd4; buffSig_enb_t_0_0 = buffSig_enb_t_0_0 + 32'sd1) begin
        buffSig_2[buffSig_enb_t_0_0] = buffSig_1[buffSig_enb_t_0_0];
      end
    end
  end

  assign ic_0 = buffSig_2[0];

  assign ic_1 = buffSig_2[1];

  assign ic_2 = buffSig_2[2];

  assign ic_3 = buffSig_2[3];

  assign ic_4 = buffSig_2[4];

  always @(posedge clk)
    begin : buffSig_state_1_process
      if (reset == 1'b1) begin
        buffSig_held_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          buffSig_held_1 <= buffSig_3;
        end
      end
    end

  assign buffSig_3 = (crp_temp_streamed_enb_phase_5_0 == 1'b0 ? buffSig_held_1 :
              Discrete_Time_Integrator_x_reg_unbuffer_1);

  assign ic_5 = buffSig_3;

endmodule  // FET_CTRL

