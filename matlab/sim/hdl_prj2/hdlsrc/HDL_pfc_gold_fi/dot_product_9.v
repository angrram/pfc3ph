// -------------------------------------------------------------
// 
// File Name: hdl_prj2\hdlsrc\HDL_pfc_gold_fi\dot_product_9.v
// Created: 2025-02-26 17:03:08
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dot_product_9
// Source Path: HDL_pfc_gold_fi/simscape_system/HDL Subsystem/Fixed-Point State-Space/hNNewMatrixB/dot_product_9
// Hierarchy Level: 3
// Model version: 1.167
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dot_product_9
          (clk,
           reset,
           enb,
           enb_1_1_1,
           in1_0,
           in1_1,
           in1_2,
           in1_3,
           in1_4,
           in1_5,
           in1_6,
           in1_7,
           in1_8,
           in2_0,
           in2_1,
           in2_2,
           in2_3,
           in2_4,
           in2_5,
           in2_6,
           in2_7,
           in2_8,
           out1);


  input   clk;
  input   reset;
  input   enb;
  input   enb_1_1_1;
  input   signed [24:0] in1_0;  // sfix25_En31
  input   signed [24:0] in1_1;  // sfix25_En31
  input   signed [24:0] in1_2;  // sfix25_En31
  input   signed [24:0] in1_3;  // sfix25_En31
  input   signed [24:0] in1_4;  // sfix25_En31
  input   signed [24:0] in1_5;  // sfix25_En31
  input   signed [24:0] in1_6;  // sfix25_En31
  input   signed [24:0] in1_7;  // sfix25_En31
  input   signed [24:0] in1_8;  // sfix25_En31
  input   signed [24:0] in2_0;  // sfix25_En13
  input   signed [24:0] in2_1;  // sfix25_En13
  input   signed [24:0] in2_2;  // sfix25_En13
  input   signed [24:0] in2_3;  // sfix25_En13
  input   signed [24:0] in2_4;  // sfix25_En13
  input   signed [24:0] in2_5;  // sfix25_En13
  input   signed [24:0] in2_6;  // sfix25_En13
  input   signed [24:0] in2_7;  // sfix25_En13
  input   signed [24:0] in2_8;  // sfix25_En13
  output  signed [49:0] out1;  // sfix50_En44


  wire signed [24:0] mul_in1 [0:8];  // sfix25_En31 [9]
  reg signed [24:0] mul_in1_1 [0:8];  // sfix25_En31 [9]
  wire signed [24:0] mul_in2 [0:8];  // sfix25_En13 [9]
  reg signed [24:0] mul_in2_1 [0:8];  // sfix25_En13 [9]
  wire signed [49:0] mul_out1 [0:8];  // sfix50_En44 [9]
  reg signed [49:0] mul_out1_1 [0:8];  // sfix50_En44 [9]
  wire signed [49:0] mul_out1_0;  // sfix50_En44
  reg signed [49:0] mul_out1_0_1;  // sfix50_En44
  wire signed [49:0] mul_out1_1_1;  // sfix50_En44
  reg signed [49:0] mul_out1_1_2;  // sfix50_En44
  wire signed [49:0] sum_stage1_1;  // sfix50_En44
  reg signed [49:0] sum_stage1_1_1;  // sfix50_En44
  wire signed [49:0] mul_out1_2;  // sfix50_En44
  reg signed [49:0] mul_out1_2_1;  // sfix50_En44
  wire signed [49:0] mul_out1_3;  // sfix50_En44
  reg signed [49:0] mul_out1_3_1;  // sfix50_En44
  wire signed [49:0] sum_stage1_2;  // sfix50_En44
  reg signed [49:0] sum_stage1_2_1;  // sfix50_En44
  wire signed [49:0] sum_stage2_1;  // sfix50_En44
  reg signed [49:0] sum_stage2_1_1;  // sfix50_En44
  wire signed [49:0] mul_out1_4;  // sfix50_En44
  reg signed [49:0] mul_out1_4_1;  // sfix50_En44
  wire signed [49:0] mul_out1_5;  // sfix50_En44
  reg signed [49:0] mul_out1_5_1;  // sfix50_En44
  wire signed [49:0] sum_stage1_3;  // sfix50_En44
  reg signed [49:0] sum_stage1_3_1;  // sfix50_En44
  wire signed [49:0] mul_out1_6;  // sfix50_En44
  reg signed [49:0] mul_out1_6_1;  // sfix50_En44
  wire signed [49:0] mul_out1_7;  // sfix50_En44
  reg signed [49:0] mul_out1_7_1;  // sfix50_En44
  wire signed [49:0] sum_stage1_4;  // sfix50_En44
  reg signed [49:0] sum_stage1_4_1;  // sfix50_En44
  wire signed [49:0] sum_stage2_2;  // sfix50_En44
  reg signed [49:0] sum_stage2_2_1;  // sfix50_En44
  wire signed [49:0] sum_stage3_1;  // sfix50_En44
  reg signed [49:0] sum_stage3_1_1;  // sfix50_En44
  wire signed [49:0] mul_out1_8;  // sfix50_En44
  reg signed [49:0] rd_15_regin;  // sfix50_En44
  reg [1:0] rd_15_waddr;  // ufix2
  wire rd_15_wrenb;  // ufix1
  reg [1:0] rd_15_raddr;  // ufix2
  wire signed [49:0] rd_15_regout;  // sfix50_En44
  reg signed [49:0] sum_stage3_2;  // sfix50_En44
  wire signed [49:0] sum_stage4_1;  // sfix50_En44
  reg signed [31:0] HwModeRegister_t_0_0;  // int32
  reg signed [31:0] HwModeRegister_t_1;  // int32
  reg signed [31:0] HwModeRegister1_t_0_0;  // int32
  reg signed [31:0] HwModeRegister1_t_1;  // int32
  reg signed [31:0] PipelineRegister_t_0_0;  // int32
  reg signed [31:0] PipelineRegister_t_1;  // int32


  assign mul_in1[0] = in1_0;
  assign mul_in1[1] = in1_1;
  assign mul_in1[2] = in1_2;
  assign mul_in1[3] = in1_3;
  assign mul_in1[4] = in1_4;
  assign mul_in1[5] = in1_5;
  assign mul_in1[6] = in1_6;
  assign mul_in1[7] = in1_7;
  assign mul_in1[8] = in1_8;

  always @(posedge clk)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1 = 32'sd0; HwModeRegister_t_1 <= 32'sd8; HwModeRegister_t_1 = HwModeRegister_t_1 + 32'sd1) begin
          mul_in1_1[HwModeRegister_t_1] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_0 = 32'sd0; HwModeRegister_t_0_0 <= 32'sd8; HwModeRegister_t_0_0 = HwModeRegister_t_0_0 + 32'sd1) begin
            mul_in1_1[HwModeRegister_t_0_0] <= mul_in1[HwModeRegister_t_0_0];
          end
        end
      end
    end

  assign mul_in2[0] = in2_0;
  assign mul_in2[1] = in2_1;
  assign mul_in2[2] = in2_2;
  assign mul_in2[3] = in2_3;
  assign mul_in2[4] = in2_4;
  assign mul_in2[5] = in2_5;
  assign mul_in2[6] = in2_6;
  assign mul_in2[7] = in2_7;
  assign mul_in2[8] = in2_8;

  always @(posedge clk)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        for(HwModeRegister1_t_1 = 32'sd0; HwModeRegister1_t_1 <= 32'sd8; HwModeRegister1_t_1 = HwModeRegister1_t_1 + 32'sd1) begin
          mul_in2_1[HwModeRegister1_t_1] <= 25'sb0000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister1_t_0_0 = 32'sd0; HwModeRegister1_t_0_0 <= 32'sd8; HwModeRegister1_t_0_0 = HwModeRegister1_t_0_0 + 32'sd1) begin
            mul_in2_1[HwModeRegister1_t_0_0] <= mul_in2[HwModeRegister1_t_0_0];
          end
        end
      end
    end


  genvar t_0_01;
  generate
    for(t_0_01 = 32'sd0; t_0_01 <= 32'sd8; t_0_01 = t_0_01 + 32'sd1) begin:mul_out1_gen
      assign mul_out1[t_0_01] = mul_in1_1[t_0_01] * mul_in2_1[t_0_01];
    end
  endgenerate
  always @(posedge clk)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        for(PipelineRegister_t_1 = 32'sd0; PipelineRegister_t_1 <= 32'sd8; PipelineRegister_t_1 = PipelineRegister_t_1 + 32'sd1) begin
          mul_out1_1[PipelineRegister_t_1] <= 50'sh0000000000000;
        end
      end
      else begin
        if (enb) begin
          for(PipelineRegister_t_0_0 = 32'sd0; PipelineRegister_t_0_0 <= 32'sd8; PipelineRegister_t_0_0 = PipelineRegister_t_0_0 + 32'sd1) begin
            mul_out1_1[PipelineRegister_t_0_0] <= mul_out1[PipelineRegister_t_0_0];
          end
        end
      end
    end

  assign mul_out1_0 = mul_out1_1[0];
  always @(posedge clk)
    begin : rd_0_process
      if (reset == 1'b1) begin
        mul_out1_0_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_0_1 <= mul_out1_0;
        end
      end
    end

  assign mul_out1_1_1 = mul_out1_1[1];

  always @(posedge clk)
    begin : rd_4_process
      if (reset == 1'b1) begin
        mul_out1_1_2 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_1_2 <= mul_out1_1_1;
        end
      end
    end

  assign sum_stage1_1 = mul_out1_0_1 + mul_out1_1_2;
  always @(posedge clk)
    begin : rd_5_process
      if (reset == 1'b1) begin
        sum_stage1_1_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage1_1_1 <= sum_stage1_1;
        end
      end
    end

  assign mul_out1_2 = mul_out1_1[2];

  always @(posedge clk)
    begin : rd_1_process
      if (reset == 1'b1) begin
        mul_out1_2_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_2_1 <= mul_out1_2;
        end
      end
    end

  assign mul_out1_3 = mul_out1_1[3];

  always @(posedge clk)
    begin : rd_6_process
      if (reset == 1'b1) begin
        mul_out1_3_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_3_1 <= mul_out1_3;
        end
      end
    end

  assign sum_stage1_2 = mul_out1_2_1 + mul_out1_3_1;
  always @(posedge clk)
    begin : rd_7_process
      if (reset == 1'b1) begin
        sum_stage1_2_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage1_2_1 <= sum_stage1_2;
        end
      end
    end

  assign sum_stage2_1 = sum_stage1_1_1 + sum_stage1_2_1;
  always @(posedge clk)
    begin : rd_8_process
      if (reset == 1'b1) begin
        sum_stage2_1_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage2_1_1 <= sum_stage2_1;
        end
      end
    end

  assign mul_out1_4 = mul_out1_1[4];

  always @(posedge clk)
    begin : rd_2_process
      if (reset == 1'b1) begin
        mul_out1_4_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_4_1 <= mul_out1_4;
        end
      end
    end

  assign mul_out1_5 = mul_out1_1[5];

  always @(posedge clk)
    begin : rd_9_process
      if (reset == 1'b1) begin
        mul_out1_5_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_5_1 <= mul_out1_5;
        end
      end
    end

  assign sum_stage1_3 = mul_out1_4_1 + mul_out1_5_1;
  always @(posedge clk)
    begin : rd_10_process
      if (reset == 1'b1) begin
        sum_stage1_3_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage1_3_1 <= sum_stage1_3;
        end
      end
    end

  assign mul_out1_6 = mul_out1_1[6];

  always @(posedge clk)
    begin : rd_3_process
      if (reset == 1'b1) begin
        mul_out1_6_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_6_1 <= mul_out1_6;
        end
      end
    end

  assign mul_out1_7 = mul_out1_1[7];

  always @(posedge clk)
    begin : rd_11_process
      if (reset == 1'b1) begin
        mul_out1_7_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          mul_out1_7_1 <= mul_out1_7;
        end
      end
    end

  assign sum_stage1_4 = mul_out1_6_1 + mul_out1_7_1;
  always @(posedge clk)
    begin : rd_12_process
      if (reset == 1'b1) begin
        sum_stage1_4_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage1_4_1 <= sum_stage1_4;
        end
      end
    end

  assign sum_stage2_2 = sum_stage1_3_1 + sum_stage1_4_1;
  always @(posedge clk)
    begin : rd_13_process
      if (reset == 1'b1) begin
        sum_stage2_2_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage2_2_1 <= sum_stage2_2;
        end
      end
    end

  assign sum_stage3_1 = sum_stage2_1_1 + sum_stage2_2_1;
  always @(posedge clk)
    begin : rd_14_process
      if (reset == 1'b1) begin
        sum_stage3_1_1 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage3_1_1 <= sum_stage3_1;
        end
      end
    end

  assign mul_out1_8 = mul_out1_1[8];
  // Input register for RAM-based shift register rd_15
  always @(posedge clk)
    begin : rd_15_reginc_process
      if (reset == 1'b1) begin
        rd_15_regin <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          rd_15_regin <= mul_out1_8;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Write address counter for RAM-based shift register rd_15
  always @(posedge clk)
    begin : rd_15_wr_process
      if (reset == 1'b1) begin
        rd_15_waddr <= 2'b00;
      end
      else begin
        if (enb) begin
          if (rd_15_waddr >= 2'b01) begin
            rd_15_waddr <= 2'b00;
          end
          else begin
            rd_15_waddr <= rd_15_waddr + 2'b01;
          end
        end
      end
    end

  assign rd_15_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 1
  // Read address counter for RAM-based shift register rd_15
  always @(posedge clk)
    begin : rd_15_rd_process
      if (reset == 1'b1) begin
        rd_15_raddr <= 2'b01;
      end
      else begin
        if (enb) begin
          if (rd_15_raddr >= 2'b01) begin
            rd_15_raddr <= 2'b00;
          end
          else begin
            rd_15_raddr <= rd_15_raddr + 2'b01;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(2),
                                     .DataWidth(50)
                                     )
                                   u_ShiftRegisterRAM_Wrapper (.clk(clk),
                                                               .reset(reset),
                                                               .enb(enb),
                                                               .enb_1_1_1(enb_1_1_1),
                                                               .wr_din(rd_15_regin),
                                                               .wr_addr(rd_15_waddr),
                                                               .wr_en(rd_15_wrenb),  // ufix1
                                                               .rd_addr(rd_15_raddr),
                                                               .dout(rd_15_regout)
                                                               );

  // Output register for RAM-based shift register rd_15
  always @(posedge clk)
    begin : rd_15_regoutc_process
      if (reset == 1'b1) begin
        sum_stage3_2 <= 50'sh0000000000000;
      end
      else begin
        if (enb) begin
          sum_stage3_2 <= rd_15_regout;
        end
      end
    end

  assign sum_stage4_1 = sum_stage3_1_1 + sum_stage3_2;
  assign out1 = sum_stage4_1;

endmodule  // dot_product_9

