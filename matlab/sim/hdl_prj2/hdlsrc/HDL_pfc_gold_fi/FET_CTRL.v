// -------------------------------------------------------------
// 
// File Name: hdl_prj2\hdlsrc\HDL_pfc_gold_fi\FET_CTRL.v
// Created: 2025-02-26 17:03:08
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: FET_CTRL
// Source Path: HDL_pfc_gold_fi/simscape_system/FET_CTRL
// Hierarchy Level: 1
// Model version: 1.167
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module FET_CTRL
          (clk,
           reset,
           enb_1_67_1,
           enb,
           enb_1_1_1,
           vs_0,
           vs_1,
           vs_2,
           vs_3,
           vs_4,
           vs_5,
           is_0,
           is_1,
           is_2,
           is_3,
           is_4,
           is_5,
           G_0,
           G_1,
           G_2,
           G_3,
           G_4,
           G_5,
           sch_ctr_66,
           ic_0,
           ic_1,
           ic_2,
           ic_3,
           ic_4,
           ic_5);


  input   clk;
  input   reset;
  input   enb_1_67_1;
  input   enb;
  input   enb_1_1_1;
  input   signed [17:0] vs_0;  // sfix18_En6
  input   signed [17:0] vs_1;  // sfix18_En6
  input   signed [17:0] vs_2;  // sfix18_En6
  input   signed [17:0] vs_3;  // sfix18_En6
  input   signed [17:0] vs_4;  // sfix18_En6
  input   signed [17:0] vs_5;  // sfix18_En6
  input   signed [17:0] is_0;  // sfix18_En6
  input   signed [17:0] is_1;  // sfix18_En6
  input   signed [17:0] is_2;  // sfix18_En6
  input   signed [17:0] is_3;  // sfix18_En6
  input   signed [17:0] is_4;  // sfix18_En6
  input   signed [17:0] is_5;  // sfix18_En6
  input   G_0;  // boolean
  input   G_1;  // boolean
  input   G_2;  // boolean
  input   G_3;  // boolean
  input   G_4;  // boolean
  input   G_5;  // boolean
  input   [6:0] sch_ctr_66;  // ufix7
  output  signed [17:0] ic_0;  // sfix18_En8
  output  signed [17:0] ic_1;  // sfix18_En8
  output  signed [17:0] ic_2;  // sfix18_En8
  output  signed [17:0] ic_3;  // sfix18_En8
  output  signed [17:0] ic_4;  // sfix18_En8
  output  signed [17:0] ic_5;  // sfix18_En8


  reg [5:0] mergedDelay_waddr;  // ufix6
  wire mergedDelay_wrenb;  // ufix1
  reg [5:0] mergedDelay_raddr;  // ufix6
  wire crp_temp_shared_enb_phase_24_0;
  reg  [9:0] rd_7_reg;  // ufix1 [10]
  wire crp_temp_shared_enb_phase_24_0_1;
  wire crp_temp_shared_enb_phase_0_1;
  reg  crp_temp_shared_enb_phase_0_1_1;
  wire enb_gated;
  reg  counterSig;  // ufix1
  reg  rd_3_regin;  // ufix1
  reg [4:0] rd_3_waddr;  // ufix5
  wire rd_3_wrenb;  // ufix1
  reg [4:0] rd_3_raddr;  // ufix5
  wire rd_3_regout;  // ufix1
  wire signed [17:0] is [0:5];  // sfix18_En6 [6]
  wire signed [17:0] is_6 [0:5];  // sfix18 [6]
  wire signed [17:0] vs [0:5];  // sfix18_En6 [6]
  wire signed [17:0] vs_6 [0:5];  // sfix18 [6]
  wire signed [17:0] c0_serial_0 [0:11];  // sfix18 [12]
  reg signed [17:0] c0_serial_0_1 [0:11];  // sfix18 [12]
  reg  counterSig_1;  // ufix1
  wire signed [17:0] ratechange_splitcomp_out0 [0:5];  // sfix18 [6]
  wire signed [17:0] ratechange_splitcomp_out1 [0:5];  // sfix18 [6]
  reg signed [17:0] is_7 [0:5];  // sfix18 [6]
  wire signed [17:0] is_8 [0:5];  // sfix18 [6]
  wire signed [17:0] kconst;  // sfix18_En17
  wire signed [17:0] kconst_1;  // sfix18
  wire signed [17:0] kconst_2;  // sfix18_En22
  wire signed [17:0] kconst_3;  // sfix18
  wire signed [17:0] kconst_4;  // sfix18
  wire [23:0] mergedInput;  // ufix24
  reg [23:0] mergedDelay_regin;  // ufix24
  reg [4:0] mergedDelay_waddr_1;  // ufix5
  wire mergedDelay_wrenb_1;  // ufix1
  reg [4:0] mergedDelay_raddr_1;  // ufix5
  wire [23:0] mergedDelay_regout;  // ufix24
  reg [23:0] mergedOutput;  // ufix24
  reg signed [17:0] is_9 [0:5];  // sfix18 [6]
  wire [17:0] slicedInput;  // ufix18
  wire signed [17:0] kconst_5;  // sfix18
  wire signed [35:0] on [0:5];  // sfix36 [6]
  reg signed [35:0] on_1 [0:5];  // sfix36 [6]
  reg signed [35:0] on_2 [0:5];  // sfix36 [6]
  reg signed [35:0] Gain3_out1 [0:5];  // sfix36 [6]
  reg signed [35:0] Gain3_out1_held [0:5];  // sfix36 [6]
  wire signed [35:0] Gain3_out1_1 [0:5];  // sfix36_En28 [6]
  wire signed [17:0] Gain3_out1_2 [0:5];  // sfix18_En12 [6]
  reg signed [17:0] HwModeRegister_reg [0:17];  // sfix18 [18]
  reg signed [17:0] HwModeRegister_reg_next [0:17];  // sfix18_En12 [18]
  reg signed [17:0] Gain3_out1_3 [0:5];  // sfix18_En12 [6]
  wire crp_temp_shared_enb_phase_23_0;
  reg  [9:0] rd_0_reg;  // ufix1 [10]
  wire crp_temp_shared_enb_phase_23_0_1;
  reg signed [35:0] on_3 [0:5];  // sfix36 [6]
  reg signed [35:0] on_4 [0:5];  // sfix36 [6]
  wire signed [35:0] on_5 [0:5];  // sfix36_En23 [6]
  wire signed [17:0] on_6 [0:5];  // sfix18_En12 [6]
  reg signed [17:0] on_7 [0:5];  // sfix18_En12 [6]
  reg signed [17:0] Gain3_out1_4 [0:5];  // sfix18_En12 [6]
  wire signed [18:0] Subtract1_sub_cast [0:5];  // sfix19_En12 [6]
  wire signed [18:0] Subtract1_sub_cast_1 [0:5];  // sfix19_En12 [6]
  wire signed [18:0] Subtract1_sub_temp [0:5];  // sfix19_En12 [6]
  wire signed [17:0] Subtract1_out1 [0:5];  // sfix18_En11 [6]
  wire slicedInput_1;  // ufix1
  wire delayOut0;
  wire slicedInput_2;  // ufix1
  wire delayOut1;
  wire slicedInput_3;  // ufix1
  wire delayOut2;
  wire slicedInput_4;  // ufix1
  wire delayOut3;
  wire slicedInput_5;  // ufix1
  wire delayOut4;
  wire slicedInput_6;  // ufix1
  wire delayOut5;
  wire [5:0] G;  // boolean [6]
  wire signed [17:0] Constant_out1;  // sfix18_En17
  reg signed [17:0] vs_7 [0:5];  // sfix18_En6 [6]
  wire signed [28:0] Equal_cast [0:5];  // sfix29_En17 [6]
  wire signed [28:0] Equal_cast_1 [0:5];  // sfix29_En17 [6]
  wire [5:0] Equal_out1;  // boolean [6]
  reg  [5:0] Equal_out1_1;  // boolean [6]
  wire [5:0] OR_out1;  // boolean [6]
  wire OR_out1_0;
  wire OR_out1_1;
  wire OR_out1_2;
  wire OR_out1_3;
  wire OR_out1_4;
  wire OR_out1_5;
  wire [5:0] mergedInput_1;  // ufix6
  reg [5:0] mergedDelay_regin_1;  // ufix6
  reg [2:0] mergedDelay_waddr_2;  // ufix3
  wire mergedDelay_wrenb_2;  // ufix1
  reg [2:0] mergedDelay_raddr_2;  // ufix3
  wire [5:0] mergedDelay_regout_1;  // ufix6
  reg [5:0] mergedOutput_1;  // ufix6
  reg signed [17:0] Subtract1_out1_1 [0:5];  // sfix18_En11 [6]
  wire slicedInput_7;  // ufix1
  wire delayOut0_1;
  wire slicedInput_8;  // ufix1
  wire delayOut1_1;
  wire slicedInput_9;  // ufix1
  wire delayOut2_1;
  wire slicedInput_10;  // ufix1
  wire delayOut3_1;
  wire slicedInput_11;  // ufix1
  wire delayOut4_1;
  wire slicedInput_12;  // ufix1
  wire delayOut5_1;
  wire [5:0] OR_out1_6;  // boolean [6]
  wire signed [17:0] Multiply_Add_mul_in1 [0:5];  // sfix18_En11 [6]
  wire signed [18:0] Multiply_Add_mul_cast [0:5];  // sfix19_En11 [6]
  (* use_dsp  = "yes" *)   wire signed [17:0] mulOutput [0:5];  // sfix18_En11 [6]
  reg signed [17:0] mulOutput_1 [0:5];  // sfix18_En11 [6]
  wire signed [19:0] Multiply_Add_add_add_cast [0:5];  // sfix20_En12 [6]
  wire signed [19:0] Multiply_Add_add_add_cast_1 [0:5];  // sfix20_En12 [6]
  wire signed [19:0] Multiply_Add_add_add_temp [0:5];  // sfix20_En12 [6]
  wire signed [17:0] Multiply_Add_out1 [0:5];  // sfix18_En12 [6]
  reg signed [17:0] rd_8_reg [0:11];  // sfix18 [12]
  reg signed [17:0] rd_8_reg_next [0:11];  // sfix18_En12 [12]
  reg signed [17:0] Multiply_Add_out1_1 [0:5];  // sfix18_En12 [6]
  reg [5:0] mergedDelay_waddr_3;  // ufix6
  wire mergedDelay_wrenb_3;  // ufix1
  reg [5:0] mergedDelay_raddr_3;  // ufix6
  reg signed [17:0] Discrete_Time_Integrator_x_reg [0:5];  // sfix18_En8 [6]
  reg [107:0] mergedOutput_2;  // ufix108
  wire [17:0] slicedInput_13;  // ufix18
  wire signed [17:0] delayOut5_2;  // sfix18_En8
  wire [17:0] slicedInput_14;  // ufix18
  wire signed [17:0] delayOut4_2;  // sfix18_En8
  wire [17:0] slicedInput_15;  // ufix18
  wire signed [17:0] delayOut3_2;  // sfix18_En8
  wire [17:0] slicedInput_16;  // ufix18
  wire signed [17:0] delayOut2_2;  // sfix18_En8
  wire [17:0] slicedInput_17;  // ufix18
  wire signed [17:0] delayOut1_2;  // sfix18_En8
  reg signed [17:0] ic [0:5];  // sfix18_En8 [6]
  wire signed [17:0] delayIn5;  // sfix18_En8
  wire signed [17:0] delayIn4;  // sfix18_En8
  wire signed [17:0] delayIn3;  // sfix18_En8
  wire signed [17:0] delayIn2;  // sfix18_En8
  wire signed [17:0] delayIn1;  // sfix18_En8
  wire signed [17:0] delayIn0;  // sfix18_En8
  wire [107:0] mergedInput_2;  // ufix108
  reg [107:0] mergedDelay_regin_2;  // ufix108
  wire [107:0] mergedDelay_regout_2;  // ufix108
  wire [17:0] slicedInput_18;  // ufix18
  wire signed [17:0] delayOut0_2;  // sfix18_En8
  wire signed [17:0] ic_6 [0:5];  // sfix18_En8 [6]
  wire signed [22:0] Subtract_sub_cast [0:5];  // sfix23_En12 [6]
  wire signed [22:0] Subtract_sub_cast_1 [0:5];  // sfix23_En12 [6]
  wire signed [22:0] Subtract_sub_temp [0:5];  // sfix23_En12 [6]
  wire signed [17:0] Subtract_out1 [0:5];  // sfix18_En12 [6]
  reg signed [17:0] Subtract_out1_1 [0:5];  // sfix18_En12 [6]
  wire signed [17:0] Discrete_Time_Integrator_indtc [0:5];  // sfix18 [6]
  reg signed [17:0] Discrete_Time_Integrator_indtc_1 [0:5];  // sfix18 [6]
  wire signed [18:0] gain_cast;  // sfix19_En4
  wire signed [18:0] gain_cast_1;  // sfix19_En4
  wire signed [18:0] gain_cast_2;  // sfix19_En4
  wire signed [18:0] gain_cast_3;  // sfix19_En4
  wire signed [18:0] gain_cast_4;  // sfix19_En4
  wire signed [18:0] gain_cast_5;  // sfix19_En4
  wire signed [17:0] Discrete_Time_Integrator_u_gain [0:5];  // sfix18 [6]
  reg signed [17:0] Discrete_Time_Integrator_u_gain_1 [0:5];  // sfix18 [6]
  wire signed [17:0] Discrete_Time_Integrator_u_dtc [0:5];  // sfix18_En8 [6]
  reg signed [17:0] Discrete_Time_Integrator_u_dtc_1 [0:5];  // sfix18_En8 [6]
  reg [107:0] mergedOutput_3;  // ufix108
  wire [17:0] slicedInput_19;  // ufix18
  wire signed [17:0] delayOut5_3;  // sfix18_En8
  wire [17:0] slicedInput_20;  // ufix18
  wire signed [17:0] delayOut4_3;  // sfix18_En8
  wire [17:0] slicedInput_21;  // ufix18
  wire signed [17:0] delayOut3_3;  // sfix18_En8
  wire [17:0] slicedInput_22;  // ufix18
  wire signed [17:0] delayOut2_3;  // sfix18_En8
  wire [17:0] slicedInput_23;  // ufix18
  wire signed [17:0] delayOut1_3;  // sfix18_En8
  wire signed [17:0] delayIn5_1;  // sfix18_En8
  wire signed [17:0] delayIn4_1;  // sfix18_En8
  wire signed [17:0] delayIn3_1;  // sfix18_En8
  wire signed [17:0] delayIn2_1;  // sfix18_En8
  wire signed [17:0] delayIn1_1;  // sfix18_En8
  wire signed [17:0] delayIn0_1;  // sfix18_En8
  wire [107:0] mergedInput_3;  // ufix108
  reg [107:0] mergedDelay_regin_3;  // ufix108
  wire [107:0] mergedDelay_regout_3;  // ufix108
  wire [17:0] slicedInput_24;  // ufix18
  wire signed [17:0] delayOut0_3;  // sfix18_En8
  wire signed [17:0] Discrete_Time_Integrator_add_in [0:5];  // sfix18_En8 [6]
  wire signed [18:0] adder_add_cast [0:5];  // sfix19_En8 [6]
  wire signed [18:0] adder_add_cast_1 [0:5];  // sfix19_En8 [6]
  wire signed [18:0] adder_add_temp [0:5];  // sfix19_En8 [6]
  wire signed [17:0] Discrete_Time_Integrator_u_add [0:5];  // sfix18_En8 [6]
  reg signed [17:0] Discrete_Time_Integrator_u_add_1 [0:5];  // sfix18_En8 [6]
  reg signed [17:0] Discrete_Time_Integrator_u_sat [0:5];  // sfix18_En8 [6]
  reg signed [17:0] Discrete_Time_Integrator_u_sat_1 [0:5];  // sfix18_En8 [6]
  reg signed [17:0] Discrete_Time_Integrator_reg_bypass_reg [0:5];  // sfix18 [6]
  reg signed [17:0] Discrete_Time_Integrator_reg_bypass_reg_next [0:5];  // sfix18_En8 [6]
  wire signed [17:0] Discrete_Time_Integrator_x_reg_1 [0:5];  // sfix18_En8 [6]
  reg signed [31:0] rd_1_t_0_0;  // int32
  reg signed [31:0] rd_1_t_1;  // int32
  reg signed [31:0] splitcomp_multiport_t_0_0;  // int32
  reg signed [31:0] splitcomp_multiport_t_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_0;  // int32
  reg signed [31:0] HwModeRegister_t_1;  // int32
  reg signed [31:0] PipelineRegister_t_0_0;  // int32
  reg signed [31:0] PipelineRegister_t_1;  // int32
  reg signed [31:0] rd_6_t_0_0;  // int32
  reg signed [31:0] rd_6_t_1;  // int32
  reg signed [31:0] Gain3_out1_state_t_0_0;  // int32
  reg signed [31:0] Gain3_out1_state_t_1;  // int32
  reg signed [31:0] Gain3_out1_enb_t_0_0;  // int32
  reg signed [31:0] Gain3_out1_enb_t_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_0_1;  // int32
  reg signed [31:0] HwModeRegister_t_1_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_1;  // int32
  reg signed [31:0] HwModeRegister_t_1_0;  // int32
  reg signed [31:0] rd_5_t_0_0;  // int32
  reg signed [31:0] rd_5_t_1;  // int32
  reg signed [31:0] alpha_in0_unit_delay_t_0_0;  // int32
  reg signed [31:0] alpha_in0_unit_delay_t_1;  // int32
  reg signed [31:0] rd_2_t_0_0;  // int32
  reg signed [31:0] rd_2_t_1;  // int32
  reg signed [31:0] rd_4_t_0_0;  // int32
  reg signed [31:0] rd_4_t_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_0_2;  // int32
  reg signed [31:0] HwModeRegister_t_1_2;  // int32
  reg signed [31:0] HwModeRegister_t_0_0_3;  // int32
  reg signed [31:0] HwModeRegister_t_1_3;  // int32
  reg signed [31:0] rd_8_t_0_0;  // int32
  reg signed [31:0] rd_8_t_0_1;  // int32
  reg signed [31:0] rd_8_t_1;  // int32
  reg signed [31:0] rd_11_t_0_0;  // int32
  reg signed [31:0] rd_11_t_1;  // int32
  reg signed [31:0] rd_12_t_0_0;  // int32
  reg signed [31:0] rd_12_t_1;  // int32
  reg signed [31:0] rd_13_t_0_0;  // int32
  reg signed [31:0] rd_13_t_1;  // int32
  reg signed [31:0] rd_14_t_0_0;  // int32
  reg signed [31:0] rd_14_t_1;  // int32
  reg signed [31:0] rd_15_t_0_0;  // int32
  reg signed [31:0] rd_15_t_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_saturate_ii;  // int32
  reg signed [31:0] crp_out_delay_t_0_0;  // int32
  reg signed [31:0] crp_out_delay_t_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_0_0;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_2;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_0_1;  // int32
  reg signed [31:0] Discrete_Time_Integrator_reg_bypass_t_1_0;  // int32
  reg signed [31:0] rd_0_t_0_0;  // int32
  reg signed [31:0] rd_0_t_1;  // int32


  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 39
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 6'b000000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr >= 6'b100111) begin
            mergedDelay_waddr <= 6'b000000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 6'b000001;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 39
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 6'b000001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr >= 6'b100111) begin
            mergedDelay_raddr <= 6'b000000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 6'b000001;
          end
        end
      end
    end

  assign crp_temp_shared_enb_phase_24_0 = sch_ctr_66 == 7'b0011000;

  always @(posedge clk)
    begin : rd_7_process
      if (reset == 1'b1) begin
        rd_7_reg <= {10{1'b0}};
      end
      else begin
        if (enb) begin
          rd_7_reg[0] <= crp_temp_shared_enb_phase_24_0;
          rd_7_reg[32'sd9:32'sd1] <= rd_7_reg[32'sd8:32'sd0];
        end
      end
    end

  assign crp_temp_shared_enb_phase_24_0_1 = rd_7_reg[9];

  assign crp_temp_shared_enb_phase_0_1 = sch_ctr_66 <= 7'b0000001;

  always @(posedge clk)
    begin : rd_2_process
      if (reset == 1'b1) begin
        crp_temp_shared_enb_phase_0_1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          crp_temp_shared_enb_phase_0_1_1 <= crp_temp_shared_enb_phase_0_1;
        end
      end
    end

  assign enb_gated = crp_temp_shared_enb_phase_0_1_1 && enb;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  always @(posedge clk)
    begin : ctr_0_1_process
      if (reset == 1'b1) begin
        counterSig <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          counterSig <=  ~ counterSig;
        end
      end
    end

  // Input register for RAM-based shift register rd_3
  always @(posedge clk)
    begin : rd_3_reginc_process
      if (reset == 1'b1) begin
        rd_3_regin <= 1'b0;
      end
      else begin
        if (enb) begin
          rd_3_regin <= counterSig;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 26
  // Write address counter for RAM-based shift register rd_3
  always @(posedge clk)
    begin : rd_3_wr_process
      if (reset == 1'b1) begin
        rd_3_waddr <= 5'b00000;
      end
      else begin
        if (enb) begin
          if (rd_3_waddr >= 5'b11010) begin
            rd_3_waddr <= 5'b00000;
          end
          else begin
            rd_3_waddr <= rd_3_waddr + 5'b00001;
          end
        end
      end
    end

  assign rd_3_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 26
  // Read address counter for RAM-based shift register rd_3
  always @(posedge clk)
    begin : rd_3_rd_process
      if (reset == 1'b1) begin
        rd_3_raddr <= 5'b00001;
      end
      else begin
        if (enb) begin
          if (rd_3_raddr >= 5'b11010) begin
            rd_3_raddr <= 5'b00000;
          end
          else begin
            rd_3_raddr <= rd_3_raddr + 5'b00001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_singlebit #(.AddrWidth(5),
                                       .DataWidth(1)
                                       )
                                     u_ShiftRegisterRAM_Wrapper_singlebit (.clk(clk),
                                                                           .reset(reset),
                                                                           .enb(enb),
                                                                           .enb_1_1_1(enb_1_1_1),
                                                                           .wr_din(rd_3_regin),  // ufix1
                                                                           .wr_addr(rd_3_waddr),
                                                                           .wr_en(rd_3_wrenb),  // ufix1
                                                                           .rd_addr(rd_3_raddr),
                                                                           .dout(rd_3_regout)  // ufix1
                                                                           );

  assign is[0] = is_0;
  assign is[1] = is_1;
  assign is[2] = is_2;
  assign is[3] = is_3;
  assign is[4] = is_4;
  assign is[5] = is_5;


  genvar ii8;
  generate
    for(ii8 = 32'sd0; ii8 <= 32'sd5; ii8 = ii8 + 32'sd1) begin:is_6_gen
      assign is_6[ii8] = is[ii8];
    end
  endgenerate

  assign vs[0] = vs_0;
  assign vs[1] = vs_1;
  assign vs[2] = vs_2;
  assign vs[3] = vs_3;
  assign vs[4] = vs_4;
  assign vs[5] = vs_5;


  genvar ii11;
  generate
    for(ii11 = 32'sd0; ii11 <= 32'sd5; ii11 = ii11 + 32'sd1) begin:vs_6_gen
      assign vs_6[ii11] = vs[ii11];
    end
  endgenerate

  assign c0_serial_0[0] = is_6[0];
  assign c0_serial_0[1] = is_6[1];
  assign c0_serial_0[2] = is_6[2];
  assign c0_serial_0[3] = is_6[3];
  assign c0_serial_0[4] = is_6[4];
  assign c0_serial_0[5] = is_6[5];
  assign c0_serial_0[6] = vs_6[0];
  assign c0_serial_0[7] = vs_6[1];
  assign c0_serial_0[8] = vs_6[2];
  assign c0_serial_0[9] = vs_6[3];
  assign c0_serial_0[10] = vs_6[4];
  assign c0_serial_0[11] = vs_6[5];

  always @(posedge clk)
    begin : rd_1_process
      if (reset == 1'b1) begin
        for(rd_1_t_1 = 32'sd0; rd_1_t_1 <= 32'sd11; rd_1_t_1 = rd_1_t_1 + 32'sd1) begin
          c0_serial_0_1[rd_1_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_1_t_0_0 = 32'sd0; rd_1_t_0_0 <= 32'sd11; rd_1_t_0_0 = rd_1_t_0_0 + 32'sd1) begin
            c0_serial_0_1[rd_1_t_0_0] <= c0_serial_0[rd_1_t_0_0];
          end
        end
      end
    end

  // Output register for RAM-based shift register rd_3
  always @(posedge clk)
    begin : rd_3_regoutc_process
      if (reset == 1'b1) begin
        counterSig_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          counterSig_1 <= rd_3_regout;
        end
      end
    end

  assign ratechange_splitcomp_out0[0] = c0_serial_0_1[0];
  assign ratechange_splitcomp_out0[1] = c0_serial_0_1[1];
  assign ratechange_splitcomp_out0[2] = c0_serial_0_1[2];
  assign ratechange_splitcomp_out0[3] = c0_serial_0_1[3];
  assign ratechange_splitcomp_out0[4] = c0_serial_0_1[4];
  assign ratechange_splitcomp_out0[5] = c0_serial_0_1[5];

  assign ratechange_splitcomp_out1[0] = c0_serial_0_1[6];
  assign ratechange_splitcomp_out1[1] = c0_serial_0_1[7];
  assign ratechange_splitcomp_out1[2] = c0_serial_0_1[8];
  assign ratechange_splitcomp_out1[3] = c0_serial_0_1[9];
  assign ratechange_splitcomp_out1[4] = c0_serial_0_1[10];
  assign ratechange_splitcomp_out1[5] = c0_serial_0_1[11];

  always @* begin
    if (counterSig_1 == 1'b0) begin
      for(splitcomp_multiport_t_1 = 32'sd0; splitcomp_multiport_t_1 <= 32'sd5; splitcomp_multiport_t_1 = splitcomp_multiport_t_1 + 32'sd1) begin
        is_7[splitcomp_multiport_t_1] = ratechange_splitcomp_out0[splitcomp_multiport_t_1];
      end
    end
    else begin
      for(splitcomp_multiport_t_0_0 = 32'sd0; splitcomp_multiport_t_0_0 <= 32'sd5; splitcomp_multiport_t_0_0 = splitcomp_multiport_t_0_0 + 32'sd1) begin
        is_7[splitcomp_multiport_t_0_0] = ratechange_splitcomp_out1[splitcomp_multiport_t_0_0];
      end
    end
  end

  assign is_8[0] = is_7[0];
  assign is_8[1] = is_7[1];
  assign is_8[2] = is_7[2];
  assign is_8[3] = is_7[3];
  assign is_8[4] = is_7[4];
  assign is_8[5] = is_7[5];

  assign kconst = 18'sb100000000000000000;

  assign kconst_1 = kconst;

  assign kconst_2 = 18'sb010100011110101110;

  assign kconst_3 = kconst_2;

  assign kconst_4 = (counterSig == 1'b0 ? kconst_1 :
              kconst_3);

  assign mergedInput = {G_0, G_1, G_2, G_3, G_4, G_5, kconst_4};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 24'b000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 27
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_1_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_1 <= 5'b00000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_1 >= 5'b11011) begin
            mergedDelay_waddr_1 <= 5'b00000;
          end
          else begin
            mergedDelay_waddr_1 <= mergedDelay_waddr_1 + 5'b00001;
          end
        end
      end
    end

  assign mergedDelay_wrenb_1 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 27
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_1_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_1 <= 5'b00001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_1 >= 5'b11011) begin
            mergedDelay_raddr_1 <= 5'b00000;
          end
          else begin
            mergedDelay_raddr_1 <= mergedDelay_raddr_1 + 5'b00001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(5),
                                     .DataWidth(24)
                                     )
                                   u_ShiftRegisterRAM_Wrapper (.clk(clk),
                                                               .reset(reset),
                                                               .enb(enb),
                                                               .enb_1_1_1(enb_1_1_1),
                                                               .wr_din(mergedDelay_regin),
                                                               .wr_addr(mergedDelay_waddr_1),
                                                               .wr_en(mergedDelay_wrenb_1),  // ufix1
                                                               .rd_addr(mergedDelay_raddr_1),
                                                               .dout(mergedDelay_regout)
                                                               );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 24'b000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  always @(posedge clk)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1 = 32'sd0; HwModeRegister_t_1 <= 32'sd5; HwModeRegister_t_1 = HwModeRegister_t_1 + 32'sd1) begin
          is_9[HwModeRegister_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_0 = 32'sd0; HwModeRegister_t_0_0 <= 32'sd5; HwModeRegister_t_0_0 = HwModeRegister_t_0_0 + 32'sd1) begin
            is_9[HwModeRegister_t_0_0] <= is_8[HwModeRegister_t_0_0];
          end
        end
      end
    end

  assign slicedInput = mergedOutput[17:0];

  assign kconst_5 = slicedInput;


  genvar t_0_07;
  generate
    for(t_0_07 = 32'sd0; t_0_07 <= 32'sd5; t_0_07 = t_0_07 + 32'sd1) begin:on_gen
      assign on[t_0_07] = is_9[t_0_07] * kconst_5;
    end
  endgenerate
  always @(posedge clk)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        for(PipelineRegister_t_1 = 32'sd0; PipelineRegister_t_1 <= 32'sd5; PipelineRegister_t_1 = PipelineRegister_t_1 + 32'sd1) begin
          on_1[PipelineRegister_t_1] <= 36'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(PipelineRegister_t_0_0 = 32'sd0; PipelineRegister_t_0_0 <= 32'sd5; PipelineRegister_t_0_0 = PipelineRegister_t_0_0 + 32'sd1) begin
            on_1[PipelineRegister_t_0_0] <= on[PipelineRegister_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : rd_6_process
      if (reset == 1'b1) begin
        for(rd_6_t_1 = 32'sd0; rd_6_t_1 <= 32'sd5; rd_6_t_1 = rd_6_t_1 + 32'sd1) begin
          on_2[rd_6_t_1] <= 36'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_6_t_0_0 = 32'sd0; rd_6_t_0_0 <= 32'sd5; rd_6_t_0_0 = rd_6_t_0_0 + 32'sd1) begin
            on_2[rd_6_t_0_0] <= on_1[rd_6_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Gain3_out1_state_process
      if (reset == 1'b1) begin
        for(Gain3_out1_state_t_1 = 32'sd0; Gain3_out1_state_t_1 <= 32'sd5; Gain3_out1_state_t_1 = Gain3_out1_state_t_1 + 32'sd1) begin
          Gain3_out1_held[Gain3_out1_state_t_1] <= 36'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(Gain3_out1_state_t_0_0 = 32'sd0; Gain3_out1_state_t_0_0 <= 32'sd5; Gain3_out1_state_t_0_0 = Gain3_out1_state_t_0_0 + 32'sd1) begin
            Gain3_out1_held[Gain3_out1_state_t_0_0] <= Gain3_out1[Gain3_out1_state_t_0_0];
          end
        end
      end
    end

  always @* begin
    if (crp_temp_shared_enb_phase_24_0_1 == 1'b0) begin
      for(Gain3_out1_enb_t_1 = 32'sd0; Gain3_out1_enb_t_1 <= 32'sd5; Gain3_out1_enb_t_1 = Gain3_out1_enb_t_1 + 32'sd1) begin
        Gain3_out1[Gain3_out1_enb_t_1] = Gain3_out1_held[Gain3_out1_enb_t_1];
      end
    end
    else begin
      for(Gain3_out1_enb_t_0_0 = 32'sd0; Gain3_out1_enb_t_0_0 <= 32'sd5; Gain3_out1_enb_t_0_0 = Gain3_out1_enb_t_0_0 + 32'sd1) begin
        Gain3_out1[Gain3_out1_enb_t_0_0] = on_2[Gain3_out1_enb_t_0_0];
      end
    end
  end


  genvar ii21;
  generate
    for(ii21 = 32'sd0; ii21 <= 32'sd5; ii21 = ii21 + 32'sd1) begin:Gain3_out1_1_gen
      assign Gain3_out1_1[ii21] = Gain3_out1[ii21];
    end
  endgenerate


  genvar ii31;
  generate
    for(ii31 = 32'sd0; ii31 <= 32'sd5; ii31 = ii31 + 32'sd1) begin:Gain3_out1_2_gen
      assign Gain3_out1_2[ii31] = Gain3_out1_1[ii31][33:16];
    end
  endgenerate

  always @(posedge clk)
    begin : HwModeRegister_1_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1_0 = 32'sd0; HwModeRegister_t_1_0 <= 32'sd17; HwModeRegister_t_1_0 = HwModeRegister_t_1_0 + 32'sd1) begin
          HwModeRegister_reg[HwModeRegister_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_1 = 32'sd0; HwModeRegister_t_0_1 <= 32'sd17; HwModeRegister_t_0_1 = HwModeRegister_t_0_1 + 32'sd1) begin
            HwModeRegister_reg[HwModeRegister_t_0_1] <= HwModeRegister_reg_next[HwModeRegister_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(HwModeRegister_t_0_0_1 = 32'sd0; HwModeRegister_t_0_0_1 <= 32'sd5; HwModeRegister_t_0_0_1 = HwModeRegister_t_0_0_1 + 32'sd1) begin
      Gain3_out1_3[HwModeRegister_t_0_0_1] = HwModeRegister_reg[32'sd12 + HwModeRegister_t_0_0_1];
      HwModeRegister_reg_next[HwModeRegister_t_0_0_1] = Gain3_out1_2[HwModeRegister_t_0_0_1];
    end
    for(HwModeRegister_t_1_1 = 32'sd0; HwModeRegister_t_1_1 <= 32'sd11; HwModeRegister_t_1_1 = HwModeRegister_t_1_1 + 32'sd1) begin
      HwModeRegister_reg_next[HwModeRegister_t_1_1 + 32'sd6] = HwModeRegister_reg[HwModeRegister_t_1_1];
    end

  end

  assign crp_temp_shared_enb_phase_23_0 = sch_ctr_66 == 7'b0010111;

  always @(posedge clk)
    begin : rd_0_process
      if (reset == 1'b1) begin
        rd_0_reg <= {10{1'b0}};
      end
      else begin
        if (enb) begin
          rd_0_reg[0] <= crp_temp_shared_enb_phase_23_0;
          rd_0_reg[32'sd9:32'sd1] <= rd_0_reg[32'sd8:32'sd0];
        end
      end
    end

  assign crp_temp_shared_enb_phase_23_0_1 = rd_0_reg[9];

  always @(posedge clk)
    begin : rd_5_process
      if (reset == 1'b1) begin
        for(rd_5_t_1 = 32'sd0; rd_5_t_1 <= 32'sd5; rd_5_t_1 = rd_5_t_1 + 32'sd1) begin
          on_3[rd_5_t_1] <= 36'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_5_t_0_0 = 32'sd0; rd_5_t_0_0 <= 32'sd5; rd_5_t_0_0 = rd_5_t_0_0 + 32'sd1) begin
            on_3[rd_5_t_0_0] <= on_1[rd_5_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : alpha_in0_unit_delay_process
      if (reset == 1'b1) begin
        for(alpha_in0_unit_delay_t_1 = 32'sd0; alpha_in0_unit_delay_t_1 <= 32'sd5; alpha_in0_unit_delay_t_1 = alpha_in0_unit_delay_t_1 + 32'sd1) begin
          on_4[alpha_in0_unit_delay_t_1] <= 36'sh000000000;
        end
      end
      else begin
        if (enb && crp_temp_shared_enb_phase_23_0_1) begin
          for(alpha_in0_unit_delay_t_0_0 = 32'sd0; alpha_in0_unit_delay_t_0_0 <= 32'sd5; alpha_in0_unit_delay_t_0_0 = alpha_in0_unit_delay_t_0_0 + 32'sd1) begin
            on_4[alpha_in0_unit_delay_t_0_0] <= on_3[alpha_in0_unit_delay_t_0_0];
          end
        end
      end
    end


  genvar ii41;
  generate
    for(ii41 = 32'sd0; ii41 <= 32'sd5; ii41 = ii41 + 32'sd1) begin:on_5_gen
      assign on_5[ii41] = on_4[ii41];
    end
  endgenerate


  genvar ii51;
  generate
    for(ii51 = 32'sd0; ii51 <= 32'sd5; ii51 = ii51 + 32'sd1) begin:on_6_gen
      assign on_6[ii51] = on_5[ii51][28:11];
    end
  endgenerate

  always @(posedge clk)
    begin : rd_1_1_process
      if (reset == 1'b1) begin
        for(rd_1_t_1 = 32'sd0; rd_1_t_1 <= 32'sd5; rd_1_t_1 = rd_1_t_1 + 32'sd1) begin
          on_7[rd_1_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_1_t_0_0 = 32'sd0; rd_1_t_0_0 <= 32'sd5; rd_1_t_0_0 = rd_1_t_0_0 + 32'sd1) begin
            on_7[rd_1_t_0_0] <= on_6[rd_1_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : rd_2_1_process
      if (reset == 1'b1) begin
        for(rd_2_t_1 = 32'sd0; rd_2_t_1 <= 32'sd5; rd_2_t_1 = rd_2_t_1 + 32'sd1) begin
          Gain3_out1_4[rd_2_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_2_t_0_0 = 32'sd0; rd_2_t_0_0 <= 32'sd5; rd_2_t_0_0 = rd_2_t_0_0 + 32'sd1) begin
            Gain3_out1_4[rd_2_t_0_0] <= Gain3_out1_2[rd_2_t_0_0];
          end
        end
      end
    end


  genvar t_0_011;
  generate
    for(t_0_011 = 32'sd0; t_0_011 <= 32'sd5; t_0_011 = t_0_011 + 32'sd1) begin:Subtract1_out1_gen
      assign Subtract1_sub_cast[t_0_011] = {on_7[t_0_011][17], on_7[t_0_011]};
      assign Subtract1_sub_cast_1[t_0_011] = {Gain3_out1_4[t_0_011][17], Gain3_out1_4[t_0_011]};
      assign Subtract1_sub_temp[t_0_011] = Subtract1_sub_cast[t_0_011] - Subtract1_sub_cast_1[t_0_011];
      assign Subtract1_out1[t_0_011] = Subtract1_sub_temp[t_0_011][18:1];
    end
  endgenerate
  assign slicedInput_1 = mergedOutput[23];

  assign delayOut0 = slicedInput_1;

  assign slicedInput_2 = mergedOutput[22];

  assign delayOut1 = slicedInput_2;

  assign slicedInput_3 = mergedOutput[21];

  assign delayOut2 = slicedInput_3;

  assign slicedInput_4 = mergedOutput[20];

  assign delayOut3 = slicedInput_4;

  assign slicedInput_5 = mergedOutput[19];

  assign delayOut4 = slicedInput_5;

  assign slicedInput_6 = mergedOutput[18];

  assign delayOut5 = slicedInput_6;

  assign G[0] = delayOut0;
  assign G[1] = delayOut1;
  assign G[2] = delayOut2;
  assign G[3] = delayOut3;
  assign G[4] = delayOut4;
  assign G[5] = delayOut5;

  assign Constant_out1 = 18'sb101001100110011010;
  always @(posedge clk)
    begin : rd_4_process
      if (reset == 1'b1) begin
        for(rd_4_t_1 = 32'sd0; rd_4_t_1 <= 32'sd5; rd_4_t_1 = rd_4_t_1 + 32'sd1) begin
          vs_7[rd_4_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_4_t_0_0 = 32'sd0; rd_4_t_0_0 <= 32'sd5; rd_4_t_0_0 = rd_4_t_0_0 + 32'sd1) begin
            vs_7[rd_4_t_0_0] <= vs[rd_4_t_0_0];
          end
        end
      end
    end


  genvar t_0_021;
  generate
    for(t_0_021 = 32'sd0; t_0_021 <= 32'sd5; t_0_021 = t_0_021 + 32'sd1) begin:Equal_out1_gen
      assign Equal_cast[t_0_021] = {{11{Constant_out1[17]}}, Constant_out1};
      assign Equal_cast_1[t_0_021] = {vs_7[t_0_021], 11'b00000000000};
      assign Equal_out1[t_0_021] = Equal_cast[t_0_021] >= Equal_cast_1[t_0_021];
    end
  endgenerate
  always @(posedge clk)
    begin : rd_5_1_process
      if (reset == 1'b1) begin
        Equal_out1_1 <= {6{1'b0}};
      end
      else begin
        if (enb) begin
          Equal_out1_1 <= Equal_out1;
        end
      end
    end


  genvar t_01;
  generate
    for(t_01 = 32'sd0; t_01 <= 32'sd5; t_01 = t_01 + 32'sd1) begin:OR_out1_gen
      assign OR_out1[t_01] = G[t_01] | Equal_out1_1[t_01];
    end
  endgenerate
  assign OR_out1_0 = OR_out1[0];

  assign OR_out1_1 = OR_out1[1];

  assign OR_out1_2 = OR_out1[2];

  assign OR_out1_3 = OR_out1[3];

  assign OR_out1_4 = OR_out1[4];

  assign OR_out1_5 = OR_out1[5];

  assign mergedInput_1 = {OR_out1_0, OR_out1_1, OR_out1_2, OR_out1_3, OR_out1_4, OR_out1_5};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_1_process
      if (reset == 1'b1) begin
        mergedDelay_regin_1 <= 6'b000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_1 <= mergedInput_1;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_2_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_2 <= 3'b000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_2 >= 3'b010) begin
            mergedDelay_waddr_2 <= 3'b000;
          end
          else begin
            mergedDelay_waddr_2 <= mergedDelay_waddr_2 + 3'b001;
          end
        end
      end
    end

  assign mergedDelay_wrenb_2 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 2
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_2_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_2 <= 3'b001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_2 >= 3'b010) begin
            mergedDelay_raddr_2 <= 3'b000;
          end
          else begin
            mergedDelay_raddr_2 <= mergedDelay_raddr_2 + 3'b001;
          end
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(3),
                                     .DataWidth(6)
                                     )
                                   u_ShiftRegisterRAM_Wrapper_generic (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb(enb),
                                                                       .enb_1_1_1(enb_1_1_1),
                                                                       .wr_din(mergedDelay_regin_1),
                                                                       .wr_addr(mergedDelay_waddr_2),
                                                                       .wr_en(mergedDelay_wrenb_2),  // ufix1
                                                                       .rd_addr(mergedDelay_raddr_2),
                                                                       .dout(mergedDelay_regout_1)
                                                                       );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_1_process
      if (reset == 1'b1) begin
        mergedOutput_1 <= 6'b000000;
      end
      else begin
        if (enb) begin
          mergedOutput_1 <= mergedDelay_regout_1;
        end
      end
    end

  always @(posedge clk)
    begin : HwModeRegister_2_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1_2 = 32'sd0; HwModeRegister_t_1_2 <= 32'sd5; HwModeRegister_t_1_2 = HwModeRegister_t_1_2 + 32'sd1) begin
          Subtract1_out1_1[HwModeRegister_t_1_2] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_0_2 = 32'sd0; HwModeRegister_t_0_0_2 <= 32'sd5; HwModeRegister_t_0_0_2 = HwModeRegister_t_0_0_2 + 32'sd1) begin
            Subtract1_out1_1[HwModeRegister_t_0_0_2] <= Subtract1_out1[HwModeRegister_t_0_0_2];
          end
        end
      end
    end

  assign slicedInput_7 = mergedOutput_1[5];

  assign delayOut0_1 = slicedInput_7;

  assign slicedInput_8 = mergedOutput_1[4];

  assign delayOut1_1 = slicedInput_8;

  assign slicedInput_9 = mergedOutput_1[3];

  assign delayOut2_1 = slicedInput_9;

  assign slicedInput_10 = mergedOutput_1[2];

  assign delayOut3_1 = slicedInput_10;

  assign slicedInput_11 = mergedOutput_1[1];

  assign delayOut4_1 = slicedInput_11;

  assign slicedInput_12 = mergedOutput_1[0];

  assign delayOut5_1 = slicedInput_12;

  assign OR_out1_6[0] = delayOut0_1;
  assign OR_out1_6[1] = delayOut1_1;
  assign OR_out1_6[2] = delayOut2_1;
  assign OR_out1_6[3] = delayOut3_1;
  assign OR_out1_6[4] = delayOut4_1;
  assign OR_out1_6[5] = delayOut5_1;


  genvar t_0_031;
  generate
    for(t_0_031 = 32'sd0; t_0_031 <= 32'sd5; t_0_031 = t_0_031 + 32'sd1) begin:mulOutput_gen
      assign Multiply_Add_mul_in1[t_0_031] = (OR_out1_6[t_0_031] == 1'b1 ? Subtract1_out1_1[t_0_031] :
                  18'sb000000000000000000);
      assign Multiply_Add_mul_cast[t_0_031] = {Multiply_Add_mul_in1[t_0_031][17], Multiply_Add_mul_in1[t_0_031]};
      assign mulOutput[t_0_031] = Multiply_Add_mul_cast[t_0_031][17:0];
    end
  endgenerate
  always @(posedge clk)
    begin : HwModeRegister_3_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1_3 = 32'sd0; HwModeRegister_t_1_3 <= 32'sd5; HwModeRegister_t_1_3 = HwModeRegister_t_1_3 + 32'sd1) begin
          mulOutput_1[HwModeRegister_t_1_3] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_0_3 = 32'sd0; HwModeRegister_t_0_0_3 <= 32'sd5; HwModeRegister_t_0_0_3 = HwModeRegister_t_0_0_3 + 32'sd1) begin
            mulOutput_1[HwModeRegister_t_0_0_3] <= mulOutput[HwModeRegister_t_0_0_3];
          end
        end
      end
    end


  genvar t_0_041;
  generate
    for(t_0_041 = 32'sd0; t_0_041 <= 32'sd5; t_0_041 = t_0_041 + 32'sd1) begin:Multiply_Add_out1_gen
      assign Multiply_Add_add_add_cast[t_0_041] = {{2{Gain3_out1_3[t_0_041][17]}}, Gain3_out1_3[t_0_041]};
      assign Multiply_Add_add_add_cast_1[t_0_041] = {mulOutput_1[t_0_041][17], {mulOutput_1[t_0_041], 1'b0}};
      assign Multiply_Add_add_add_temp[t_0_041] = Multiply_Add_add_add_cast[t_0_041] + Multiply_Add_add_add_cast_1[t_0_041];
      assign Multiply_Add_out1[t_0_041] = ((Multiply_Add_add_add_temp[t_0_041][19] == 1'b0) && (Multiply_Add_add_add_temp[t_0_041][18:17] != 2'b00) ? 18'sb011111111111111111 :
                  ((Multiply_Add_add_add_temp[t_0_041][19] == 1'b1) && (Multiply_Add_add_add_temp[t_0_041][18:17] != 2'b11) ? 18'sb100000000000000000 :
                  $signed(Multiply_Add_add_add_temp[t_0_041][17:0])));
    end
  endgenerate
  always @(posedge clk)
    begin : rd_8_process
      if (reset == 1'b1) begin
        for(rd_8_t_1 = 32'sd0; rd_8_t_1 <= 32'sd11; rd_8_t_1 = rd_8_t_1 + 32'sd1) begin
          rd_8_reg[rd_8_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_8_t_0_1 = 32'sd0; rd_8_t_0_1 <= 32'sd11; rd_8_t_0_1 = rd_8_t_0_1 + 32'sd1) begin
            rd_8_reg[rd_8_t_0_1] <= rd_8_reg_next[rd_8_t_0_1];
          end
        end
      end
    end

  always @* begin

    for(rd_8_t_0_0 = 32'sd0; rd_8_t_0_0 <= 32'sd5; rd_8_t_0_0 = rd_8_t_0_0 + 32'sd1) begin
      Multiply_Add_out1_1[rd_8_t_0_0] = rd_8_reg[32'sd6 + rd_8_t_0_0];
      rd_8_reg_next[rd_8_t_0_0] = Multiply_Add_out1[rd_8_t_0_0];
      rd_8_reg_next[rd_8_t_0_0 + 32'sd6] = rd_8_reg[rd_8_t_0_0];
    end

  end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 35
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_wr_3_process
      if (reset == 1'b1) begin
        mergedDelay_waddr_3 <= 6'b000000;
      end
      else begin
        if (enb) begin
          if (mergedDelay_waddr_3 >= 6'b100011) begin
            mergedDelay_waddr_3 <= 6'b000000;
          end
          else begin
            mergedDelay_waddr_3 <= mergedDelay_waddr_3 + 6'b000001;
          end
        end
      end
    end

  assign mergedDelay_wrenb_3 = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 35
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_rd_3_process
      if (reset == 1'b1) begin
        mergedDelay_raddr_3 <= 6'b000001;
      end
      else begin
        if (enb) begin
          if (mergedDelay_raddr_3 >= 6'b100011) begin
            mergedDelay_raddr_3 <= 6'b000000;
          end
          else begin
            mergedDelay_raddr_3 <= mergedDelay_raddr_3 + 6'b000001;
          end
        end
      end
    end

  assign slicedInput_13 = mergedOutput_2[17:0];

  assign delayOut5_2 = slicedInput_13;

  assign slicedInput_14 = mergedOutput_2[35:18];

  assign delayOut4_2 = slicedInput_14;

  assign slicedInput_15 = mergedOutput_2[53:36];

  assign delayOut3_2 = slicedInput_15;

  assign slicedInput_16 = mergedOutput_2[71:54];

  assign delayOut2_2 = slicedInput_16;

  assign slicedInput_17 = mergedOutput_2[89:72];

  assign delayOut1_2 = slicedInput_17;

  assign delayIn5 = ic[5];

  assign delayIn4 = ic[4];

  assign delayIn3 = ic[3];

  assign delayIn2 = ic[2];

  assign delayIn1 = ic[1];

  assign delayIn0 = ic[0];

  assign mergedInput_2 = {delayIn0, delayIn1, delayIn2, delayIn3, delayIn4, delayIn5};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_2_process
      if (reset == 1'b1) begin
        mergedDelay_regin_2 <= 108'h000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_2 <= mergedInput_2;
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(6),
                                     .DataWidth(108)
                                     )
                                   u_ShiftRegisterRAM_Wrapper_1 (.clk(clk),
                                                                 .reset(reset),
                                                                 .enb(enb),
                                                                 .enb_1_1_1(enb_1_1_1),
                                                                 .wr_din(mergedDelay_regin_2),
                                                                 .wr_addr(mergedDelay_waddr_3),
                                                                 .wr_en(mergedDelay_wrenb_3),  // ufix1
                                                                 .rd_addr(mergedDelay_raddr_3),
                                                                 .dout(mergedDelay_regout_2)
                                                                 );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_2_process
      if (reset == 1'b1) begin
        mergedOutput_2 <= 108'h000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_2 <= mergedDelay_regout_2;
        end
      end
    end

  assign slicedInput_18 = mergedOutput_2[107:90];

  assign delayOut0_2 = slicedInput_18;

  assign ic_6[0] = delayOut0_2;
  assign ic_6[1] = delayOut1_2;
  assign ic_6[2] = delayOut2_2;
  assign ic_6[3] = delayOut3_2;
  assign ic_6[4] = delayOut4_2;
  assign ic_6[5] = delayOut5_2;


  genvar t_0_051;
  generate
    for(t_0_051 = 32'sd0; t_0_051 <= 32'sd5; t_0_051 = t_0_051 + 32'sd1) begin:Subtract_out1_gen
      assign Subtract_sub_cast[t_0_051] = {{5{Multiply_Add_out1_1[t_0_051][17]}}, Multiply_Add_out1_1[t_0_051]};
      assign Subtract_sub_cast_1[t_0_051] = {ic_6[t_0_051][17], {ic_6[t_0_051], 4'b0000}};
      assign Subtract_sub_temp[t_0_051] = Subtract_sub_cast[t_0_051] - Subtract_sub_cast_1[t_0_051];
      assign Subtract_out1[t_0_051] = Subtract_sub_temp[t_0_051][17:0];
    end
  endgenerate
  always @(posedge clk)
    begin : rd_11_process
      if (reset == 1'b1) begin
        for(rd_11_t_1 = 32'sd0; rd_11_t_1 <= 32'sd5; rd_11_t_1 = rd_11_t_1 + 32'sd1) begin
          Subtract_out1_1[rd_11_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_11_t_0_0 = 32'sd0; rd_11_t_0_0 <= 32'sd5; rd_11_t_0_0 = rd_11_t_0_0 + 32'sd1) begin
            Subtract_out1_1[rd_11_t_0_0] <= Subtract_out1[rd_11_t_0_0];
          end
        end
      end
    end


  genvar ii61;
  generate
    for(ii61 = 32'sd0; ii61 <= 32'sd5; ii61 = ii61 + 32'sd1) begin:Discrete_Time_Integrator_indtc_gen
      assign Discrete_Time_Integrator_indtc[ii61] = Subtract_out1_1[ii61];
    end
  endgenerate

  always @(posedge clk)
    begin : rd_12_process
      if (reset == 1'b1) begin
        for(rd_12_t_1 = 32'sd0; rd_12_t_1 <= 32'sd5; rd_12_t_1 = rd_12_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_indtc_1[rd_12_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_12_t_0_0 = 32'sd0; rd_12_t_0_0 <= 32'sd5; rd_12_t_0_0 = rd_12_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_indtc_1[rd_12_t_0_0] <= Discrete_Time_Integrator_indtc[rd_12_t_0_0];
          end
        end
      end
    end

  assign gain_cast = {Discrete_Time_Integrator_indtc_1[0][17], Discrete_Time_Integrator_indtc_1[0]};
  assign Discrete_Time_Integrator_u_gain[0] = {{3{gain_cast[18]}}, gain_cast[18:4]};
  assign gain_cast_1 = {Discrete_Time_Integrator_indtc_1[1][17], Discrete_Time_Integrator_indtc_1[1]};
  assign Discrete_Time_Integrator_u_gain[1] = {{3{gain_cast_1[18]}}, gain_cast_1[18:4]};
  assign gain_cast_2 = {Discrete_Time_Integrator_indtc_1[2][17], Discrete_Time_Integrator_indtc_1[2]};
  assign Discrete_Time_Integrator_u_gain[2] = {{3{gain_cast_2[18]}}, gain_cast_2[18:4]};
  assign gain_cast_3 = {Discrete_Time_Integrator_indtc_1[3][17], Discrete_Time_Integrator_indtc_1[3]};
  assign Discrete_Time_Integrator_u_gain[3] = {{3{gain_cast_3[18]}}, gain_cast_3[18:4]};
  assign gain_cast_4 = {Discrete_Time_Integrator_indtc_1[4][17], Discrete_Time_Integrator_indtc_1[4]};
  assign Discrete_Time_Integrator_u_gain[4] = {{3{gain_cast_4[18]}}, gain_cast_4[18:4]};
  assign gain_cast_5 = {Discrete_Time_Integrator_indtc_1[5][17], Discrete_Time_Integrator_indtc_1[5]};
  assign Discrete_Time_Integrator_u_gain[5] = {{3{gain_cast_5[18]}}, gain_cast_5[18:4]};

  always @(posedge clk)
    begin : rd_13_process
      if (reset == 1'b1) begin
        for(rd_13_t_1 = 32'sd0; rd_13_t_1 <= 32'sd5; rd_13_t_1 = rd_13_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_u_gain_1[rd_13_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_13_t_0_0 = 32'sd0; rd_13_t_0_0 <= 32'sd5; rd_13_t_0_0 = rd_13_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_u_gain_1[rd_13_t_0_0] <= Discrete_Time_Integrator_u_gain[rd_13_t_0_0];
          end
        end
      end
    end


  genvar ii71;
  generate
    for(ii71 = 32'sd0; ii71 <= 32'sd5; ii71 = ii71 + 32'sd1) begin:Discrete_Time_Integrator_u_dtc_gen
      assign Discrete_Time_Integrator_u_dtc[ii71] = Discrete_Time_Integrator_u_gain_1[ii71];
    end
  endgenerate

  always @(posedge clk)
    begin : rd_14_process
      if (reset == 1'b1) begin
        for(rd_14_t_1 = 32'sd0; rd_14_t_1 <= 32'sd5; rd_14_t_1 = rd_14_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_u_dtc_1[rd_14_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_14_t_0_0 = 32'sd0; rd_14_t_0_0 <= 32'sd5; rd_14_t_0_0 = rd_14_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_u_dtc_1[rd_14_t_0_0] <= Discrete_Time_Integrator_u_dtc[rd_14_t_0_0];
          end
        end
      end
    end

  assign slicedInput_19 = mergedOutput_3[17:0];

  assign delayOut5_3 = slicedInput_19;

  assign slicedInput_20 = mergedOutput_3[35:18];

  assign delayOut4_3 = slicedInput_20;

  assign slicedInput_21 = mergedOutput_3[53:36];

  assign delayOut3_3 = slicedInput_21;

  assign slicedInput_22 = mergedOutput_3[71:54];

  assign delayOut2_3 = slicedInput_22;

  assign slicedInput_23 = mergedOutput_3[89:72];

  assign delayOut1_3 = slicedInput_23;

  assign delayIn5_1 = ic[5];

  assign delayIn4_1 = ic[4];

  assign delayIn3_1 = ic[3];

  assign delayIn2_1 = ic[2];

  assign delayIn1_1 = ic[1];

  assign delayIn0_1 = ic[0];

  assign mergedInput_3 = {delayIn0_1, delayIn1_1, delayIn2_1, delayIn3_1, delayIn4_1, delayIn5_1};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_reginc_3_process
      if (reset == 1'b1) begin
        mergedDelay_regin_3 <= 108'h000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedDelay_regin_3 <= mergedInput_3;
        end
      end
    end

  ShiftRegisterRAM_Wrapper_generic #(.AddrWidth(6),
                                     .DataWidth(108)
                                     )
                                   u_ShiftRegisterRAM_Wrapper_2 (.clk(clk),
                                                                 .reset(reset),
                                                                 .enb(enb),
                                                                 .enb_1_1_1(enb_1_1_1),
                                                                 .wr_din(mergedDelay_regin_3),
                                                                 .wr_addr(mergedDelay_waddr),
                                                                 .wr_en(mergedDelay_wrenb),  // ufix1
                                                                 .rd_addr(mergedDelay_raddr),
                                                                 .dout(mergedDelay_regout_3)
                                                                 );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk)
    begin : mergedDelay_regoutc_3_process
      if (reset == 1'b1) begin
        mergedOutput_3 <= 108'h000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mergedOutput_3 <= mergedDelay_regout_3;
        end
      end
    end

  assign slicedInput_24 = mergedOutput_3[107:90];

  assign delayOut0_3 = slicedInput_24;

  assign Discrete_Time_Integrator_add_in[0] = delayOut0_3;
  assign Discrete_Time_Integrator_add_in[1] = delayOut1_3;
  assign Discrete_Time_Integrator_add_in[2] = delayOut2_3;
  assign Discrete_Time_Integrator_add_in[3] = delayOut3_3;
  assign Discrete_Time_Integrator_add_in[4] = delayOut4_3;
  assign Discrete_Time_Integrator_add_in[5] = delayOut5_3;


  genvar t_0_061;
  generate
    for(t_0_061 = 32'sd0; t_0_061 <= 32'sd5; t_0_061 = t_0_061 + 32'sd1) begin:Discrete_Time_Integrator_u_add_gen
      assign adder_add_cast[t_0_061] = {Discrete_Time_Integrator_add_in[t_0_061][17], Discrete_Time_Integrator_add_in[t_0_061]};
      assign adder_add_cast_1[t_0_061] = {Discrete_Time_Integrator_u_dtc_1[t_0_061][17], Discrete_Time_Integrator_u_dtc_1[t_0_061]};
      assign adder_add_temp[t_0_061] = adder_add_cast[t_0_061] + adder_add_cast_1[t_0_061];
      assign Discrete_Time_Integrator_u_add[t_0_061] = ((adder_add_temp[t_0_061][18] == 1'b0) && (adder_add_temp[t_0_061][17] != 1'b0) ? 18'sb011111111111111111 :
                  ((adder_add_temp[t_0_061][18] == 1'b1) && (adder_add_temp[t_0_061][17] != 1'b1) ? 18'sb100000000000000000 :
                  $signed(adder_add_temp[t_0_061][17:0])));
    end
  endgenerate

  always @(posedge clk)
    begin : rd_15_process
      if (reset == 1'b1) begin
        for(rd_15_t_1 = 32'sd0; rd_15_t_1 <= 32'sd5; rd_15_t_1 = rd_15_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_u_add_1[rd_15_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_15_t_0_0 = 32'sd0; rd_15_t_0_0 <= 32'sd5; rd_15_t_0_0 = rd_15_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_u_add_1[rd_15_t_0_0] <= Discrete_Time_Integrator_u_add[rd_15_t_0_0];
          end
        end
      end
    end

  always @* begin

    for(Discrete_Time_Integrator_saturate_ii = 32'sd0; Discrete_Time_Integrator_saturate_ii <= 32'sd5; Discrete_Time_Integrator_saturate_ii = Discrete_Time_Integrator_saturate_ii + 32'sd1) begin
      if (Discrete_Time_Integrator_u_add_1[Discrete_Time_Integrator_saturate_ii] > 18'sb000110010000000000) begin
        Discrete_Time_Integrator_u_sat[Discrete_Time_Integrator_saturate_ii] = 18'sb000110010000000000;
      end
      else if (Discrete_Time_Integrator_u_add_1[Discrete_Time_Integrator_saturate_ii] < 18'sb111001110000000000) begin
        Discrete_Time_Integrator_u_sat[Discrete_Time_Integrator_saturate_ii] = 18'sb111001110000000000;
      end
      else begin
        Discrete_Time_Integrator_u_sat[Discrete_Time_Integrator_saturate_ii] = Discrete_Time_Integrator_u_add_1[Discrete_Time_Integrator_saturate_ii];
      end
    end

  end

  always @(posedge clk)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        for(crp_out_delay_t_1 = 32'sd0; crp_out_delay_t_1 <= 32'sd5; crp_out_delay_t_1 = crp_out_delay_t_1 + 32'sd1) begin
          Discrete_Time_Integrator_u_sat_1[crp_out_delay_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay_t_0_0 = 32'sd0; crp_out_delay_t_0_0 <= 32'sd5; crp_out_delay_t_0_0 = crp_out_delay_t_0_0 + 32'sd1) begin
            Discrete_Time_Integrator_u_sat_1[crp_out_delay_t_0_0] <= Discrete_Time_Integrator_u_sat[crp_out_delay_t_0_0];
          end
        end
      end
    end

  always @(posedge clk)
    begin : Discrete_Time_Integrator_reg_bypass_process
      if (reset == 1'b1) begin
        for(Discrete_Time_Integrator_reg_bypass_t_1_0 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_1_0 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_1_0 = Discrete_Time_Integrator_reg_bypass_t_1_0 + 32'sd1) begin
          Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_1_0] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_1_67_1) begin
          for(Discrete_Time_Integrator_reg_bypass_t_0_1 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_0_1 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_0_1 = Discrete_Time_Integrator_reg_bypass_t_0_1 + 32'sd1) begin
            Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_0_1] <= Discrete_Time_Integrator_reg_bypass_reg_next[Discrete_Time_Integrator_reg_bypass_t_0_1];
          end
        end
      end
    end

  always @* begin
    if (enb_1_67_1 == 1'b1) begin
      for(Discrete_Time_Integrator_reg_bypass_t_1 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_1 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_1 = Discrete_Time_Integrator_reg_bypass_t_1 + 32'sd1) begin
        Discrete_Time_Integrator_x_reg[Discrete_Time_Integrator_reg_bypass_t_1] = Discrete_Time_Integrator_u_sat_1[Discrete_Time_Integrator_reg_bypass_t_1];
      end
    end
    else begin
      for(Discrete_Time_Integrator_reg_bypass_t_0_0 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_0_0 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_0_0 = Discrete_Time_Integrator_reg_bypass_t_0_0 + 32'sd1) begin
        Discrete_Time_Integrator_x_reg[Discrete_Time_Integrator_reg_bypass_t_0_0] = Discrete_Time_Integrator_reg_bypass_reg[Discrete_Time_Integrator_reg_bypass_t_0_0];
      end
    end

    for(Discrete_Time_Integrator_reg_bypass_t_2 = 32'sd0; Discrete_Time_Integrator_reg_bypass_t_2 <= 32'sd5; Discrete_Time_Integrator_reg_bypass_t_2 = Discrete_Time_Integrator_reg_bypass_t_2 + 32'sd1) begin
      Discrete_Time_Integrator_reg_bypass_reg_next[Discrete_Time_Integrator_reg_bypass_t_2] = Discrete_Time_Integrator_u_sat_1[Discrete_Time_Integrator_reg_bypass_t_2];
    end

  end

  assign Discrete_Time_Integrator_x_reg_1[0] = Discrete_Time_Integrator_x_reg[0];
  assign Discrete_Time_Integrator_x_reg_1[1] = Discrete_Time_Integrator_x_reg[1];
  assign Discrete_Time_Integrator_x_reg_1[2] = Discrete_Time_Integrator_x_reg[2];
  assign Discrete_Time_Integrator_x_reg_1[3] = Discrete_Time_Integrator_x_reg[3];
  assign Discrete_Time_Integrator_x_reg_1[4] = Discrete_Time_Integrator_x_reg[4];
  assign Discrete_Time_Integrator_x_reg_1[5] = Discrete_Time_Integrator_x_reg[5];

  always @(posedge clk)
    begin : rd_0_1_process
      if (reset == 1'b1) begin
        for(rd_0_t_1 = 32'sd0; rd_0_t_1 <= 32'sd5; rd_0_t_1 = rd_0_t_1 + 32'sd1) begin
          ic[rd_0_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_0_t_0_0 = 32'sd0; rd_0_t_0_0 <= 32'sd5; rd_0_t_0_0 = rd_0_t_0_0 + 32'sd1) begin
            ic[rd_0_t_0_0] <= Discrete_Time_Integrator_x_reg_1[rd_0_t_0_0];
          end
        end
      end
    end

  assign ic_0 = ic[0];

  assign ic_1 = ic[1];

  assign ic_2 = ic[2];

  assign ic_3 = ic[3];

  assign ic_4 = ic[4];

  assign ic_5 = ic[5];

endmodule  // FET_CTRL

