/******************************************************************************
* Copyright (C) 2023 Advanced Micro Devices, Inc. All Rights Reserved.
* SPDX-License-Identifier: MIT
******************************************************************************/
/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)   00000101100000000000000000001000
 */

#include <stdio.h>


#include "mblaze_nt_types.h"

#include <math.h>
#include "xil_printf.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xuartlite.h"
#include "xuartlite_i.h"


#define number_reg 7


/*
u32 data_io[number_reg],debug_reg_axi2bus;
sint32 Data_1,Data_2,Data_3,Rdata;
u8 received_data[3],data_f[number_reg+1];
XUartLite xuart;
u32 init_=0;
u32 flip=0;


 bus 2 axi
 1-load_curr2
 2-I_inductor
 3-Vdiode
 4-Vout

 axi 2 bus
 5-V_bat
 6-Vin
 7-clk_enable
*/



void recv_cbr(void);
void extractor(void);
void fixed2dec(void);
void config_uart(void);
int fault_mngr(void);
void read_gpio_mw(void);
void rgb_led_ctrl(int);

int main()
{
/*
	config_uart();
	int color=3;
	while(1)
	{
		extractor();
		fixed2dec();
		data_f[7]= fault_mngr();
		XUartLite_Send(&xuart, data_f,number_reg+1);
		while(XUartLite_IsSending(&xuart)){}
		Rdata=XUartLite_Recv(&xuart, received_data,4);
		if(Rdata>0)
		{
			recv_cbr();
		}
		read_gpio_mw();
		if(data_f[7]>0){color=1;}
		rgb_led_ctrl(color);
		 //1 red, 2 green, 3  blue

	}*/
    return 0;
}


/*

void recv_cbr()
{

	boolean mayor_reg=0;
	u32 aux = received_data[2]<<24;
	u32 reg4 = IO_LV_VANILLA_BOOST_mReadReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG4_OFFSET);
	if (reg4>aux)
	{
		mayor_reg=1;
	}

	u32 cnt = 0;
	if(mayor_reg)
	{
	while((reg4-cnt)>aux)
		{
			IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG4_OFFSET,reg4-cnt);
			cnt++;
		}
	}else
	{
		while((reg4+cnt)<aux)
				{
					IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG4_OFFSET,reg4+cnt);
					cnt++;
				}
	}

	 mayor_reg=0;
	 aux = received_data[1]<<24;
	 reg4 = IO_LV_VANILLA_BOOST_mReadReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG5_OFFSET);
	 if (reg4>aux)
	 {
	 	mayor_reg=1;
	 }
 	cnt = 0;
 	if(mayor_reg)
 	{
 	while((reg4-cnt)>aux)
 		{
 			IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG5_OFFSET,reg4-cnt);
 			cnt++;
 		}
 	}else
 	{
 		while((reg4+cnt)<aux)
 				{
 					IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG5_OFFSET,reg4+cnt);
 					cnt++;
 				}
 	}





	//IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG4_OFFSET, received_data[2]<<24);
	//IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG5_OFFSET, received_data[1]<<24);
	IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG6_OFFSET, received_data[0]);

}

/*
void extractor()
{
	int cnt=0;
	int index_ext=0;
	while(cnt<((4*number_reg)))
	{
		data_io[index_ext]=IO_LV_VANILLA_BOOST_mReadReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, cnt);
		cnt=cnt+4;
		index_ext++;
	}

}

void config_uart(void)
{
		XUartLite_Initialize(&xuart, XPAR_AXI_UARTLITE_0_DEVICE_ID);
		XUartLite_EnableInterrupt(&xuart);
		xuart.RecvCallBackRef = &recv_cbr;
		XUartLite_InterruptHandler(&xuart);
		XUartLite_SetRecvHandler(&xuart,xuart.RecvHandler, &recv_cbr);
		//XUartLite_ResetFifos(&xuart);
}
int fault_mngr()
{
	if (data_f[1]>=70)
	{

		return 1;
	}
	if (data_f[2]>=100)
	{

		return 2;
	}
	return 0;
}

*/
