/******************************************************************************
* Copyright (C) 2023 Advanced Micro Devices, Inc. All Rights Reserved.
* SPDX-License-Identifier: MIT
******************************************************************************/
/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)   00000101100000000000000000001000
 */

#include <stdio.h>


#include "mblaze_nt_types.h"


#include "xil_printf.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xuartlite.h"
#include "xuartlite_i.h"


#define number_reg 7



u32 data_io[number_reg],debug_reg_axi2bus;
sint32 Data_1,Data_2,Data_3,Rdata;
u8 received_data[3],data_f[number_reg+1];
XUartLite xuart;
u32 init_=0;
u32 flip=0;
/*
 bus 2 axi
 1-load_curr2
 2-I_inductor
 3-Vdiode
 4-Vout

 axi 2 bus
 5-V_bat
 6-Vin
 7-clk_enable
*/



void recv_cbr(void);
void extractor(void);
void fixed2dec(void);
void config_uart(void);
int fault_mngr(void);
void read_gpio_mw(void);
void rgb_led_ctrl(int);

int main()
{

	config_uart();
	int color=3;
	while(1)
	{
		extractor();
		fixed2dec();
		data_f[7]= fault_mngr();
		XUartLite_Send(&xuart, data_f,number_reg+1);
		while(XUartLite_IsSending(&xuart)){}
		Rdata=XUartLite_Recv(&xuart, received_data,4);
		if(Rdata>0)
		{
			recv_cbr();
		}
		read_gpio_mw();
		if(data_f[7]>0){color=1;}
		rgb_led_ctrl(color);
		 //1 red, 2 green, 3  blue

	}
    return 0;
}

void rgb_led_ctrl(int color)
{
	u32 cnt;
	cnt = IO_LV_VANILLA_BOOST_mReadReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR,IO_LV_VANILLA_BOOST_S_AXI_SLV_REG7_OFFSET);

	if (cnt>0xFFFFFF)
	{
		if (color==1)
		{
			Xil_Out32(XPAR_RGB_LED_BASEADDR,0b011);
		}
		if (color==2)
		{
			Xil_Out32(XPAR_RGB_LED_BASEADDR,0b101);
		}
		if (color==3)
		{
			Xil_Out32(XPAR_RGB_LED_BASEADDR,0b110);
		}

	}else
	{
		Xil_Out32(XPAR_RGB_LED_BASEADDR,0b111); //pull high to deactivate
	}

}


void read_gpio_mw(void )
{

	if (Xil_In32(XPAR_PUSH_BOTTON_BASEADDR))
	{
		IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG6_OFFSET,1);
		Xil_Out32(XPAR_GPIO_0_BASEADDR, 0b0001);
		flip = flip ? 0b0 : 0b1;

	}


}
void fixed2dec()
{
	int index_ext=0;
	boolean sign;

	while(index_ext<(number_reg-1))
	{
		sign = data_io[index_ext]>>31;
		if(sign)
		{
			if((index_ext==2))
			{
							//two complement
							Data_1  = (~data_io[index_ext]);
						    Data_2  = Data_1 + 0x1;
							Data_3  = Data_1<<1;
							data_f[index_ext] = Data_3>>24;
			}else{
				data_f[index_ext] = 0x0;
			}
		}else
		{
			//extract from 31-25
			Data_3  = data_io[index_ext]<<1;
			data_f[index_ext] = Data_3>>24;
		}


		index_ext++;
	}
	if(data_io[6])
	{
		data_f[6] = 0x1;
	}else
	{
		data_f[6] = 0x0;
	}
}
void recv_cbr()
{

	boolean mayor_reg=0;
	u32 aux = received_data[2]<<24;
	u32 reg4 = IO_LV_VANILLA_BOOST_mReadReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG4_OFFSET);
	if (reg4>aux)
	{
		mayor_reg=1;
	}

	u32 cnt = 0;
	if(mayor_reg)
	{
	while((reg4-cnt)>aux)
		{
			IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG4_OFFSET,reg4-cnt);
			cnt++;
		}
	}else
	{
		while((reg4+cnt)<aux)
				{
					IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG4_OFFSET,reg4+cnt);
					cnt++;
				}
	}

	 mayor_reg=0;
	 aux = received_data[1]<<24;
	 reg4 = IO_LV_VANILLA_BOOST_mReadReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG5_OFFSET);
	 if (reg4>aux)
	 {
	 	mayor_reg=1;
	 }
 	cnt = 0;
 	if(mayor_reg)
 	{
 	while((reg4-cnt)>aux)
 		{
 			IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG5_OFFSET,reg4-cnt);
 			cnt++;
 		}
 	}else
 	{
 		while((reg4+cnt)<aux)
 				{
 					IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG5_OFFSET,reg4+cnt);
 					cnt++;
 				}
 	}





	//IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG4_OFFSET, received_data[2]<<24);
	//IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG5_OFFSET, received_data[1]<<24);
	IO_LV_VANILLA_BOOST_mWriteReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, IO_LV_VANILLA_BOOST_S_AXI_SLV_REG6_OFFSET, received_data[0]);

}


void extractor()
{
	int cnt=0;
	int index_ext=0;
	while(cnt<((4*number_reg)))
	{
		data_io[index_ext]=IO_LV_VANILLA_BOOST_mReadReg(XPAR_IO_LV_VANILLA_BOOST_0_S_AXI_BASEADDR, cnt);
		cnt=cnt+4;
		index_ext++;
	}

}
void config_uart(void)
{
		XUartLite_Initialize(&xuart, XPAR_AXI_UARTLITE_0_DEVICE_ID);
		XUartLite_EnableInterrupt(&xuart);
		xuart.RecvCallBackRef = &recv_cbr;
		XUartLite_InterruptHandler(&xuart);
		XUartLite_SetRecvHandler(&xuart,xuart.RecvHandler, &recv_cbr);
		//XUartLite_ResetFifos(&xuart);
}
int fault_mngr()
{
	if (data_f[1]>=70)
	{

		return 1;
	}
	if (data_f[2]>=100)
	{

		return 2;
	}
	return 0;
}

